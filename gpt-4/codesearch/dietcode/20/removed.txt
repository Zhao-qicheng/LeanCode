public Input Stream get As Stream ( String Name ) { Input Stream is ; String Path get Real Path ( Name ) ; ( is File Path ( Name , Path ) ) { { is File Input Stream ( Path ) ; } ( File Not Found ) { . debug ( " The resource " + real Path + " has not been found " ) ; if ( is == null ) { is = super . get Resource As Stream ( real Path ) ; return is ;<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>0
public static void register ( Binder binder , Class , Class > annotation ) { register Key ( binder , Key . get ( clazz , annotation ) ) ; }<CODESPLIT>Registers a class / annotation combination to instantiate eagerly . Classes mentioned here will be pulled out of the injector with an injector . getInstance () call when the lifecycle is created .<CODESPLIT>1
public static br restoreconfig restoreconfig ( nitro client , br restoreconfig resources ) throws { ( resources ) ( Null array ) ; ( resources . 1 ) return ( ( br _ restoreconfig [ ] ) resources [ 0 ] . perform _ operation ( client , " restoreconfig " ) ) ; return ( ( br _ restoreconfig [ ] ) perform _ operation _ bulk _ request ( client , resources , " restoreconfig " ) ) ; }<CODESPLIT><pre > Use this operation to restore config from file on Repeater Instances . < / pre ><CODESPLIT>0
public Page find Page Parameter ( Object param ) { Page page = ; ( param Page ) { page = ( Page ) param ; } ( param Map ) { for ( Object m . values ( ) ) { if ( o instanceof Page ) { page = ( Page ) o ; break ; } } } if ( page != null ) { PAGE _ THREAD _ LOCAL . set ( page ) ; } return page ; }<CODESPLIT>从传递的参数中找Page对象，并返回<CODESPLIT>1
public static Input Stream get As Stream ( Class clazz , String fn ) throws { Input Stream stream = clazz . get As Stream ( fn ) ; ( stream ) { ( \"" + fn + "\" relative to " + clazz + " not found ." ) ; } return unpack Stream ( stream , fn ) ; }<CODESPLIT>Get an input stream to read the raw contents of the given resource remember to close it : )<CODESPLIT>1
public static , Supplier compose ( Function , , Supplier ) { . precondition ( f != null , " cannot compose supplier with a null function " ) ; dbc . precondition ( g != null , " cannot compose function with a null supplier " ) ; return ( ) -> f . apply ( g . get ( ) ) ; }<CODESPLIT>Composes a function with a ternary function .<CODESPLIT>0
public void get Chars ( int Begin , int , char dst , int dst Begin ) { int Index dst Begin ; ( int Begin ; End ; i ++ ) { dst [ dest Index ++ ] = m _ str . char At ( i ) ; } }<CODESPLIT>Copies characters from this string into the destination character array .<CODESPLIT>1
public String get URL ( Context context , String , Map String , String parameters , boolean include View Params ) { return get Action URL ( context , view Id ) ; }<CODESPLIT><p class = changed_added_2_0 > Return a JSF action URL derived from the <code > viewId< / code > argument that is suitable to be used by the { @link NavigationHandler } to issue a redirect request to the URL using a NonFaces request . Compliant implementations must implement this method as specified in section JSF . 7 . 6 . 2 . The default implementation simply calls through to { @link #getActionURL } passing the arguments <code > context< / code > and <code > viewId< / code > . < / p ><CODESPLIT>1
public E Class get Server ( ) { ( E Class ) { E Class ( E Class ) E Package get E Package ( Store Package . e NS _ URI ) . get E Classifiers ( ) . get ( 45 ) ; } return server Info E Class ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>0
public void add Maybe ( , ) throws { synchronized ( handlers ) { ( get ( ) ) { ( || stage . compare To ( curr Stage ) < 1 ) { handler . start ( ) ; } } handlers . get ( stage ) . add ( handler ) ; } }<CODESPLIT>This will materialize the entire sequence in memory . Use at your own risk .<CODESPLIT>0
public static Clever Tap API instance With Config ( , @ Clever Tap Instance Config ) { ( ) { ( Clever Tap Instance Config cannot ) ; ; ( ) { instances = new Hash Map <> ( ) ; Clever Tap API instance = instances . get ( config . get Account Id ( ) ) ; if ( instance == null ) { instance = new Clever Tap API ( context , config ) ; instances . put ( config . get Account Id ( ) , instance ) ; } return instance ;<CODESPLIT>Lifecycle<CODESPLIT>0
public get Current ) { Element get Current Element ) ; != elem ) && ( elem . get XSL Token ( ) != Constants . ELEMNAME _ TEMPLATE ) ) { elem = elem . get Parent Elem ( ) ; } return ( Elem Template ) elem ; }<CODESPLIT>This method retrieves the xsl : template that is in effect which may be a matched template or a named template .<CODESPLIT>1
public static boolean ( I Atom Container , Document ) throws Smiles , CDK { Node List nl = . get Elements By Tag Name ( replace set ) ; Smiles = Smiles ( . get Builder ( ) ) ; boolean = false ; for ( int = 0 ; nl . get Length ( ) ; ) { Element child = ( Element ) nl . item ( ) ; Node List replaces = child . get Elements By Tag Name ( replace ) ; Node List replacement = child . get Elements By Tag Name ( replacement " ) ; if ( replacementstring . index Of ( ' ' ) > - 1 || replacementstring . length ( ) < 1 ) { } I Atom Container replacement Structure = sp . parse Smiles ( replacementstring ) ; for ( int k = 0 ; k < replaces . get Length ( ) ; k ++ ) { Element replace = ( Element ) replaces . item ( k ) ; if ( replacestring . index Of ( ' ' ) > - 1 || replacestring . length ( ) < 1 ) { replacestring = replace . get First Child ( ) . get Next Sibling ( ) . get Node Value ( ) ; } I Atom Container replace Structure = sp . parse Smiles ( replacestring ) ; List < R Map > l = null ; Universal Isomorphism Tester universal Isomorphism Tester = new Universal Isomorphism Tester ( ) ; while ( ( l = universal Isomorphism Tester . get Subgraph Map ( ac , replace Structure ) ) != null ) { Iterator < R Map > bondit = l . iterator ( ) ; while ( bondit . has Next ( ) ) { R Map rmap = bondit . next ( ) ; I Bond acbond = ac . get Bond ( rmap . get Id 1 ( ) ) ; I Bond replacebond = replacement Structure . get Bond ( rmap . get Id 2 ( ) ) ; acbond . set Order ( replacebond . get Order ( ) ) ; change = true ; } Iterator < R Map > atomit = l 2 . iterator ( ) ; while ( atomit . has Next ( ) ) { R Map rmap = atomit . next ( ) ; I Atom acatom = ac . get Atom ( rmap . get Id 1 ( ) ) ; I Atom replaceatom = replacement Structure . get Atom ( rmap . get Id 2 ( ) ) ; acatom . set Formal Charge ( replaceatom . get Formal Charge ( ) ) ; change = true ; } } } } return ( change ) ; }<CODESPLIT>The method takes an XML files like the following : <br > &lt ; replace - set&gt ; <br > &lt ; replace&gt ; O = N = O&lt ; / replace&gt ; <br > &lt ; replacement&gt ; [ O - ] [ N + ] = O&lt ; / replacement&gt ; <br > &lt ; / replace - set&gt ; <br > All parts in ac which are the same as replace will be changed according to replacement . Currently the following changes are done : BondOrder FormalCharge . For detection of fragments like replace we rely on UniversalIsomorphismTester . doc may contain several replace - sets and a replace - set may contain several replace fragments which will all be normalized according to replacement .<CODESPLIT>1
protected void write Tracee To ( message ) { ( backend is Empty ( ) backend get Configuration ( ) should Process ( Async Dispatch ) ) { Map String , String backend get Configuration ( ) filter Params ( backend . copy To Map ( ) , Async Dispatch ) ; final String context As String = http Header Serialization . render ( filtered Context ) ; message . set String Property ( Tracee Constants . TPIC _ HEADER , context As String ) ; } }<CODESPLIT>Writes the current TraceeContext to the given javaee message . This method is idempotent .<CODESPLIT>1
public void product ( Int Long Vector other ) { ( int 0 ; ; ) { [ i + start ] *= other . get ( i ) ; } }<CODESPLIT>/ * This method is used to get PHSFellowshipSupplemental12 XMLObject and set the data to it from DevelopmentProposal data .<CODESPLIT>0
public static Signature Filter build Signature Filter ( final Resource Resource Location ) throws { ( ! Resource . Resource Exist ( Resource Location ) ) { . ( Resource [{}] cannot located , Resource Location ) ; return ; } key Info Provider List = Array List Key Info Provider ( ) ; key Info Provider List . add ( RSA Key Value Provider ( ) ) ; key Info Provider List . add ( DSA Key Value Provider ( ) ) ; key Info Provider List . add ( DER Encoded Key Value Provider ( ) ) ; key Info Provider List . add ( X 509 Data Provider ( ) ) ; . ( Attempting to resolve from [{}]" , signature Resource Location ) ; val credential = build Credential For Metadata Signature Validation ( signature Resource Location ) ; LOGGER . info ( " Successfully resolved credentials from [{}]" , signature Resource Location ) ; LOGGER . debug ( " Configuring credential resolver for key signature trust engine @ [{}]" , credential . get Credential Type ( ) . get Simple Name ( ) ) ; val resolver = new Static Credential Resolver ( credential ) ; val key Info Resolver = new Basic Provider Key Info Credential Resolver ( key Info Provider List ) ; LOGGER . debug ( " Adding signature validation filter based on the configured trust engine " ) ; val signature Validation Filter = new Signature Validation Filter ( trust Engine ) ; LOGGER . debug ( " Added metadata Signature Validation Filter with signature from [{}]" , signature Resource Location ) ; return signature Validation Filter ; }<CODESPLIT>Build signature validation filter if needed .<CODESPLIT>1
public static make ( String specification ) { ( retrieving specification '{}'" , specification ) ; ( specification With ( :" ) ) { logger . trace ( " URL is of type ' classpath '" ) ; return new URL ( null , specification , new Class Path URL Stream Handler ( ) ) ; logger . trace ( " URL is of normal type " ) ; return new URL ( specification ) ;<CODESPLIT>Returns an URL object for the given URL specification .<CODESPLIT>1
public void ( Object , Throwable ) { ( Level ( LEVEL _ DEBUG ) ) { log ( LOG _ LEVEL _ DEBUG , message , t ) ; } }<CODESPLIT><p > Log a message with debug log level . < / p ><CODESPLIT>1
protected ( ) { ( ) { ; language get ( ) ; get ( ) ; variant . get Variant ( ) ; if ( language == "" && country == "" && variant == "" ) { return "" ; String Builder sb = new String Builder ( ) ; if ( variant != "" ) { sb . append ( language ) . append ( ' ' ) . append ( country ) . append ( ' ' ) . append ( variant ) ; } else if ( country != "" ) { sb . append ( language ) . append ( ' ' ) . append ( country ) ; else { sb . append ( language ) ; return sb . to String ( ) ;<CODESPLIT>Convert locale to string with language_country [ _variant ]<CODESPLIT>1
public Facet Attributes Result with Attributes ( Facet Attribute ... attributes ) { ( attributes ) { set Attributes ( Array Facet Attribute ( attributes . length ) ) ; } for ( Facet Attribute ele : attributes ) { this . attributes . add ( ele ) ; } return this ; }<CODESPLIT><p > Associates an Identity and Access Management ( IAM ) role from an Neptune DB cluster . < / p ><CODESPLIT>0
public Autofit add On Text Change Listener ( On Text Change Listener listener ) { ( ) { = Array List < On Text Size Change Listener > ( ) ; } m Listeners . add ( listener ) ; return this ; }<CODESPLIT>Adds an {<CODESPLIT>1
public void merge Vertices ( vertex , Graph , Combinator combinator , Graph Toolkit Graph , , toolkit ) { ( vertex ( ) <= ) { ; } ( ) ; Type e = i . next ( ) ; if ( vertex Set . contains ( e . get Source ( ) ) || vertex Set . contains ( e . get Target ( ) ) ) { edge Set . add ( e ) ; } } Vertex Type composite Vertex = combinator . combine Vertices ( vertex Set ) ; for ( Edge Type e : edge Set ) { Vertex Type source = vertex Set . contains ( e . get Source ( ) ) ? composite Vertex : e . get Source ( ) ; Vertex Type target = vertex Set . contains ( e . get Target ( ) ) ? composite Vertex : e . get Target ( ) ; if ( source == composite Vertex && target == composite Vertex && e . get Source ( ) != e . get Target ( ) ) { continue ; } if ( g . lookup Edge ( source , target ) != null ) { continue ; } Edge Type composite Edge = g . create Edge ( source , target ) ; toolkit . copy Edge ( e , composite Edge ) ; } for ( Vertex Type a Vertex Set : vertex Set ) { g . remove Vertex ( a Vertex Set ) ; } }<CODESPLIT>Resolve an annotation into AnnotationValues representing any type qualifier ( s ) the annotation resolves to . Detects annotations which are directly marked as TypeQualifier annotations and also resolves the use of TypeQualifierNickname annotations .<CODESPLIT>0
public void visit ( Node ) throws { ( Ast Function ) { Ast Function func Node = ( Ast Function ) ; Method = ; ( this . fn != ) { = fn . resolve Function ( func Node . get Prefix ( ) , func Node . get Name ( ) ) ; } ( == this . var != null && func Node . get Prefix ( ) . length ( ) == 0 ) { this . var Mapper . resolve Variable ( func Node . get Local Name ( ) ) ; return ; } if ( this . fn Mapper == null ) { throw new EL Exception ( Message Factory . get ( " error . fn Mapper . null " ) ) ; } if ( m == null ) { throw new EL Exception ( Message Factory . get ( " error . fn Mapper . method " , func Node . get Output Name ( ) ) ) ; } int method Parameter Count = m . get Parameter Types ( ) . length ; int input Parameter Count = node . jjt Get Child ( 0 ) . jjt Get Num Children ( ) ; if ( m . is Var Args ( ) && input Parameter Count < method Parameter Count - 1 || ! m . is Var Args ( ) && input Parameter Count != method Parameter Count ) { } } else if ( node instanceof Ast Identifier && this . var Mapper != null ) { String variable = ( ( Ast Identifier ) node ) . get Image ( ) ; this . var Mapper . resolve Variable ( variable ) ; } }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public Observable get Details Async ( team , ) { get Details With Async ( team , ) . map ( new Func 1 < Service Response < Job > , Job > ( ) { @ Override public Job call ( Service Response < Job > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Get the Job Details for a Job Id .<CODESPLIT>0
private void check Indices ( int row , int ) { ( row 0 row >= ) Array Out Of ( row row ) ; else if ( col < 0 || col >= cols ) throw new Array Index Out Of Bounds Exception ( " column : " + col ) ; }<CODESPLIT>Check that the indices of a requested cell are within bounds .<CODESPLIT>1
private void create Parent Child Relationships ( db , Map String , Account description Map , Map String , Array List String seq Map ) throws { Array List String Id Array List String ( ) ; Id add ( Account ACCOUNT ) ; ( Id ( ) 0 ) { String Id Id get ( 0 ) ; Account Account description Map get ( Id ) ; Id remove ( 0 ) ; if ( parent Id . compare To ( Account . ROOT _ ACCOUNT _ URI ) != 0 ) { if ( parent Account != null ) { if ( db . find Account By Id ( parent Id ) == null ) { Account parent Parent Account = db . find Parent ( parent Account ) ; if ( parent Parent Account == null ) { logger . warning ( " Seq Node [" + parent Id + "] does not have a parent , will be dropped " ) ; parent Account = null ; } } } else { logger . warning ( " Seq Node [" + parent Id + "] does not have a matching RDF : Description node , it will be dropped " ) ; } } else { parent Account = db . get Root Account ( ) ; if ( parent Account != null ) { for ( String child Id : seq Map . get ( parent Id ) ) { Account child Account = description Map . get ( child Id ) ; if ( child Account != null ) { if ( ! parent Account . has Child ( child Account ) ) { parent Account . get Children ( ) . add ( child Account ) ; if ( seq Map . contains Key ( child Account . get Id ( ) ) ) { parent Id Stack . add ( child Id ) ; child Account . set Is Folder ( true ) ; else { logger . warning ( " Duplicate child '" + child Id + "' found of parent '" + parent Account . get Id ( ) + "'" ) ; else { logger . warning ( " Cannot find RDF : Description for '" + child Id + "', it will be dropped " ) ;<CODESPLIT><p > Specifies the type of the array components so that the adequate array functions can be offered . < / p ><CODESPLIT>0
private Decimal Format get Number ( Transformer transformer , int context ) throws Transformer { Locale = ( Locale ) get Locale ( transformer , context ) . clone ( ) ; Decimal Format = ; ( ( Group Sep Value ) ( ! _ grouping _ avt . is ( ) ) ( Group Sep Value . ( ) ) ) { transformer . get ( ) . ( this , XSLT Error Resources . WG _ ILLEGAL _ ATTRIBUTE _ VALUE , Object [ ] { . ATTRNAME _ , _ grouping _ avt . get Name ( ) } ) ; } String Digits Per Group Value = ( m _ grouping Size _ avt ) ? m _ grouping Size _ avt . evaluate ( transformer . get X Path Context ( ) , context Node , this ) : null ; if ( ( null != digit Group Sep Value ) && ( null != n Digits Per Group Value ) && ( digit Group Sep Value . length ( ) > 0 ) ) { try { formatter = ( Decimal Format ) Number Format . get Number Instance ( locale ) ; formatter . set Grouping Size ( Integer . value Of ( n Digits Per Group Value ) . int Value ( ) ) ; Decimal Format Symbols symbols = formatter . get Decimal Format Symbols ( ) ; symbols . set Grouping Separator ( digit Group Sep Value . char At ( 0 ) ) ; formatter . set Decimal Format Symbols ( symbols ) ; formatter . set Grouping Used ( true ) ; } catch ( Number Format Exception ex ) { formatter . set Grouping Used ( false ) ; } } return formatter ; }<CODESPLIT>Get the number formatter to be used the format the numbers<CODESPLIT>1
public static Commerce Notification Template to Models ( Commerce Notification Template Soap Models ) { ( Models ) { ; } Commerce Notification Template models List < Commerce Notification Template > ( soap Models . length ) ; for ( Commerce Notification Template Soap soap Model : soap Models ) { models . add ( to Model ( soap Model ) ) ; } return models ; }<CODESPLIT>Converts the soap model instances into normal model instances .<CODESPLIT>1
public static Double Double ( Object value ) { ( value ) ; ( value Date ) ( double ) ( ( Date ) value ) get ( ) ; ( value Calendar ) ( double ) ( ( Calendar ) value ) get In ( ) ; ( value Boolean ) ( boolean ) value . 0 : 0 . 0 ; if ( value instanceof Integer ) return ( double ) ( ( int ) value ) ; if ( value instanceof Short ) return ( double ) ( ( short ) value ) ; if ( value instanceof Long ) return ( double ) ( ( long ) value ) ; if ( value instanceof Float ) return ( double ) ( ( float ) value ) ; if ( value instanceof Double ) return ( double ) value ; if ( value instanceof String ) try { return Double . parse Double ( ( String ) value ) ; } catch ( Number Format Exception ex ) { return null ; } return null ; }<CODESPLIT>Converts value into doubles or returns default value when conversion is not possible .<CODESPLIT>0
public Processor get Processor ( ) { String command Processor command Processor get ( ) ; ( command Processor ) { Panic In The Cougar ( Processor has configured + protocol ) ; } Http Command Processor command Processor = ( Http Command Processor ) application Context . get Bean ( command Processor Name ) ; if ( command Processor == null ) { throw new Panic In The Cougar ( " No HTTP Command Processor has been configured for the name " + command Processor Name ) ; } return command Processor ; }<CODESPLIT>Returns the command processor assocated with the supplied protocol<CODESPLIT>1
public get Parameters ) "," ; ." get ) From ()" ; "," ; ." get Name ( ) + " To ()" ; result += "," ; result += this . get Owner ( ) . get Finder Class Name ( ) + "." + this . get Name ( ) + " Infinity " ; result += "," ; result += this . future Expiring Rows Exist ( ) ; result += "," ; result += this . is To Is Inclusive ( ) ; result += "," ; result += this . get Owner ( ) . get Finder Class Name ( ) + "." + this . get Name ( ) + " Default " ; result += "," ; result += this . is Processing Date ( ) ; result += "," ; result += this . is Infinity Null ( ) ; return result ; }<CODESPLIT>/ * String attributeName String dataClassName String busClassName boolean isNullable boolean hasBusDate RelatedFinder relatedFinder Map<String Object > properties boolean transactional boolean isOptimistic<CODESPLIT>1
public boolean set Active ( ) { boolean Active ( ) ; ( ) { Locator Locator ( get Path ( ) get ( ) ) set El Path ( get Title Path ( ) ) ; Locator Element set Message ( get Path Builder ( ) . get Text ( ) + " Tab " ) ; activated = title Element . click ( ) ; } if ( activated ) { LOGGER . info ( " set Active : " + to String ( ) ) ; } return activated ; }<CODESPLIT>example new DataField () . setDate ( 19 05 2013 )<CODESPLIT>0
public String Converter find Converter ( Class ) { ( cls == Byte [ ] . class ) { return Byte Array String Converter . INSTANCE ; } return null ; }<CODESPLIT>Creates a new conversion manager including the extended standard set of converters . <p > The returned converter is a new instance that includes additional converters : <ul > <li > JDK converters <li > { @link NumericArrayStringConverterFactory } <li > { @link NumericObjectArrayStringConverterFactory } <li > { @link CharObjectArrayStringConverterFactory } <li > { @link ByteObjectArrayStringConverterFactory } <li > { @link BooleanArrayStringConverterFactory } <li > { @link BooleanObjectArrayStringConverterFactory } < / ul > <p > The convert instance is mutable in a thread - safe manner . Converters may be altered at any time including the JDK converters . It is strongly recommended to only alter the converters before performing actual conversions .<CODESPLIT>0
public Disassociate Resources disassociate Resources ( Disassociate Resources Request request ) { request before Client Execution ( request ) ; return execute Disassociate S 3 Resources ( request ) ; }<CODESPLIT><p > Removes specified S3 resources from being monitored by Amazon Macie . If memberAccountId isn t specified the action removes specified S3 resources from Macie for the current master account . If memberAccountId is specified the action removes specified S3 resources from Macie for the specified member account . < / p ><CODESPLIT>1
public static double cdf ( double double k double lambda double theta ) { ( theta ) ( Fast exp ( - Fast Math . pow ( ( val - theta ) / lambda , k ) ) ) : val == val ? 0 . 0 : Double . Na N ; }<CODESPLIT>CDF of Weibull distribution<CODESPLIT>1
public static void equalize Col ( Gray U , int , int start X , Gray U output , I work ) { int width = 2 ; int area = width width ; int Value = work . ( ) ; int [ histogram = work . ( ) ; int [ = work . ( ) ; int 0 = start X ; int = start X width ; ( 1 > input . width ) { } local Histogram ( input , hist 0 , 0 , hist 1 , width , histogram ) ; int sum = 0 ; for ( int i = 0 ; i < histogram . length ; i ++ ) { transform [ i ] = sum += histogram [ i ] ; } int index In = input . start Index + radius * input . stride + start X ; int index Out = output . start Index + radius * output . stride + start X ; for ( int x = 0 ; x < radius ; x ++ ) { int input Value = input . data [ index In ++ ] & 0 xff ; output . data [ index Out ++ ] = ( short ) ( ( transform [ input Value ] * max Value ) / area ) ; } for ( int y = radius + 1 ; y < input . height - radius ; y ++ ) { for ( int x = hist 0 ; x < hist 1 ; x ++ ) { histogram [ input . data [ index In + x ] & 0 x FFFF ] -- ; } index In += width * input . stride ; for ( int x = hist 0 ; x < hist 1 ; x ++ ) { histogram [ input . data [ index In + x ] & 0 x FFFF ] ++ ; for ( int i = 0 ; i < histogram . length ; i ++ ) { transform [ i ] = sum += histogram [ i ] ; for ( int x = 0 ; x < radius ; x ++ ) { int input Value = input . data [ index In ++ ] & 0 xff ; output . data [ index Out ++ ] = ( short ) ( ( transform [ input Value ] * max Value ) / area ) ; work Arrays . recycle ( histogram ) ; work Arrays . recycle ( transform ) ;<CODESPLIT>Local equalization along a row . Image must be at least the histogram s width ( 2 * r + 1 ) in width and height .<CODESPLIT>0
public static int Array ( int index , int array Length , String message ) { ( index 0 index >= array Length ) { Index Out Of Bounds Exception ( message ) ; } return index ; }<CODESPLIT>Throws an { @link IndexOutOfBoundsException } if { @code sliceFrom } or { @code sliceLength } is negative or the sum of both is greater than { @code arrayLength } . Note that this means that a slice of length zero starting at array length is a valid slice .<CODESPLIT>0
public static Q Sync create ( String , ) { return create ( host , port , true , true ) ; }<CODESPLIT>ファイルが1904年始まりの設定かどうか。<CODESPLIT>0
private T T add ( String , T , long Diskspace , boolean inherit ) throws Quota Exceeded { get Path ( ) ; path components . length - 1 ] ; child . set Local Name ( path ) ; cache Name ( child ) ; I Node [ ] inodes = new I Node [ components . length ] ; write Lock ( ) ; try { root Dir . get Existing Path I Nodes ( components , inodes ) ; return add Child ( inodes , inodes . length - 1 , child , child Diskspace , inherit Permission ) ; } finally { write Unlock ( ) ; } }<CODESPLIT>Add a node child to the namespace . The full path name of the node is src . childDiskspace should be - 1 if unknown . QuotaExceededException is thrown if it violates quota limit<CODESPLIT>1
public Vector add ( float , float , float , float ) { add ( , y , z , w , this Or New ( ) ) ; }<CODESPLIT>Increment the components of this vector by the given values .<CODESPLIT>1
public Detect detect ( String , String , String mime ) { ( is Empty ( ) ) { TEMPLATE validate ( , detect " ) ; } Detect Language Request request = Detect Language Request . new Builder ( ) . set Parent ( parent ) . set Model ( model ) . set Mime Type ( mime Type ) . build ( ) ; return detect Language ( request ) ; }<CODESPLIT>Formats a string containing the fully - qualified path to represent a location resource .<CODESPLIT>0
protected void common ( Z Matrix Maj ) { set Expected ( Rows , A . num Cols ) ; QR . set ( A ) ; }<CODESPLIT><p > Computes the householder vector u for the first column of submatrix j . Note this is a specialized householder for this problem . There is some protection against overflow and underflow . < / p > <p > Q = I - &gamma ; uu<sup > H< / sup > < / p > <p > This function finds the values of u and &gamma ; . < / p ><CODESPLIT>0
public Esa Resource Writable parse File To Resource ( File asset File , File File , String content Url ) throws Repository { Artifact Metadata artifact Metadata = explode Artifact ( asset File , File ) ; { feature = Esa Feature Definition . construct Instance ( asset File ) ; } ( IO ) { Repository Archive IO ( . get Message ( ) , asset File , ) ; } Esa Resource Writable resource = Writable Resource Factory . create Esa ( ) ; String symbolic Name = feature . get Symbolic Name ( ) ; String version = feature . get Version ( ) . to String ( ) ; String Name = feature . get Header ( - Name , Locale . ENGLISH ) ; String short Name = feature . get Ibm Short Name ( ) ; String Name = artifact Metadata != artifact Metadata . get Name ( ) : ; final String name ; ( Name != ! Name . is Empty ( ) ) { } else if ( subsystem Name != null && ! subsystem Name . is Empty ( ) ) { } else if ( short Name != null && ! short Name . is Empty ( ) ) { } else { } resource . set Name ( name ) ; String short Description = null ; String overridden Display Policy = null ; if ( artifact Metadata != null ) { short Description = artifact Metadata . get Short Description ( ) ; resource . set Description ( artifact Metadata . get Long Description ( ) ) ; resource . set Vanity URL ( artifact Metadata . get Property ( PROP _ VANITY _ URL ) ) ; overridden Display Policy = artifact Metadata . get Property ( PROP _ DISPLAY _ POLICY ) ; } if ( short Description == null ) { short Description = feature . get Header ( " Subsystem - Description " , Locale . ENGLISH ) ; } resource . set Short Description ( short Description ) ; resource . set Version ( version ) ; process Icons ( asset File , feature , resource ) ; String provider = feature . get Header ( " Subsystem - Vendor " ) ; if ( provider != null && ! provider . is Empty ( ) ) { resource . set Provider Name ( provider ) ; if ( " IBM " . equals ( provider ) ) { resource . set Provider Url ( " http :// www . ibm . com " ) ; } } else { throw new Invalid Parameter Exception ( " Subsystem - Vendor must be set in the manifest headers " ) ; } resource . set Provide Feature ( symbolic Name ) ; if ( artifact Metadata != null && artifact Metadata . get Property ( " IBM - Applies To " ) != null ) { resource . set Applies To ( artifact Metadata . get Property ( " IBM - Applies To " ) ) ; } else { resource . set Applies To ( feature . get Header ( " IBM - Applies To " ) ) ; } } } } else { } resource . set Visibility ( visibility ) ; if ( feature . is Auto Feature ( ) ) { resource . set Provision Capability ( feature . get Header ( " IBM - Provision - Capability " ) ) ; String IBM Install Policy = feature . get Header ( " IBM - Install - Policy " ) ; if ( IBM Install Policy != null && ( " when - satisfied " . equals ( IBM Install Policy ) ) ) { } else { } resource . set Install Policy ( install Policy ) ; } if ( is Beta ( resource . get Applies To ( ) ) ) { resource . set Web Display Policy ( Display Policy . HIDDEN ) ; } else { resource . set Web Display Policy ( web Display Policy ) ; } if ( overridden Display Policy != null ) { display Policy = Display Policy . value Of ( overridden Display Policy ) ; } resource . set Display Policy ( display Policy ) ; String required Fixes = feature . get Header ( " IBM - Require - Fix " ) ; if ( required Fixes != null && ! required Fixes . is Empty ( ) ) { String [ ] fixes = required Fixes . split ( "," ) ; for ( String fix : fixes ) { fix = fix . trim ( ) ; if ( ! fix . is Empty ( ) ) { resource . add Require Fix ( fix ) ; } } } resource . set Short Name ( short Name ) ; Collection < Feature Resource > required Features = feature . get Constituents ( Subsystem Content Type . FEATURE _ TYPE ) ; for ( Feature Resource feature Resource : required Features ) { List < String > tolerates = feature Resource . get Tolerates ( ) ; String required Feature Symbolic Name = feature Resource . get Symbolic Name ( ) ; resource . add Require Feature With Tolerates ( required Feature Symbolic Name , tolerates ) ; String superseded By = feature . get Superseded By ( ) ; if ( superseded By != null && ! superseded By . trim ( ) . is Empty ( ) ) { String [ ] superseded By Array = superseded By . split ( "," ) ; for ( String f : superseded By Array ) { if ( f . starts With ( "[" ) ) { f = f . substring ( 1 , f . length ( ) - 1 ) ; resource . add Superseded By Optional ( f ) ; else { resource . add Superseded By ( f ) ; if ( artifact Metadata != null ) { attach License Data ( artifact Metadata , resource ) ; set Java Requirements ( asset File , resource ) ; String attachment Name = symbolic Name + ". esa " ; add Content ( resource , asset File , attachment Name , artifact Metadata , content Url ) ; try { process L Aand LI ( asset File , resource , feature ) ; catch ( IO Exception e ) { throw new Repository Archive IO Exception ( e . get Message ( ) , asset File , e ) ; resource . set License Id ( feature . get Header ( " Subsystem - License " ) ) ; resource . set Singleton ( Boolean . to String ( feature . is Singleton ( ) ) ) ; resource . set IBM Install To ( feature . get Header ( " IBM - Install To " ) ) ; return resource ;<CODESPLIT>Look in the esa for bundles with particular java version requirements . Create an aggregate requirement of the esa as a whole and write the data into the supplied resource<CODESPLIT>0
public static T T invoke Method ( Object , Method method , Object ... ) { { ( T ) method invoke ( , ) ; } ( e ) { throw Exception Util . unwrap And Unchecked ( e ) ; } }<CODESPLIT>调用构造函数 .<CODESPLIT>0
public add Common ) { get Cipher Suites ) get Cipher Suites ) ) { . set Enabled Cipher Suites ( ssl Config . get Cipher Suites ( ) ) ; } if ( ssl Config . get Enable Protocols ( ) != null && ssl Config . get Enable Protocols ( ) . length > 0 ) { engine . set Enabled Protocols ( ssl Config . get Enable Protocols ( ) ) ; } engine . set Enable Session Creation ( ssl Config . is Enable Session Creation ( ) ) ; return engine ; }<CODESPLIT>Add common configs for both client and server ssl engines .<CODESPLIT>1
public static Internal ( String kbase , Kie Configuration ) { return new Knowledge Base Impl ( kbase Id , ( Rule Base Configuration ) conf ) ; }<CODESPLIT>TODO : FIXME : make it consistent with above<CODESPLIT>0
private T void add Internal ( @ Nonnull Iterable T ) { ( ! iterator ( ) has Next ( ) ) { ; ( newer Than older Than ) { Iterator T iterator ( ) ; ( has Next ( ) ) { add ( ( ) ) ; if ( is Full ( ) ) { break ; } } has Down Page = iter . has Next ( ) ; } else if ( newer Than != null ) { int to Fill Count = get Fill Count ( ) ; if ( to Fill Count > 0 ) { Iterator < Item T > iter = items . iterator ( ) ; while ( iter . has Next ( ) ) { Item T item = iter . next ( ) ; if ( History Page Entry . get Entry Id ( item ) > newer Than ) { items To Add . add Last ( item ) ; if ( items To Add . size ( ) > to Fill Count ) { items To Add . remove First ( ) ; has Up Page = true ; } } else { break ; } } if ( items To Add . size ( ) == 0 ) { has Down Page = true ; } else { if ( items To Add . size ( ) < to Fill Count ) { Iterator < Item T > skipped Iter = items . iterator ( ) ; Iterators . skip ( skipped Iter , items To Add . size ( ) ) ; Item T item = skipped Iter . next ( ) ; items To Add . add Last ( item ) ; } } has Down Page = iter . has Next ( ) ; for ( Object item : items To Add ) { add ( item ) ; } } } } else if ( older Than != null ) { Iterator < Item T > iter = items . iterator ( ) ; while ( iter . has Next ( ) ) { Object item = iter . next ( ) ; if ( History Page Entry . get Entry Id ( item ) >= older Than ) { has Up Page = true ; } else { add ( item ) ; if ( is Full ( ) ) { has Down Page = iter . has Next ( ) ; break ; }<CODESPLIT>Add run items and queued items to the History page .<CODESPLIT>0
private Artifact get Management ( ) { Artifact = Artifact ( ) ; Management dependency Management = get Project ( ) . get Dependency Management ( ) ; if ( dependency Management != null ) { for ( Dependency dependency : dependency Management . get Dependencies ( ) ) { result . add ( to Artifact ( dependency ) ) ; } } return result ;<CODESPLIT>Returns all dependency artifacts in all modules excluding all reactor artifacts ( including attached ) .<CODESPLIT>0
public void add ( Rec field ) { Record ( Record ) field ; ( ( ( get Record ( ) get Mode ( ) REFRESH AND _ ON _ CHANGE _ STRATEGY ) != DB Constants . OPEN _ REFRESH _ AND _ LOCK _ ON _ CHANGE _ STRATEGY ) || ( record . is Refreshed Record ( ) ) ) this . restore Main Record ( record , true ) ; super . add ( record ) ; }<CODESPLIT>Add this record ( Always called from the record class ) .<CODESPLIT>1
protected void set ( Throwable ) { ( U compare And Int ( , STATE , , COMPLETING ) ) { outcome ; U Ordered Int ( this , STATE , EXCEPTIONAL ) ; finish Completion ( ) ; } }<CODESPLIT>Sets the result of this future to the given value unless this future has already been set or has been cancelled .<CODESPLIT>0
public static get ( Class , String path ) { current Resource Instance . get Resource ( class Loader , path ) ; }<CODESPLIT>Replies the input stream of a resource .<CODESPLIT>0
static , Map , dynamically Cast Map ( Map , map , Class Type , Class value Type ) { ( map ) { ; } assert check Collection ( map Set ( ) , key Type ) : " The map contains keys with a type other than " + key Type . get Name ( ) ; assert check Collection Members ( map . values ( ) , value Type ) : " The map contains values with a type other than " + value Type . get Name ( ) ; return ( Map < K , V > ) map ; }<CODESPLIT>=====<CODESPLIT>0
public java List liferay commerce product model CP Option Value Rel get CP Option Value By Uuid And Company Id ( String uuid , long company Id ) { _ cp Definition Option Value Rel Local Service . get CP Definition Option Value Rels By Uuid And Company Id ( uuid , company Id ) ; }<CODESPLIT>Returns a range of cp definition option value rels matching the UUID and company .<CODESPLIT>0
public void set Compliance ( java Collection String Filter compliance ) { ( compliance ) { . compliance Status = null ; return ; } this . compliance Status = new java . util . Array List < String Filter > ( compliance Status ) ; }<CODESPLIT><p > The details of a resource that does not have a specific sub - field for the resource type defined . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setResourceDetailsOther ( java . util . Collection ) } or { @link #withResourceDetailsOther ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
public static void call Method ( Object , String method Name , boolean include Private Mehtods , Object ... ) throws Invocation Target { Class [ ] int Class = init Params ( ) ; { Class current = . get Class ( ) ; Method method = ; ( current != Object . class ) { { method = current . get Method ( method Name , int Class ) ; ; } ( No Method ) { current = current . get Superclass ( ) ; } } if ( method == null ) { throw new No Such Method Exception ( " Mehtod is not found in " + current ) ; } method . set Accessible ( true ) ; method . invoke ( obj , args ) ; } catch ( final Invocation Target Exception e ) { } catch ( final Exception e ) { throw new Invocation Target Exception ( e ) ; } }<CODESPLIT>Checks if is class avilable in class path .<CODESPLIT>0
public boolean Parse ( File file ) { String filename file get Name ( ) ; With ( filename , ". xes " ) ; }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public Product Sets Paged list Product Sets ( Location Name ) { Product Sets Request request Product Sets Request ( ) set Parent ( null ? null : parent . to String ( ) ) . build ( ) ; return list Product Sets ( request ) ; }<CODESPLIT>Lists ProductSets in an unspecified order .<CODESPLIT>1
public Matrix ( Matrix ) { ( . get Row Dimension ( ) != ) { Argument ( Matrix row dimensions must agree ." ) ; } ( ! isspd ) { ( Matrix is not symmetric positive definite ." ) ; } double [ ] [ ] X = B . get Array Copy ( ) ; int nx = B . get Column Dimension ( ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { for ( int i = 0 ; i < k ; i ++ ) { X [ k ] [ j ] -= X [ i ] [ j ] * L [ k ] [ i ] ; } X [ k ] [ j ] /= L [ k ] [ k ] ; } } for ( int k = n - 1 ; k >= 0 ; k -- ) { for ( int j = 0 ; j < nx ; j ++ ) { for ( int i = k + 1 ; i < n ; i ++ ) { } } } return new Matrix ( X , n , nx ) ; }<CODESPLIT>Solve A * X = B<CODESPLIT>1
public java List Record Patch get Record Patches ( ) { ( record Patches ) { record Patches com . amazonaws . internal . Sdk Internal List < Record Patch > ( ) ; } return record Patches ; }<CODESPLIT>A list of patch operations .<CODESPLIT>1
private void process Fields ( ) { Field fields Introspection get Fields ( embeddable Class ) ; ( Field field fields ) { ( field is ( Embedded class ) ) { process Embedded Field ( field ) ; } else { process Simple Field ( field ) ; } } }<CODESPLIT>Processes the given simple ( or primitive ) field and updates the metadata .<CODESPLIT>0
public Operation update Explicit Async ( long item Update Explicit Parameter update Explicit Item Optional Parameter ) { return update Explicit List Item With Service Response Async ( app Id , version Id , entity Id , item Id , update Explicit List Item Optional Parameter ) . map ( new Func 1 < Service Response < Operation Status > , Operation Status > ( ) { @ Override public Operation Status call ( Service Response < Operation Status > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Updates an explicit list item for a Pattern . Any entity .<CODESPLIT>1
public void register ( Diagnostics Plugin plugin ) { check Not Null ( plugin , plugin ) ; ( ! ) { ; } long period plugin get Period ( ) ; ( period ) { ( plugin a period ) ; logger . finest ( plugin . get Class ( ) . to String ( ) + " is " + ( period Millis == DISABLED ? " disabled " : " enabled " ) ) ; if ( period Millis == DISABLED ) { return ; plugins Map . put ( plugin . get Class ( ) , plugin ) ; plugin . on Start ( ) ; if ( period Millis > 0 ) { scheduler . schedule At Fixed Rate ( new Write Plugin Task ( plugin ) , 0 , period Millis , MILLISECONDS ) ; } else { add Static Plugin ( plugin ) ; }<CODESPLIT>Registers a { @link DiagnosticsPlugin } . <p > This method is thread - safe . <p > There is no checking for duplicate registration . <p > If the { @link Diagnostics } is disabled the call is ignored .<CODESPLIT>1
public clean Area Async ( Context , , int Min , int ) { task new Cache Manager Task ( this , get Cleaning Action ( ) , bb , zoom Min , zoom Max ) ; task . add Callback ( get Cleaning Dialog ( ctx , task ) ) ; return execute ( task ) ; }<CODESPLIT>Remove all cached tiles in the specified area .<CODESPLIT>1
public static List External Graphic From Graphic ( Graphic graphic ) { List External Graphic List Array List External Graphic ( ) ; ( Graphical gs graphic . graphical ( ) ) { ( ( gs ) && ( gs instanceof External Graphic ) ) { External Graphic external Graphic = ( External Graphic ) gs ; g List . add ( external Graphic ) ; } } return g List ;<CODESPLIT>Creates a default { @link Style } for a featurecollection .<CODESPLIT>0
public get ( String Name , array ) { Impl element Class Info = get Delayable Class Info ( array Type . get Element Type ( ) ) ; return new Array Class Info ( type Class Name , element Class Info ) ; }<CODESPLIT>For array types the previous implementation used the element name .<CODESPLIT>0
public void ( ) { Calendar ( Calendar ) get Sub Screen ( this , Calendar . class ) ; if ( panel != null ) panel . free ( ) ; super . free ( ) ; }<CODESPLIT>Free the sub = components .<CODESPLIT>1
public void rule X Member Feature ( ) throws Recognition { int stack = keep ( ) ; { { { ( state . backtracking 0 ) { before ( grammar Access . get X Member Feature Access ( ) . get Group ( ) ) ; } { Follow ( FOLLOW _ 2 ) ; rule __ X Member Feature __ Group __ 0 ( ) ; state . _ fsp ; if ( state . failed ) return ; } if ( state . backtracking == 0 ) { } } } } catch ( Recognition Exception re ) { report Error ( re ) ; recover ( input , re ) ; } finally { restore Stack Size ( stack Size ) ; } return ; }<CODESPLIT>InternalXbase . g : 633 : 1 : entryRuleXMemberFeatureCall : ruleXMemberFeatureCall EOF ;<CODESPLIT>0
protected String sign And Base Encode ( , String key , Signing algorithm ) throws Sdk Client { { sign ( , key . get Bytes ( 8 ) , algorithm ) ; Base . encode As String ( ) ; } ( Exception e ) { throw new Sdk Client Exception ( " Unable to calculate a request signature : " + e . get Message ( ) , e ) ; } }<CODESPLIT>Computes an RFC 2104 - compliant HMAC signature for an array of bytes and returns the result as a Base64 encoded string .<CODESPLIT>1
private void Process Next ( ) { ( ) { _ SOURCE _ : _ DEST _ : ( Catalog To Select ( ) ) { f Main . show ( ) ; return ; } ; f Main . show ( ) ; return ; } ; _ SOURCE _ TABLES : ( Transfer Mode == TRFM _ TRANSFER ) { Start . set Label ( " Start Transfer " ) ; } else if ( i Transfer Mode == TRFM _ DUMP ) { b Start . set Label ( " Start Dump " ) ; } else if ( i Transfer Mode == TRFM _ RESTORE ) { b Start . set Label ( " Start Restore " ) ; } b Start . invalidate ( ) ; b Start . set Enabled ( false ) ; l Table . set Multiple Mode ( false ) ; Refresh Main Display ( ) ; break ; default : break ; } }<CODESPLIT>Method declaration<CODESPLIT>0
Representation Repr ( Representation payload Repr ) { Representation Repr Representation ( ) ; Representation Repr = Json Representation . new Map ( ) ; event Repr . map Put ( " metadata " , metadata Repr ) ; metadata Repr . map Put ( " id " , metadata . get Id ( ) ) ; metadata Repr . map Put ( " transaction Id " , metadata . get Transaction Id ( ) ) ; metadata Repr . map Put ( " sequence " , metadata . get Sequence ( ) ) ; metadata Repr . map Put ( " event Type " , metadata . get Event Type ( ) ) ; metadata Repr . map Put ( " user " , metadata . get User ( ) ) ; event Repr . map Put ( " payload " , payload Repr ) ; return event Repr ; }<CODESPLIT>Set up the screen fields ( default = set them all up for the current record ) .<CODESPLIT>0
public float ( Int Float Vector ) { ( Int Float Vector ) { Int Float Vector other = ( ( Int Float Vector ) ) ; float = 0 ; int oc = 0 ; ( int = 0 ; ; ) { ( oc other . used ) { if ( other . indices [ oc ] < indices [ c ] ) { oc ++ ; } dot += values [ c ] * other . values [ oc ] ; break ; } else { break ; } } } return dot ; } else { float dot = 0 ; for ( int c = 0 ; c < used ; c ++ ) { dot += this . values [ c ] * y . get ( indices [ c ] ) ; } return dot ; }<CODESPLIT>Computes the dot product of this vector with the other vector .<CODESPLIT>1
protected Prc Refresh Catalog Get Prc Refresh Catalog ( Map String , Object Param ) { String Name Prc Refresh Catalog get Name ( ) ; Prc Refresh Catalog proc ( Prc Refresh Catalog ) processors Map get ( Name ) ; ( proc ) { proc Prc Refresh Catalog ( ) ; proc get ( ) add ( . fct Bn Public Trade Processors . lazy Get Prc Webstore Page ( p Add Param ) ) ; this . processors Map . put ( bean Name , proc ) ; this . logger . info ( null , Fct Bn Trade Processors . class , bean Name + " has been created ." ) ; } return proc ;<CODESPLIT><p > Lazy get PrcRefreshCatalog . < / p ><CODESPLIT>1
private static String build ( String ) { ( ) { NULL _ MESSAGE ; } return format ( INVALID _ MSG _ FMT , id ) ; }<CODESPLIT>Build the exception s message using the <tt > id< / tt > value .<CODESPLIT>1
public get Moneyness As Offsets ) Double moneyness get Nodes Per Moneyness ) ) ) map To Double ) quoting Convention Quoting Convention PAYERVOLATILITYLOGNORMAL ) moneyness moneyness map Double Unary ) Override public apply As Double ( double x ) { return x * 0 . 01 ; } } ) ; } else if ( quoting Convention == Quoting Convention . RECEIVERPRICE ) { moneyness = moneyness . map ( new Double Unary Operator ( ) { @ Override public double apply As Double ( double x ) { return - x * 0 . 0001 ; } } ) ; } else { moneyness = moneyness . map ( new Double Unary Operator ( ) { @ Override public double apply As Double ( double x ) { return x * 0 . 0001 ; } } ) ; } return moneyness . to Array ( ) ;<CODESPLIT>Return all valid maturities for a given moneyness . Uses the fixing times of the fix schedule to determine fractions .<CODESPLIT>0
public Frustum set To Projection ( double double double double double near double Vector near Normal boolean ortho boolean mirrored ) { double nfnx near Normal ( ) nfny near Normal ( ) nfnz near Normal ( ) ; ( ortho ) { double nrz nfnz ; vertices 0 ] . set ( left , bottom , xl + yb - near ) ; _ vertices [ mirrored ? 3 : 1 ] . set ( right , bottom , xr + yb - near ) ; _ vertices [ 2 ] . set ( right , top , xr + yt - near ) ; _ vertices [ mirrored ? 1 : 3 ] . set ( left , top , xl + yt - near ) ; _ vertices [ 4 ] . set ( left , bottom , xl + yb - far ) ; _ vertices [ mirrored ? 7 : 5 ] . set ( right , bottom , xr + yb - far ) ; _ vertices [ 6 ] . set ( right , top , xr + yt - far ) ; _ vertices [ mirrored ? 5 : 7 ] . set ( left , top , xl + yt - far ) ; } else { double rn = 1 f / near ; double z 0 = nz / ( nfnx * lrn + nfny * brn - nfnz ) ; _ vertices [ 0 ] . set ( - z 0 * lrn , - z 0 * brn , z 0 ) ; double z 1 = nz / ( nfnx * rrn + nfny * brn - nfnz ) ; _ vertices [ mirrored ? 3 : 1 ] . set ( - z 1 * rrn , - z 1 * brn , z 1 ) ; double z 2 = nz / ( nfnx * rrn + nfny * trn - nfnz ) ; _ vertices [ 2 ] . set ( - z 2 * rrn , - z 2 * trn , z 2 ) ; double z 3 = nz / ( nfnx * lrn + nfny * trn - nfnz ) ; _ vertices [ mirrored ? 1 : 3 ] . set ( - z 3 * lrn , - z 3 * trn , z 3 ) ; double z 4 = fz / ( nfnx * lrn + nfny * brn - nfnz ) ; _ vertices [ 4 ] . set ( - z 4 * lrn , - z 4 * brn , z 4 ) ; double z 5 = fz / ( nfnx * rrn + nfny * brn - nfnz ) ; _ vertices [ mirrored ? 7 : 5 ] . set ( - z 5 * rrn , - z 5 * brn , z 5 ) ; double z 6 = fz / ( nfnx * rrn + nfny * trn - nfnz ) ; _ vertices [ 6 ] . set ( - z 6 * rrn , - z 6 * trn , z 6 ) ; double z 7 = fz / ( nfnx * lrn + nfny * trn - nfnz ) ; } update Derived State ( ) ; return this ; }<CODESPLIT>Sets this frustum to an orthographic one pointing in the Z - direction with the specified parameters determining its size ( see the OpenGL documentation for <code > glOrtho< / code > ) .<CODESPLIT>0
private String To String ( Object param ) { ( param ) { ; } ( param Date ) { format Date ( ( Date ) param ) ; } ( param Collection ) { for ( Object o : ( Collection ) param ) { if ( b . length ( ) > 0 ) { b . append ( "," ) ; b . append ( String . value Of ( o ) ) ; return b . to String ( ) ; } else { return String . value Of ( param ) ; } }<CODESPLIT>Reads a buffer .<CODESPLIT>0
public static validate Not Null ( value , String error Template , Object ... params ) throws { ( is Null ( value ) ) { Validate Exception ( error Msg Template , params ) ; } return value ; }<CODESPLIT>检查指定值是否为<code > null< / code ><CODESPLIT>0
public void set Commit Trigger Commit Trigger commit Trigger ) commit Trigger commit Trigger ) ;  commit Trigger != null ) { this . commit Trigger . remove Commit Trigger Listener ( commit Trigger Handler ) ; this . commit Trigger = null ; } if ( commit Trigger != null ) { if ( this . commit Trigger Handler == null ) { this . commit Trigger Handler = new Commit Trigger Handler ( ) ; } this . commit Trigger . add Commit Trigger Listener ( commit Trigger Handler ) ; }<CODESPLIT>Sets the <code > CommitTrigger< / code > that triggers the commit and flush events .<CODESPLIT>1
public static String get Relative Sub Path ( String , String path ) { String ; Cms String join ( , ) ; path Cms String join ( path , ) ; ( path . starts With ( base ) ) { result = path . substring ( base . length ( ) ) ; } if ( result != null ) { if ( result . ends With ( "/" ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; if ( ! result . starts With ( "/" ) ) { return result ;<CODESPLIT>Returns <code > true< / code > if the provided Objects are either both <code > null< / code > or equal according to { @link Object#equals ( Object ) } . <p ><CODESPLIT>0
private void read More From Stream ( ) throws { ( Stream Has More ) { ; } int Available In Buffer ; ( Available <= 0 ) { return ; int bytes Read = stream . read ( buffer , bytes In Buffer , buffer Space Available ) ; if ( bytes Read == - 1 ) { inner Stream Has More Data = false ; } else { bytes In Buffer += bytes Read ; } }<CODESPLIT>Fill the buffer with more data from the InputStream if there is any .<CODESPLIT>1
public Get get Get Request request ) { request Client Execution ( request ) ; return execute Get Plan ( request ) ; }<CODESPLIT><p > Retrieves a specified security configuration . < / p ><CODESPLIT>0
public void ( String ) throws { writer print ( ) ; this . writer . print ( "\ r \ n " ) ; this . writer . flush ( ) ; }<CODESPLIT>{<CODESPLIT>0
public void set Peer Peer Marshaller ) { Peer Marshaller ovalue peer ; request Attribute Change PEER SERVICE , value , ovalue ) ; this . peer Service = value ; }<CODESPLIT>Requests that the <code > bootStamp< / code > field be set to the specified value . The local value will be updated immediately and an event will be propagated through the system to notify all listeners that the attribute did change . Proxied copies of this object ( on clients ) will apply the value change when they received the attribute changed notification .<CODESPLIT>0
public String Doc Root ( String htmlstr ) { index htmlstr index Of ( "{@" ) ; ( index ) { htmlstr ; } Matcher docroot Matcher docroot Pattern ( htmlstr ) ; ( docroot Matcher find ( ) ) { htmlstr ; } String String ( ) ; 0 ; do { int match = docroot Matcher . start ( ) ; buf . append ( htmlstr . substring ( prev End , match ) ) ; prev End = docroot Matcher . end ( ) ; if ( configuration . docrootparent . length ( ) > 0 && htmlstr . starts With ( "/.." , prev End ) ) { buf . append ( configuration . docrootparent ) ; prev End += 3 ; } else { } if ( prev End < htmlstr . length ( ) && htmlstr . char At ( prev End ) != ' ' ) { buf . append ( ' ' ) ; } } while ( docroot Matcher . find ( ) ) ; buf . append ( htmlstr . substring ( prev End ) ) ; return buf . to String ( ) ; }<CODESPLIT>Programmatic interface .<CODESPLIT>0
public static String get ( Object ) { String property String ( ) ; if ( obj == null ) { return property Names ; } else { List < Object > cycle Detect = new Array List < Object > ( ) ; perform Get Property Names ( obj , null , property Names , cycle Detect ) ; return property Names ; }<CODESPLIT>Recursively gets names of all properties implemented in specified object and its subobjects .<CODESPLIT>1
public boolean check Locks ( boolean exclusive ) { ( check Parents ( exclusive ) check ( exclusive ) ) { return true ; } return false ; }<CODESPLIT>checks if a lock of the given exclusivity can be placed only considering children up to depth<CODESPLIT>1
private static void create Instance ( ) { { Class Class Name ( MP EVALUATOR ) ; instance ( MP ) Instance ( ) ; } catch ( Exception e ) { FFDC Filter . process Exception ( e , " com . ibm . ws . sib . processor . MP Selector Evaluator Factory . create Factory Instance " , " 100 " ) ; throw new SI Error Exception ( e ) ; } }<CODESPLIT>Create the singleton Factory instance .<CODESPLIT>1
public Chain basic Uniform Distribution ( Uniform Distribution Uniform Distribution , Chain msgs ) { ( ( Feature Internal ) get Mixed ( ) ) basic ( Bpsim Literals . DOCUMENT _ ROOT __ UNIFORM _ DISTRIBUTION , new Uniform Distribution , msgs ) ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>1
private Entity get Entity ( ) { Entity em ; ( Tx . is Active ( ) ) { em = ( Entity ) . get ( Name ) ; ( em == null ) { em = create Entity Manager ( ) ; transaction Synchronization Registry . put Resource ( unit Name , em ) ; } else { validate Compatible Sync Types ( em ) ; } } else { em = non Tx Em Holder . get Entity Manager ( ) ; if ( em == null ) { em = create Entity Manager ( ) ; non Tx Em Holder . set Entity Manager ( em ) ; } } return em ; }<CODESPLIT>Subscribes to an event dispatcher and starts a watch for a given key .<CODESPLIT>0
public FS get ( ) { ( Type ( ( Type ) Type ) item ) Type . throw Feat Missing ( " item List " , " de . julielab . jules . types . List " ) ; return ( FS Array ) ( jcas Type . ll _ cas . ll _ get FS For Ref ( jcas Type . ll _ cas . ll _ get Ref Value ( addr , ( ( List _ Type ) jcas Type ) . cas Feat Code _ item List ) ) ) ; }<CODESPLIT>setter for itemList - sets contains items of the level 1 . The items of the level 1 could contain further items of next level and so on in order to represent an iterative structure of list items .<CODESPLIT>0
public Push Rules create Push Rules ( Or Push Rules Rule ) Git Lab { Git Lab Git Lab ( ) with Param ( delete tag Rule get Deny Tag ( ) ) with Param ( check Rule get Member ( ) ) with Param ( secrets Rule get Secrets ( ) ) with Param ( commit push Rule . get Commit Message Regex ( ) ) . with Param ( " branch _ name _ regex " , push Rule . get Branch Name Regex ( ) ) . with Param ( " author _ email _ regex " , push Rule . get Author Email Regex ( ) ) . with Param ( " file _ name _ regex " , push Rule . get File Name Regex ( ) ) . with Param ( " max _ file _ size " , push Rule . get Max File Size ( ) ) ; Response response = post ( Response . Status . CREATED , form Data , " projects " , get Project Id Or Path ( project Id Or Path ) , " push _ rule " ) ; return ( response . read Entity ( Push Rules . class ) ) ; }<CODESPLIT>Adds a push rule to a specified project .<CODESPLIT>1
public static Recurrence Date Interval of ( int count , Plain Date start , Date ) { check ( count ) ; ( start == ) { Null Exception ( " Missing start of recurrent interval ." ) ; } return new Recurrent Date Intervals ( count , TYPE _ START _ DURATION , start , duration ) ; }<CODESPLIT>/ * [ deutsch ] <p > Erzeugt eine Sequenz von wiederkehrenden Datumsintervallen mit der angegebenen Dauer . < / p ><CODESPLIT>1
private static String upper ( String ) { char chars . to Char Array ( ) ; int . ( ) ; ( chars ) { case ' ' : chars [ i ] = ' ' ; break ; case ' ' : chars [ i ] = ' ' ; break ; case ' ' : chars [ i ] = ' ' ; break ; case ' ' : chars [ i ] = ' ' ; break ; case ' ' : chars [ i ] = ' ' ; break ; case ' ' : chars [ i ] = ' ' ; break ; } } return new String ( chars ) ; }<CODESPLIT>/ * Efficiently converts a string containing a hexadecimal number from lower case to upper case<CODESPLIT>1
check Not ( analytics ) ; check Not ( ) ; check Not ( Page Title ) ; check Not ( Page ) ; check Not ( ) ; check Not ( ) ; check Not ( Number ) ; check Not ( billing ) ; check Not ( Hostname ) ; check Not ( ) ; Value ( ) ; add ( Value ( ) ) ; add ( Value Pair ( PARAM _ PROPERTY _ ID , analytics Id ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ TYPE , VALUE _ TYPE _ PAGEVIEW ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ IS _ NON _ INTERACTIVE , VALUE _ FALSE ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ CACHEBUSTER , Long . to String ( random . next Long ( ) ) ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ EVENT _ TYPE , event Type ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ EVENT _ NAME , event Name ) ) ; if ( client Hostname . is Present ( ) && ! client Hostname . get ( ) . is Empty ( ) ) { list Builder . add ( new Basic Name Value Pair ( PARAM _ HOSTNAME , client Hostname . get ( ) ) ) ; } list Builder . add ( new Basic Name Value Pair ( PARAM _ CLIENT _ ID , client Id ) ) ; if ( project Number Hash . is Present ( ) && ! project Number Hash . get ( ) . is Empty ( ) ) { list Builder . add ( new Basic Name Value Pair ( PARAM _ PROJECT _ NUM _ HASH , project Number Hash . get ( ) ) ) ; } if ( billing Id Hash . is Present ( ) && ! billing Id Hash . get ( ) . is Empty ( ) ) { list Builder . add ( new Basic Name Value Pair ( PARAM _ BILLING _ ID _ HASH , billing Id Hash . get ( ) ) ) ; } list Builder . add ( new Basic Name Value Pair ( PARAM _ USER _ SIGNED _ IN , to Value ( is User Signed In ) ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ USER _ INTERNAL , to Value ( is User Internal ) ) ) ; if ( is User Trial Eligible . is Present ( ) ) { list Builder . add ( new Basic Name Value Pair ( PARAM _ USER _ TRIAL _ ELIGIBLE , to Value ( is User Trial Eligible . get ( ) ) ) ) ; } list Builder . add ( new Basic Name Value Pair ( PARAM _ IS _ VIRTUAL , VALUE _ TRUE ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ PAGE , virtual Page Name ) ) ; if ( ! virtual Page Title . is Empty ( ) ) { list Builder . add ( new Basic Name Value Pair ( PARAM _ PAGE _ TITLE , virtual Page Title ) ) ; } return list Builder . build ( ) ; }<CODESPLIT>Adds more data providers to the validator .<CODESPLIT>0
public void insert ( Char Sequence text ) throws { int ln = text . ( ) ; ( ln == 0 ) { return ; ( ln >= size ( end ) ) { ( text fit the buffer " ) ; if ( cursor != end ) { make Room ( ln ) ; for ( int ii = 0 ; ii < ln ; ii ++ ) { set ( ( cursor + ii ) , text . char At ( ii ) ) ; end += ln ;<CODESPLIT>Inserts text at cursor position<CODESPLIT>1
public void on New Tab ( Ajax Request Target , tab , index ) { ( ( index ) ( index >= get Tabs ( ) ( ) ) ) { Out Of ( ) ; } get Tabs ( ) . add ( index , tab ) ; set Selected Tab ( index ) ; target . add ( this ) ; }<CODESPLIT>On new tab .<CODESPLIT>1
public static void output Image ( int , int , Output Stream os , String code ) throws { int verify = code . ( ) ; Buffered Image image = Buffered Image ( , , Buffered Image . TYPE _ _ RGB ) ; Random = Random ( ) ; 2 D 2 = image . create ( ) ; 2 . set Rendering Hint ( Rendering Hints . _ ANTIALIASING , Rendering Hints . VALUE _ ANTIALIAS _ ) ; Color [ ] colors = Color [ 5 ] ; Color [ ] = Color [ ] { ; float [ ] fractions = float [ colors . ] ; ( int = 0 ; colors . ; ) { fractions [ ] = . Float ( ) ; } . sort ( fractions ) ; 2 . set Color ( Color . GRAY ) ; 2 . fill Rect ( 0 , 0 , w , h ) ; Color c = get Rand Color ( 200 , 250 ) ; g 2 . set Color ( c ) ; g 2 . fill Rect ( 0 , 2 , w , h - 4 ) ; Random random = new Random ( ) ; g 2 . set Color ( get Rand Color ( 160 , 200 ) ) ; for ( int i = 0 ; i < 20 ; i ++ ) { int x = random . next Int ( w - 1 ) ; int y = random . next Int ( h - 1 ) ; int xl = random . next Int ( 6 ) + 1 ; int yl = random . next Int ( 12 ) + 1 ; g 2 . draw Line ( x , y , x + xl + 40 , y + yl + 20 ) ; } float yawp Rate = 0 . 05 f ; int area = ( int ) ( yawp Rate * w * h ) ; for ( int i = 0 ; i < area ; i ++ ) { int x = random . next Int ( w ) ; int y = random . next Int ( h ) ; int rgb = get Random Int Color ( ) ; image . set RGB ( x , y , rgb ) ; } shear ( g 2 , w , h , c ) ; g 2 . set Color ( get Rand Color ( 100 , 160 ) ) ; int font Size = h - 4 ; Font font = new Font ( " Algerian " , Font . ITALIC , font Size ) ; g 2 . set Font ( font ) ; char [ ] chars = code . to Char Array ( ) ; for ( int i = 0 ; i < verify Size ; i ++ ) { Affine Transform affine = new Affine Transform ( ) ; g 2 . set Transform ( affine ) ; g 2 . draw Chars ( chars , i , 1 , ( ( w - 10 ) / verify Size ) * i + 5 , h / 2 + font Size / 2 - 10 ) ; } g 2 . dispose ( ) ; Image IO . write ( image , " jpg " , os ) ; }<CODESPLIT>生成指定验证码图像文件<CODESPLIT>0
public Object find Closest Object ( int x , int y , int [ ] distance ) { ( _ size == 0 ) { return ; } int sr = ( x ) , sl = sr ; int mindist = Integer . _ VALUE , minidx = ; for ( boolean expanded = ; expanded ; ) { expanded = false ; ( sr _ size ) { ( rec . x x mindist ) { int dist = distance ( rec . x , rec . y , x , y ) ; ( dist mindist ) { } sr += 1 ; expanded = true ; } } if ( sl >= 0 ) { if ( x - rec . x < mindist ) { int dist = distance ( rec . x , rec . y , x , y ) ; if ( dist < mindist ) { minidx = sl ; mindist = dist ; } expanded = true ; } } } if ( minidx == - 1 ) { throw new Runtime Exception ( " Proximity algorithm failed !" ) ; } if ( distance != null && distance . length > 0 ) { } return _ records [ minidx ] . object ; }<CODESPLIT>Removes from the tracker the object that is equal to ( <code > o1 . equals ( object ) < / code > ) the specified object .<CODESPLIT>0
public void set Golden Grammar ( FS ) { ( Golden ( ( Golden ) ) golden Grammar ) jcas Type . jcas . throw Feat Missing ( " golden Grammar Errors " , " cogroo . uima . Golden Sentence " ) ; jcas Type . ll _ cas . ll _ set Ref Value ( addr , ( ( Golden Sentence _ Type ) jcas Type ) . cas Feat Code _ golden Grammar Errors , jcas Type . ll _ cas . ll _ get FS Ref ( v ) ) ; }<CODESPLIT>setter for goldenGrammarErrors - sets<CODESPLIT>1
Map Cms Principal Bean , String get Responsibles ( Cms Object cms , Cms Resource res ) { Map Cms Principal Bean , String = Map Cms Principal Bean , String ( ) ; List Cms Resource Resources = Array List Cms Resource ( ) ; { Resources = cms . read Path ( res , Cms Resource Filter . IGNORE _ EXPIRATION ) ; } ( Cms ) { . error ( . get ( ) , ) ; } ( Cms Resource resource Resources ) { String Site Root = cms . get Request Context ( ) . get Site Root ( ) ; String site Path = cms . get Request Context ( ) . remove Site Root ( resource . get Root Path ( ) ) ; try { cms . get Request Context ( ) . set Site Root ( "/" ) ; for ( Cms Access Control Entry ace : entries ) { if ( ace . is Responsible ( ) ) { I _ Cms Principal principal = cms . lookup Principal ( ace . get Principal ( ) ) ; if ( principal != null ) { if ( ! resource . get Root Path ( ) . equals ( res . get Root Path ( ) ) ) { if ( resource . get Root Path ( ) . starts With ( stored Site Root ) ) { result . put ( prin Bean , site Path ) ; } else { result . put ( prin Bean , resource . get Root Path ( ) ) ; } } else { result . put ( prin Bean , null ) ; } } } } } catch ( Cms Exception e ) { LOG . info ( " Problem with reading responsible users for " + resource . get Name ( ) + " : " + e . get Localized Message ( ) , e ) ; } finally { cms . get Request Context ( ) . set Site Root ( stored Site Root ) ; } } return result ; }<CODESPLIT>Returns the responsibles . <p ><CODESPLIT>1
public static Router ( String Template , Context ) { return route ( ) . post ( uri Template , handler ) ; }<CODESPLIT>Performs mapping for all routers .<CODESPLIT>0
public static void descending ( Matrix R Maj U , boolean tran U , Matrix R Maj , Matrix R Maj , boolean tran ) { Singular ( , ) ; check Svd Matrix ( U , tran U , , , tran ) ; ( 0 ; Singular ; ++ ) { int big Index = - 1 ; for ( int j = i ; j < num Singular ; j ++ ) { double v = W . get ( j , j ) ; if ( v > big Value ) { } } if ( big Index == i ) continue ; if ( big Index == - 1 ) { break ; double tmp = W . get ( i , i ) ; W . set ( i , i , big Value ) ; W . set ( big Index , big Index , tmp ) ; if ( V != null ) { swap Row Or Col ( V , tran V , i , big Index ) ; } if ( U != null ) { swap Row Or Col ( U , tran U , i , big Index ) ; } }<CODESPLIT>Computes the SVD and sorts singular values in descending order . While easier to use this can reduce performance when performed on small matrices numerous times .<CODESPLIT>0
public Api Response stop Monitoring ( Monitoring stop Monitoring ) throws Api { Api Response Api Response resp stop Monitoring With Http ( stop Monitoring Data ) ; return resp . get Data ( ) ; }<CODESPLIT>Start recording a call Start recording the specified call . Recording stops when the call is completed or you send [ / voice / calls / { id } / stop - recording ] ( / reference / workspace / Voice / index . html#stopRecording ) on either the call or the DN .<CODESPLIT>0
public String get Attribute String ( String ) { Object attributes get ( ) ; ( == null ) { return null ; } else { return ( String ) o ; } }<CODESPLIT>Get the value for a given attribute .<CODESPLIT>1
public static CP Option Value find By Group ( long , start , ) { return get Persistence ( ) . find By Group Id ( group Id , start , end ) ; }<CODESPLIT>Returns a range of all the cp option values where groupId = &#63 ; .<CODESPLIT>1
private static void handle Singleton Class ( String , String value ) { Object handle Value ( value ) ; ( contains ( "," ) ) { String ( "," ) ; ( String an Interface : interfaces ) { service Map . put ( an Interface , object ) ; } } else { service Map . put ( key , object ) ; }<CODESPLIT>Send email with a string content and attachment<CODESPLIT>0
public static String ( String , char separator , boolean Quotes ) { strtok Str Tokenizer ( string , Str Matcher . char Matcher ( separator ) , Str Matcher . quote Matcher ( ) ) ; return strtok . get Token Array ( ) ; }<CODESPLIT>Normalize and collapse whitespaces from string buffer .<CODESPLIT>0
public Comparison get Lt Filter From Prefix Like ( ) { Type Type COMPARE LESSTHAN ; String comparand extract And Like Prefix ( ) ; return range Filter From Prefix Like ( m _ left , range Comparator , comparand ) ; }<CODESPLIT>/ Construct the upper bound comparison filter implied by a prefix LIKE comparison .<CODESPLIT>1
public void show Forgot View ( Token ) { { Cms Token Cms Token ( ) ; Result validate Token ( Cms get Cms Object ( ) Token Cms get Login ( ) get Token Lifetime ( ) ) ; ( Result ) { Cms User user get User ( ) ; ( user ( ) ) { Cms Dialog dlg Cms Dialog ( Cms user get Locale ( ) ) ; Cms get ( ) set Content To Dialog ( Messages get ( ) get ( Cms get ( ) get Locale ( ) ) . key ( Messages . GUI _ PWCHANGE _ HEADER _ 0 ) + user . get Name ( ) , dlg ) ; else { Notification . show ( Cms Vaadin Utils . get Message Text ( Messages . ERR _ USER _ NOT _ SELF _ MANAGED _ 1 , user . get Name ( ) ) , Type . ERROR _ MESSAGE ) ; else { A _ Cms UI . get ( ) . set Error ( Messages . get ( ) . get Bundle ( A _ Cms UI . get ( ) . get Locale ( ) ) . key ( Messages . GUI _ PWCHANGE _ INVALID _ TOKEN _ 0 ) ) ; LOG . info ( " Invalid authorization token : " + auth Token + " / " + validation Result ) ; } } catch ( Exception e ) { LOG . error ( e . get Localized Message ( ) , e ) ;<CODESPLIT>Initializes the login view . <p ><CODESPLIT>0
public C Hints ( Server Table Hints ... Hints ) { ( Hints 0 ) { String Server Grammar table Hints ( table Hints ) ; add Join Flag ( hints , Join Flag . Position . END ) ; } return ( C ) this ; }<CODESPLIT>Set the table hints<CODESPLIT>1
private void populate ( Field field , Object , String Value ) { field set ( ) ; { field field get ( ) ; Object value Converter convert ( Value ) ( field Type ) ; field . set ( target , value ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( " Could not populate field " + field , e ) ; } }<CODESPLIT>Populates the specified field on the target with the value from the given option .<CODESPLIT>1
public Object get Parameter ( String name ) { { Q Name qname = Q Name . get Q Name From String ( name ) ; ( == _ user ) return ; for ( int = ; >= 0 ; ) { arg = ( ) _ user Params . element At ( i ) ; if ( arg . get Q Name ( ) . equals ( qname ) ) { return arg . get Val ( ) . object ( ) ; } } return null ; } catch ( java . util . No Such Element Exception nsee ) { return null ; } }<CODESPLIT>Reset parameters that the user specified for the transformation . Called during transformer . reset () after we have cleared the variable stack . We need to make sure that user params are reset so that the transformer object can be reused .<CODESPLIT>0
private Multipart Content create Content Problem Input ) { ) ; set Parameter BOUNDARY create ) ) ; ) get ) ) ) ; Multipart Content Multipart Content ) set type ) . add Part ( Http Request Executor . build Data Part ( CSRF _ PARAMETER _ NAME , values . get Token ( ) ) ) . add Part ( Http Request Executor . build File Part ( ANSWER _ PARAMETER , output ) ) . add Part ( Http Request Executor . build File Part ( SOURCE _ FILE _ PARAMETER , source ) ) . add Part ( Http Request Executor . build Data Part ( SOURCE _ FILE _ NAME _ PARAMETER , source File Path ) ) . add Part ( Http Request Executor . build Data Part ( COMMAND _ PARAMETER _ NAME , SUBMIT _ COMMAND ) ) . add Part ( Http Request Executor . build Data Part ( PROBLEM _ PARAMETER _ NAME , input . get Problem ( ) . get Id ( ) ) ) . add Part ( Http Request Executor . build Data Part ( INPUT _ ID _ PARAMETER _ NAME , String . value Of ( input . get Number ( ) ) ) ) . add Part ( Http Request Executor . build Data Part ( NUM _ SOURCE _ FILE _ PARAMETER , DEFAULT _ NUM _ SOURCE _ FILE ) ) . add Part ( Http Request Executor . build Data Part ( AGENT _ PARAMETER _ NAME , DEFAULT _ AGENT ) ) ; return content ; }<CODESPLIT><p > Created and returns a valid { @link MultipartContent } instance that contains data required for submission . < / p ><CODESPLIT>1
public boolean ( E ) { ( cnt In >= ) { buckets . add ( ( E ) Object ) ; cnt In Bucket = 0 ; } buckets . get Last ( ) [ cnt In Bucket ++ ] = e ; size ++ ; return true ; }<CODESPLIT>This method verifies that this GO has no PCI representation or that the PCI representation is not dirty or new . Otherwise it will throw an exception in order to prevent the dirty state of the GO and the PC to result in conflicting updates in the database .<CODESPLIT>0
static ( DTO DTO ) { ( DTO get ( ) ) ; ( DTO Datasource DTO get Datasources ( ) ) { ( get Heartbeat ( ) ) { r Descriptor . datasource ( ds . get Label ( ) , ds . get Source ( ) , ds . get Heartbeat ( ) , ds . get Function ( ) ) ; } else { r Descriptor . datasource ( ds . get Label ( ) , ds . get Source ( ) , ds . get Function ( ) ) ; for ( Result Descriptor DTO . Expression expr : r Descriptor DTO . get Expressions ( ) ) { r Descriptor . expression ( expr . get Label ( ) , expr . get Expression ( ) ) ; r Descriptor . export ( r Descriptor DTO . get Exports ( ) ) ; return r Descriptor ;<CODESPLIT>Visits all nodes in the resource tree bellow the given resource using depth - first search .<CODESPLIT>0
public boolean handle Remote Criteria ( String Buffer , boolean Include File , Vector Field Param ) { get ( ) ; ( next Listener != null ) return ( ( File Listener ) next Listener ) . do Remote Criteria ( str Filter , b Include File Name , v Param List ) ; else return this . do Remote Criteria ( str Filter , b Include File Name , v Param List ) ; }<CODESPLIT>Check to see if this record should be skipped . Generally you use a remote criteria .<CODESPLIT>0
@ Consumes ( Media ) @ Produces ( Media ) public register Windows ( Windows windows @ Path Param ( App ) @ ) { Push App get ( ) find By Push For Developer ( ) ; ( App ) { status ( NOT ) ( " Could not find requested Push Application Entity " ) . build ( ) ; } try { validate Model Class ( windows Variant ) ; } catch ( Constraint Violation Exception cve ) { logger . trace ( " Unable to create Windows variant " ) ; Response . Response Builder builder = create Bad Request Response ( cve . get Constraint Violations ( ) ) ; return builder . build ( ) ; } logger . trace ( " Register Windows variant with Push Application '{}'" , push Application ID ) ; variant Service . add Variant ( windows Variant ) ; push App Service . add Variant ( push App , windows Variant ) ; return Response . created ( uri Info . get Absolute Path Builder ( ) . path ( String . value Of ( windows Variant . get Variant ID ( ) ) ) . build ( ) ) . entity ( windows Variant ) . build ( ) ; }<CODESPLIT>Get a global integer property . This method will first try to get the value from an environment variable and if that does not exist it will look up a system property .<CODESPLIT>0
public static Iterable Reference get ( String Id , Offline Auth ) { Genomics genomics Genomics ( ) build ( ) from Offline Auth ( auth ) ; return Paginator . References . create ( genomics ) . search ( new Search References Request ( ) . set Reference Set Id ( reference Set Id ) ) ; }<CODESPLIT>Gets VariantSetIds from a given datasetId using the Genomics API .<CODESPLIT>0
public void ( String File , String remote Target ) throws { ( String ] { local File } , remote Target Directory , " 0600 " ) ; }<CODESPLIT>Copy a local file to a remote directory uses mode 0600 when creating the file on the remote side .<CODESPLIT>1
public synchronized void throttle ( int Rpc Target ) { ( is Throttling ) { ; } long high Target = ( long ) ( Rpc Target . 2 ) ; long low Target = ( long ) ( Rpc Target 0 . 8 ) ; set Current In Flight Rpcs ( get Current In Flight Rpcs ( ) / 4 ) ; Runnable = Runnable ( ) { @ Override public void run ( ) { long mean = get Mean ( stats . get Timer ( ) ) ; ( mean >= Rpc Target ) { reduce Parallelism ( mean , absolute In Flight Rpcs / ) ; } ( mean Ms >= high Target Ms ) { reduce Parallelism ( mean Latency Ms , absolute Max In Flight Rpcs / 10 ) ; } else if ( get Mean Ms ( stats . get Throttling Timer ( ) ) > 1 ) { if ( mean Latency Ms <= low Target Ms ) { increase Parallelism ( mean Latency Ms , absolute Max In Flight Rpcs / 20 ) ; } else if ( current In Flight Max Rpcs < absolute Max In Flight Rpcs / 20 && mean Latency Ms <= ( bulk Mutation Rpc Target Ms * 2 ) ) { increase Parallelism ( mean Latency Ms , absolute Max In Flight Rpcs / 50 ) ; } } } private long get Mean Ms ( Timer timer ) { return Time Unit . NANOSECONDS . to Millis ( ( long ) timer . get Snapshot ( ) . get Mean ( ) ) ; } private void reduce Parallelism ( long mean Latency Nanos , int step ) { int minimum Rpc Count = Math . max ( absolute Max In Flight Rpcs / 100 , 1 ) ; int new Value = Math . max ( current In Flight Max Rpcs - step , minimum Rpc Count ) ; set Parallelism ( mean Latency Nanos , " Reducing " , new Value ) ; } private void increase Parallelism ( long mean Latency Nanos , int increment Step ) { int new Value = Math . min ( current In Flight Max Rpcs + increment Step , absolute Max In Flight Rpcs ) ; set Parallelism ( mean Latency Nanos , " Increasing " , new Value ) ; } private void set Parallelism ( long mean Latency Nanos , String type , int new Value ) { int current Value = get Current In Flight Max Rpcs ( ) ; if ( new Value != current Value ) { set Current In Flight Max Rpcs ( new Value ) ; } } } ; Bigtable Session Shared Thread Pools . get Instance ( ) . get Retry Executor ( ) . schedule At Fixed Rate ( r , 20 , 20 , Time Unit . SECONDS ) ; is Throttling = true ; }<CODESPLIT>Enable an experimental feature that will throttle requests made from {<CODESPLIT>1
public static Unchecked Binary from Base ( String ) { for ( int = 0 ; . ( ) ; ) { char = . char At ( i ) ; if ( c == ' ' ) c = ' ' ; if ( c == ' ' ) c = ' ' ; if ( c == ' ' ) c = ' ' ; normalized Base 64 . append ( c ) ; } while ( normalized Base 64 . length ( ) % 4 != 0 ) { normalized Base 64 . append ( ' ' ) ; } byte [ ] bytes = Datatype Converter . parse Base 64 Binary ( normalized Base 64 . to String ( ) ) ; return Binary . from ( bytes ) ; }<CODESPLIT>Reads standard and URL / filename - safe Base 64 dialects as described in RFC 4686 . Additionally it accepts not Base 64 encoded strings without padding or allows to use dot character ( . ) as padding character .<CODESPLIT>1
boolean is Match ( Class Type , Object id ) { Type equals ( this . bean Type ) && id Match ( id ) ; }<CODESPLIT>Checks that the supplied parameter is not null . Throws a {<CODESPLIT>0
private String format ( value ) { String ; ( value ) { String priority Types Locale get String Array ( , Locale PRIORITY ) ; priority value get Value ( ) ; ( priority < Priority . LOWEST ) { priority = Priority . LOWEST ; } else { if ( priority > Priority . DO _ NOT _ LEVEL ) { priority = Priority . DO _ NOT _ LEVEL ; } } priority /= 100 ; result = priority Types [ priority - 1 ] ; } return ( result ) ; }<CODESPLIT>This method is called to format a task type .<CODESPLIT>0
public static Memcpy Peer ( Udeviceptr dst Device Ucontext dst Udeviceptr Device Ucontext src Context , long Byte Count ) { return cu Memcpy Peer Native ( dst Device , dst Context , src Device , src Context , Byte Count ) ; }<CODESPLIT>Copies device memory between two contexts .<CODESPLIT>1
private Graph Centric Query has ( String , Titan , Object ) { check Not Null ( ) ; check Not Null ( ) ; check ( is Valid ( condition ) , " Invalid condition : % s " , condition ) ; constraints . add ( new Predicate Condition <> ( key , predicate , condition ) ) ; return this ; }<CODESPLIT>/ * --------------------------------------------------------------- Query Execution ---------------------------------------------------------------<CODESPLIT>0
private void Replicas ( term ) { Context execute ( ( ) -> { ( term term term ( ) . term . term ( ) ) { this . term = term ; consumer . register ( term . primary ( ) . member Id ( ) ) ; } } ) ; }<CODESPLIT>Handles a replica change event .<CODESPLIT>1
public void ( Vector , translation ) { 03 translation . get X ( ) ; this . m 13 += translation . get Y ( ) ; this . m 23 += translation . get Z ( ) ; }<CODESPLIT>Translate the position .<CODESPLIT>1
public static get Float ( value Value float max Value ) { return Math . min ( max Value , Math . max ( min Value , value ) ) ; }<CODESPLIT>Return a float value within the range . <p > This is just a wrapper for Math . min () and Math . max () . This may be useful if you feel it confusing ( Which is min and which is max? ) . < / p ><CODESPLIT>1
public void ( ) { Object preferences To Gdx Sets ( ) ; ( Entry String , > > preference : preferences ) { final Preferences preferences File = names To Files . get ( preference . key ) ; preferences To Flush . add ( preferences File ) ; preference . value . save ( preference . key , preferences File ) ; for ( final Preferences preferences File : preferences To Flush ) { preferences File . flush ( ) ;<CODESPLIT>Saves all current preferences . This is a reasonably heavy operation as it flushes all preferences files - by default this is done once before the application is closed .<CODESPLIT>1
public void unsubscribe ( Subscription subscription ) { subscription get Token ( ) ; log ( Level FINER , Remote { } { }" , Object { name , } ) ; ( ) { transport . register Error Handler ( null ) ; } else if ( token instanceof Tuple 2 ) { this . tuple To Handler Map . remove ( token ) ; } else if ( token instanceof Class ) { this . msg Type To Handler Map . remove ( token ) ; } else { throw new Remote Runtime Exception ( " Unknown subscription type : " + subscription . get Class ( ) . get Canonical Name ( ) ) ; } }<CODESPLIT>Unsubscribes a handler .<CODESPLIT>1
public static to Dna ( Sequence sequence ) throws { check Not Null ( sequence ) ; DNA create DNA ( sequence . get Value ( ) . replace All ( "\\ s +" , "" ) ) ; }<CODESPLIT>Convert the specified HML Sequence element into a DNA symbol list .<CODESPLIT>1
private boolean process Arguments ( String [ ] args ) { ( args . < 1 ) { . err . println ( . get ( argument _ needed ) ) ; return false ; } set Custom Message File From Environment ( ) ; Pattern arg Pattern = Pattern . compile ( "--?(.*)" ) ; for ( int = 0 ; < args . ; ) { Matcher arg Match = arg Pattern . ( args [ ] ) ; ( arg Match . ( ) ) { ( arg Match . group ( 1 ) ) { v : ( 1 < args . ) { ( args [ ] . equals ( 2 . 0 ) args [ ] . equals ( 2 ) ) { } else ( args [ ] . equals ( 3 . 0 ) args [ ] . equals ( 3 ) ) { } else { out Writer . println ( . get ( display _ help " ) ) ; throw new Runtime Exception ( new Invalid Version Exception ( Invalid Version Exception . UNSUPPORTED _ VERSION ) ) ; } } else { out Writer . println ( messages . get ( " display _ help " ) ) ; throw new Runtime Exception ( messages . get ( " version _ argument _ expected " ) ) ; } break ; case " m " : case " mode " : if ( i + 1 < args . length ) { expanded = mode . equals ( " exp " ) ; } else { out Writer . println ( messages . get ( " display _ help " ) ) ; throw new Runtime Exception ( messages . get ( " mode _ argument _ expected " ) ) ; } break ; case " p " : case " profile " : if ( i + 1 < args . length ) { String profile Str = args [ ++ i ] ; try { profile = EPUB Profile . value Of ( profile Str . to Upper Case ( Locale . ROOT ) ) ; } catch ( Illegal Argument Exception e ) { System . err . println ( messages . get ( " mode _ version _ ignored " , profile Str ) ) ; } } else { out Writer . println ( messages . get ( " display _ help " ) ) ; throw new Runtime Exception ( messages . get ( " profile _ argument _ expected " ) ) ; } break ; case " s " : case " save " : keep = true ; break ; file Out = new File ( args [ ++ i ] ) ; } else if ( ( args . length > ( i + 1 ) ) && ( args [ i + 1 ] . equals Ignore Case ( "-" ) ) ) { file Out = null ; i ++ ; } else { File path File = new File ( path ) ; if ( path File . is Directory ( ) ) { } else { file Out = new File ( path + " check . xml " ) ; } } xml Output = true ; break ; file Out = new File ( args [ ++ i ] ) ; } file Out = null ; i ++ ; } else { File path File = new File ( path ) ; if ( path File . is Directory ( ) ) { } else { file Out = new File ( path + " check . json " ) ; } } json Output = true ; break ; file Out = new File ( args [ ++ i ] ) ; } file Out = null ; i ++ ; } else { File path File = new File ( path ) ; if ( path File . is Directory ( ) ) { } else { file Out = new File ( path + " check . xmp " ) ; } } xmp Output = true ; break ; case " i " : case " info " : reporting Level = Reporting Level . Info ; break ; case " f " : case " fatal " : reporting Level = Reporting Level . Fatal ; break ; case " e " : case " error " : reporting Level = Reporting Level . Error ; break ; case " w " : case " warn " : reporting Level = Reporting Level . Warning ; break ; case " u " : case " usage " : reporting Level = Reporting Level . Usage ; break ; case " q " : case " quiet " : out Writer . set Quiet ( true ) ; break ; case " failonwarnings " : String fw = args [ i ] . substring ( "-- failonwarnings " . length ( ) ) ; fail On Warnings = ( fw . compare To ( "-" ) != 0 ) ; break ; case " r " : case " redir " : if ( i + 1 < args . length ) { file Out = new File ( args [ ++ i ] ) ; } break ; case " c " : case " custom Messages " : if ( i + 1 < args . length ) { String file Name = args [ i + 1 ] ; if ( " none " . compare To ( file Name . to Lower Case ( Locale . ROOT ) ) == 0 ) { custom Message File = null ; } else if ( ! file Name . starts With ( "-" ) ) { custom Message File = new File ( file Name ) ; use Custom Message File = true ; } else { System . err . println ( String . format ( messages . get ( " expected _ message _ filename " ) , file Name ) ) ; display Help ( ) ; return false ; } } break ; case " l " : case " list Checks " : if ( i + 1 < args . length ) { if ( ! args [ i + 1 ] . starts With ( "-" ) ) { list Checks Out = new File ( args [ ++ i ] ) ; } else { list Checks Out = null ; } } list Checks = true ; break ; case " locale " : if ( i + 1 < args . length ) { if ( args [ i + 1 ] . starts With ( "-" ) ) { System . err . println ( String . format ( messages . get ( " incorrect _ locale " ) , args [ i + 1 ] ) ) ; display Help ( ) ; return false ; } else { String lang Tag = args [ ++ i ] ; this . locale = Locale . for Language Tag ( lang Tag ) ; this . messages = Messages . get Instance ( this . locale ) ; } else { System . err . println ( String . format ( messages . get ( " missing _ locale " ) ) ) ; display Help ( ) ; return false ; break ; case " h " : case "?" : case " help " : display Help ( ) ; break ; case " version " : display Version ( ) ; break ; default : System . err . println ( String . format ( messages . get ( " unrecognized _ argument " ) , args [ i ] ) ) ; display Help ( ) ; return false ; else { if ( path == null ) { else { System . err . println ( String . format ( messages . get ( " unrecognized _ argument " ) , args [ i ] ) ) ; display Help ( ) ; return false ; if ( ( xml Output && xmp Output ) || ( xml Output && json Output ) || ( xmp Output && json Output ) ) { System . err . println ( messages . get ( " output _ type _ conflict " ) ) ; return false ; if ( path != null ) { String Builder sb = new String Builder ( ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { if ( path . char At ( i ) == ' ' ) { sb . append ( ' ' ) ; else { sb . append ( path . char At ( i ) ) ; path = sb . to String ( ) ; if ( path == null ) { if ( list Checks ) { return true ; else { System . err . println ( messages . get ( " no _ file _ specified " ) ) ; return false ; else if ( path . matches ( ".+\\.[ Ee ][ Pp ][ Uu ][ Bb ]" ) ) { if ( mode != null || version != EPUB Version . VERSION _ 3 ) { System . err . println ( messages . get ( " mode _ version _ ignored " ) ) ; mode = null ; else if ( mode == null && profile == null ) { out Writer . println ( messages . get ( " mode _ required " ) ) ; return false ; return true ;<CODESPLIT>recursively get the values stored for the given {<CODESPLIT>0
public move ( Rel Position ) { Logical Position POSITION ; get ( ) move ( Rel Position ) ; Current Position Position ; ( Rel Position ) Current Position ; ( Rel Position DB Constants . LAST _ RECORD ) { if ( m _ i End Of File Index == UNKNOWN _ POSITION ) { i Current Position = UNKNOWN _ POSITION ; } else i Current Position = m _ i End Of File Index - 1 ; } else i Current Position += i Rel Position ; m _ i Physical File Position = i Current Position ; if ( ( record == null ) && ( ( i Rel Position == DB Constants . FIRST _ RECORD ) || ( i Rel Position == DB Constants . NEXT _ RECORD ) ) ) m _ i End Of File Index = i Current Position ; else { if ( i Current Position != - 1 ) this . add Record Reference ( i Current Position ) ; m _ i Logical File Position = i Current Position ; } return record ; }<CODESPLIT>Find this bookmark in one of the lists .<CODESPLIT>0
public void register Query ( long index , Runnable query ) { List Runnable queries index Queries compute If ( index , -> Linked List <> ( ) ) ; queries . add ( query ) ; }<CODESPLIT>Registers a causal session query .<CODESPLIT>0
public static populate Command ( command , String ... ) { Command Line cli to Command Line ( command , Default ( ) ) ; cli . parse ( args ) ; return command ; }<CODESPLIT><p > Convenience method that initializes the specified annotated object from the specified command line arguments . < / p > <p > This is equivalent to < / p > <pre > CommandLine cli = new CommandLine ( command ) ; cli . parse ( args ) ; return command ; < / pre ><CODESPLIT>1
public Event get Events ( ) { ( Events ) { Event 0 ; } else { Log Event [ ] events = new Log Event [ m Log Events . size ( ) ] ; return ( Log Event [ ] ) m Log Events . to Array ( events ) ; } }<CODESPLIT>Finds a template based on the given URI . If path ends in a slash revert to loading default template . If default not found or not specified return null .<CODESPLIT>0
@ Ensures ( ) protected instrument With Contracts ( , Contract contracts ) { Class Reader reader Class Reader ( ) ; Class writer Non Loading Class ( reader , Class . COMPUTE _ FRAMES | Class Writer . COMPUTE _ MAXS ) ; Specification Class Adapter adapter = new Specification Class Adapter ( writer , contracts ) ; reader . accept ( adapter , Class Reader . EXPAND _ FRAMES ) ; return writer . to Byte Array ( ) ; }<CODESPLIT>Processes the specified reader and returns extracted contracts .<CODESPLIT>0
public void dissociate ( ) { ( Trace Component is Tracing ( ) is Entry ( ) ) { Sib Tr ( , dissociate ) ; } ( final Iterator iterator = _ sessions . iterator ( ) ; iterator . has Next ( ) ; ) { if ( object instanceof Jms Jca Session Impl ) { ( ( Jms Jca Session Impl ) object ) . dissociate ( ) ; iterator . remove ( ) ; } } if ( Trace Component . is Any Tracing Enabled ( ) && TRACE . is Entry Enabled ( ) ) { Sib Tr . exit ( this , TRACE , " dissociate Connections " ) ; } }<CODESPLIT>Returns the current global or container local transaction if any for this managed connection . If there is currently no transaction associated with this managed connection calls <code > lazyEnlist< / code > to ensure that one has not been started .<CODESPLIT>0
public . . . ads . adwords . . 201809 . cm . String String Map Entry [ get Value ( ) { return display Value ; }<CODESPLIT>Gets the parentDimensionValue value for this ProductBiddingCategoryData .<CODESPLIT>0
public Api Future Void delete Instance Async ( String instance ) { String instance Name Name Instance Name ( , instance ) ; bigtable Instance Request request bigtable . v 2 . Delete Instance Request . new Builder ( ) . set Name ( instance Name ) . build ( ) ; return Api Futures . transform ( stub . delete Instance Callable ( ) . future Call ( request ) , new Api Function < Empty , Void > ( ) { @ Override public Void apply ( Empty input ) { return null ; } } , More Executors . direct Executor ( ) ) ; }<CODESPLIT>Asynchronously lists all of the instances in the current project .<CODESPLIT>0
boolean contains ( String Path ) { ( Path ) ; ( Path ( ) normalized Root . length ( ) ) return false ; return normalized Path . region Matches ( 0 , normalized Root , 0 , normalized Root . length ( ) ) ; }<CODESPLIT>Check if the provided path is contained within this root s hierarchy .<CODESPLIT>1
private static boolean check Validity ( Client client , from , expected ) { from >= 0 client get State ( ) == expected ; }<CODESPLIT>Check if the client is in a valid state .<CODESPLIT>1
public Request Vpc Classic Link Request get Dry Run Request ( ) { Request Vpc Classic Link Request request Vpc Classic Link Request Marshaller ( ) marshall ( ) ; request add Parameter ( Dry Run " , Boolean . to String ( true ) ) ; return request ; }<CODESPLIT><p > One or more filters to limit the type of sessions returned by the request . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setFilters ( java . util . Collection ) } or { @link #withFilters ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
private generate Method ( Ct Method method ) Not Found { method get ( ) get ( ) ; method method . get Name ( ) ; List < String > arg Class Qualified Names = get Arg Class Qualified Names ( method ) ; return Test Method . generate Method Key ( class Qualified Name , method Simple Name , arg Class Qualified Names ) ; }<CODESPLIT>( for example when class of method argument type has not been loaded by class loader )<CODESPLIT>0
public static void ( , Object ... ) { ( Factory . indirect Get ( ) , format , arguments ) ; }<CODESPLIT>Info等级日志，小于Warn<br > 由于动态获取Log，效率较低，建议在非频繁调用的情况下使用！！<CODESPLIT>1
private static find Option ( String ) { ( command Argument : Command Line Argument . values ( ) ) { if ( command Line Argument . match ( arg ) ) { return command Line Argument ; } } return null ; }<CODESPLIT>Not needed until workers support dynamic removal ( currently reload required )<CODESPLIT>0
public void add Inherited Summary ( Element Element Content ) { Content Link get Link ( Link MEMBER Element ) ; Content Content ( utils ( Element ) ? configuration . get Text ( " doclet . Fields _ Inherited _ From _ Class " ) : configuration . get Text ( " doclet . Fields _ Inherited _ From _ Interface " ) ) ; Content label Heading = Html Tree . HEADING ( Html Constants . INHERITED _ SUMMARY _ HEADING , label ) ; label Heading . add Content ( Contents . SPACE ) ; label Heading . add Content ( class Link ) ; inherited Tree . add Content ( label Heading ) ; }<CODESPLIT>{<CODESPLIT>0
public static String make Link ( String ) { ( get Current Remote Link ( ) contains Remote Parameter ( ) ) { += ( . contains ( "?" ) ? "&" : "?" ) + PARAM _ REMOTE _ CONNECTION + "=" + get Current Remote Connection Link ( ) ; } return link ; }<CODESPLIT>Adds remote connection parameter to link GET query if parameter yet not present in this link .<CODESPLIT>1
public static Object convert ( String property Name , String , Class , Class property Editor Class ) throws { { ( ) { ; } ( property Editor Class ) { get Value From Bean Property Editor ( , property Name , , property Editor Class ) ; ( . equals ( Boolean . class ) . equals ( Boolean . TYPE ) ) { " ; return new Boolean ( s ) ; else if ( t . equals ( Byte . class ) || t . equals ( Byte . TYPE ) ) { return new Byte ( s ) ; } else if ( t . equals ( Character . class ) || t . equals ( Character . TYPE ) ) { return s . length ( ) > 0 ? new Character ( s . char At ( 0 ) ) : null ; } else if ( t . equals ( Short . class ) || t . equals ( Short . TYPE ) ) { return new Short ( s ) ; } else if ( t . equals ( Integer . class ) || t . equals ( Integer . TYPE ) ) { return new Integer ( s ) ; } else if ( t . equals ( Float . class ) || t . equals ( Float . TYPE ) ) { return new Float ( s ) ; else if ( t . equals ( Long . class ) || t . equals ( Long . TYPE ) ) { return new Long ( s ) ; else if ( t . equals ( Double . class ) || t . equals ( Double . TYPE ) ) { return new Double ( s ) ; else if ( t . equals ( String . class ) ) { return s ; else if ( t . equals ( java . io . File . class ) ) { return new java . io . File ( s ) ; else if ( t . get Name ( ) . equals ( " java . lang . Object " ) ) { return new Object [ ] { else { return get Value From Property Editor Manager ( t , property Name , s ) ; catch ( Exception ex ) { throw new Jsp Core Exception ( ex ) ;<CODESPLIT>{<CODESPLIT>0
public boolean Instance ( ) { boolean ; ( Instance ) { this . general Instance ; } else if ( get Parent Type ( ) != null ) { ret = get Parent Type ( ) . is General Instance ( ) ; } return ret ; }<CODESPLIT>Getter method for the instance variable { @link #generalInstance } .<CODESPLIT>1
public List Cms Property Config get Property Configuration ( ) { Cms ADE Config ( ) ; List Cms Property Config Properties ; ( ( ) is Discard Inherited Properties ( ) ) { Properties parent Data . get Property Configuration ( ) ; } else { parent Properties = Collections . empty List ( ) ; } List < Cms Property Config > result = combine Configuration Elements ( parent Properties , m _ data . get Own Property Configurations ( ) , false ) ; return result ; }<CODESPLIT>Gets the configuration for the available properties . <p ><CODESPLIT>1
public static void remove Consecutive Separators ( Popup popup ) { ( ; popup get ( ) ; ) { ( Popup Menu Separator ( popup Menu . get Component ( i ) ) ) { if ( is Popup Menu Separator ( popup Menu . get Component ( i - 1 ) ) ) { popup Menu . remove ( i ) ; i -- ; } } } }<CODESPLIT>Removes all top separators from the given pop up menu . <p > For example calling the method on the given menu : <pre > Separator Separator Menu Entry Separator Menu Entry Separator Menu Entry < / pre > would result in : <pre > Menu Entry Separator Menu Entry Separator Menu Entry < / pre ><CODESPLIT>0
protected void write Numbers ( Output Stream ) throws { ( list Level ) { write ( Rtf . LIST _ LEVEL _ NUMBER ) ; result . write ( int To Byte Array ( list Level ) ) ; } }<CODESPLIT>Write the indentation values for this <code > RtfList< / code > .<CODESPLIT>0
private String build Internal Form ( ) { String Buffer String Buffer ( 128 ) ; Cms ; boolean internal ; { get Cms ( ) . read ( get Param ( ) , Cms Filter . ALL ) ; internal . is Internal ( ) ; } ( Cms ) { . error ( . get ( ) ) ; ( ( ) ( . is File ( ) ) ) { . append ( "< =\"" ) . append ( get Dialog ( ) ) . append ( method =\" name =\" internal class =\" nomargin \">\ ) ; . append ( "< table border =\" 0 \" width =\" 100 %\">\ n " ) ; result . append ( "< tr >\ n " ) ; result . append ( "\ t < td class =\" dialogpermissioncell \">" ) . append ( key ( Messages . GUI _ PERMISSION _ INTERNAL _ 0 ) ) ; result . append ( " < input type =\" checkbox \" name =\"" ) ; result . append ( PARAM _ INTERNAL ) ; result . append ( "\" value =\" true \"" ) ; if ( internal ) { result . append ( " checked =\" checked \"" ) ; } if ( ! get Editable ( ) ) { result . append ( " disabled =\" disabled \"" ) ; } result . append ( " ></ td >\ n " ) ; if ( get Editable ( ) ) { result . append ( "</ td >\ n " ) ; result . append ( "</ tr >\ n " ) ; result . append ( "</ table >\ n " ) ; set Param Action ( DIALOG _ INTERNALUSE ) ; set Param Type ( null ) ; set Param Name ( null ) ; result . append ( params As Hidden ( ) ) ; result . append ( "</ form >\ n " ) ; } return result . to String ( ) ;<CODESPLIT>Builds a String with HTML code to display the form to add a new access control entry for the current resource . <p ><CODESPLIT>1
public Integration with Integration Responses ( Map String , Integration Response integration Responses ) { set Integration Responses ( integration Responses ) ; this ; }<CODESPLIT><p > Specifies the integration s responses . < / p > <div class = remarks > <p / > <h4 > Example : Get integration responses of a method< / h4 > <h5 > Request< / h5 > <p / ><CODESPLIT>1
public static String get Style ( Cms Resource state ) { String state Style = ; ( state ) { ( state . is Deleted ( ) ) { state Style = Cms Theme . STATE _ DELETED ; } if ( state . is New ( ) ) { state Style = Open Cms Theme . STATE _ NEW ; } else if ( state . is Changed ( ) ) { } } return state Style ; }<CODESPLIT>Gets the CSS style name for the given resource state . <p ><CODESPLIT>1
public Closeable Master Client acquire Master Client ) { Closeable Master Client ( m Block Master Client Pool . acquire ( ) ) { @ Override public void close ( ) { m Block Master Client Pool . release ( get ( ) ) ; } } ; }<CODESPLIT>Releases a block worker client to the client pools .<CODESPLIT>0
public void set Recommendations ( java Collection Reservation Purchase Recommendation recommendations ) { ( recommendations ) { recommendations null ; return ; } this . recommendations = new java . util . Array List < Reservation Purchase Recommendation > ( recommendations ) ; }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public static find findme tolerance ) get ) ; findme findme . get Width ( ) ; if ( image Width >= findme Width ) { final int image Height = image . get Height ( ) ; final int findme Height = findme . get Height ( ) ; if ( image Height >= findme Height ) { return find Image ( get RGB ( image ) , image Width , image Height , get RGB ( findme ) , findme Width , findme Height , tolerance ) ; } } return null ; }<CODESPLIT>Gets the RGB pixels for the given image into a new array .<CODESPLIT>0
protected void fire Entry Removed ( key , value ) { ( this . listeners ) { ( Map Listener , V > listener : this . listeners . get Listeners ( D Map Listener . class ) ) { listener . entry Removed ( key , value ) ; } } }<CODESPLIT>Fire the removal event .<CODESPLIT>1
public void set Welcome Files ( String welcome Files ) { ( welcome Files ) { welcome Files . copy Of ( welcome Files , welcome Files . length ) ; } }<CODESPLIT>CHECKSTYLE : OFF<CODESPLIT>0
public static void set Configs ( One Configs , String Config Absolute Class Path ) { ( Configs null ) { Configs . debug Configs = debug Configs Obj ; } if ( debug Config Absolute Class Path != null ) { Configs . debug Configs . init Configs ( Configs . debug Config Absolute Class Path ) ; } else if ( debug Configs != null ) { Configs . debug Configs . init Configs ( Configs . debug Config Absolute Class Path ) ; } }<CODESPLIT><p > Set self define debug configs . < / p > Can use self debug configs path or self class extends { @link OneProperties } .<CODESPLIT>1
public Style get Style ( String style Name ) { String style this . styles . get ( style Name ) ; ( style ) { this . style Parser . load Style ( this , this . client Http Request Factory , style Ref ) ; } else { return Optional . empty ( ) ; } }<CODESPLIT>Retrieve the configuration of the named template .<CODESPLIT>0
public For License Result For License ( For License Request request ) { request = before Client Execution ( request ) ; return execute List Usage For License Configuration ( request ) ; }<CODESPLIT><p > Modifies the attributes of an existing license configuration object . A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager . Components include specifications for the license type ( Instances cores sockets VCPUs ) tenancy ( shared or Dedicated Host ) host affinity ( how long a VM is associated with a host ) the number of licenses purchased and used . < / p ><CODESPLIT>0
public Hub Consumer Group create Hub Consumer Group ( Group , , Hub , name ) { return create Event Hub Consumer Group With Service Response Async ( resource Group Name , resource Name , event Hub Endpoint Name , name ) . to Blocking ( ) . single ( ) . body ( ) ; }<CODESPLIT>Add a consumer group to an Event Hub - compatible endpoint in an IoT hub . Add a consumer group to an Event Hub - compatible endpoint in an IoT hub .<CODESPLIT>1
public Constant add Constant ( Constant constant ) { Constant = ( Constant ) . get ( constant ) ; ( ) { ; } int entry Count = constant . get Entry Count ( ) ; if ( m Indexed Constants != null && m Preserve Order ) { m Indexed Constants . set Size ( size + entry Count ) ; m Indexed Constants . set ( size , constant ) ; } m Constants . put ( constant , constant ) ; m Entries += entry Count ; return constant ; }<CODESPLIT>Perform an HTTP GET at the given path returning the results of the response .<CODESPLIT>0
public void visit ( Column ) { String Value get Column ( ) ; ( Value ( " ) || string Value . equals Ignore Case ( " false " ) ) { set Value ( Boolean . value Of ( string Value ) , Types . BOOLEAN ) ; } }<CODESPLIT>Booleans are not recognized by the parser but are seen as column names .<CODESPLIT>1
private Hod Result add ( Iterable Name index Identifiers , Hod Result ) { String index get ( ) ; String domain ; ( Name index Identifier index Identifiers ) { ( index ( index Identifier get Name ( ) ) ) { domain index Identifier get ( ) ; break ; } } if ( domain == null ) { domain = PUBLIC _ INDEX _ NAMES . contains ( index ) ? Resource Name . PUBLIC _ INDEXES _ DOMAIN : get Domain ( ) ; } return document . to Builder ( ) . domain ( domain ) . build ( ) ; }<CODESPLIT>Add a domain to a FindDocument given the collection of indexes which were queried against to return it from HOD<CODESPLIT>1
private initiate Resumable Upload ( Upload Url ) Batch { Request request http Transport create Request ( -> { headers create ( ) ; headers set Content Length ( ) ; headers set ( goog resumable start ) ; set ( headers ) ; set Logging ( ) ; } ) ; { Request http Request request build Post Request ( Generic Url ( Job Upload Url ) , new Empty Content ( ) ) ; Http Response response = http Request . execute ( ) ; if ( response . get Headers ( ) == null || response . get Headers ( ) . get Location ( ) == null ) { throw new Batch Job Exception ( " Initiate upload failed . Resumable upload URI was not in the response ." ) ; } return URI . create ( response . get Headers ( ) . get Location ( ) ) ; } catch ( IO Exception e ) { throw new Batch Job Exception ( " Failed to initiate upload " , e ) ; } }<CODESPLIT>Post - processes the request content to conform to the requirements of Google Cloud Storage .<CODESPLIT>0
protected get Selected Value ( Cms Object cms Cms Select Widget Option Value ) { param Value Value ; ( Cms Empty ( param Value ) ) { Cms Select Widget Option option = Cms Select Widget Option . get Default Option ( select Options ) ; if ( option != null ) { param Value = option . get Value ( ) ; } } return param Value ; }<CODESPLIT>Returns the currently selected value of the select widget . <p ><CODESPLIT>1
public void marshall ( Actions Request list Actions Request , Marshaller Marshaller ) { ( list Actions Request ) { Sdk Client ( argument to marshall (...)" ) ; } { Marshaller marshall ( list Actions Request get ( ) , CLUSTERID BINDING ) ; Marshaller marshall ( list Bootstrap Actions Request . get Marker ( ) , MARKER _ BINDING ) ; } catch ( Exception e ) { throw new Sdk Client Exception ( " Unable to marshall request to JSON : " + e . get Message ( ) , e ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public static License license ( To License ) { ( Pro ( ) ) { License ( ) { @ Override public boolean initialize From File ( File license ) { ; } @ Override public boolean Of Trial ( ) { ; } @ Override public boolean Pro Trial ( ) { ; } @ Override public boolean Enterprise Trial ( ) { ; } @ Override public Hostcount ( ) { ; } @ Override public expires ( ) { get Instance ( ) ; add ( YEAR ) ; ; } @ Override public boolean verify ( ) { true ; } @ Override public boolean is Dr Replication Allowed ( ) { return false ; } @ Override public boolean is Dr Active Active Allowed ( ) { return false ; } @ Override public boolean is Command Logging Allowed ( ) { return false ; } @ Override public boolean is AWS Marketplace ( ) { return false ; } @ Override public boolean is Enterprise ( ) { return false ; } @ Override public boolean is Pro ( ) { return false ; } @ Override public String licensee ( ) { return " Volt DB Community Edition User " ; } @ Override public Calendar issued ( ) { Calendar result = Calendar . get Instance ( ) ; return result ; } @ Override public String note ( ) { return "" ; } @ Override public boolean hard Expiration ( ) { return false ; } @ Override public boolean secondary Initialization ( ) { return true ; } } ; } if ( license Api == null ) { return null ; File license File = new File ( path To License ) ; if ( license File . exists ( ) == false ) { return null ; host Log . info ( " Found Volt DB license file at path : " + path To License ) ; if ( license Api . initialize From File ( license File ) == false ) { host Log . fatal ( " Unable to load license file : could not parse license ." ) ; return null ; try { if ( license Api . verify ( ) == false ) { host Log . fatal ( " Unable to load license file : could not verify license signature ." ) ; return null ; catch ( License Exception lex ) { host Log . fatal ( lex . get Message ( ) ) ; return null ; return license Api ;<CODESPLIT>Simple code to copy a file from one place to another ... Java should have this built in ... stupid java ...<CODESPLIT>0
public Modify Instance Result modify Instance ( Modify Instance Request request ) { request = before Client Execution ( request ) ; return execute Modify Instance Event Start Time ( request ) ; }<CODESPLIT><p > Modifies the placement attributes for a specified instance . You can do the following : < / p > <ul > <li > <p > Modify the affinity between an instance and a <a href = https : // docs . aws . amazon . com / AWSEC2 / latest / UserGuide / dedicated - hosts - overview . html > Dedicated Host< / a > . When affinity is set to <code > host< / code > and the instance is not associated with a specific Dedicated Host the next time the instance is launched it is automatically associated with the host on which it lands . If the instance is restarted or rebooted this relationship persists . < / p > < / li > <li > <p > Change the Dedicated Host with which an instance is associated . < / p > < / li > <li > <p > Change the instance tenancy of an instance from <code > host< / code > to <code > dedicated< / code > or from <code > dedicated< / code > to <code > host< / code > . < / p > < / li > <li > <p > Move an instance to or from a <a href = https : // docs . aws . amazon . com / AWSEC2 / latest / UserGuide / placement - groups . html > placement group< / a > . < / p > < / li > < / ul > <p > At least one attribute for affinity host ID tenancy or placement group name must be specified in the request . Affinity and tenancy can be modified in the same request . < / p > <p > To modify the host ID tenancy placement group or partition for an instance the instance must be in the <code > stopped< / code > state . < / p ><CODESPLIT>0
public static , L Int 1 , T 2 > obj Int Obj Predicate ( Consumer < L Obj Int Obj Predicate < T 1 , T 2 > > consumer ) { return new L Obj Int Obj Predicate Builder ( consumer ) ; }<CODESPLIT>One of ways of creating builder . This might be the only way ( considering all _functional_ builders ) that might be utilize to specify generic params only once .<CODESPLIT>1
public Interceptors Type get Or Create Interceptors ( ) { model get Or Create ( interceptors ) ; Interceptors Type Jar Descriptor > interceptors = new Interceptors Type Impl < Ejb Jar Descriptor > ( this , " interceptors " , model , node ) ; return interceptors ; }<CODESPLIT>If not already created a new <code > interceptors< / code > element with the given value will be created . Otherwise the existing <code > interceptors< / code > element will be returned .<CODESPLIT>1
protected static find ( Object grammar Component , String assignment ) { ( Grammar contained Actions ( grammar Component ) ) { ( Grammar Assigned Action ( action ) ) { if ( Objects . equals ( assignment Name , action . get Feature ( ) ) ) { return action ; } } } return null ; }<CODESPLIT>Replies the assignment component with the given nazme in the given grammar component .<CODESPLIT>1
public get Medium Int ( ) { get ( ) ; get ( ) ; get ( ) ; if ( _ is Big Endian ) { return ( b 1 << 16 ) | ( b 2 << 8 ) | b 3 ; } else { return ( b 3 << 16 ) | ( b 2 << 8 ) | b 1 ; } }<CODESPLIT>Returns an unsigned three - byte medium int from the buffer at the current position<CODESPLIT>1
public void rollback ( ) { { log ( Rolling modify Attributes ) ; ldap modify Attributes ( dn , compensating Modifications ) ; } ( ) { log warn ( " Failed to rollback Modify Attributes operation , dn : " + dn ) ; } }<CODESPLIT>/ *<CODESPLIT>1
static XML Name ( String , String Name ) { ( Xml Node . Namespace . create ( uri ) , local Name ) ; }<CODESPLIT>TODO : marked deprecated by original implementor<CODESPLIT>0
public synchronized void Transaction ( ) throws Database { { get Connection ( ) ; ( ! . get Commit ( ) ) { . ( There ' one active ) ; return ; } . set Commit ( false ) ; } ( final Exception ex ) { throw new Database Engine Runtime Exception ( " Error occurred while starting transaction " , ex ) ; } }<CODESPLIT>Closes a { @link MappedEntity } logging a warning if an { @link Exception } is thrown . <p > It flushes before closing the { @link MappedEntity } .<CODESPLIT>0
public List mangoo models get All ( ) throws Mangoo { Null ( quartz , Required SCHEDULER to String ( ) ) ; List mangoo models Array List ( ) ; { ( get All Keys ( ) ) { List Trigger triggers ( List Trigger ) quartz Scheduler . get Triggers Of Job ( job Key ) ; Trigger trigger = triggers . get ( 0 ) ; Trigger State trigger State = quartz Scheduler . get Trigger State ( trigger . get Key ( ) ) ; boolean active = ( Trigger State . NORMAL == trigger State ) ? true : false ; jobs . add ( new io . mangoo . models . Job ( active , job Key . get Name ( ) , trigger . get Description ( ) , trigger . get Next Fire Time ( ) , trigger . get Previous Fire Time ( ) ) ) ; } } catch ( Scheduler Exception e ) { throw new Mangoo Scheduler Exception ( e ) ; } return jobs ; }<CODESPLIT>Pauses a job by a given name @param name The name of the job to pause<CODESPLIT>0
public void flush ( ) { { Array List Batch batches all ( ) ; Outstanding Records ; ( Batch batches ) { Outstanding Records += get Records ( ) ( ) ; } ( Flush called on {} batches with {} records total " , batches . size ( ) , num Outstanding Records ) ; for ( Batch batch : batches ) { batch . await ( ) ; } } catch ( Exception e ) { LOG . error ( " Error happened while flushing batches " ) ; } }<CODESPLIT>This will block until all the incomplete batches are acknowledged<CODESPLIT>1
static double compute Angular Similarity ( Double , Double ) { Math . acos ( compute Cosine Similarity ( t 0 , t 1 ) ) / Math . PI ; }<CODESPLIT>Get the keysize . If no key size specified this will return the default key size .<CODESPLIT>0
public static boolean xor ( boolean ... array ) { ( Array . is Empty ( array ) ) { Argument ( The Array must not ) ; } boolean = false ; ( boolean element : array ) { result = element ; } return result ; }<CODESPLIT>对Boolean数组取或<CODESPLIT>0
public static Shared User get User ) { Shared Context < I User > ) Context Manager . get Instance ( ) . get Shared Context ( User Context . class . get Name ( ) ) ; }<CODESPLIT>Returns the managed user context .<CODESPLIT>1
public void copy Selenium ( browser Store cookie Store ) { ( browser : browser Cookies ) { Client Cookie cookie = convert Cookie ( browser Cookie ) ; cookie Store . add Cookie ( cookie ) ; } }<CODESPLIT>Converts Selenium cookie to Apache http client .<CODESPLIT>0
private In Macro ( Macro macro To , Blocks ) { Macro ( macro Block To Wrap . get Id ( ) , macro Block To Wrap . get Parameters ( ) , macro Block To Wrap . get Content ( ) , new Blocks , macro Block To Wrap . is Inline ( ) ) ; }<CODESPLIT>TODO : support more than strings<CODESPLIT>0
public void abort ( final ) throws { ( == ) { Exception ( " Missing executor " ) ; } if ( this . closed ) { return ; } this . closed = true ; }<CODESPLIT>アノテーションを元にフォーマッタを作成する。<CODESPLIT>0
public Json Value Json Value ( ) { String name get ( ) ; Object value get Value ( name , ) ; Json Value json Value = wrap Value ( value ) ; return json Value ; }<CODESPLIT>Return the indicated claim value as a JsonValue<CODESPLIT>1
public int get ( Temporal Field field ) { ( field Chrono Field ) { ( ( Chrono Field ) field ) { INSTANT SECONDS Temporal Type ( field get () method , get Long () instead ) ; OFFSET _ SECONDS : return get Offset ( ) . get Total Seconds ( ) ; } return date Time . get ( field ) ; } return Temporal . super . get ( field ) ; }<CODESPLIT>Gets the value of the specified field from this date - time as an { @code int } . <p > This queries this date - time for the value of the specified field . The returned value will always be within the valid range of values for the field . If it is not possible to return the value because the field is not supported or for some other reason an exception is thrown . <p > If the field is a { @link ChronoField } then the query is implemented here . The { @link #isSupported ( TemporalField ) supported fields } will return valid values based on this date - time except { @code NANO_OF_DAY } { @code MICRO_OF_DAY } { @code EPOCH_DAY } { @code PROLEPTIC_MONTH } and { @code INSTANT_SECONDS } which are too large to fit in an { @code int } and throw a { @code DateTimeException } . All other { @code ChronoField } instances will throw an { @code UnsupportedTemporalTypeException } . <p > If the field is not a { @code ChronoField } then the result of this method is obtained by invoking { @code TemporalField . getFrom ( TemporalAccessor ) } passing { @code this } as the argument . Whether the value can be obtained and what the value represents is determined by the field .<CODESPLIT>1
public void relocate ( ) { int = 200 , h = 235 ; enable Database Connection . set Location ( x , y ) ; Host . set Location ( x , y 40 ) ; Host Field . set Location ( x 110 , y 40 ) ; sql Database Label . set Location ( x , y + 70 ) ; sql Database Field . set Location ( x + 110 , y + 70 ) ; sql User Label . set Location ( x , y + 100 ) ; sql User Field . set Location ( x + 110 , y + 100 ) ; sql Password Label . set Location ( x , y + 130 ) ; sql Password Field . set Location ( x + 110 , y + 130 ) ; enable Zip Encoding Check Box . set Location ( x , y + 180 ) ; }<CODESPLIT>A call of this method should validate the positions of the panels components .<CODESPLIT>1
public void fixate Distorted ( ) { ( 0 ; ; ) { ( 0 ; < grid Cols ; col ++ ) { Cache cache = get Grid ( row , col ) ; compute Average Q ( cache ) ; model . compute Deformed ( cache , col , row ) ; } } }<CODESPLIT>Precompute the portion of the equation which only concerns the undistorted location of each point on the grid even the current undistorted location of each control point .<CODESPLIT>0
public Redis Patch get ( String Group , String name ) { get With Async ( Group , name ) . to Blocking ( ) . single ( ) . body ( ) ; }<CODESPLIT>Create or replace the patching schedule for Redis cache ( requires Premium SKU ) .<CODESPLIT>0
public void ( int feature ) { ( feature ) { Afplib Package MCF RG __ LID set Lid ( CF _ LID _ EDEFAULT ) ; return ; case Afplib Package . MCF 1 RG __ SECTID : set Sectid ( SECTID _ EDEFAULT ) ; return ; case Afplib Package . MCF 1 RG __ CF _ NAME : set CF Name ( CF _ NAME _ EDEFAULT ) ; return ; case Afplib Package . MCF 1 RG __ CP _ NAME : set CP Name ( CP _ NAME _ EDEFAULT ) ; return ; case Afplib Package . MCF 1 RG __ FCS _ NAME : set FCS Name ( FCS _ NAME _ EDEFAULT ) ; return ; return ; } super . e Unset ( feature ID ) ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>0
public void convert Operation Parameter ( Path , String , Value , operation , Transformation Context context ) { convert Attribute ( address , attribute Name , attribute Value , context ) ; }<CODESPLIT>{<CODESPLIT>1
public If Class Available Exclude T get Or Create If Class Available ( ) { List List get ( class available ) ; ( List && node List . size ( ) > 0 ) { return new If Class Available Impl < Exclude < T > > ( this , " if - class - available " , child Node , node List . get ( 0 ) ) ; } return create If Class Available ( ) ; }<CODESPLIT>If not already created a new <code > if - class - available< / code > element will be created and returned . Otherwise the first existing <code > if - class - available< / code > element will be returned .<CODESPLIT>1
public static void set Thread ( Thread pool ) { ( pool pool ) { shutdown ( ) ; Concurrency Tools . pool = pool ; } }<CODESPLIT>Sets thread pool to given size .<CODESPLIT>0
public Thymeleaf Config P set ( Resolver message Resolver ) { message Resolvers ( ) . clear ( ) ; message Resolvers ( ) . add ( message Resolver ) ; return this ; }<CODESPLIT><p > Sets a single message resolver for this template engine . < / p > <p > Calling this method is equivalent to calling { @link #setMessageResolvers ( Set ) } passing a Set with only one message resolver . < / p > <p > This operation can only be executed before processing templates for the first time . Once a template is processed the template engine is considered to be <i > initialized< / i > and from then on any attempt to change its configuration will result in an exception . < / p ><CODESPLIT>1
public static Gray U To Binary ( Gray S Image , Gray U Image , int Labels , int ... selected ) { boolean selected Blobs boolean Labels ; ( int 0 ; < selected . length ; i ++ ) { selected Blobs [ selected [ i ] ] = true ; } return label To Binary ( label Image , binary Image , selected Blobs ) ; }<CODESPLIT>Scans through the labeled image and adds the coordinate of each pixel that has been labeled to a list specific to its label .<CODESPLIT>0
public Class get Ifc Faceted Brep ( ) { ( ifc Faceted Brep Class ) { ifc Faceted Brep Class ( Class ) get Package ( Ifc 2 x 3 tc 1 Package . e NS _ URI ) . get E Classifiers ( ) . get ( 225 ) ; } return ifc Faceted Brep E Class ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>1
public void marshall ( Dominant Language Detection Request Dominant Language Detection Request , Marshaller Marshaller ) { ( Dominant Language Detection Request ) { Sdk Client ( argument passed to marshall (...)" ) ; } { Marshaller marshall ( Dominant Language Detection Request get Id ( ) , JOBID _ BINDING ) ; } catch ( Exception e ) { throw new Sdk Client Exception ( " Unable to marshall request to JSON : " + e . get Message ( ) , e ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public String get File Link ( ) { ( ) { Cms Value Wrapper . Link ( m _ cms , m _ cms . get Site Path ( m _ resource ) ) ; } else { return "" ; } }<CODESPLIT>Gets a lazy map which maps locales to attachment beans for that locale . <p ><CODESPLIT>0
private List Map Stream State , State > > repartition ( Group By State Name name To State By Mode , int Parallelism ) { List Map Stream State , Operator State Handle > > merge Map List = new Array List <> ( new Parallelism ) ; for ( int i = 0 ; i < new Parallelism ; ++ i ) { merge Map List . add ( new Hash Map <> ( ) ) ; } Map < String , List < Tuple 2 < Stream State Handle , Operator State Handle . State Meta Info > > > name To Distribute State = name To State By Mode . get By Mode ( Operator State Handle . Mode . SPLIT _ DISTRIBUTE ) ; repartition Split State ( name To Distribute State , new Parallelism , merge Map List ) ; Map < String , List < Tuple 2 < Stream State Handle , Operator State Handle . State Meta Info > > > name To Union State = name To State By Mode . get By Mode ( Operator State Handle . Mode . UNION ) ; repartition Union State ( name To Union State , merge Map List ) ; repartition Broadcast State ( name To Broadcast State , merge Map List ) ; return merge Map List ; }<CODESPLIT>Repartition SPLIT_DISTRIBUTE state .<CODESPLIT>0
private String Parameters ( Value Map String , String Parameters ) { Value Map String , String Parameters Value Map String , String ( ) ; ( Entry String , String Parameters ( ) iterator ( ) ; has Next ( ) ; ) { Entry String , String > entry = entry It . next ( ) ; String collected Name = entry . get Key ( ) ; List < String > collected Values = entry . get Value ( ) ; List < String > encoded Values = new Array List < String > ( collected Values . size ( ) ) ; sorted Encoded Parameters . put ( oauth Encode ( collected Name ) , encoded Values ) ; for ( Iterator < String > value It = collected Values . iterator ( ) ; value It . has Next ( ) ; ) { String value = value It . next ( ) ; encoded Values . add ( value != null ? oauth Encode ( value ) : "" ) ; } Collections . sort ( encoded Values ) ; } String Builder params Builder = new String Builder ( ) ; Entry < String , List < String > > entry = entry It . next ( ) ; String name = entry . get Key ( ) ; List < String > values = entry . get Value ( ) ; for ( Iterator < String > value It = values . iterator ( ) ; value It . has Next ( ) ; ) { String value = value It . next ( ) ; params Builder . append ( name ) . append ( ' ' ) . append ( value ) ; if ( value It . has Next ( ) ) { params Builder . append ( "&" ) ; if ( entry It . has Next ( ) ) { params Builder . append ( "&" ) ; return params Builder . to String ( ) ;<CODESPLIT>internal helpers<CODESPLIT>1
public void remove ( TCP end Point ) { ( Trace Component . is Any Tracing ( ) tc . is Entry ( ) ) { Tr . ( tc , remove : end Point . get Server ( ) ) ; } synchronized ( this ) { NB Accept Channel Selector accept = end Point To Accept . get ( end Point ) ; ( accept != ) { ( 3100 <= accept . ) { ( Trace Component . is Any Tracing ( ) tc . is Event ( ) ) { Tr . event ( tc , Ignoring remove call on fatal / . path " ) ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) { Tr . exit ( tc , " remove Port " ) ; return ; } synchronized ( work Sync ) { if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Event Enabled ( ) ) { } accept . add Work ( work ) ; try { work Sync . wait ( ) ; } catch ( Interrupted Exception x ) { if ( accept == shared Accept && accept . get Usage Count ( ) <= 0 ) { shared Accept = null ; else { Illegal Argument Exception iae = new Illegal Argument Exception ( " TCP Port to be removed is not registered ." ) ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Event Enabled ( ) ) { Tr . event ( tc , " Throwing Illegal Argument Exception " ) ; FFDC Filter . process Exception ( iae , CLASS _ NAME + ". remove Port " , " 387 " , this ) ; throw iae ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) { Tr . exit ( tc , " remove Port " ) ;<CODESPLIT>Removes an end point from the set of end points that we are accepting connections on . This has the effect of removing the server socket from the selector and closing it .<CODESPLIT>1
public Extended Auditing create Or Update Async Group Extended Auditing parameters ) { create Or Update With Async ( resource Group Name , server Name , parameters ) . map ( new Func 1 < Service Response < Extended Server Blob Auditing Policy Inner > , Extended Server Blob Auditing Policy Inner > ( ) { @ Override public Extended Server Blob Auditing Policy Inner call ( Service Response < Extended Server Blob Auditing Policy Inner > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Creates or updates an extended server s blob auditing policy .<CODESPLIT>0
public Map String , String get To Map ( Map String , String map ) { ( map ) map Map ( ) ; Map String , String map 0 = map ; header . for Each ( ( k , v ) -> map 0 . put ( k , v ) ) ; return map 0 ; }<CODESPLIT>获取指定的header值 没有返回默认值<CODESPLIT>0
public Artifact create Artifact ( group , artifact ) { repository . create Artifact ( group Id , artifact Id , " RELEASE " , " jar " ) ; }<CODESPLIT>Replies the dependencies for the given artifact .<CODESPLIT>0
eclipse xtext Singleton Binding ( eager ) public Class eclipse xtext generator parser . antlr . debug . validation . Simple Antlr Java Validator > bind Simple Antlr Java Validator ( ) { return org . eclipse . xtext . generator . parser . antlr . debug . validation . Simple Antlr Java Validator . class ; }<CODESPLIT>contributed by org . eclipse . xtext . generator . validation . JavaValidatorFragment<CODESPLIT>1
public void marshall ( Create Group Request create Group Request , Marshaller Marshaller ) { ( create Group Request ) { } { Marshaller marshall ( create Group Request get ( ) , APPLICATIONNAME BINDING ) ; Marshaller marshall ( create Group Request get Group ( ) , DEPLOYMENTGROUPNAME BINDING ) ; Marshaller . marshall ( create Deployment Group Request . get Deployment Config Name ( ) , DEPLOYMENTCONFIGNAME _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Ec 2 Tag Filters ( ) , EC 2 TAGFILTERS _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get On Premises Instance Tag Filters ( ) , ONPREMISESINSTANCETAGFILTERS _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Auto Scaling Groups ( ) , AUTOSCALINGGROUPS _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Service Role Arn ( ) , SERVICEROLEARN _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Trigger Configurations ( ) , TRIGGERCONFIGURATIONS _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Alarm Configuration ( ) , ALARMCONFIGURATION _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Auto Rollback Configuration ( ) , AUTOROLLBACKCONFIGURATION _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Deployment Style ( ) , DEPLOYMENTSTYLE _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Blue Green Deployment Configuration ( ) , BLUEGREENDEPLOYMENTCONFIGURATION _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Load Balancer Info ( ) , LOADBALANCERINFO _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Ec 2 Tag Set ( ) , EC 2 TAGSET _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Ecs Services ( ) , ECSSERVICES _ BINDING ) ; } catch ( Exception e ) { } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public void prepend ( @ Nonnull EJS JS @ Nonnull Has JS ) { Value Enforcer not ( JS JS ) ; Value Enforcer not ( , " New Handler " ) ; Collecting JS Code Provider a Code = m _ a Events . get ( e JS Event ) ; if ( a Code == null ) { a Code = new Collecting JS Code Provider ( ) ; m _ a Events . put ( e JS Event , a Code ) ; } a Code . prepend ( a New Handler ) ; }<CODESPLIT>Add an additional handler for the given JS event . If an existing handler is present the new handler is appended at front .<CODESPLIT>1
public static @ Integer , Integer Dimensions ( Input Stream is ) { check Not Null ( is ) ; Byte Buffer Buffer DECODE acquire ( ) ; ( Buffer ) { Buffer Byte Buffer ( DECODE BUFFER ) ; } Bitmap Factory Bitmap Factory ( ) ; Decode Bounds = true ; try { options . in Temp Storage = byte Buffer . array ( ) ; Bitmap Factory . decode Stream ( is , null , options ) ; return ( options . out Width == - 1 || options . out Height == - 1 ) ? null : new Pair <> ( options . out Width , options . out Height ) ; } finally { DECODE _ BUFFERS . release ( byte Buffer ) ; } }<CODESPLIT>Decodes the bounds of an image and returns its width and height or null if the size can t be determined<CODESPLIT>1
public static Response execute ( Request request ) throws { not Null ( request , Missing request !" ) ; Client client Client create ( ) . set Redirect Strategy ( new Default Redirect Strategy ( ) ) . build ( ) ; return client . execute ( request ) ; }<CODESPLIT>Execute http response .<CODESPLIT>1
private static void sort start boolean descending ) { start ) { ; } start + end ) >> 1 ; Merge . sort ( byte Array , start , middle , descending ) ; Merge . sort ( byte Array , middle + 1 , end , descending ) ; if ( descending ) { Merge . merge Descending ( byte Array , start , middle , end ) ; } else { Merge . merge ( byte Array , start , middle , end ) ;<CODESPLIT>Merge two sorted arrays into a bigger array in ascending order . This routine runs in O ( n ) time .<CODESPLIT>0
public void write Throwable Output Stream Throwable value ) { write ) ; write Serialized OM THROWABLE value ) ; sw = new String Writer ( ) ; value . print Stack Trace ( new Print Writer ( sw ) ) ; write String Field ( out , OM _ STACKTRACE , sw . to String ( ) ) ; write End Object ( out ) ; }<CODESPLIT>Encode a Throwable instance as JSON : { throwable : Base64 stackTrace : String }<CODESPLIT>1
protected String render Radio ( Context faces Context , Input ui Component , String value , boolean , boolean , boolean render Id , Integer item ) { String client Id ui Component get Client Id ( faces Context ) ; Response writer faces Context get Response ( ) ; writer start Element ( HTML INPUT ELEM , ui Component ) ; ( item Id ) { writer write Attribute ( HTML , item Id , ) ; } ( render Id ) { writer write Attribute ( HTML , client Id , ) ; } writer write Attribute ( HTML . TYPE _ ATTR , HTML . INPUT _ TYPE _ RADIO , null ) ; writer . write Attribute ( HTML . NAME _ ATTR , client Id , null ) ; if ( disabled ) { writer . write Attribute ( HTML . DISABLED _ ATTR , HTML . DISABLED _ ATTR , null ) ; } if ( checked ) { writer . write Attribute ( HTML . CHECKED _ ATTR , HTML . CHECKED _ ATTR , null ) ; } if ( value != null ) { writer . write Attribute ( HTML . VALUE _ ATTR , value , null ) ; } else { writer . write Attribute ( HTML . VALUE _ ATTR , "" , null ) ; } Map < String , List < Client Behavior > > behaviors = null ; if ( ui Component instanceof Client Behavior Holder ) { behaviors = ( ( Client Behavior Holder ) ui Component ) . get Client Behaviors ( ) ; long common Properties Marked = 0 L ; if ( is Common Properties Optimization Enabled ( faces Context ) ) { common Properties Marked = Common Property Utils . get Common Properties Marked ( ui Component ) ; } Common Property Utils . render Change Event Property ( writer , common Properties Marked , ui Component ) ; Common Property Utils . render Event Properties ( writer , common Properties Marked , ui Component ) ; Common Property Utils . render Field Event Properties Without Onchange ( writer , common Properties Marked , ui Component ) ; } else { Html Renderer Utils . render Behaviorized Onchange Event Handler ( faces Context , writer , ui Component , behaviors ) ; if ( is Common Events Optimization Enabled ( faces Context ) ) { Long common Events Marked = Common Event Utils . get Common Events Marked ( ui Component ) ; Common Event Utils . render Behaviorized Event Handlers ( faces Context , writer , common Properties Marked , common Events Marked , ui Component , behaviors ) ; Common Event Utils . render Behaviorized Field Event Handlers Without Onchange ( faces Context , writer , common Properties Marked , common Events Marked , ui Component , behaviors ) ; } else { Html Renderer Utils . render Behaviorized Event Handlers ( faces Context , writer , ui Component , behaviors ) ; Html Renderer Utils . render Behaviorized Field Event Handlers Without Onchange ( faces Context , writer , ui Component , behaviors ) ; } } } else { Html Renderer Utils . render HTML Attributes ( writer , ui Component , HTML . INPUT _ PASSTHROUGH _ ATTRIBUTES _ WITHOUT _ DISABLED _ AND _ STYLE ) ; } if ( is Disabled ( faces Context , ui Component ) ) { } writer . end Element ( HTML . INPUT _ ELEM ) ; return item Id ; }<CODESPLIT>Renders the given SelectItem ( Group )<CODESPLIT>0
public Source get Source ( String Source Name ) Locator { Source Source ; { Source ( Source ) ic ( Source Name ) ; } catch ( Naming Exception ne ) { throw new Service Locator Exception ( ne ) ; } catch ( Exception e ) { throw new Service Locator Exception ( e ) ; } return data Source ; }<CODESPLIT>This method obtains the topc itself for a caller<CODESPLIT>0
private void build Hosts ( Map , servers , String , Kundera kundera ) { get ( ) ; ; String hosts = null ; String port As String = null ; if ( external Properties != null ) { hosts = ( String ) external Properties . get ( Persistence Properties . KUNDERA _ NODES ) ; port As String = ( String ) external Properties . get ( Persistence Properties . KUNDERA _ PORT ) ; } if ( hosts == null ) { hosts = ( String ) props . get ( Persistence Properties . KUNDERA _ NODES ) ; } if ( port As String == null ) { port As String = ( String ) props . get ( Persistence Properties . KUNDERA _ PORT ) ; } if ( hosts != null && port As String != null ) { build Hosts ( hosts , port As String , this . hosts List ) ; } else if ( servers != null && servers . size ( ) >= 1 ) { build Hosts ( servers , this . hosts List ) ; } }<CODESPLIT>Build host array .<CODESPLIT>1
public String get Presentation ML ( ) throws { ( message ML ) { ( The message . Please call ML Context . parse () ." ) ; } Byte Array Output Stream bout Byte Array Output Stream ( ) ; Xml Print Stream out = new Xml Print Stream ( bout ) ; out . set No Indent ( true ) ; out . set No Nl ( true ) ; message ML . as Presentation ML ( out ) ; out . close ( ) ; return bout . to String ( ) ; }<CODESPLIT>Parse a Markdown message into its MessageMLV2 representation . Generates document tree structures for serialization into output formats with the respective get () methods .<CODESPLIT>0
private void show Facebook App Error ( ) { Toast make ( , get ( string . wings _ facebook __ error _ facebook _ app ) , Toast . LENGTH _ SHORT ) . show ( ) ; }<CODESPLIT>Links an account .<CODESPLIT>0
public static GPX read ( Input Stream ) throws { return reader ( . , Mode . STRICT ) . read ( input ) ; }<CODESPLIT>Read an GPX object from the given { @code input } stream .<CODESPLIT>0
String = String ( 128 ) ; . append ( INSERT INTO ) . append ( table ) . append ( ) ; ( int = 0 ; . ; ) { ( 0 ) { . append ( ) ; } . append ( [ ] ) ; } . append ( ") VALUES ) ; ( int = 0 ; columns . length ; i ++ ) { if ( i > 0 ) { sql . append ( ", " ) ; if ( values [ i ] == null ) { sql . append ( " NULL " ) ; } else { sql . append ( ' ' ) ; } } sql . append ( ' ' ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( " About to execute : {}" , sql . to String ( ) ) ; } Prepared Statement stmt = conn . prepare Statement ( sql . to String ( ) ) ; try { int var Index = 0 ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] != null ) { var Index ++ ; if ( numeric != null && numeric [ i ] ) { set Numeric ( stmt , var Index , columns [ i ] , values [ i ] ) ; } else { stmt . set String ( var Index , values [ i ] ) ; } stmt . execute Update ( ) ; finally { close Statement ( stmt ) ;<CODESPLIT>Get a long string which could be a TEXT or CLOB type . ( CLOBs require special handling -- this method normalizes the reading of them )<CODESPLIT>0
int get Next Position ( int Of Paragraph , int start Of Position ) { ( Entry an Entry ) { ( an Entry Of Paragraph Of Paragraph an Entry start Of Sentence Position == start Of Sentence Position ) { return an Entry . next Sentence Position ; } } return - 1 ; }<CODESPLIT>get Proofreading errors of sentence out of paragraph matches from cache<CODESPLIT>0
private void Refresh ) { Refreshing compare And ) ) { { executor submit Runnable ) { @ Override public void run ) { { refresh Value ( ) ; } finally { async Refreshing . set ( false ) ; } } } ) ; } catch ( Runtime Exception ex ) { async Refreshing . set ( false ) ; throw ex ; } } }<CODESPLIT>Invokes the callback to get a new value .<CODESPLIT>0
public Expression get ( ) { boolean is Trace On = Trace Component . is Tracing ( ) ; ( is Trace On tc . is Entry ( ) ) Tr . ( tc , get this ) ; check Timer Access ( ) ; Persistent Timer Handler task Handler = get Timer Handler ( _ CACHED _ _ GET _ SCHEDULE ) ; Parsed Schedule Expression parsed Schedule = task Handler . get Parsed Schedule ( ) ; if ( parsed Schedule == null ) { if ( is Trace On && tc . is Entry Enabled ( ) ) Tr . exit ( tc , " get Schedule : " + ise ) ; throw ise ; } Schedule Expression schedule = EJS Container . get Default Container ( ) . iv Object Copier . copy ( parsed Schedule . get Schedule ( ) ) ; if ( is Trace On && tc . is Entry Enabled ( ) ) Tr . exit ( tc , " get Schedule : " + schedule ) ; return schedule ; }<CODESPLIT>Query whether this timer has persistent semantics .<CODESPLIT>0
public void marshall ( Operating operating , Protocol Marshaller Marshaller ) { ( operating == ) { Sdk Client ( argument passed to marshall (...)" ) ; } { Marshaller . marshall ( operating . get Name ( ) , NAME _ BINDING ) ; Marshaller . marshall ( operating System . get Id ( ) , ID _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Type ( ) , TYPE _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Configuration Managers ( ) , CONFIGURATIONMANAGERS _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Reported Name ( ) , REPORTEDNAME _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Reported Version ( ) , REPORTEDVERSION _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Supported ( ) , SUPPORTED _ BINDING ) ; } catch ( Exception e ) { } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
private static void resolve Config ( Config Config ) { String Host Config get Bound Host ( ) ; ( Host ) { String Config get Host ( ) ; ( String is ( ) ) { get Host ( ) ; Config set Host ( ) ; } else { bound Host = host ; } server Config . set Bound Host ( bound Host ) ; } if ( server Config . is Adaptive Port ( ) ) { int ori Port = server Config . get Port ( ) ; int port = Net Utils . get Available Port ( bound Host , ori Port , Rpc Configs . get Int Value ( Rpc Options . SERVER _ PORT _ END ) ) ; if ( port != ori Port ) { if ( LOGGER . is Info Enabled ( ) ) { LOGGER . info ( " Changed port from {} to {} because the config port is disabled " , ori Port , port ) ; } server Config . set Port ( port ) ; } } }<CODESPLIT>初始化Server实例<CODESPLIT>0
public static String blur ( , sigma ) { ( ) { ( Radius must greater zero ." ) ; ( 150 ) { throw new Illegal Argument Exception ( " Radius must be lower or equal than 150 ." ) ; if ( sigma < 0 ) { throw new Illegal Argument Exception ( " Sigma must be greater than zero ." ) ; } return FILTER _ BLUR + "(" + radius + "," + sigma + ")" ;<CODESPLIT>This filter uses a 9 - patch to overlay the image .<CODESPLIT>0
public void send ( @ Nonnull String ) throws { check Connected ( ) ; _ Socket . send ( data ) ; }<CODESPLIT>{<CODESPLIT>0
public void throttle ( boolean ) { ( current Time ( ) Last Check 5000 ) { ( get Count ( ) get Count ( ) 0 ) { double observed ( double ) ( get Total ( ) get Total ( ) ) / ( double ) ( get Count ( ) this . Start . get Execution Count ( ) ) ; double tuning Latency = observed Latency ; long [ ] el = this . End . get Latency Buckets ( ) ; long [ ] sl = this . Start . get Latency Buckets ( ) ; long ec = this . End . get Execution Count ( ) - this . Start . get Execution Count ( ) ; long elsum = 0 ; for ( int i = 0 ; i < 25 ; i ++ ) { elsum += el [ i ] ; } long slsum = 0 ; for ( int i = 0 ; i < 25 ; i ++ ) { slsum += sl [ i ] ; } if ( ( ( double ) ( elsum - slsum ) / ( double ) ec ) > 0 . 97 ) { long outlier Execution Duration = 0 ; long outlier Execution Count = 0 ; for ( int i = 25 ; i < 109 ; i ++ ) { outlier Execution Count += ( el [ i ] - sl [ i ] ) ; if ( i >= 100 ) outlier Execution Duration += ( el [ i ] - sl [ i ] ) * 50 l ; else outlier Execution Duration += ( el [ i ] - sl [ i ] ) ; } tuning Latency = ( double ) ( this . End . get Total Execution Duration ( ) - this . Start . get Total Execution Duration ( ) - outlier Execution Duration ) / ( double ) ( this . End . get Execution Count ( ) - this . Start . get Execution Count ( ) - outlier Execution Count ) ; } long old Rate = this . Rate ; if ( tuning Latency > this . Target Latency * 2 . 0 ) this . Rate = ( long ) ( this . Rate * 0 . 8 ) ; else if ( tuning Latency > this . Target Latency * 1 . 25 ) this . Rate = ( long ) ( this . Rate * 0 . 95 ) ; else if ( tuning Latency > this . Target Latency * 1 . 1 ) this . Rate = ( long ) ( this . Rate * 0 . 999 ) ; else if ( tuning Latency < this . Target Latency * 0 . 5 ) this . Rate = ( long ) ( this . Rate * 1 . 1 ) ; else if ( tuning Latency < this . Target Latency * 0 . 75 ) this . Rate = ( long ) ( this . Rate * 1 . 01 ) ; else if ( tuning Latency < this . Target Latency * 0 . 9 ) this . Rate = ( long ) ( this . Rate * 1 . 001 ) ; } this . Start = ( Perf Counter ) this . End . clone ( ) ; this . End = Client Connection Pool . get Statistics ( this . Connection ) . get ( this . Procedure ) ; this . Last Check = System . current Time Millis ( ) ; } this . Limiter . throttle ( this . Rate ) ; }<CODESPLIT>Throttle the execution process and re - adjust the rate requirement on the fly . The limiter will automatically re - adjust the rate internally by using a basic { @link RateLimiter } after analysis of the latency data gathered from the performance tracking .<CODESPLIT>1
private Print Stream create Output Stream ( ) { ( output Log Filename ) { { File Output Stream fout = File Output Stream ( output Log Filename , false ) ; Buffered Output Stream bos = Buffered Output Stream ( fout , 4096 ) ; ( encoding ) { return Print Stream ( bos , false , encoding ) ; } { return Print Stream ( bos , false ) ; } } ( Exception e ) { } } is System Out = true ; if ( encoding != null ) { try { return new Print Stream ( System . out , false , encoding ) ; } catch ( Unsupported Encoding Exception e ) { } } return System . out ; }<CODESPLIT>Utility method to skip a given amount of bytes from the input stream . This will return the index after the skip ( which may or may not be able to skip the entire requested amount ) .<CODESPLIT>0
public static boolean are Not Empty ( String ... ) { boolean = ; ( == . == 0 ) { = ; } { for ( String value : values ) { result &= ! is Empty ( value ) ; } } return result ; }<CODESPLIT>检查指定的字符串列表是否不为空。<CODESPLIT>1
public static String get ( Http Request request ) { String Path request get Path ( ) ; String context Path request get Context Path ( ) ; ( Path ( ) <= ) { context Path Path ; } int context Path Len context Path . length ( ) ; final String request URI = request . get Request URI ( ) ; final char [ ] request Uri Chars = request URI . to Char Array ( ) ; final String Builder servlet URI = new String Builder ( context Path ) ; int request Uri Char Index = context Path Len ; for ( char ch : servlet Path . to Char Array ( ) ) { if ( ch == ' ' ) { request Uri Char Index = copy Path Fragment ( request Uri Chars , request Uri Char Index , servlet URI ) ; servlet URI . append ( ' ' ) ; request Uri Char Index += 1 ; } } return servlet URI . to String ( ) ;<CODESPLIT>Get request s servlet URI encoded based on results from { @link HttpServletRequest#getContextPath () } and { @link HttpServletRequest#getRequestURI () } which are both encoded URI / path and { @link HttpServletRequest#getServletPath () } which is DECODED path . We cannot just concatenate context path and servlet path to get the proper result because of these encoding / decoding differences especially if the Servlet path contains encoded characters . @param request @return servlet URI ( meant to be equivalent to contextPath + URLEncoded ( servletPath ))<CODESPLIT>1
public void set Mode ( Mode ) { ; ( Parsing Mode . HTML . equals ( this . mode ) ) { this . case Sensitive = false ; } }<CODESPLIT>This method will try to avoid creating new strings for each structure name ( element / attribute )<CODESPLIT>0
private void create Map ( ) { ( ) ; Map String , List Summarized Data sub Map Map String , List Summarized Data ( ) ; sub Map put ( Suite Summary , Suites ) ; sub Map put ( Test Summary , Tests ) ; sub Map put ( Classwise Summary , ) ; sub Map put ( Groupwise Summary , Groups ) ; Report Map < Summarized Data > test Summary Report = new Report Map < Summarized Data > ( Report Sheet Names . TESTSUMMARYREPORT . get Name ( ) , sub Report Map , 0 ) ; full Report Map . add ( test Summary Report ) ; List < Summarized Data > groups Clone = new Array List < Summarized Data > ( l Groups ) ; List < Summarized Data > class Data ; Summarized Data na Group Data = new Summarized Data ( ) ; na Group Data . sets Name ( Test Case Result . NA ) ; groups Clone . add ( na Group Data ) ; sub Report Map = new Linked Hash Map < String , List < Summarized Data > > ( ) ; for ( Summarized Data group : groups Clone ) { String s Group Name = group . gets Name ( ) ; class Data = new Array List < Summarized Data > ( ) ; for ( String s Group Class Name : mp Group Class Data . key Set ( ) ) { if ( s Group Class Name . substring ( 0 , s Group Name . length ( ) ) . equals ( s Group Name ) ) { class Data . add ( mp Group Class Data . get ( s Group Class Name ) ) ; } } sub Report Map . put ( s Group Name , class Data ) ; } Report Map < Summarized Data > second Report = new Report Map < Summarized Data > ( Report Sheet Names . GROUPSUMMARYREPORT . get Name ( ) , sub Report Map , 0 ) ; full Report Map . add ( second Report ) ; Map < String , List < List < String > > > sub Detail Report Map = new Linked Hash Map < String , List < List < String > > > ( ) ; sub Detail Report Map . put ( " Passed TC List " , tc Passed Data ) ; sub Detail Report Map . put ( " Failed TC List " , tc Failed Data ) ; sub Detail Report Map . put ( " Skipped TC List " , tc Skipped Data ) ; Report Map < List < String > > third Report = new Report Map < List < String > > ( Report Sheet Names . TESTCASEREPORT . get Name ( ) , sub Detail Report Map , 1 ) ; full Report Map . add ( third Report ) ; Map < String , List < List < String > > > lst Defect Reports = new Linked Hash Map < String , List < List < String > > > ( ) ; lst Defect Reports . put ( " Defect Summary " , tc Defect Data ) ; Report Map < List < String > > fourth Report = new Report Map < List < String > > ( Report Sheet Names . DEFECTREPORT . get Name ( ) , lst Defect Reports , 1 ) ; full Report Map . add ( fourth Report ) ; Base Report < List < String > > b R = ( Base Report < List < String > > ) full Report Map . get ( full Report Map . size ( ) - 1 ) . get Generated Report ( ) . iterator ( ) . next ( ) ; b R . set Col Titles ( ls Titles ) ; fifth Test Output Sub Report Map . put ( " Test Output " , tc Output Data ) ; full Report Map . add ( fifth Report Sheet ) ; logger . exiting ( ) ; }<CODESPLIT>Generates all summarized counts for various reports<CODESPLIT>0
public Processor create Processor ( Servlet Context Context ) throws { Web Module Data Data = ( ( Web App Config Extended ) ( Context . get Web App Config ( ) ) ) . get Data ( ) ; Jax Rs Module Data jax Rs Module Data = Jax Rs Data . get Jax Rs Module Data ( Data ) ; ( jax Rs Module Data ) { ; } Non Persistent Cache overlay Cache = Context . get Module Container ( ) . ( Non Persistent Cache . class ) ; Jax Rs Module jax Rs Module = ( Jax Rs Module ) overlay Cache . get From Cache ( Jax Rs Module . class ) ; ( jax Rs Module jax Rs Module . ( ) 0 ) { ( tc . is Enabled ( ) ) { Tr . debug ( tc , " No JAX - RS service is found in the web module , will not create web service processor " ) ; } return null ; } Container publisher Module Container = servlet Context . get Module Container ( ) ; Jax Rs Publisher Context publisher Context = new Jax Rs Publisher Context ( jax Rs Module Meta Data , publisher Module Container , Jax Rs Utils . get Web Module Info ( publisher Module Container ) ) ; publisher Context . set Attribute ( Jax Rs Server Constants . SERVLET _ CONTEXT , servlet Context ) ; Web App web App = ( Web App ) servlet Context ; publisher Context . set Attribute ( Jax Rs Constants . COLLABORATOR , web App . get Collaborator Helper ( ) . get Web App Name Space Collaborator ( ) ) ; Endpoint Publisher endpoint Publisher = endpoint Publisher SR . get Service With Exception ( ) ; for ( Endpoint Info endpoint Info : jax Rs Module Info . get Endpoint Infos ( ) ) { endpoint Publisher . publish ( endpoint Info , publisher Context ) ; } for ( Jax Rs Web App Configurator jax Rs Web App Configurator : jax Rs Web App Configurators ) { jax Rs Web App Configurator . configure ( jax Rs Module Info , servlet Context . get Web App Config ( ) ) ; } return new Jax Rs Extension Processor ( servlet Context ) ; }<CODESPLIT>{<CODESPLIT>1
private void Every ( visitor ) { get From ( ) ; ( ) ; Id Iterator NO EDGE ; ( 0 ; ; ) { Iterator get Iterator ( Ids . get ( i ) , tmp Node ) ; if ( edge Base == null ) throw new Illegal State Exception ( " Edge " + edge Ids . get ( i ) + " was empty when requested with node " + tmp Node + ", array index :" + i + ", edges :" + edge Ids . size ( ) ) ; tmp Node = edge Base . get Base Node ( ) ; edge Base = graph . get Edge Iterator State ( edge Base . get Edge ( ) , tmp Node ) ; visitor . next ( edge Base , i , prev Edge Id ) ; prev Edge Id = edge Base . get Edge ( ) ; } visitor . finish ( ) ; }<CODESPLIT>Returns the list of all edges .<CODESPLIT>0
public static guess ( fkeys , boolean Quote , check ) { guess ( fkeys , ( GUESS _ INFO , GUESS _ SEP , single Quote , check Header , GUESS _ COL _ CNT , null , new Parse Writer . Parse Err [ 0 ] ) ) ; }<CODESPLIT>Discover the parse setup needed to correctly parse all files . This takes a ParseSetup as guidance . Each file is examined individually and then results merged . If a conflict exists between any results all files are re - examined using the best guess from the first examination .<CODESPLIT>0
public static boolean ( ) { Boolean value Of ( get Prop ( Keys . METRICS _ ENABLED _ KEY , Configuration Keys . DEFAULT _ METRICS _ ENABLED ) ) ; }<CODESPLIT>Check whether metrics collection and reporting are enabled or not .<CODESPLIT>1
static T , Dao T , create Dao ( Connection Source Source , Class T clazz ) throws Exception { return new Base Dao Impl < T , ID > ( connection Source , clazz ) { } ; }<CODESPLIT>Helper method to create a Dao object without having to define a class . Dao classes are supposed to be convenient but if you have a lot of classes they can seem to be a pain .<CODESPLIT>0
public void set ( String timecode ) Timecode Timecode { clear ( ) ; set Hours ( get Token ( timecode , ) ) ; set Minutes ( get Token ( timecode , ) ) ; set ( get Token ( timecode , 2 ) ) ; set Frames ( get Token ( timecode , ) ) ; ( Samples ( ) ) { { set Samples ( get Token ( timecode , ) ) ; set Frames Per ( ) ; } } } normalize ( ) ; }<CODESPLIT>Sets the object based on a string in the form HH : MM : SS : FF<CODESPLIT>1
private void extract ( Json Object ) { Json Object get As Json Object ( ) ; ( ) { Json = meta . get As Json Primitive ( " msg " ) ; if ( msg != null ) { this . message = msg . get As String ( ) ; return ; } } Json Primitive error = object . get As Json Primitive ( " error " ) ; if ( error != null ) { this . message = error . get As String ( ) ; return ; } }<CODESPLIT>Performs an XAuth authentication .<CODESPLIT>0
public static update nitro gslbparameter ) { gslbparameter updateresource gslbparameter ) ; updateresource ldnsentrytimeout ldnsentrytimeout ; updateresource . rtttolerance = resource . rtttolerance ; updateresource . ldnsmask = resource . ldnsmask ; updateresource . v 6 ldnsmasklen = resource . v 6 ldnsmasklen ; updateresource . ldnsprobeorder = resource . ldnsprobeorder ; updateresource . dropldnsreq = resource . dropldnsreq ; return updateresource . update _ resource ( client ) ; }<CODESPLIT>Use this API to fetch lbvserver_tmtrafficpolicy_binding resources of given name .<CODESPLIT>0
protected synchronized void activate ( Context context , Map String , Object ) { String Name = ( String ) . get ( Name ) ; String Value = ( String ) . get ( value ) ; boolean = ( Boolean ) . get ( ) ; ( Name Name . is Empty ( ) Value Value . is Empty ( ) ) { ( Trace Component . is Tracing ( ) tc . is Debug ( ) ) { ; String value = Value ; if ( decode ) { try { value = Password Util . decode ( original Value ) ; } catch ( Exception e ) { Tr . error ( tc , " jndi . decode . failed " , original Value , e ) ; } } Object parsed Value = Literal Parser . parse ( value ) ; String value Class Name = parsed Value . get Class ( ) . get Name ( ) ; final Object service Object = decode ? new Decode ( original Value ) : parsed Value ; Dictionary < String , Object > properties For Jndi Service = new Hashtable < String , Object > ( ) ; properties For Jndi Service . put ( " osgi . jndi . service . name " , jndi Name ) ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Debug Enabled ( ) ) { Tr . debug ( tc , " Registering JNDI Entry " + value Class Name + " with value " + parsed Value + " and JNDI name " + jndi Name ) ; } this . service Registration = context . register Service ( value Class Name , service Object , properties For Jndi Service ) ; }<CODESPLIT>Registers the JNDI service for the supplied properties as long as the jndiName and value are set<CODESPLIT>1
public String , String get WMI Object ( WMI wmi Class ) { return get WMI Object List ( wmi Class . get Name ( ) ) ; }<CODESPLIT>Query a list of object data for an specific class <br ><CODESPLIT>1
public static void close ( Transport ) { { ( . is Connected ( ) ) . close ( ) ; } catch ( Throwable e ) { Exception Util . rethrow If Necessary ( e ) ; } }<CODESPLIT>close Writer without a Exception<CODESPLIT>1
public static Class Loader Element Matcher Junction is Parent Of ( Class Loader class Loader ) { class Loader BOOTSTRAP CLASSLOADER Element Matchers . < T > is Bootstrap Class Loader ( ) : new Class Loader Parent Matcher < T > ( class Loader ) ; }<CODESPLIT>Matches all class loaders in the hierarchy of the matched class loader against a given matcher .<CODESPLIT>0
public void marshall ( Batch Get Object Attributes Get Object Attributes , Marshaller Marshaller ) { ( Get Object Attributes ) { Sdk Client ( argument to marshall (...)" ) ; } { Marshaller marshall ( Get Object Attributes get Attributes ( ) , ATTRIBUTES _ BINDING ) ; } catch ( Exception e ) { throw new Sdk Client Exception ( " Unable to marshall request to JSON : " + e . get Message ( ) , e ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public void handle Input Stream ( Input Stream is ) throws { ( Handling ." ) ; Output Stream File Output Stream ( file ) ; { long Written littleshoot util . Io Utils . copy ( is , os , this . m _ write Listener ) ; LOG . trace ( " Wrote " + bytes Written + " to file : " + this . m _ file ) ; } finally { IO Utils . close Quietly ( is ) ; IO Utils . close Quietly ( os ) ; } }<CODESPLIT>{<CODESPLIT>0
public rule Sync ( Rule ) { Rule rule ( ) ; Each ( rule -> { Rule exist Rule get Exist Rule ( rule ) ; rule . add ( exist Rule != null ? exist Rule : rule ) ; } ) ; this . validation Rules . remove All ( rule List ) ; this . temp Rules . add All ( this . validation Rules ) ; this . validation Rules = rule List ; this . validation Rules . sort ( new Rule Sorter ( ) ) ; return this ; }<CODESPLIT>Find list parent validation data .<CODESPLIT>0
protected String get Type ( ) { ( all Type ) { all Type List < String > ( ) ; all Data Type Start Words . add All ( Data Types . DATATYPE _ START _ WORDS ) ; all Data Type Start Words . add All ( get Custom Data Type Start Words ( ) ) ; } return all Data Type Start Words ; }<CODESPLIT>Returns a list of data type start words which can be used to help identify a column definition sub - statement .<CODESPLIT>1
protected void Toolbar ( Tool Bar toolbar ) { ; Insets insets Insets ( ) ; add Tool Bar ( toolbar TOOLBAR ) ; toolbar add ( ( Constant get ( ". toolbar ) ) . get GBC ( x ++ , 0 , 1 , 0 , insets ) ) ; toolbar . add ( get Context Select Combo Box ( ) , Layout Helper . get GBC ( x ++ , 0 , 1 , 0 , insets ) ) ; x = this . add Tool Bar Elements ( toolbar , TOOLBAR _ LOCATION _ AFTER _ CONTEXTS _ SELECT , x ) ; toolbar . add ( new J Label ( ) , Layout Helper . get GBC ( x ++ , 0 , 1 , 1 . 0 ) ) ; if ( has Options ( ) ) { toolbar . add ( get Options Button ( ) , Layout Helper . get GBC ( x ++ , 0 , 1 , 0 , insets ) ) ; } this . add Tool Bar Elements ( toolbar , TOOLBAR _ LOCATION _ END , x ) ;<CODESPLIT>Gets the Context select combo box .<CODESPLIT>0
private int parse Trailer ( [ ] , int in Offset , List Byte Buffer list ) throws Data Format { ( Trace Component . is Any Tracing ( ) tc . is Debug ( ) ) { Tr . ( tc , trailer , =" this . parse Offset =" this . parse Int ) ; } int = in Offset ; long = 0 L ; ( 8 this . parse Offset . ) { ( this . parse Offset ) { 0 : 2 : case 4 : case 6 : this . parse First Byte = input [ offset ] & 0 xff ; break ; break ; case 3 : val = ( ( input [ offset ] & 0 xff ) << 8 ) | this . parse First Byte ; if ( this . checksum . get Value ( ) != val ) { String msg = " Checksum does not match ; crc =" + this . checksum . get Value ( ) + " trailer =" + val ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Debug Enabled ( ) ) { Tr . debug ( tc , msg ) ; } release ( list ) ; throw new Data Format Exception ( msg ) ; } break ; case 7 : val = ( ( input [ offset ] & 0 xff ) << 8 ) | this . parse First Byte ; if ( this . inflater . get Bytes Written ( ) != val ) { String msg = " Bytes Written does not match ; inflater =" + this . inflater . get Bytes Written ( ) + " trailer =" + val ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Debug Enabled ( ) ) { Tr . debug ( tc , msg ) ; } release ( list ) ; throw new Data Format Exception ( msg ) ; } this . reset Needed To Proceed = true ; break ; } offset ++ ; this . parse Offset ++ ; } return offset ; }<CODESPLIT>Parse past the GZIP trailer information . This is the two ints for the CRC32 checksum validation .<CODESPLIT>1
public Observable Deleted get Deleted Async ( Url , ) { get Deleted With Async ( Url , Name ) . map ( new Func 1 < Service Response < Deleted Secret Bundle > , Deleted Secret Bundle > ( ) { @ Override public Deleted Secret Bundle call ( Service Response < Deleted Secret Bundle > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Permanently deletes the specified secret . The purge deleted secret operation removes the secret permanently without the possibility of recovery . This operation can only be enabled on a soft - delete enabled vault . This operation requires the secrets / purge permission .<CODESPLIT>0
public void add To ( , String ) { not ( , cannot ) ; has ( , ( ) cannot or only whitespaces ) ; ( To contains ( ) ) { Argument Exception ( " Class " + clazz + " has already defined alias ( id ) " + class To Id . get ( clazz ) + " cannot set another alias " + id ) ; } if ( id To Class . contains Key ( id ) ) { throw new Illegal Argument Exception ( " Alias ( id ) " + id + " is used by another class " + id To Class . get ( id ) + " and cannot be used by " + clazz ) ; } class To Id . put ( clazz , id ) ; id To Class . put ( id , clazz ) ; }<CODESPLIT>Adds single mapping : class < - > alias ( id ) .<CODESPLIT>1
void submit ( ) { ; ( is Mode All ( ) ) { Cms Flex CLEAR ONLINE ; } { Cms Flex CLEAR ONLINE ENTRIES ; } Cms . fire Cms Event ( new Cms Event ( I _ Cms Event Listener . EVENT _ FLEX _ CACHE _ CLEAR , Collections . < String , Object > singleton Map ( Cms Flex Cache . CACHE _ ACTION , new Integer ( action ) ) ) ) ; }<CODESPLIT>Set defautl values to vaadin components . <p ><CODESPLIT>0
public Shutdown Gateway shutdown Gateway Shutdown Gateway Request request ) request Client request ) ; return execute Shutdown Gateway ( request ) ; }<CODESPLIT><p > Shuts down a gateway . To specify which gateway to shut down use the Amazon Resource Name ( ARN ) of the gateway in the body of your request . < / p > <p > The operation shuts down the gateway service component running in the gateway s virtual machine ( VM ) and not the host VM . < / p > <note > <p > If you want to shut down the VM it is recommended that you first shut down the gateway component in the VM to avoid unpredictable conditions . < / p > < / note > <p > After the gateway is shutdown you cannot call any other API except <a > StartGateway< / a > <a > DescribeGatewayInformation< / a > and <a > ListGateways< / a > . For more information see <a > ActivateGateway< / a > . Your applications cannot read from or write to the gateway s storage volumes and there are no snapshots taken . < / p > <note > <p > When you make a shutdown request you will get a <code > 200 OK< / code > success response immediately . However it might take some time for the gateway to shut down . You can call the <a > DescribeGatewayInformation< / a > API to check the status . For more information see <a > ActivateGateway< / a > . < / p > < / note > <p > If do not intend to use the gateway again you must delete the gateway ( using <a > DeleteGateway< / a > ) to no longer pay software charges associated with the gateway . < / p ><CODESPLIT>1
@ For static Metric Client create Metric Client ( @ ) { Metric Settings settings Metric Settings ( ) set Transport Channel ( Instantiating Grpc Channel new Builder ( ) . set Header Provider ( OPENCENSUS _ USER _ AGENT _ HEADER _ PROVIDER ) . build ( ) ) ; if ( credentials != null ) { settings Builder . set Credentials Provider ( Fixed Credentials Provider . create ( credentials ) ) ; } return Metric Service Client . create ( settings Builder . build ( ) ) ; }<CODESPLIT>Resets exporter to null . Used only for unit tests .<CODESPLIT>0
public List Connection get ( Connection Mode Mode , String Source Name , int ) throws { Data Source Source get Data Source Map ( ) . get ( Source Name ) ; . check ( Source , Missing the source name '% '" , Source Name ) ; Collection Connection > connections ; synchronized ( cached Connections ) { connections = cached Connections . get ( data Source Name ) ; } List < Connection > result ; if ( connections . size ( ) >= connection Size ) { result = new Array List <> ( connections ) . sub List ( 0 , connection Size ) ; } else if ( ! connections . is Empty ( ) ) { result = new Array List <> ( connection Size ) ; result . add All ( connections ) ; result . add All ( new Connections ) ; synchronized ( cached Connections ) { cached Connections . put All ( data Source Name , new Connections ) ; } } else { result = new Array List <> ( create Connections ( data Source Name , connection Mode , data Source , connection Size ) ) ; synchronized ( cached Connections ) { cached Connections . put All ( data Source Name , result ) ; } } return result ; }<CODESPLIT>Get database connections .<CODESPLIT>1
public void copy From Image start Row start , int columns , int destination Row Offset , int destination Column Offset ) { source . copy To ( backend , start Row Index , rows , start Column Index , columns , destination Row Offset , destination Column Offset ) ; }<CODESPLIT>Copies the content from a TextImage into this buffer .<CODESPLIT>1
public Date Time Weeks ( long weeks ) { ( weeks Long . _ VALUE Weeks ( Long . _ VALUE ) . Weeks ( ) : plus Weeks ( - weeks ) ) ; }<CODESPLIT>Returns a copy of this { @code LocalDateTime } with the specified number of months subtracted . <p > This method subtracts the specified amount from the months field in three steps : <ol > <li > Subtract the input months from the month - of - year field< / li > <li > Check if the resulting date would be invalid< / li > <li > Adjust the day - of - month to the last valid day if necessary< / li > < / ol > <p > For example 2007 - 03 - 31 minus one month would result in the invalid date 2007 - 04 - 31 . Instead of returning an invalid result the last valid day of the month 2007 - 04 - 30 is selected instead . <p > This instance is immutable and unaffected by this method call .<CODESPLIT>0
public static String concat ( String ... strs ) { String String ( ) ; ( String strs ) { . append ( str ) ; } return sb . to String ( ) ; }<CODESPLIT>快速连接参数中的字符串 .<CODESPLIT>1
public static build Object ( Class Class , Class extended Class , Class ? extends T > extended Interface Wrapper Class , Collection < String > class Names Iterator , T default Object ) { return build Application Object ( interface Class , extended Interface Class , extended Interface Wrapper Class , class Names Iterator , default Object , null ) ; }<CODESPLIT>Creates ApplicationObjects like NavigationHandler or StateManager and creates the right wrapping chain of the ApplicationObjects known as the decorator pattern .<CODESPLIT>0
public synchronized Record read ( long session Id , long url Id ) { { Read set Long ( , session Id ) ; Read set Long ( 2 , url Id ) ; ( Result Read execute ( ) ) { Record result = build ( rs ) ; return result ; } } catch ( SQL Exception e ) { throw new Database Exception ( e ) ; } }<CODESPLIT>This method initializes this<CODESPLIT>0
public final T process ( final Map String , Object p Add Param , final T p Entity , final I Request Data p Request Data ) throws { String field Path Name = p Request Data . get Parameter ( field Name File Path ) ; Method Field Path = this . getters Rapi . get For ( p Entity . get Class ( ) , field Path Name ) ; String file Path = ( String ) Field Path . invoke ( p Entity ) ; ( file Path != ) { File file To Del = new File ( file Path ) ; if ( file To Del . exists ( ) && ! file To Del . delete ( ) ) { } } this . srv Orm . delete Entity ( p Add Param , p Entity ) ; return null ; }<CODESPLIT><p > Process entity request . < / p ><CODESPLIT>1
protected int get Transaction Isolation ( ) { String = . get ( PROPS _ _ ) ; return == 1 : Integer . parse Int ( val ) ; }<CODESPLIT>transactionIsolationオプションの指定<CODESPLIT>1
public static kronecker ( Big a , Big ) { . get ( ) . kronecker Impl ( a , p ) ; }<CODESPLIT>Verifies this library is loaded properly .<CODESPLIT>0
private static void parse ) bounds ) ) bounds get Object ( " bounds " ) ; current . set Bounds ( new Bounds ( new Point ( bounds Object . get JSON Object ( " lower Right " ) . get Double ( " x " ) , bounds Object . get JSON Object ( " lower Right " ) . get Double ( " y " ) ) , new Point ( bounds Object . get JSON Object ( " upper Left " ) . get Double ( " x " ) , bounds Object . get JSON Object ( " upper Left " ) . get Double ( " y " ) ) ) ) ; } }<CODESPLIT>creates a point array of all dockers and add it to the current shape<CODESPLIT>0
public Parse Result parse ( Reader reader , Attribute Source parent ) throws { Parse Result res = Parse Result ( ) ; String = String ( ) ; char [ ] = char [ 128 ] ; int cnt ; ( ( cnt = reader . read ( ) ) 0 ) { . append ( , 0 , cnt ) ; iterator = . get Iterator ( ) ; ( iterator != iterator . has Next ( ) ) { res . = . get Stored String Value ( ) ; res . bin = . get Stored Bin Value ( ) ; { res . = ; res . bin = ; . close ( ) ; return res ; } parent . clear Attributes ( ) ; ( iterator . has Next ( ) ) { Mtas Update Request Processor Result item = iterator . next ( ) ; if ( item . token Term != null ) { Char Term Attribute catt = parent . add Attribute ( Char Term Attribute . class ) ; catt . append ( item . token Term ) ; if ( item . token Flags != null ) { Flags Attribute flags = parent . add Attribute ( Flags Attribute . class ) ; flags . set Flags ( item . token Flags ) ; if ( item . token Pos Incr != null ) { Position Increment Attribute patt = parent . add Attribute ( Position Increment Attribute . class ) ; patt . set Position Increment ( item . token Pos Incr ) ; if ( item . token Payload != null ) { Payload Attribute p = parent . add Attribute ( Payload Attribute . class ) ; p . set Payload ( new Bytes Ref ( item . token Payload ) ) ; Offset Attribute offset = parent . add Attribute ( Offset Attribute . class ) ; offset . set Offset ( item . token Offset Start , item . token Offset End ) ; State state = parent . capture State ( ) ; res . states . add ( state . clone ( ) ) ; parent . clear Attributes ( ) ; catch ( IO Exception e ) { log . debug ( e ) ; return res ;<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public String get ( String code ) { assert code ; Missing Resource error = ; Resource [ ] bundles = get ( ) ; ( int = 0 ; bundles . ; ) { { return bundles [ i ] . get String ( code ) ; } catch ( Missing Resource Exception e ) { if ( error != null ) { } } } assert error != null ; throw error ; }<CODESPLIT>An implementation of { @link Parser } s abstract { @link Parser#flatten ( Options String [] boolean ) flatten } method . <p > The following are the rules used by this flatten method . <ol > <li > if <code > stopAtNonOption< / code > is <b > true< / b > then do not burst anymore of <code > arguments< / code > entries just add each successive entry without further processing . Otherwise ignore <code > stopAtNonOption< / code > . < / li > <li > if the current <code > arguments< / code > entry is <b > -- < / b > just add the entry to the list of processed tokens< / li > <li > if the current <code > arguments< / code > entry is <b > - < / b > just add the entry to the list of processed tokens< / li > <li > if the current <code > arguments< / code > entry is two characters in length and the first character is <b > - < / b > then check if this is a valid { @link Option } id . If it is a valid id then add the entry to the list of processed tokens and set the current { @link Option } member . If it is not a valid id and <code > stopAtNonOption< / code > is true then the remaining entries are copied to the list of processed tokens . Otherwise the current entry is ignored . < / li > <li > if the current <code > arguments< / code > entry is more than two characters in length and the first character is <b > - < / b > then we need to burst the entry to determine its constituents . For more information on the bursting algorithm see { @link GroovyInternalPosixParser#burstToken ( String boolean ) burstToken } . < / li > <li > if the current <code > arguments< / code > entry is not handled by any of the previous rules then the entry is added to the list of processed tokens . < / li > < / ol ><CODESPLIT>0
public Iterable find All ( @ Null sort ) { not Null ( sort , sort of find All should not ) ; Document query Document ( Criteria get Instance ( Criteria Type . ALL ) ) . with ( sort ) ; return operation . find ( query , information . get Java Type ( ) , information . get Collection Name ( ) ) ; }<CODESPLIT>Returns all entities sorted by the given options .<CODESPLIT>1
void load Configs ( ) { load ( ) ; user load ( ) ; load ( ) ; get Config ( ) . with Fallback ( user . get Config ( ) ) . with Fallback ( system . get Config ( ) ) ; dump 2 debug Log ( " MERGED " , config ) ; }<CODESPLIT>end of class ConfigSource<CODESPLIT>0
private void append Line ( String , Level , String , String ) { append ( ) ; append ( ) ; append ( Class Graph class get Name ( ) ) ; buf . append ( ' ' ) ; final int num Dashes = 2 * ( indent Level - 1 ) ; for ( int i = 0 ; i < num Dashes ; i ++ ) { buf . append ( ' ' ) ; if ( num Dashes > 0 ) { buf . append ( ' ' ) ; buf . append ( line ) ; buf . append ( ' ' ) ; }<CODESPLIT>Add a child log node .<CODESPLIT>0
static public String create ( String Url , Instruction , String modifies , TE ) { monitors get ( Url ) ; set ( ) ; ( Instruction ) { set Parser Instruction ( Dom Utils . get Element ( parser Instruction ) ) ; mc . set Modifies Response ( Boolean . parse Boolean ( modifies Response ) ) ; } LOGR . log ( Level . CONFIG , " Configured monitor without test :\ n { 0 }" , mc ) ; return "" ; }<CODESPLIT>Monitor without parser that doesn t trigger a test<CODESPLIT>0
public void add Relation To ( Cms Cms Cms Cms Relation boolean import ) Cms { ( Defined In Content ( ) ) { Cms ( Messages get ( ) ( Messages RELATION remove Site ( get Path ( ) ) remove Site ( target . get Root Path ( ) ) , type . get Localized Name ( dbc . get Request Context ( ) . get Locale ( ) ) ) ) ; } Cms Relation relation = new Cms Relation ( resource , target , type ) ; get Vfs Driver ( dbc ) . create Relation ( dbc , dbc . current Project ( ) . get Uuid ( ) , relation ) ; if ( ! import Case ) { log ( dbc , new Cms Log Entry ( dbc , resource . get Structure Id ( ) , Cms Log Entry Type . RESOURCE _ ADD _ RELATION , new String [ ] { relation . get Source Path ( ) , relation . get Target Path ( ) } ) , false ) ; set Date Last Modified ( dbc , resource , System . current Time Millis ( ) ) ; } }<CODESPLIT>Adds a resource to the given organizational unit . <p ><CODESPLIT>0
public void marshall ( Associate Product With Portfolio Request associate Product With Portfolio Request , Protocol Marshaller Marshaller ) { ( associate Product With Portfolio Request == ) { Sdk Client ( " argument passed to marshall (...)" ) ; } { Marshaller . marshall ( associate Product With Portfolio Request . get Accept Language ( ) , ACCEPTLANGUAGE _ BINDING ) ; protocol Marshaller . marshall ( associate Product With Portfolio Request . get Product Id ( ) , PRODUCTID _ BINDING ) ; protocol Marshaller . marshall ( associate Product With Portfolio Request . get Portfolio Id ( ) , PORTFOLIOID _ BINDING ) ; protocol Marshaller . marshall ( associate Product With Portfolio Request . get Source Portfolio Id ( ) , SOURCEPORTFOLIOID _ BINDING ) ; } catch ( Exception e ) { } }<CODESPLIT><p > To help organize your resources you can assign your own metadata to the resources that you create . Each tag is a key - value pair . < / p ><CODESPLIT>0
public static void swap ( array array 2 Index ) { if ( int Array 1 [ array 1 Index ] != int Array 2 [ array 2 Index ] ) { int hold = int Array 1 [ array 1 Index ] ; int Array 1 [ array 1 Index ] = int Array 2 [ array 2 Index ] ; int Array 2 [ array 2 Index ] = hold ; } }<CODESPLIT>Helper method that swaps all the elements of the arrays . This method runs in O ( <code > Math . min ( array1 . length array2 . length< / code > ) time .<CODESPLIT>1
public void marshall ( User Request delete User Request , Marshaller Marshaller ) { ( delete User Request ) { Sdk Client ( argument marshall (...)" ) ; } { Marshaller marshall ( delete User Request get User ( ) , USERNAME BINDING ) ; Marshaller marshall ( delete User Request get ( ) , AUTHENTICATIONTYPE _ BINDING ) ; } catch ( Exception e ) { throw new Sdk Client Exception ( " Unable to marshall request to JSON : " + e . get Message ( ) , e ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
protected void add Webuser ( Cms Select , Cms Organizational , ) { String webuser Template ; ( has Webuser ( ) ) { webuser Template "( % >= 32768 AND % < 65536 )" ; } else { webuser Condition Template = "( % 1 $ s < 32768 OR % 1 $ s >= 65536 )" ; } String webuser Condition = String . format ( webuser Condition Template , users . column ( col Flags ( ) ) ) ; select . add Condition ( webuser Condition ) ;<CODESPLIT>Adds a check for the web user condition to an SQL query . <p ><CODESPLIT>1
void add ( Less Extend Extend , String main Selector ) { ( main Selector main Selector 0 With ( "@ media ) ) { main Selector Extend get Selectors ( ) ; } { main Selector Selector merge ( main Selector , Extend get Selectors ( ) ) ; } String extending Selector = less Extend . get Extending Selector ( ) ; if ( less Extend . is All ( ) ) { Selector Tokenizer tokenizer = tokenizers . poll Last ( ) . init ( extending Selector ) ; do { String token = tokenizer . next ( ) ; if ( token == null ) { break ; } all . add ( token , extend ) ; } while ( true ) ; tokenizers . add Last ( tokenizer ) ; } else { exact . add ( extending Selector , main Selector ) ; } }<CODESPLIT>Add to the given selectors all possible extends and return the resulting selectors .<CODESPLIT>0
JMF get ( ) Encode Failed { ( Tracing ( ) tc ( ) ) Sib Tr ( tc get ) ; JMF ; { JMF ( ( JMF ) header Part jmf Part ) get Schemata ( ) ; JMF ; ; ( payload Part ) { ( ( JMF ) payload Part jmf Part ) get Schemata ( ) ; ; } JMF Schema [ result Size ] ; System . arraycopy ( result 1 , 0 , result , 0 , result 1 . length ) ; if ( payload Part != null ) { System . arraycopy ( result 2 , 0 , result , result 1 . length , result 2 . length ) ; } } catch ( JMF Exception e ) { FFDC Filter . process Exception ( e , " com . ibm . ws . sib . mfp . impl . Js Msg Object . get Encoding Schemas " , " jmo 700 " , this , new Object [ ] { new Object [ ] { Mfp Constants . DM _ MESSAGE , header Part . jmf Part , the Message } , new Object [ ] { Mfp Constants . DM _ MESSAGE , payload Part . jmf Part , the Message } } ) ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Debug Enabled ( ) ) Sib Tr . debug ( this , tc , " get Encoding Schemas failed : " + e ) ; throw new Message Encode Failed Exception ( e ) ; } if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) Sib Tr . exit ( this , tc , " get Encoding Schemas " ) ; return result ; }<CODESPLIT>Get a list of the JMF schemas needed to decode this message<CODESPLIT>1
public boolean add ( int value ) { ( size == ) { ( This Int of is ) ; } int index = int ( value , mask ) ; while ( values [ index ] != missing Value ) { if ( values [ index ] == value ) { return false ; } index = next ( index ) ; } values [ index ] = value ; size ++ ; return true ; }<CODESPLIT>Splits a { @link ClientMessage } into frames of a maximum size .<CODESPLIT>0
private void delete property ( , String name , String , String propname ) Dev Failed { ( is Access ( ) ) check Access ( ) ; String array ; array = new String [ 1 ] ; array [ 0 ] = propname ; delete _ obj _ property ( database , name , type , array ) ; }<CODESPLIT>==========================================================================<CODESPLIT>1
public static get Ctrl Or ( ) { Page get Current ( ) get ( ) ; if ( web Browser . is Mac OSX ( ) ) { return Shortcut Action . Modifier Key . META ; } return Shortcut Action . Modifier Key . CTRL ; }<CODESPLIT>Dynamic styles for window .<CODESPLIT>0
public User resolve User ( long user Id ) throws { . user . mark ( ) ; User user user . get If ( user Id ) ; ( user ) { metrics . user Cache Hits . mark ( ) ; return user ; } else { user = select User ( user Id ) ; user Cache . put ( user Id , user ) ; } return user ; } }<CODESPLIT>Resolves a user by username possibly with the internal cache .<CODESPLIT>1
public static build Cleaned Parameters Representation apache commons httpclient Spider Param Parameters Option handle Parameters boolean handle Parameters Visited ) { handle Parameters Parameters Option USE ) ) { ) ; } handle Parameters Parameters Option . IGNORE _ COMPLETELY ) ) { return create Base Uri With Cleaned Path ( uri , handle Parameters , handle O Data Parameters Visited ) ; if ( handle Parameters . equals ( Handle Parameters Option . IGNORE _ VALUE ) ) { String Builder ret Val = new String Builder ( create Base Uri With Cleaned Path ( uri , handle Parameters , handle O Data Parameters Visited ) ) ; String cleaned Query = get Cleaned Query ( uri . get Escaped Query ( ) ) ; if ( cleaned Query . length ( ) > 0 ) { ret Val . append ( ' ' ) . append ( cleaned Query ) ; } return ret Val . to String ( ) ; return uri . to String ( ) ;<CODESPLIT>Tells whether or not the given port is the default for the given scheme . <p > <strong > Note : < / strong > Only HTTP and HTTPS schemes are taken into account .<CODESPLIT>0
public int run ( String arg , boolean stdin , boolean force ) throws { Output Stream output Stream = ; Input Stream Stream = ; { ( command ) { CREATE : ( ks Exists ( ) ) { boolean = prompt Yes No ( An es hadoop . Overwrite [ y / N ]" ) ; ( == false ) { prompt . ( Exiting without ) ; return 0 ; } } Wrapper = Keystore Wrapper . Store ( ) . build ( ) ; output Stream = open Write ( ) ; Wrapper . save Keystore ( output Stream ) ; return 0 ; LIST : ( ! ks Exists ( ) ) { return 5 ; } Stream = open Read ( ) ; Wrapper = Keystore Wrapper . load Store ( Stream ) . build ( ) ; for ( String : Wrapper . list Entries ( ) ) { prompt . ( ) ; } return 0 ; ADD : if ( ! ks Exists ( ) ) { return 5 ; } input Stream = open Read ( ) ; keystore Wrapper = Keystore Wrapper . load Store ( input Stream ) . build ( ) ; if ( keystore Wrapper . contains Entry ( arg ) && force == false ) { boolean proceed = prompt Yes No ( " Setting % s already exists . Overwrite ? [ y / N ]" , arg ) ; if ( proceed == false ) { prompt . println ( " Exiting without modifying keystore " ) ; return 0 ; } } if ( stdin ) { String data = prompt . read Line ( ) ; keystore Wrapper . set Secure Setting ( arg , data ) ; } else { char [ ] data = prompt . read Password ( " Enter value for % s :" , arg ) ; keystore Wrapper . set Secure Setting ( arg , new String ( data ) ) ; Arrays . fill ( data , ( char ) 0 ) ; } output Stream = open Write ( ) ; keystore Wrapper . save Keystore ( output Stream ) ; return 0 ; case REMOVE : if ( ! ks Exists ( ) ) { return 5 ; } input Stream = open Read ( ) ; keystore Wrapper = Keystore Wrapper . load Store ( input Stream ) . build ( ) ; if ( keystore Wrapper . contains Entry ( arg ) == false ) { prompt . printf ( " ERROR : Setting [% s ] does not exist in the keystore .% n " , arg ) ; return 6 ; keystore Wrapper . remove Secure Setting ( arg ) ; output Stream = open Write ( ) ; keystore Wrapper . save Keystore ( output Stream ) ; return 0 ; default : prompt . println ( " ERROR : Unsupported command " + command . get Text ( ) ) ; return 7 ; catch ( Es Hadoop Security Exception ehse ) { prompt . println ( " ERROR Could not load keystore file : " + ehse . get Message ( ) ) ; return 8 ; catch ( File Not Found Exception fnfe ) { prompt . println ( " ERROR : Could not load keystore file : " + fnfe . get Message ( ) ) ; return 9 ; catch ( IO Exception ioe ) { prompt . println ( " ERROR : " + ioe . get Message ( ) ) ; return 10 ; finally { if ( output Stream != null ) { output Stream . close ( ) ; if ( input Stream != null ) { input Stream . close ( ) ;<CODESPLIT>{<CODESPLIT>0
private boolean update Stream Blacklist ( 2 String , String processing Blacklist , message , String Stream ) { boolean ; ( Stream message get ( ) ) { ( ! initial Stream Ids . remove ( stream . get Id ( ) ) ) { added Streams = true ; } else { processing Blacklist . add ( tuple ( message . get Id ( ) , stream . get Id ( ) ) ) ; } } return added Streams ; }<CODESPLIT>Evaluates all pipelines that apply to the given messages based on the current stream routing of the messages .<CODESPLIT>0
protected boolean Firehose Drainable By Closing Firehose firehose ) firehose Receiver Firehose firehose Shutoff Firehose Firehose Drainable By Closing ( ( ( Timed Shutoff Firehose Factory ) firehose Factory ) . get Delegate Factory ( ) ) ) || ( firehose Factory instanceof Clipped Firehose Factory && is Firehose Drainable By Closing ( ( ( Clipped Firehose Factory ) firehose Factory ) . get Delegate ( ) ) ) ; }<CODESPLIT>Is a firehose from this factory drainable by closing it? If so we should drain on stopGracefully rather than abruptly stopping . <p > This is a hack to get around the fact that the Firehose and FirehoseFactory interfaces do not help us do this . <p > Protected for tests .<CODESPLIT>1
public boolean Event ( Event ) { GVR Cursor Controller controller get Controller Id ( get Device Id ( ) ) ; ( controller ) { return controller . dispatch Key Event ( event ) ; } return false ; }<CODESPLIT>returns controller if a new device is found<CODESPLIT>0
public boolean Derivation ( , ) { ( ( ) ) { ; } ( . Nominal ) { Type . Nominal t = ( Type . Nominal ) child ; Decl . Type decl = t . get Link ( ) . get Target ( ) ; return is Derivation ( parent , decl . get Type ( ) ) ; } else { return false ; }<CODESPLIT>Check whether one type is a derivation of another . For example in this scenario :<CODESPLIT>1
public void set Selected ( String selected ) { get Helper ( ) . put ( Property Keys . selected Class , selected Class ) ; }<CODESPLIT><p > Return the value of the <code > selectedClass< / code > property . < / p > <p > Contents : CSS style class to apply to the rendered label on selected options .<CODESPLIT>0
public static T Predicates T In ( Function T , function , Iterable < ? > iterable ) { return new Attribute Predicate < T , Object > ( function , Predicates . in ( iterable ) ) ; }<CODESPLIT>Creates a predicate which returns true if an attribute selected from an object passed to accept method is contained in the iterable .<CODESPLIT>1
private void validate Request ( Download Request dreq ) throws Error Response { String path dreq get Path ( ) ; ( path With ( Catalog XML ) path index Of ( "__" ) - 1 ) { throw new Error Response Exception ( Download Response . get No Content Response ( ) ) ; } }<CODESPLIT>Make sure that it is a valid request . This is also the place to implement the reverse IP lookup<CODESPLIT>1
public Autofit set ( boolean ) { ( ) { ( ) { View add Changed ( Watcher ) ; View add On Layout Change Listener ( m On Layout Change Listener ) ; autofit ( ) ; } else { m Text View . remove Text Changed Listener ( m Text Watcher ) ; m Text View . remove On Layout Change Listener ( m On Layout Change Listener ) ; m Text View . set Text Size ( Typed Value . COMPLEX _ UNIT _ PX , m Text Size ) ; } } return this ; }<CODESPLIT>Set the enabled state of automatically resizing text .<CODESPLIT>1
public static void check If Unmodified Since ( String Unmodified Since , modified ) { parse Date ( Unmodified Since ) ; ( modified truncated To ( SECONDS ) . is After ( time ) ) { throw new Client Error Exception ( status ( PRECONDITION _ FAILED ) . build ( ) ) ; } }<CODESPLIT>Check for a conditional operation .<CODESPLIT>1
public void set Progress ( Cms Upload Progess ) { File get Current File ( ) ; File ; ( File ) { } { File File ; ( File >= Filenames To Upload ( ) ) { File Filenames To Upload ( ) ; } } if ( m _ content Length == 0 ) { m _ content Length = info . get Content Length ( ) ; } String curr Filename = m _ ordered Filenames To Upload . get ( curr File Index ) ; String content Length = Cms Upload Button . format Bytes ( m _ content Length ) ; int file Count = m _ ordered Filenames To Upload . size ( ) ; String read Bytes = Cms Upload Button . format Bytes ( get Bytes Read ( info . get Percent ( ) ) ) ; m _ bar . set Value ( info . get Percent ( ) ) ; if ( ! m _ started ) { m _ started = true ; m _ fileinfo . set HTML ( 0 , 0 , "< b >" + Messages . get ( ) . key ( Messages . GUI _ UPLOAD _ PROGRESS _ CURRENT _ FILE _ 0 ) + "</ b >" ) ; m _ fileinfo . set HTML ( 1 , 0 , "< b >" + Messages . get ( ) . key ( Messages . GUI _ UPLOAD _ PROGRESS _ UPLOADING _ 0 ) + "</ b >" ) ; m _ fileinfo . set HTML ( 2 , 0 , "" ) ; m _ fileinfo . set Text ( 0 , 1 , "" ) ; m _ fileinfo . set Text ( 1 , 1 , "" ) ; m _ fileinfo . set Text ( 2 , 1 , "" ) ; m _ fileinfo . get Column Formatter ( ) . set Width ( 0 , " 100 px " ) ; } m _ fileinfo . set Text ( 0 , 1 , curr Filename ) ; m _ fileinfo . set Text ( 2 , 1 , Messages . get ( ) . key ( Messages . GUI _ UPLOAD _ PROGRESS _ UPLOADING _ VALUE _ 2 , read Bytes , content Length ) ) ; }<CODESPLIT>Returns the file text . <p ><CODESPLIT>0
public static void escape ( String , String ) { ( ; ( ) ; ) { hi At ( ) ; ( hi hi hi C ( hi >= hi ) ( hi >= hi ) ( ( hi >= Character is High Surrogate ( hi ) ) ) ) { append ( String format ( "\\ % 04 x " , ( int ) hi ) ) ; } else if ( Character . is High Surrogate ( hi ) ) { final char lo = str . char At ( ++ i ) ; final int c = ( hi << 10 ) + lo + ( 0 x 10000 - ( 0 x D 800 << 10 ) - 0 x DC 00 ) ; rval . append ( String . format ( "\\ U % 08 x " , c ) ) ; } else { switch ( hi ) { case ' ' : rval . append ( "\\ b " ) ; break ; case ' ' : rval . append ( "\\ n " ) ; break ; case ' ' : rval . append ( "\\ t " ) ; break ; case ' ' : rval . append ( "\\ f " ) ; break ; case ' ' : rval . append ( "\\ r " ) ; break ; case ' ' : rval . append ( "\\\"" ) ; break ; case ' ' : rval . append ( "\\\\" ) ; break ; default : rval . append ( hi ) ; break ; } } } }<CODESPLIT>Parses the authority for the pre - parsed given JsonLdUrl .<CODESPLIT>0
public static void send ( Byte Buffer , Web Channel Channel , Web Void callback ) { Close Message sm = new Close Message ( data ) ; send Close ( sm , ws Channel , callback ) ; }<CODESPLIT>Sends a complete close message invoking the callback when complete<CODESPLIT>0
public get Inverse ( ) { Set ( ) ; n . forbidden Characters = characters ; n . characters = forbidden Characters ; return n ; }<CODESPLIT>Write VCF record with the specified print writer .<CODESPLIT>0
protected boolean read Feature Parameters ( Element ) { { List childrent . get Child Nodes ( ) ; cpnames Vector String ( ) ; paras Vector Vector Integer ( ) ; ( int 0 ; childrent . get Length ( ) ; ) ( childrent . item ( ) Element ) { Element child ( Element ) childrent . item ( ) ; String value child . get Attribute ( value ) ; String [ ] parastr = value . split ( ":" ) ; for ( int j = 3 ; j < parastr . length ; ++ j ) { para . add ( Integer . parse Int ( parastr [ j ] ) ) ; } cpnames . add ( parastr [ 2 ] ) ; paras . add ( para ) ; } } catch ( Exception e ) { System . out . println ( e . get Message ( ) ) ; e . print Stack Trace ( ) ; return false ; } return true ; }<CODESPLIT>Read feature parameters .<CODESPLIT>1
public insert Before ( Child , Child ) throws { error ( XML Error Resources . ER _ FUNCTION _ NOT _ ) ; return null ; }<CODESPLIT>Unimplemented . See org . w3c . dom . Node<CODESPLIT>1
public static Auth Token basic ( String username , String password , String ) { . Non Null ( username , Username ) ; . Non Null ( password , " Password can ' t be null " ) ; map . put ( SCHEME _ KEY , value ( " basic " ) ) ; map . put ( PRINCIPAL _ KEY , value ( username ) ) ; map . put ( CREDENTIALS _ KEY , value ( password ) ) ; if ( realm != null ) { map . put ( REALM _ KEY , value ( realm ) ) ; } return new Internal Auth Token ( map ) ; }<CODESPLIT>The basic authentication scheme using a username and a password .<CODESPLIT>1
private Function Expression , Statement add To Placeholder Map ( String map , Standalone ) { To Map Function ( map , placeholder Compiler compile To Soy Value ( map , , Extra Code Compiler . NO _ OP , Extra Code Compiler . NO _ OP ) ) ; }<CODESPLIT>See go / soy - element - keyed - roots for reasoning on why this is disallowed .<CODESPLIT>0
public void marshall ( Metric , Marshaller Marshaller ) { ( ) { Sdk Client ( argument passed to marshall (...)" ) ; } { Marshaller . marshall ( . get Name ( ) , BINDING ) ; Marshaller . marshall ( Definition . get Regex ( ) , REGEX _ BINDING ) ; } catch ( Exception e ) { throw new Sdk Client Exception ( " Unable to marshall request to JSON : " + e . get Message ( ) , e ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
static String [ ] split ( URI remote , String , @ Nullable String default Branch ) { String host = remote . get Host ( ) ; ( host == ! remote . get ( ) . With ( "+ file ) ) { Argument ( no host in remote : remote ) ; } String path = remote . get Raw Path ( ) ; ( path == ) { new Illegal Argument Exception ( " no path in remote Uri : " + remote Uri ) ; } final Matcher matcher = Pattern . compile ( " (.*?\\." + suffix + ")(?:$|/)" ) . matcher ( path ) ; if ( ! matcher . find ( ) ) { } final String new Remote Uri ; final int port = remote Uri . get Port ( ) ; if ( host != null ) { if ( port > 0 ) { new Remote Uri = remote Uri . get Scheme ( ) + "://" + host + ' ' + port + matcher . group ( 1 ) ; } else { new Remote Uri = remote Uri . get Scheme ( ) + "://" + host + matcher . group ( 1 ) ; } } else { new Remote Uri = remote Uri . get Scheme ( ) + "://" + matcher . group ( 1 ) ; } final String remote Path ; try { decoded = normalize Path ( decoded ) ; remote Path = decoded ; } catch ( Unsupported Encoding Exception e ) { throw new Error ( e ) ; } final String fragment = remote Uri . get Fragment ( ) ; final String remote Branch = fragment != null ? fragment : default Branch ; return new String [ ] { new Remote Uri , remote Path , remote Branch } ; }<CODESPLIT>Splits the specified remoteUri into : - the actual remote repository URI - the path in the remote repository - the branch name .<CODESPLIT>1
public static List Class resolve ( Class type ) { List Class res Lists . new Array List ( ) ; Class < ? > current = type ; while ( ! Object . class . equals ( current ) && current != null ) { res . add ( current ) ; current = current . get Superclass ( ) ; } return res ; }<CODESPLIT>Assigns base class in scheme for provided model type ( for example to make class vertex type it must extend V ) .<CODESPLIT>0
public void set Refreshing ( boolean refreshing ) { ( refreshing Refreshing refreshing ) { Refreshing refreshing ; int end Target 0 ; ( Using ) { ( Direction ) { BOTTOM end Target get Measured ( ) ( int ) ( Spinner Final ) ; ; TOP end Target ( int ) ( Spinner Final Offset - Math . abs ( m Original Offset Top ) ) ; break ; } } else { end Target = ( int ) m Spinner Final Offset ; } set Target Offset Top And Bottom ( end Target - m Current Target Offset Top , true ) ; start Scale Up Animation ( m Refresh Listener ) ; } else { set Refreshing ( refreshing , false ) ; } }<CODESPLIT>Notify the widget that refresh state has changed . Do not call this when refresh is triggered by a swipe gesture .<CODESPLIT>1
private Field get All Instance Fields ( Object ) { Field fields instance Fields By Class get ( get Class ( ) ) ; ( fields ) { Field field get All Fields ( , exclude Static , exclude Transient ) ; fields = field List . to Array ( new Field [ field List . size ( ) ] ) ; instance Fields By Class . put ( obj . get Class ( ) , fields ) ; } return fields ; }<CODESPLIT>Visits all the keys and entries of the given map .<CODESPLIT>0
private Vector Layer dto Attribute Criterion To ( Attribute Criterion criterion ) Geomajas { Vector Layer filters Vector Layer ( ) ; Vector Layer configuration get Vector Layer ( criterion get Layer ( ) ) ; ( ) { Geomajas ( LAYER NOT criterion get Layer ( ) ) ; } operator criterion get Operator ( ) ; if ( " LIKE " . equals ( operator . to Upper Case ( ) ) ) { f = filter Service . create Like Filter ( criterion . get Attribute Name ( ) , criterion . get Value ( ) ) ; else if ( " DURING " . equals ( operator . to Upper Case ( ) ) || " BEFORE " . equals ( operator . to Upper Case ( ) ) || " AFTER " . equals ( operator . to Upper Case ( ) ) ) { f = filter Service . parse Filter ( criterion . to String ( ) ) ; else { f = filter Service . create Compare Filter ( criterion . get Attribute Name ( ) , criterion . get Operator ( ) , criterion . get Value ( ) ) ; } filters . put ( l , f ) ; return filters ; }<CODESPLIT>Prune impossible combinations . ( eg . If And criteria filter different layers they will return nothing so they are pruned ) .<CODESPLIT>0
public Session create Session ( , , username , ) { generate ( ) ; ( Host ( ) , ) ; ( Name Port ( ) , String . value Of ( port ) ) ; if ( username != null ) { props . put ( transport Strategy . property Name Username ( ) , username ) ; } if ( password != null ) { props . put ( transport Strategy . property Name Authenticate ( ) , " true " ) ; return Session . get Instance ( props , new Authenticator ( ) { @ Override protected Password Authentication get Password Authentication ( ) { return new Password Authentication ( username , password ) ; } } ) ; } else { return Session . get Instance ( props ) ; } }<CODESPLIT>Actually instantiates and configures the { @link Session } instance . Delegates resolving transport protocol specific properties to the { @link #transportStrategy } in two ways : <ol > <li > request an initial property list which the strategy may pre - populate< / li > <li > by requesting the property names according to the respective transport protocol it handles ( for the host property name it would be <em > mail . smtp . host < / em > for SMTP and <em > mail . smtps . host < / em > for SMTPS ) < / li > < / ol ><CODESPLIT>1
final List configurations = Array List ( ) ; final Map String , Object Settings = Map ( ) ; Settings . put ( GCC _ WARN _ ABOUT _ _ TYPE , YES ) ; Settings . put ( GCC _ WARN _ UNUSED _ , YES ) ; Settings . put ( PREBINDING , NO ) ; final PBX Object Config = create XC Configuration ( Debug , Settings ) ; objects . put ( Config . get ID ( ) , Config . get Properties ( ) ) ; configurations . add ( Config ) ; final Map String , Object release Settings = Map ( ) ; release Settings . put ( GCC _ WARN _ ABOUT _ _ TYPE , YES ) ; release Settings . put ( " GCC _ WARN _ UNUSED _ VARIABLE " , " YES " ) ; release Settings . put ( " PREBINDING " , " NO " ) ; final PBX Object Ref release Config = create XC Build Configuration ( " Release " , release Settings ) ; objects . put ( release Config . get ID ( ) , release Config . get Properties ( ) ) ; configurations . add ( release Config ) ; final PBX Object Ref configuration List = create XC Configuration List ( configurations ) ; final Map project Configuration List Properties = configuration List . get Properties ( ) ; project Configuration List Properties . put ( " default Configuration Is Visible " , " 0 " ) ; project Configuration List Properties . put ( " default Configuration Name " , " Debug " ) ; objects . put ( configuration List . get ID ( ) , configuration List . get Properties ( ) ) ; final File [ ] include Dirs = compiler Config . get Include Path ( ) ; if ( include Dirs . length > 0 ) { final List < String > include Paths = new Array List <> ( ) ; final Map < String , String > include Path Map = new Hash Map <> ( ) ; for ( final File include Dir : include Dirs ) { if ( ! C Util . is System Path ( include Dir ) ) { final String abs Path = include Dir . get Absolute Path ( ) ; if ( ! include Path Map . contains Key ( abs Path ) ) { if ( abs Path . starts With ( "/ usr /" ) ) { include Paths . add ( C Util . to Unix Path ( abs Path ) ) ; } else { include Paths . add ( rel Path ) ; } include Path Map . put ( abs Path , abs Path ) ; } } } include Paths . add ( "${ inherited )" ) ; debug Settings . put ( " HEADER _ SEARCH _ PATHS " , include Paths ) ; release Settings . put ( " HEADER _ SEARCH _ PATHS " , include Paths ) ; } final String [ ] pre Args = compiler Config . get Pre Arguments ( ) ; final List < String > defines = new Array List <> ( ) ; for ( final String pre Arg : pre Args ) { if ( pre Arg . starts With ( "- D " ) ) { defines . add ( pre Arg . substring ( 2 ) ) ; if ( defines . size ( ) > 0 ) { defines . add ( "$( inherited )" ) ; debug Settings . put ( " GCC _ PREPROCESSOR _ DEFINITIONS " , defines ) ; release Settings . put ( " GCC _ PREPROCESSOR _ DEFINITIONS " , defines ) ; if ( linker Config != null ) { final Map < String , String > library Search Map = new Hash Map <> ( ) ; final List < String > library Search Paths = new Array List <> ( ) ; final List < String > other Ld Flags = new Array List <> ( ) ; final String [ ] linker Args = linker Config . get End Arguments ( ) ; for ( final String linker Arg : linker Args ) { if ( linker Arg . starts With ( "- L " ) ) { final String lib Dir = linker Arg . substring ( 2 ) ; if ( ! library Search Map . contains Key ( lib Dir ) ) { if ( ! lib Dir . equals ( "/ usr / lib " ) ) { library Search Map . put ( lib Dir , lib Dir ) ; else if ( linker Arg . starts With ( "- l " ) ) { final String lib Name = linker Arg . substring ( 2 ) ; boolean found = false ; for ( final Dependency Def dependency : dependencies ) { if ( lib Name . starts With ( dependency . get Name ( ) ) ) { final File dependency File = dependency . get File ( ) ; found = true ; break ; if ( ! found ) { other Ld Flags . add ( linker Arg ) ; debug Settings . put ( " LIBRARY _ SEARCH _ PATHS " , library Search Paths ) ; debug Settings . put ( " OTHER _ LDFLAGS " , other Ld Flags ) ; release Settings . put ( " LIBRARY _ SEARCH _ PATHS " , library Search Paths ) ; release Settings . put ( " OTHER _ LDFLAGS " , other Ld Flags ) ; return configuration List ;<CODESPLIT>Add project configuration list .<CODESPLIT>1
public Result get Privileges ( ) { check ( ) ; Volt vtable Volt ( Column ( CAT Volt ) Column ( " TABLE _ SCHEM " , Volt Type . STRING ) , new Column Info ( " TABLE _ NAME " , Volt Type . STRING ) , new Column Info ( " GRANTOR " , Volt Type . STRING ) , new Column Info ( " GRANTEE " , Volt Type . STRING ) , new Column Info ( " PRIVILEGE " , Volt Type . STRING ) , new Column Info ( " IS _ GRANTABLE " , Volt Type . STRING ) ) ; JDBC 4 Result Set res = new JDBC 4 Result Set ( this . sys Catalog , vtable ) ; return res ; }<CODESPLIT>Retrieves a description of the access rights for each table available in a catalog .<CODESPLIT>1
public Account get Account Async ( Group , account , Account ) { get Account With Async ( Group , account Name , storage Account Name ) . map ( new Func 1 < Service Response < Storage Account Info Inner > , Storage Account Info Inner > ( ) { @ Override public Storage Account Info Inner call ( Service Response < Storage Account Info Inner > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Gets the specified Azure Storage account linked to the given Data Lake Analytics account .<CODESPLIT>1
private static double Q double xa double xb ) { ) xa ) 5 ) ; double epsilon xa EIGHTHS ; double sint SINE ; double sint SINE B [ idx ] ; final double cost A = COSINE _ TABLE _ A [ idx ] ; final double cost B = COSINE _ TABLE _ B [ idx ] ; double sin Eps A = epsilon ; double sin Eps B = poly Sine ( epsilon ) ; final double cos Eps A = 1 . 0 ; final double cos Eps B = poly Cosine ( epsilon ) ; final double temp = sin Eps A * HEX _ 40000000 ; double temp 2 = ( sin Eps A + temp ) - temp ; sin Eps B += sin Eps A - temp 2 ; sin Eps A = temp 2 ; double result ; double a = 0 ; double b = 0 ; double t = sint A ; double c = a + t ; double d = - ( c - a - t ) ; a = c ; b = b + d ; t = cost A * sin Eps A ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + sint A * cos Eps B + cost A * sin Eps B ; b = b + sint B + cost B * sin Eps A + sint B * cos Eps B + cost B * sin Eps B ; if ( xb != 0 . 0 ) { c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; } result = a + b ; return result ; }<CODESPLIT>Compute sine over the first quadrant ( 0 < x < pi / 2 ) . Use combination of table lookup and rational polynomial expansion .<CODESPLIT>1
public void set Executors ( @ Nonnegative int ) throws , Argument { ( 0 ) { Argument ( Incorrect field \"# of executors \": + ". It should be a non - negative number ." ) ; } if ( this . num Executors != n ) { this . num Executors = n ; update Computer List ( ) ; save ( ) ; } }<CODESPLIT>{ @inheritDoc } .<CODESPLIT>0
private static boolean class Name Matches File Name ( Class , Context ) { toplevel sourcefile . is Name Compatible ( c . name . to String ( ) , Java File Object . Kind . SOURCE ) ; }<CODESPLIT>Does class have the same name as the file it appears in?<CODESPLIT>1
@ Json ( value Page Link ) @ Api ( value The pagination link ." , position = 4 ) public Page Request Link Dto get Next Page Link ( ) { return next Page Link ; }<CODESPLIT>Returns the next pagination link .<CODESPLIT>1
public static Homoglyph build ( @ Nonnull @ Will Close Reader a Reader ) throws { Value Enforcer . not Null ( a Reader , reader ) ; ( Non Blocking Buffered Reader a BR = Non Blocking Buffered Reader ( a Reader ) ) { I Commons List Int a List = Commons Array List ( ) ; String Line ; ( ( Line = a BR . read Line ( ) ) != ) { Line = Line . trim ( ) ; ( Line . starts With ( "#" ) || s Line . length ( ) == 0 ) continue ; final Int Set a Set = new Int Set ( s Line . length ( ) / 3 ) ; for ( final String s Char Code : String Helper . get Exploded ( ' ' , s Line ) ) { if ( n Val >= 0 ) a Set . add ( n Val ) ; a List . add ( a Set ) ; } return new Homoglyph ( a List ) ;<CODESPLIT>Consumes the supplied Reader and uses it to construct a populated Homoglyph object .<CODESPLIT>1
private boolean has Nullified FK ( Field Descriptor fk Field , Object fk Values ) { boolean = ; ( int = 0 ; fk Values . ; ) { ( ! pb . Broker ( ) . represents Null ( fk Field Descriptors [ i ] , fk Values [ i ] ) ) { result = false ; break ; } } return result ; }<CODESPLIT>to avoid creation of unmaterializable proxies<CODESPLIT>1
public Historic Date get Begin Of Year ( Historic Era era , year Of Era ) { Historic Date Year get Year ( ) Year ( era , year Of Era ) ; ( Valid ( Year ) ) { Plain Date date = this . convert ( new Year ) ; Historic Era preferred Era = this . era Preference . get Preferred Era ( new Year , date ) ; if ( preferred Era != era ) { int yoe = preferred Era . year Of Era ( new Year . get Era ( ) , new Year . get Year Of Era ( ) ) ; new Year = Historic Date . of ( preferred Era , yoe , new Year . get Month ( ) , new Year . get Day Of Month ( ) ) ; } return new Year ; } else { } }<CODESPLIT>/ * [ deutsch ] <p > Determines the date of New Year . < / p ><CODESPLIT>1
protected static void check array ) { check ( ( Object ) array ) ; for ( Object o : array ) { check Not Null ( o ) ; } }<CODESPLIT>Validate the specified arguments .<CODESPLIT>1
private static String get Extent Of Participation Mention ( List event List , List List , process NAF vars ) { List Wf event Word List = get The WF List By Terms From Target List ( event List , vars ) ; List Wf Word List = get The WF List By Terms From Target List ( List , vars ) ; List Wf merged Word List = List Wf > ( ) ; int char Start Of Event = Integer . parse Int ( event Word List . get First ( ) . get Offset ( ) ) ; int char Start Of Role = Integer . parse Int ( role Word List . get First ( ) . get Offset ( ) ) ; if ( char Start Of Event <= char Start Of Role ) { } else { } for ( Wf w : first WL ) { if ( ! merged Word List . contains ( w ) ) { merged Word List . add ( w ) ; } } for ( Wf w : second WL ) { if ( ! merged Word List . contains ( w ) ) { merged Word List . add ( w ) ; } } String Buffer extent = new String Buffer ( ) ; for ( Wf w : merged Word List ) { extent . append ( w . getvalue ( ) + " " ) ; } String s Extent = extent . to String ( ) ; return s Extent . substring ( 0 , s Extent . length ( ) - 1 ) ; }<CODESPLIT>/ * similar to generateTheMIdAndSetID () but specific for ParticipationMention<CODESPLIT>1
public Config set Txns Expiration Timeout ( int ) { ( 0 1000 ) { Setting ( Transaction should greater than a second " ) ; } set Setting ( ENV _ MONITOR _ TXNS _ EXPIRATION _ TIMEOUT , timeout ) ; if ( timeout > 0 && timeout < get Env Monitor Txns Check Freq ( ) ) { set Env Monitor Txns Check Freq ( timeout ) ; } return this ;<CODESPLIT>Sets the maximum size of page of B + Tree . Default value is { @code 128 } . Only sizes in the range [ 16 .. 1024 ] are accepted . <p > Mutable at runtime : yes<CODESPLIT>0
public static void add Type ( Class clz , Class mapper ) { synchronized ( ) { Class = class Mapper . get ( clz ) ; if ( h == null ) { h = new Linked Hash Set < Class < ? > > ( ) ; class Mapper . put ( clz , h ) ; } h . add ( mapper ) ; } }<CODESPLIT>Field type convertor for all classes<CODESPLIT>1
public static Document Document ( Document Factory factory ) { { Document factory Document ( ) ; return builder ; } catch ( Exception e ) { throw MESSAGES . unable To Create Instance Of ( e , Document Builder . class . get Name ( ) ) ; } }<CODESPLIT>Parse the given XML string and return the root Element This uses the document builder associated with the current thread .<CODESPLIT>0
public synchronized void clear ( ) { ( valid ) { ( ) ; } { clear ( ) ; fc ( 0 ) ( 0 ) force ( true ) ; close ( ) ; open ( ) ; } catch ( Exception e ) { log . error ( " Exception in clear ()" , e ) ; } }<CODESPLIT>Read value from file<CODESPLIT>0
void send Migration Event ( Migration status ) { int Id get Id ( ) ; get ( ) ; Member Member get Member ( ) ; Migration Event Migration Event ( partition Id , null , local Member , status ) ; final Event Service event Service = node Engine . get Event Service ( ) ; final Collection < Event Registration > registrations = event Service . get Registrations ( SERVICE _ NAME , MIGRATION _ EVENT _ TOPIC ) ; event Service . publish Event ( SERVICE _ NAME , registrations , event , partition Id ) ;<CODESPLIT>Sends a {<CODESPLIT>1
private void process Constraint ( final Set Constraint Object violations , final Binding Errors Errors , final Context Object validation Context ) { for ( Constraint Object violation : violations ) { final String field = violation . get Property Path ( ) . to String ( ) ; final Constraint Descriptor cd = violation . get Constraint Descriptor ( ) ; final String [ ] error = determine Error Code ( cd ) ; final Map String , Object error = create Variable For Constraint ( cd ) ; ( is Field ( field , validation Context ) ) { final Csv Field Error field Error = binding Errors . get First Field Error ( field ) ; if ( field Error != null && field Error . is Processing Failure ( ) ) { continue ; } error Vars . put ( " line Number " , validation Context . get Csv Context ( ) . get Line Number ( ) ) ; error Vars . put ( " row Number " , validation Context . get Csv Context ( ) . get Row Number ( ) ) ; error Vars . put ( " column Number " , column Mapping . get Number ( ) ) ; error Vars . put ( " label " , column Mapping . get Label ( ) ) ; error Vars . compute If Absent ( " printer " , key -> column Mapping . get Formatter ( ) ) ; final Object field Value = violation . get Invalid Value ( ) ; error Vars . compute If Absent ( " validated Value " , key -> field Value ) ; String default Message = determine Defalt Message ( error Vars , violation ) ; } else { binding Errors . reject ( error Codes , error Vars , violation . get Message ( ) ) ; } } }<CODESPLIT>BeanValidationの検証結果をSheet用のエラーに変換する<CODESPLIT>1
public static void write To File ( @ File , @ String content ) { Output Stream writer Output Stream ( File Output Stream ( ) , ) ; { writer write ( content ) ; writer flush ( ) ; } ( ioe ) { Log . e ( LOG _ TAG , ioe . to String ( ) ) ; } finally { try { writer . close ( ) ; } catch ( IO Exception ioe ) { Log . e ( LOG _ TAG , ioe . to String ( ) ) ; } } }<CODESPLIT>Delete file .<CODESPLIT>0
public static extract ( ) { Img With Alt ( ) ; = safe Remove All Tags ( html ) ; html = unescape Html ( html ) ; return html ; }<CODESPLIT>Extracts the title of the page .<CODESPLIT>0
public static Rule get Rule ( inequality field value ) { ( field ( Logging Field LEVEL FIELD ) ) { Level Inequality Rule get Rule ( inequality Symbol , value ) ; } else if ( field . equals Ignore Case ( Logging Event Field Resolver . TIMESTAMP _ FIELD ) ) { return Timestamp Inequality Rule . get Rule ( inequality Symbol , value ) ; } else { return new Inequality Rule ( inequality Symbol , field , value ) ;<CODESPLIT>Create new instance from top two elements on stack .<CODESPLIT>0
public void create Equi Angle ( float , Rotations , Samples , float jitter , d ) { float spacing Rotations ; ( sample ; sample Samples ; sample ) { float angle ( float ) ( sample Rotations ) Samples ; float radius * sample / ( num Samples - 1 ) + ( rnd . next Float ( ) * 2 . 0 f - 1 . 0 f ) * spacing * jitter ; float x = ( float ) Math . sin _ roquen _ 9 ( angle + 0 . 5 f * ( float ) Math . PI ) * r ; float y = ( float ) Math . sin _ roquen _ 9 ( angle ) * r ; callback . on New Sample ( x , y ) ; } }<CODESPLIT>Create <code > numSamples< / code > number of samples on a spiral with maximum radius <code > radius< / code > around the center using <code > numRotations< / code > number of rotations along the spiral and call the given <code > callback< / code > for each sample generated . <p > The generated sample points are distributed with equal angle differences around the spiral so they concentrate towards the center . <p > Additionally the radius of each sample point is jittered by the given <code > jitter< / code > factor .<CODESPLIT>1
private void read Object ( Object Input Stream ) , Class Not Found { Read Object ( ) ; INFO ; summary ; detail ; ordinal . read Int ( ) ; if ( ordinal == SEVERITY _ INFO . get Ordinal ( ) ) { severity = Faces Message . SEVERITY _ INFO ; } else if ( ordinal == SEVERITY _ WARN . get Ordinal ( ) ) { severity = Faces Message . SEVERITY _ WARN ; } else if ( ordinal == SEVERITY _ ERROR . get Ordinal ( ) ) { } else if ( ordinal == SEVERITY _ FATAL . get Ordinal ( ) ) { summary = ( String ) in . read Object ( ) ; detail = ( String ) in . read Object ( ) ; rendered = ( Boolean ) in . read Object ( ) ; }<CODESPLIT><p > Reconstruct {<CODESPLIT>1
public void For ( String log String , int Time ) throws Timeout { For Container For Condition ( new Log Checker ( this , log Search String ) , wait Time , describe ( ) ) ; }<CODESPLIT>Stop and wait till given string will show in container output .<CODESPLIT>1
public Query from ( Collection Expression from ) { ( from null ) { return this ; } this . from Columns . add All ( from Columns ) ; return this ; }<CODESPLIT>Adds the FROM columns .<CODESPLIT>1
public void get Element Settings Config ( String , String , Cms Cms Element Settings Config ) { Cms Rpc Cms Element Settings Config Cms Rpc Cms Element Settings Config ( ) { @ Override public void execute ( ) { start ( , ) ; get Containerpage ( ) get Element Settings Config ( get ( ) get Rpc ( ) , , container Id , get Page State ( ) , get Locale ( ) , this ) ; } @ Override protected void on Response ( Cms Element Settings Config result ) { if ( result != null ) { callback . execute ( result ) ; } stop ( false ) ; } } ; action . execute ( ) ; }<CODESPLIT>Requests the element settings config data for a container element specified by the client id . The data will be provided to the given call - back function . <p ><CODESPLIT>1
protected synchronized void copy ( Writable other ) { ( other ) { { Data Output Buffer Data Output Buffer ( ) ; other write ( ) ; Data Input Buffer Data Input Buffer ( ) ; reset ( get Data ( ) , get Length ( ) ) ; read Fields ( ) ; } ( e ) { throw new Illegal Argument Exception ( " map cannot be copied : " + e . get Message ( ) ) ; } else { throw new Illegal Argument Exception ( " source map cannot be null " ) ;<CODESPLIT>Used by child copy constructors .<CODESPLIT>1
public Cell C , T ( Value C , T ) { = width ; pref Width = width ; max Width = width ; return this ; }<CODESPLIT>Sets the minWidth prefWidth and maxWidth to the specified value .<CODESPLIT>0
public void create Reference ( Reference ) Green Pepper { { start Session ( ) ; Transaction ( ) ; repository load ( get ( ) get ( ) get Uid ( ) ) ; create Reference ( ) ; commit Transaction ( ) ; ( " Created Reference : " + reference . get Requirement ( ) . get Name ( ) + "," + reference . get Specification ( ) . get Name ( ) ) ; } catch ( Exception ex ) { session Service . rollback Transaction ( ) ; throw handle Exception ( REFERENCE _ CREATE _ FAILED , ex ) ; } finally { session Service . close Session ( ) ; } }<CODESPLIT>{<CODESPLIT>0
public static Document build PDF Document ( snowtide pdf Document pdf , Lucene PDF Configuration ) throws { String Writer String Writer ( ) ; pdf pipe ( Output Target ( ) ) ; Document Document ( ) ; LUCENE INTERFACE add Field ( , get Body Text Field Name ( ) , to String ( ) , Body Text ( ) , index Body Text ( ) , Body Text ( ) ) ; ( Map Entry String , Object Entry pdf get Attribute Map ( ) ( ) ) { String Prop Name Entry get Key ( ) ; String field Name get Metadata Field Mapping ( Prop Name ) ; ( field Name ) { ( config . copy All PDF Metadata ( ) ) { field Name = doc Prop Name ; } else { continue ; } } Object value = metadata Entry . get Value ( ) ; String value Str ; if ( value == null ) { if ( LOG _ DEBUG ) log . debug ( " Null document property value found for name [" + doc Prop Name + "] (" + pdf . get Name ( ) + ' ' ) ; continue ; } else if ( value instanceof String ) { if ( doc Prop Name . equals ( com . snowtide . pdf . Document . ATTR _ MOD _ DATE ) || doc Prop Name . equals ( com . snowtide . pdf . Document . ATTR _ CREATION _ DATE ) ) { try { value Str = Date Tools . date To String ( PDF Date Parser . parse Date String ( ( String ) value ) , Date Tools . Resolution . MILLISECOND ) ; } catch ( Exception e ) { log . warn ( " PDF date string could not be parsed into a java . util . Date instance [" + value + "] (" + pdf . get Name ( ) + ' ' , e ) ; value Str = ( String ) value ; } } else { value Str = ( String ) value ; } } else if ( value instanceof Number ) { value Str = value . to String ( ) ; } else { continue ; } LUCENE _ INTERFACE . add Field ( doc , field Name , value Str , config . store Metadata ( ) , config . index Metadata ( ) , config . tokenize Metadata ( ) ) ; } return doc ; }<CODESPLIT>Creates a new Lucene Document instance using the PDF text and metadata provided by the PDFxStream Document using a default {<CODESPLIT>0
protected void remove Target ( Component ) { remove Mouse ( ) ; remove Mouse ( ) ; ( ) { cont = ( Container ) comp ; cont . remove Container Listener ( _ child Listener ) ; for ( int ii = 0 , nn = cont . get Component Count ( ) ; ii < nn ; ii ++ ) { remove Target Listeners ( cont . get Component ( ii ) ) ; } } }<CODESPLIT>Check to see if we need to do component - level cursor setting and take care of it if needed .<CODESPLIT>0
public Observable delete By Async ( ) { delete By With Async ( ) . map ( new Func 1 < Service Response < Policy Assignment Inner > , Policy Assignment Inner > ( ) { @ Override public Policy Assignment Inner call ( Service Response < Policy Assignment Inner > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Deletes a policy assignment by ID . When providing a scope for the assigment use / subscriptions / { subscription - id } / for subscriptions / subscriptions / { subscription - id } / resourceGroups / { resource - group - name } for resource groups and / subscriptions / { subscription - id } / resourceGroups / { resource - group - name } / providers / { resource - provider - namespace } / { resource - type } / { resource - name } for resources .<CODESPLIT>0
private void get Fights ( Document , Event ) { ( Getting fights #{}[{}]" , get Sherdog Url ( ) , get Name ( ) ) ; Sherdog Object Event Sherdog Object ( ) ; Event set Name ( get Name ( ) ) ; Event set Sherdog Url ( get Sherdog Url ( ) ) ; List Fight fights Array List ( ) ; main Fight Element select ( ". content ) ; fighters main Fight Element . select ( " h 3 a " ) ; Sherdog Base Object main Fighter 1 = new Sherdog Base Object ( ) ; Element main Fighter 1 Element = fighters . get ( 0 ) ; main Fighter 1 . set Sherdog Url ( main Fighter 1 Element . attr ( " abs : href " ) ) ; main Fighter 1 . set Name ( main Fighter 1 Element . select ( " span [ itemprop =\" name \"]" ) . html ( ) ) ; Sherdog Base Object main Fighter 2 = new Sherdog Base Object ( ) ; Element main Fighter 2 Element = fighters . get ( 1 ) ; main Fighter 2 . set Sherdog Url ( main Fighter 2 Element . attr ( " abs : href " ) ) ; main Fighter 2 . set Name ( main Fighter 2 Element . select ( " span [ itemprop =\" name \"]" ) . html ( ) ) ; Fight main Fight = new Fight ( ) ; main Fight . set Event ( s Event ) ; main Fight . set Fighter 1 ( main Fighter 1 ) ; main Fight . set Fighter 2 ( main Fighter 2 ) ; main Fight . set Result ( Parser Utils . get Fight Result ( main Fight Element . first ( ) ) ) ; Elements main Td = main Fight Element . select ( " td " ) ; if ( main Td . size ( ) > 0 ) { main Fight . set Win Method ( main Td . get ( 1 ) . html ( ) . replace All ( "< em (.*)< br >" , "" ) . trim ( ) ) ; } main Fight . set Date ( event . get Date ( ) ) ; fights . add ( main Fight ) ; logger . info ( " Fight added : {}" , main Fight ) ; logger . info ( " Found {} fights " , fights . size ( ) ) ; Elements tds = doc . select ( ". event _ match table tr " ) ; fights . add All ( parse Event Fights ( tds , event ) ) ; event . set Fights ( fights ) ; }<CODESPLIT>parses an event from a jsoup document<CODESPLIT>0
public Property Descriptor [ get Tea Bean Property ( Class Class ) { ( Class == ) { NO _ PROPERTIES ; Property Descriptor [ properties = ; Map String , Property Descriptor all Props = ; { all Props = Bean . get All Properties ( Generic Type ( Class ) ) ; } ( Throwable ) { NO _ PROPERTIES ; Collection Property Descriptor clean Props = Array List Property Descriptor > ( all Props . size ( ) ) ; Iterator < Map . Entry < String , Property Descriptor > > it = all Props . entry Set ( ) . iterator ( ) ; while ( it . has Next ( ) ) { Map . Entry < String , Property Descriptor > entry = it . next ( ) ; String name = entry . get Key ( ) ; Property Descriptor desc = entry . get Value ( ) ; if ( name == null || name . length ( ) == 0 || " class " . equals ( name ) ) { continue ; } if ( desc instanceof Keyed Property Descriptor ) { try { desc = new Array Index Property Descriptor ( bean Class , type ) ; } catch ( Throwable t ) { continue ; else if ( ! bean Class . is Array ( ) && desc . get Read Method ( ) == null ) { continue ; clean Props . add ( desc ) ; properties = clean Props . to Array ( new Property Descriptor [ clean Props . size ( ) ] ) ; sort Property Descriptors ( properties ) ; return properties ;<CODESPLIT>A function that returns an array of all the available properties on a given class . <p > <b > NOTE : < / b > If possible the results of this method should be cached by the caller .<CODESPLIT>1
public synchronized void server Stopping ( ) { ( Trace Component is Tracing ( ) tc is Entry ( ) ) { Tr ( tc , server Stopping , generate progress generate In Progress ) ; } server Is Stopping ; ( int 0 ; 40 && generate In Progress ; i ++ ) { try { Thread . sleep ( 500 ) ; } catch ( Interrupted Exception e ) { } } if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) { Tr . exit ( tc , " server Stopping " ) ; }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
void flatten To Sub Message Buffer ( Byte Buffer ) throws { assert ( _ != ) ; assert ( ! _ . is Empty ( ) ) ; . put ( Volt Message Factory . FRAGMENT _ TASK _ ID ) ; . flatten To Buffer ( ) ; for ( Fragment Data item : _ ) { ( item . _ Dep Id != 1 ) { Input Dep ; } ( item . _ output Dep Id != ) { Output Dep Ids ++ ; } if ( item . m _ fragment Plan != null ) { n Unplanned ++ ; } } buf . put Short ( ( short ) m _ items . size ( ) ) ; buf . put Short ( n Unplanned ) ; buf . put ( m _ is Final ? ( byte ) 1 : ( byte ) 0 ) ; buf . put ( m _ task Type ) ; buf . put ( m _ empty For Restart ? ( byte ) 1 : ( byte ) 0 ) ; if ( m _ proc Name To Load != null ) { buf . put Short ( ( short ) m _ proc Name To Load . length ) ; buf . put ( m _ proc Name To Load ) ; } else { buf . put Short ( ( short ) - 1 ) ; } buf . put ( m _ coordinator Task ? ( byte ) 1 : ( byte ) 0 ) ; buf . put ( m _ n Part Txn ? ( byte ) 1 : ( byte ) 0 ) ; buf . put Long ( m _ restart Timestamp ) ; buf . put Long ( m _ last Sp Unique Id ) ; for ( Fragment Data item : m _ items ) { buf . put ( item . m _ plan Hash ) ; } for ( Fragment Data item : m _ items ) { if ( item . m _ stmt Name == null ) { buf . put Short ( ( short ) - 1 ) ; } else { assert ( item . m _ stmt Name . length <= Short . MAX _ VALUE ) ; buf . put Short ( ( short ) item . m _ stmt Name . length ) ; buf . put ( item . m _ stmt Name ) ; } } for ( Fragment Data item : m _ items ) { buf . put Int ( item . m _ parameter Set . remaining ( ) ) ; buf . put ( item . m _ parameter Set . as Read Only Buffer ( ) ) ; } if ( n Output Dep Ids > 0 ) { for ( Fragment Data item : m _ items ) { buf . put Int ( item . m _ output Dep Id ) ; } } if ( n Input Dep Ids > 0 ) { for ( Fragment Data item : m _ items ) { if ( item . m _ input Dep Id == - 1 ) { buf . put Short ( ( short ) 0 ) ; } else { buf . put Short ( ( short ) 1 ) ; buf . put Int ( item . m _ input Dep Id ) ; if ( m _ procedure Name == null ) { buf . put Short ( ( short ) - 1 ) ; else { assert ( m _ procedure Name . length <= Short . MAX _ VALUE ) ; buf . put Short ( ( short ) m _ procedure Name . length ) ; buf . put ( m _ procedure Name ) ; buf . put Int ( m _ current Batch Index ) ; if ( m _ batch Timeout == Batch Timeout Override Type . NO _ TIMEOUT ) { else { buf . put Int ( m _ batch Timeout ) ; buf . put Short ( ( short ) m _ involved Partitions . size ( ) ) ; for ( int pid : m _ involved Partitions ) { buf . put Int ( pid ) ; if ( m _ initiate Task Buffer != null ) { Byte Buffer dup = m _ initiate Task Buffer . duplicate ( ) ; buf . put Int ( dup . remaining ( ) ) ; buf . put ( dup ) ; else { buf . put Int ( 0 ) ; Fragment Data item = m _ items . get ( index ) ; if ( item . m _ fragment Plan != null ) { buf . put Short ( index ) ; buf . put Int ( item . m _ fragment Plan . length ) ; buf . put ( item . m _ fragment Plan ) ; assert ( item . m _ stmt Text != null ) ; buf . put Int ( item . m _ stmt Text . length ) ; buf . put ( item . m _ stmt Text ) ;<CODESPLIT>/ * Serialization Format [ description : type : byte count ]<CODESPLIT>0
public read Row ( Reader Reader , Error parse Error ) , { check Entity Config ( ) ; String Reader read ( ) ; ( line == null ) { return null ; } else { return process Row ( line , buffered Reader , parse Error , get Line Number ( buffered Reader ) ) ; } }<CODESPLIT>Read in all of the entities in the reader passed in but without the header .<CODESPLIT>0
private int To RTF ( Template Element template Parent , DTM dtm Frag ) throws Transformer { X Path Context xctxt = _ xcontext ; Content Handler rtf Handler = dtm Frag . get Content Handler ( ) ; int Fragment ; To Handler = To XMLSAX Handler ( ) ; . set Content Handler ( rtf Handler ) ; . set Transformer ( this ) ; _ serialization Handler = ; Handler rth = _ serialization Handler ; { rth . start Document ( ) ; rth . flush Pending ( ) ; { execute Child Templates ( template Parent , true ) ; rth . flush Pending ( ) ; result Fragment = dtm Frag . get Document ( ) ; } finally { rth . end Document ( ) ; } } catch ( org . xml . sax . SAX Exception se ) { throw new Transformer Exception ( se ) ; } finally { } return result Fragment ; }<CODESPLIT>Take the contents of a template element process it and convert it to a string .<CODESPLIT>0
public static void encode Length ( Byte Array Output Stream , int ) { . ( _ , encode Length , Object [ { , } ) ; int Count = 0 ; long Length = 0 ; do { Length <<= 8 ; Length ( ) ( & 0 7 f ) ; length >>= 7 ; byte Count ++ ; } while ( length > 0 ) ; do { byte encoded Byte = ( byte ) ( encoded Length & 0 xff ) ; encoded Length >>= 8 ; if ( byte Count != 1 ) { } out . write ( encoded Byte ) ; } while ( -- byte Count > 0 ) ; }<CODESPLIT>/ * Length - bytes are written out in order from most to least significant but are computed most efficiently ( using bit shifts ) from least to most significant . An integer serves as a temporary storage which is then written out in reversed order .<CODESPLIT>1
public static synchronized Ping get Instance For XMPP ) { Ping ping INSTANCES get ) ; ping Manager == null ) { ping Manager = new Ping Manager ( connection ) ; INSTANCES . put ( connection , ping Manager ) ; } return ping Manager ; }<CODESPLIT>Gets the account registration info from the server . @throws XMPPErrorException @throws NoResponseException @throws NotConnectedException @throws InterruptedException<CODESPLIT>0
public T List T dynamic Query ( Query dynamic Query ) { return Layout Persistence . find With Dynamic Query ( dynamic Query ) ; }<CODESPLIT>Returns the number of rows matching the dynamic query .<CODESPLIT>0
public void write ( String , off , ) throws { ( writer ) { writer write ( , off , ) ; } { ensure ( ) ; str Buffer . append ( s . substring ( off , off + len ) ) ; next Char += len ; } }<CODESPLIT>Write a portion of a String .<CODESPLIT>1
public void concat ( trg , , boolean restricted ) Exception { namesystem . concat ( trg , src , restricted ) ; }<CODESPLIT>{<CODESPLIT>0
public Execute Provisioned Product execute Provisioned Product Execute Provisioned Product Request request ) { request before Client Execution ( request ) ; return execute Execute Provisioned Product Service Action ( request ) ; }<CODESPLIT><p > Executes a self - service action against a provisioned product . < / p ><CODESPLIT>1
private get Wrapped Publisher ( Publisher flexible Publisher , Class ) { ( ( flexible Publisher Flexible Publisher ) ) { ( String ( Publisher of '% '. Found '% '" , Flexible Publisher , flexible Publisher get Class ( ) ) ) ; } < Conditional Publisher > conditions = ( ( Flexible Publisher ) flexible Publisher ) . get Publishers ( ) ; for ( Conditional Publisher condition : conditions ) { if ( type . is Instance ( condition . get Publisher ( ) ) ) { return type . cast ( condition . get Publisher ( ) ) ; } } return null ; }<CODESPLIT>Gets the publisher wrapped by the specofoed FlexiblePublisher .<CODESPLIT>1
public Iterable Contact query By Updated Date ( Object , Date Date ) { query By Field ( parent , D Contact Mapper . Field . UPDATEDDATE . get Field Name ( ) , updated Date ) ; }<CODESPLIT>query - by method for field updatedDate<CODESPLIT>1
static boolean is Get Or ( ) { ( get Token ( ) ) { GETTER DEF SETTER DEF ; COMPUTED _ PROP : return node . get Boolean Prop ( Node . COMPUTED _ PROP _ GETTER ) || node . get Boolean Prop ( Node . COMPUTED _ PROP _ SETTER ) ; default : break ; } return false ; }<CODESPLIT>Determines whether a node represents an object literal get or set key ( e . g . key1 in { get key1 () {} set key2 ( a ) {} ) .<CODESPLIT>1
private boolean Ct ( Ct ) { { get ( ) ( get ( get ( ) ) ) ct Field . get Type ( ) . equals ( cp . get ( List . class . get Name ( ) ) ) || ct Field . get Type ( ) . equals ( cp . get ( Set . class . get Name ( ) ) ) ; } catch ( Not Found Exception e ) { e . print Stack Trace ( ) ; return false ; } }<CODESPLIT>Add Method to ConstPool . If method was not in the ConstPool will add and return index otherwise will return index of already existing entry of constpool<CODESPLIT>0
public static void ( File path , String message ) { not Null ( path , message ) ; ( is Readable ( path ) ) { new Illegal Argument Exception ( message ) ; } }<CODESPLIT>FIXME me animal sniffer this is 1 . 6 API only<CODESPLIT>0
public Modify Subscription modify Subscription ( Modify Subscription Request request ) { request Client ( request ) ; return execute Modify Event Subscription ( request ) ; }<CODESPLIT><p > Modifies the replication instance to apply new settings . You can change one or more parameters by specifying these parameters and the new values in the request . < / p > <p > Some settings are applied during the maintenance window . < / p > <p / ><CODESPLIT>0
public java . . List Inventory Deletion get Inventory Deletions ( ) { ( inventory Deletions ) { inventory Deletions . amazonaws . internal . Sdk Internal List < Inventory Deletion Status Item > ( ) ; } return inventory Deletions ; }<CODESPLIT><p > A list of status items for deleted inventory . < / p ><CODESPLIT>0
public static boolean validate Service Name ( Configuration conf , String name Service Id ) { ( nameservice ! nameservice . is Empty ( ) ) { ( name Service Id == ) { . . ( Need to a nameservice id ) ; return false ; } else if ( ! nameservice Ids . contains ( name Service Id ) ) { System . err . println ( " An invalid nameservice id : " + name Service Id ) ; return false ; } } else if ( name Service Id != null ) { System . err . println ( " An invalid nameservice id : " + name Service Id ) ; return false ; } return true ; }<CODESPLIT>Valide if the input service name is valid<CODESPLIT>1
public OUTPUT Instance ( Map String , INPUT Map ) FAILURE { String String ( ) append ( get ( ) get ( ) ) append ( ". new Instance ( Map < String , Input >) is unsupported ." ) ; throw new Unsupported Operation Exception ( builder . to String ( ) ) ; }<CODESPLIT><p > <b > Unsupported< / b > . Override to provide an implementation . < / p ><CODESPLIT>1
long get Proposed ( ) throws { { long File read Long From File ( f Proposed ) ; ; } ( File Not Found ) { . debug ( " File not exist , initialize acknowledged epoch to - 1 " ) ; return - 1 ; } catch ( IO Exception e ) { LOG . error ( " IO Exception encountered when access acknowledged epoch " ) ; throw e ; } }<CODESPLIT>Gets the last proposed epoch .<CODESPLIT>1
public Parameterizable Request String , Object , delegation ( ) { Url Url parse ( get Url ( ) ) ( ) add Path ( DELEGATION ) build ( ) ; < String , Object > parameters = Parameter Builder . new Builder ( ) . set Client Id ( get Client Id ( ) ) . set Grant Type ( Parameter Builder . GRANT _ TYPE _ JWT ) . as Dictionary ( ) ; return factory . raw POST ( url , client , gson , auth Error Builder ) . add Parameters ( parameters ) ; }<CODESPLIT>Performs a custom <a href = https : // auth0 . com / docs / api / authentication#delegation > delegation< / a > request that will yield a delegation token . Example usage : <pre > { @code client . delegation () . addParameter ( api_type firebase ) . start ( new BaseCallback<Map<String Object >> () { { @literal } Override public void onSuccess ( Map<String Object > payload ) {}<CODESPLIT>1
public void Token ( ) throws Auth , Auth Problem { clean Error ( ) ; ( Token Token ) { } Onelogin URL Client http Client Onelogin URL Client ( ) ; Auth Client Request request Auth Client Request Location ( settings get URL ( TOKEN REFRESH URL ) ) build Body ( ) ; Map String , String headers Hash Map < String , String > ( ) ; headers . put ( O Auth . Header Type . CONTENT _ TYPE , O Auth . Content Type . JSON ) ; headers . put ( " User - Agent " , this . user Agent ) ; Map < String , Object > params = new Hash Map < String , Object > ( ) ; params . put ( " grant _ type " , Grant Type . REFRESH _ TOKEN ) ; params . put ( " access _ token " , access Token ) ; params . put ( " refresh _ token " , refresh Token ) ; String body = JSON Utils . build JSON ( params ) ; request . set Body ( body ) ; update Tokens ( http Client , request , headers ) ; }<CODESPLIT>Refreshing tokens provides a new set of access and refresh tokens .<CODESPLIT>1
public void Contact To ( ) { Reference Field fld Contact ( Reference Field ) get Record ( ) get Field ( CONTACT ) ; String str Contact Type Param = fld Contact Type . get Field Name ( ) ; this . sync Record To Main Field ( fld Contact Type , null , str Contact Type Param ) ; }<CODESPLIT>Read the current file in the header record given the current detail record .<CODESPLIT>0
@ ( ) public Chrono Zoned Date Time International Fixed Date zoned Date Time ( Temporal temporal ) { ( Chrono Zoned Date Time International Fixed Date > ) super . zoned Date Time ( temporal ) ; }<CODESPLIT>A property tied to the map updated when the idle state event is fired .<CODESPLIT>0
private Network 1 ( File [ ] networks ) { ( PHASE 2 _ STAGE 1 _ HDR , 1 , NUM _ PHASES ) ; int netct = networks . ; String Builder bldr = String Builder ( ) ; bldr . append ( Merging ) ; bldr . append ( netct ) ; bldr . append ( network ) ; ( netct 1 ) { bldr . append ( ) ; } Output ( bldr . to String ( ) ) ; long 1 = current Time Millis ( ) ; Collection Network Descriptor nds = sized Array List ( netct ) ; for ( File network : networks ) { final String root = network . get Absolute Path ( ) ; final String net Path = as Path ( root , PROTO _ NETWORK _ FILENAME ) ; final File network Bin = new File ( net Path ) ; nds . add ( new Binary Proto Network Descriptor ( network Bin ) ) ; } Proto Network ret = p 2 . stage 1 Merger ( nds ) ; new File ( artifact Path . get Absolute Path ( ) + "/ merged " ) . mkdirs ( ) ; if ( with Debug ( ) ) { try { Text Proto Network Externalizer text Externalizer = new Text Proto Network Externalizer ( ) ; } catch ( Proto Network Error e ) { error ( " Could not write out equivalenced proto network ." ) ; } long t 2 = current Time Millis ( ) ; bldr . set Length ( 0 ) ; mark Time ( bldr , t 1 , t 2 ) ; mark End Stage ( bldr ) ; stage Output ( bldr . to String ( ) ) ; return ret ;<CODESPLIT>Stage one merger of networks returning the merged proto - network .<CODESPLIT>1
public Streaming Result Hls Streaming ( String Id , boolean ) Content Store { Streaming Parameters task Streaming Parameters ( ) ; task set Id ( Id ) ; task . set Secure ( secure ) ; return Enable Streaming Task Result . deserialize ( content Store . perform Task ( Storage Task Constants . ENABLE _ HLS _ TASK _ NAME , task Params . serialize ( ) ) ) ; }<CODESPLIT>{<CODESPLIT>1
public static Map . Entry String , Map String , get Bars Command ( ) { return Map . Entry ( GET _ SYSTEM _ BARS , Immutable Map . of ( ) ) ; }<CODESPLIT>This method forms a { @link Map } of parameters for the getting of a network connection value .<CODESPLIT>0
public Response Query ( String , Input Stream , String , Http http ) { Jax get Instance ( ) ; Document Schema Checker ( " post " ) . check ( input ) ; final Map < Query Parameter , String > param = get Parameters ( doc , impl ) ; final Resource Path path = new Resource Path ( resource , param , http Headers ) ; return create Response ( impl , path ) ; }<CODESPLIT>This method will be called when a HTTP client sends a POST request to an existing resource with application / query + xml as Content - Type .<CODESPLIT>1
public boolean has Value ( index ) { ( ) { index ( ( ) base Collection ) . size ( ) ; } else if ( m _ base Collection instanceof Sorted Map ) { return index < ( ( Sorted Map < ? , ? > ) m _ base Collection ) . size ( ) ; } return false ; }<CODESPLIT>Prepares this widget dialog parameter to be committed . <p ><CODESPLIT>0
public void marshall ( Direct Connect Gateway Associations Request Direct Connect Gateway Associations Request , Marshaller Marshaller ) { ( Direct Connect Gateway Associations Request ) { Sdk Client ( argument passed to marshall (...)" ) ; } { Marshaller marshall ( Direct Connect Gateway Associations Request get Association Id ( ) , ASSOCIATIONID BINDING ) ; Marshaller . marshall ( describe Direct Connect Gateway Associations Request . get Associated Gateway Id ( ) , ASSOCIATEDGATEWAYID _ BINDING ) ; protocol Marshaller . marshall ( describe Direct Connect Gateway Associations Request . get Direct Connect Gateway Id ( ) , DIRECTCONNECTGATEWAYID _ BINDING ) ; protocol Marshaller . marshall ( describe Direct Connect Gateway Associations Request . get Max Results ( ) , MAXRESULTS _ BINDING ) ; protocol Marshaller . marshall ( describe Direct Connect Gateway Associations Request . get Next Token ( ) , NEXTTOKEN _ BINDING ) ; protocol Marshaller . marshall ( describe Direct Connect Gateway Associations Request . get Virtual Gateway Id ( ) , VIRTUALGATEWAYID _ BINDING ) ; } catch ( Exception e ) { } }<CODESPLIT><p > The sources for the applications ( up to 10 ) . If you specify scaling plan names you cannot specify application sources . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setApplicationSources ( java . util . Collection ) } or { @link #withApplicationSources ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
public Object Eval ( String arg ) { { return script . ( (" arg ")" ) ; } ( Script ) { throw new Bundling Process Exception ( " Error while evaluating a script " , e ) ; } }<CODESPLIT>Returns the JSON object from a string<CODESPLIT>0
public Map < Server Group , EV Cache Server Group Config > discover Instances ( String app Name ) throws IO Exception { final String property Name = app Name + "- NODES " ; ( log . is Debug Enabled ( ) ) log . debug ( " List of Nodes = " + node List String ) ; ( node List String != null && node List String . length ( ) > 0 ) return bootstrap From System Property ( node List String ) ; if ( env != null && region != null ) return bootstrap From Eureka ( app Name ) ; return Collections . < Server Group , EV Cache Server Group Config > empty Map ( ) ; }<CODESPLIT>Netflix specific impl so we can load from eureka .<CODESPLIT>0
private boolean distinguished Equals ( dsn , dsn ) { 500 Principal ( dsn 1 ) . equals ( new X 500 Principal ( dsn 2 ) ) ; }<CODESPLIT>Compare two DSN<CODESPLIT>1
public static Bloom Filter deserialize ( Input Stream ) throws { ( == ) { ( Input stream is ) ; } { Data Input Stream data Input Stream = Data Input Stream ( ) ; int Hash Func = data Input Stream . read Byte ( ) ; int bitset Array Len = data Input Stream . read Int ( ) ; long [ ] data = new long [ bitset Array Len ] ; for ( int i = 0 ; i < bitset Array Len ; i ++ ) { data [ i ] = data Input Stream . read Long ( ) ; } return new Bloom K Filter ( data , num Hash Func ) ; } catch ( Runtime Exception e ) { io . init Cause ( e ) ; throw io ; } }<CODESPLIT>Deserialize a bloom filter Read a byte stream which was written by { @linkplain #serialize ( OutputStream BloomKFilter ) } into a { @code BloomKFilter }<CODESPLIT>1
public void set Restore Last Valid ( boolean restore Last Valid ) { ( has ) ( Last valid text restore filed has ) ; this restore Last Valid restore Last Valid ; ( restore Last Valid ) { ( restore Focus Listener == null ) restore Focus Listener = new Last Valid Focus Listener ( ) ; add Listener ( restore Focus Listener ) ; } else { remove Listener ( restore Focus Listener ) ; } }<CODESPLIT>Adds vertical or horizontal {<CODESPLIT>0
public static Long Binding Exact Long Value ) { create Long Binding ) -> Math . decrement Exact ( a . get ( ) ) , a ) ; }<CODESPLIT>Binding for { @link java . lang . Math#decrementExact ( long ) }<CODESPLIT>1
public static String dgst ( Input Stream is , ) throws { check Not Null ( is ) ; dgst Bytes = dgst ( is , ) ; Base . base 16 ( ) . encode ( dgst Bytes ) ; }<CODESPLIT>Calculates digest and returns the value as a hex string .<CODESPLIT>1
private void write ( Target Type the Target , Value Tm the Value Tm , File the Output Directory , String the Package Base ) throws { ( ! the Output Directory . ( ) ) { the Output Directory . ( ) ; } ( ! the Output Directory . is Directory ( ) ) { } String value Name = the Value Tm . get Class Name ( ) ; String = Filename Prefix ; String = Filename Suffix ; ( the Target == Target Type . SOURCE ) { ( ! . With ( ". java ) ) { += ". java ; } } String file Name = value Name ; File f = File ( the Output Directory , file Name ) ; . debug ( " Writing file : {}" , f . get Absolute Path ( ) ) ; Velocity Context ctx = new Velocity Context ( ) ; Input Stream template Is = null ; ctx . put ( " value Set " , the Value Set Tm ) ; ctx . put ( " package Base " , the Package Base ) ; ctx . put ( " esc " , new Escape Tool ( ) ) ; Velocity Engine v = Velocity Helper . configure Velocity Engine ( my Template File , my Velocity Path , my Velocity Properties ) ; if ( my Template File != null ) { template Is = new File Input Stream ( my Template File ) ; } else { String template Name = my Template ; if ( null == template Name ) { } template Is = this . get Class ( ) . get Resource As Stream ( template Name ) ; } Input Stream Reader template Reader = new Input Stream Reader ( template Is , " UTF - 8 " ) ; v . evaluate ( ctx , w , "" , template Reader ) ; w . close ( ) ; }<CODESPLIT>}<CODESPLIT>1
public void ( issue ) { ( issue ( ) ( ) Input File ) { Input File Input File ( Input File ) issue ( ) . input Component ( ) ; if ( should Skip Storage ( default Input File ) ) { return ; } default Input File . set Published ( true ) ; } module Issues . init And Add Issue ( issue ) ; }<CODESPLIT>Thread safe assuming that each issues for each file are only written once .<CODESPLIT>1
public Class get Class From Collection ( String ) { Class mcs = mapped By Collection . get ( ) ; ( mcs == mcs . is Empty ( ) ) { Mapping ( format ( The '% is not mapped to a java class ." , ) ) ; } ( mcs . size ( ) ) { ( LOG . is Info Enabled ( ) ) { LOG . info ( format ( " Found more than one class mapped to collection '% s '% s " , collection , mcs ) ) ; } return mcs . iterator ( ) . next ( ) . get Clazz ( ) ;<CODESPLIT>Converts a DBObject back to a type - safe java object ( POJO )<CODESPLIT>0
private Token eventually Match ( Token kind ) { check Not Eof ( ) ; Token get ( index ) ; ( kind kind ) { null ; } else { index = index + 1 ; return token ; } }<CODESPLIT>Match a given sequence of tokens whilst moving passed any whitespace encountered inbetween . In the case that meet the end of the stream or we don t match the expected tokens in the expected order then an error is thrown .<CODESPLIT>0
public static Waehrung of ( ) { ( Waehrung ) { ( Waehrung ) currency Unit ; } else { return of ( currency Unit . get Currency Code ( ) ) ; } }<CODESPLIT>Gibt die entsprechende Currency als Waehrung zurueck .<CODESPLIT>1
private Content Param ( boolean , Param Tag param , String , String , Taglet writer , String Documented ) { Content writer get Output Instance ( ) ; ( param ) { ( ; param ; ) { String param pt . parameter Name ( ) : "<" + pt . parameter Name ( ) + ">" ; if ( ! rank Map . contains Key ( pt . parameter Name ( ) ) ) { writer . get Msg Retriever ( ) . warning ( pt . position ( ) , is Non Type Params ? " doclet . Parameters _ warn " : " doclet . Type _ Parameters _ warn " , param Name ) ; String rank = rank Map . get ( pt . parameter Name ( ) ) ; if ( rank != null && already Documented . contains ( rank ) ) { writer . get Msg Retriever ( ) . warning ( pt . position ( ) , is Non Type Params ? " doclet . Parameters _ dup _ warn " : " doclet . Type _ Parameters _ dup _ warn " , param Name ) ; result . add Content ( process Param Tag ( is Non Type Params , writer , pt , pt . parameter Name ( ) , already Documented . size ( ) == 0 ) ) ; already Documented . add ( rank ) ; return result ;<CODESPLIT>Checks the current system time against the time limit throwing an InterruptedException if the time is up .<CODESPLIT>0
public void set Versions ( java Collection String versions ) { ( versions ) { this versions ; return ; } this . versions = new com . amazonaws . internal . Sdk Internal List < String > ( versions ) ; }<CODESPLIT><p > The version numbers of one or more launch template versions to delete . < / p ><CODESPLIT>0
private static Script Runner get Runner ( ) { ( Runner get ( ) ) { Script Runner Script Runner create Runner ( ) ; { load Script ( CSL get Resource ( " dump . js " ) ) ; runner . load Script ( CSL . class . get Resource ( " citeproc . js " ) ) ; runner . load Script ( CSL . class . get Resource ( " formats . js " ) ) ; runner . load Script ( CSL . class . get Resource ( " loadsys . js " ) ) ; } catch ( Script Runner Exception e ) { } shared Runner . set ( runner ) ; } return shared Runner . get ( ) ; }<CODESPLIT>Calculates a list of available citation locales<CODESPLIT>0
public Print Query add ( Select select Bldr , ... ) throws E Faps { List msgphrases = Array List ( ) ; ( final UUID phrase UUID : _ msg Phrase ) { msgphrases . add ( Msg Phrase . get ( phrase UUID ) ) ; } return add Msg Phrase ( _ select Bldr , msgphrases . to Array ( new Msg Phrase [ msgphrases . size ( ) ] ) ) ; }<CODESPLIT>Adds the msg phrase .<CODESPLIT>1
private extract ( Soy ) { attributes ( ) ; Matcher MESSAGE ATTRIBUTE PATTERN . matcher ( msg . get Desc ( ) ) ; while ( matcher . find ( ) ) { attributes . append ( matcher . group ( ) ) ; } return attributes . to String ( ) ; }<CODESPLIT>Extracts message attributes from the message description . Returns an empty {<CODESPLIT>1
Volt Table execute Slow Homogeneous Batch ( List Queued , boolean ) { Mp Transaction txn = ( Mp Transaction ) txn ; assert ( txn ) ; ( int = 0 ; . size ( ) ; ) { Queued queued = . get ( ) ; assert ( queued . stmt ) ; int collector Output Dep Id = txn . get Next Id ( ) ; Byte Buffer param = ; { param = Byte Buffer . allocate ( queued . params . get Serialized ( ) ) ; queued . params . flatten To Buffer ( param ) ; } ( ) { ( Error serializing parameters statement : " + queued SQL . stmt . get Text ( ) + " with params : " + queued SQL . params . to JSON String ( ) , e ) ; } assert ( param Buf != null ) ; param Buf . flip ( ) ; state . add Statement ( i , queued SQL . stmt , param Buf , m _ site ) ; } m _ txn State . setup Procedure Resume ( state . m _ deps To Resume ) ; for ( int i = 0 ; i < state . m _ deps For Local Task . length ; i ++ ) { if ( state . m _ deps For Local Task [ i ] < 0 ) { continue ; } state . m _ local Task . set Input Dep Id ( i , state . m _ deps For Local Task [ i ] ) ; } m _ txn State . create Local Fragment Work ( state . m _ local Task , state . m _ local Frags Are Non Transactional && final Task ) ; if ( ! state . m _ distributed Task . is Empty ( ) ) { state . m _ distributed Task . set Batch ( m _ batch Index ) ; m _ txn State . create All Participating Fragment Work ( state . m _ distributed Task ) ; } Map < Integer , List < Volt Table > > map Results = m _ site . recursable Run ( m _ txn State ) ; assert ( map Results != null ) ; assert ( state . m _ deps To Resume != null ) ; assert ( state . m _ deps To Resume . length == batch . size ( ) ) ; for ( int i = 0 ; i < batch . size ( ) ; i ++ ) { List < Volt Table > matching Tables For Id = map Results . get ( state . m _ deps To Resume [ i ] ) ; assert ( matching Tables For Id != null ) ; assert ( matching Tables For Id . size ( ) == 1 ) ; state . m _ results [ i ] = matching Tables For Id . get ( 0 ) ; } return state . m _ results ; }<CODESPLIT>/ * Execute a batch of homogeneous queries i . e . all reads or all writes .<CODESPLIT>1
public Grpc Server start ( ) throws { Retry . retry ( Starting RPC server , ( ) -> Server . start ( ) , Exponential Backoff Retry ( , 500 , 5 ) ) ; = true ; return this ; }<CODESPLIT>Start serving .<CODESPLIT>1
public close ( ) { chk ( ) ; ( vec Appendable Vec ) ( ( Appendable Vec ) _ vec ) . close Chunk ( this ) ; return chk ; }<CODESPLIT>Slow - path append data<CODESPLIT>0
public static , Map , any Entry ( < ? super Map . Entry < K , V > > p ) { return for Entries ( Predicates . < Map . Entry < K , V > > any ( p ) ) ; }<CODESPLIT>Returns a predicate that evaluates to {<CODESPLIT>0
public static , U Bi , U bi ( Bi Predicate < T , U > predicate ) { return bi Predicate ( predicate , THROWABLE _ TO _ RUNTIME _ EXCEPTION ) ; }<CODESPLIT>Wrap a {<CODESPLIT>0
private Fu By Janto ) { Tile janto Tile get Janto ) get Tile ) ; ; janto Tile general Situation . get Bakaze ( ) ) { tmp += 2 ; } if ( janto Tile == personal Situation . get Jikaze ( ) ) { tmp += 2 ; } if ( janto Tile . get Type ( ) == SANGEN ) { tmp += 2 ; return tmp ;<CODESPLIT>待ちの種類による可符<CODESPLIT>0
public To Instance add To Instance To DB Instance Request request ) { request = before Client Execution ( request ) ; return execute Add Role To DB Instance ( request ) ; }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public static Object get Value ( , index ) { not ( , must not ) ; Ldap ldap Or Construct Ldap From ( ) ; Rdn rdn ldap get Rdn ( index ) ; ( rdn ( ) 1 ) { LOGGER . warn ( " Rdn at position " + index + " of dn '" + name + "' is multi - value - returned value is not to be trusted . " + " Consider using name - based get Value method instead " ) ; } return rdn . get Value ( ) ; }<CODESPLIT>Get the value of the Rdn with the requested key in the supplied Name as a String .<CODESPLIT>0
