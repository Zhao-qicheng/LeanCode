public Input Stream get As Stream ( String Name ) { Input Stream is ; String Path get Real Path ( Name ) ; { is File Input Stream ( Path ) ; } ( File Not Found ) { ( The " + real Path + " has not been found " ) ; } } if ( is == null ) { is = super . get Resource As Stream ( real Path ) ; } return is ;<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>0
public static void register ( Binder binder > annotation ) { register Key ( binder , Key . get ( clazz , annotation ) ) ; }<CODESPLIT>Registers a class / annotation combination to instantiate eagerly . Classes mentioned here will be pulled out of the injector with an injector . getInstance () call when the lifecycle is created .<CODESPLIT>1
public static br restoreconfig restoreconfig nitro br restoreconfig ) { ) array ) ; length == 1 ) return ( ( br _ restoreconfig [ ] ) resources [ 0 ] . perform _ operation ( client , " restoreconfig " ) ) ; return ( ( br _ restoreconfig [ ] ) perform _ operation _ bulk _ request ( client , resources , " restoreconfig " ) ) ; }<CODESPLIT><pre > Use this operation to restore config from file on Repeater Instances . < / pre ><CODESPLIT>0
public Page find Page Parameter ( Object param ) { Page page = ; ( param Page ) { } else ( param Map ) { for ( Object o : m . values ( ) ) { if ( o instanceof Page ) { break ; } } } if ( page != null ) { PAGE _ THREAD _ LOCAL . set ( page ) ; } return page ; }<CODESPLIT>从传递的参数中找Page对象，并返回<CODESPLIT>1
public static Input Stream get As Stream ( , String fn ) { Input Stream get As Stream ( fn ) ; ( ) { ( \"" + fn + "\" relative to " + clazz + " not found ." ) ; } return unpack Stream ( stream , fn ) ; }<CODESPLIT>Get an input stream to read the raw contents of the given resource remember to close it : )<CODESPLIT>1
public static Supplier compose ( Function Supplier ) { precondition ( " cannot compose supplier with a null function " ) ; dbc . precondition ( g != null , " cannot compose function with a null supplier " ) ; return ( ) -> f . apply ( g . get ( ) ) ; }<CODESPLIT>Composes a function with a ternary function .<CODESPLIT>0
public void get Chars ( Begin , , dst , dst Begin ) { dst Begin ; ( Begin ; src End ; i ++ ) { dst [ dest Index ++ ] = m _ str . char At ( i ) ; } }<CODESPLIT>Copies characters from this string into the destination character array .<CODESPLIT>1
public String get ( , String , String , String parameters , boolean include View Params ) { return get Action URL ( context , view Id ) ; }<CODESPLIT><p class = changed_added_2_0 > Return a JSF action URL derived from the <code > viewId< / code > argument that is suitable to be used by the { @link NavigationHandler } to issue a redirect request to the URL using a NonFaces request . Compliant implementations must implement this method as specified in section JSF . 7 . 6 . 2 . The default implementation simply calls through to { @link #getActionURL } passing the arguments <code > context< / code > and <code > viewId< / code > . < / p ><CODESPLIT>1
public Class get ( ) { ( Class ) { Class ( Class ) get E Package ( Store Package . e NS _ URI ) . get E Classifiers ( ) . get ( 45 ) ; } return server Info E Class ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>0
public void add Maybe ) { synchronized handlers ) { get ) ) { Stage == null || stage . compare To ( curr Stage ) < 1 ) { handler . start ( ) ; } handlers . get ( stage ) . add ( handler ) ;<CODESPLIT>This will materialize the entire sequence in memory . Use at your own risk .<CODESPLIT>0
public static Clever Tap API instance With @ Clever Tap Instance ) { ) { ; } ) { = new Hash Map <> ( ) ; } Clever Tap API instance = instances . get ( config . get Account Id ( ) ) ; if ( instance == null ) { instance = new Clever Tap API ( context , config ) ; instances . put ( config . get Account Id ( ) , instance ) ; } return instance ; }<CODESPLIT>Lifecycle<CODESPLIT>0
public get Current ) get Current ) ; ) elem . get XSL Token ( ) != Constants . ELEMNAME _ TEMPLATE ) ) { elem = elem . get Parent Elem ( ) ; } return ( Elem Template ) elem ; }<CODESPLIT>This method retrieves the xsl : template that is in effect which may be a matched template or a named template .<CODESPLIT>1
public static boolean ( I Atom Container , Document ) throws Smiles , CDK { List nl = . get Elements By Tag Name ( replace set ) ; Smiles = Smiles ( . get ( ) ) ; boolean = false ; ( int = 0 ; nl . get Length ( ) ; ) { Element child = ( Element ) nl . item ( ) ; List replaces = child . get Elements By Tag Name ( replace " ) ; Node List replacement = child . get Elements By Tag Name ( " replacement " ) ; I Atom Container replacement Structure = sp . parse Smiles ( replacementstring ) ; for ( int k = 0 ; k < replaces . get Length ( ) ; k ++ ) { Element replace = ( Element ) replaces . item ( k ) ; String replacestring = replace . get First Child ( ) . get Node Value ( ) ; } I Atom Container replace Structure = sp . parse Smiles ( replacestring ) ; List < R Map > l = null ; Universal Isomorphism Tester universal Isomorphism Tester = new Universal Isomorphism Tester ( ) ; while ( ( l = universal Isomorphism Tester . get Subgraph Map ( ac , replace Structure ) ) != null ) { Iterator < R Map > bondit = l . iterator ( ) ; while ( bondit . has Next ( ) ) { R Map rmap = bondit . next ( ) ; I Bond acbond = ac . get Bond ( rmap . get Id 1 ( ) ) ; I Bond replacebond = replacement Structure . get Bond ( rmap . get Id 2 ( ) ) ; acbond . set Order ( replacebond . get Order ( ) ) ; change = true ; } Iterator < R Map > atomit = l 2 . iterator ( ) ; while ( atomit . has Next ( ) ) { R Map rmap = atomit . next ( ) ; I Atom acatom = ac . get Atom ( rmap . get Id 1 ( ) ) ; I Atom replaceatom = replacement Structure . get Atom ( rmap . get Id 2 ( ) ) ; acatom . set Formal Charge ( replaceatom . get Formal Charge ( ) ) ; change = true ; } return ( change ) ;<CODESPLIT>The method takes an XML files like the following : <br > &lt ; replace - set&gt ; <br > &lt ; replace&gt ; O = N = O&lt ; / replace&gt ; <br > &lt ; replacement&gt ; [ O - ] [ N + ] = O&lt ; / replacement&gt ; <br > &lt ; / replace - set&gt ; <br > All parts in ac which are the same as replace will be changed according to replacement . Currently the following changes are done : BondOrder FormalCharge . For detection of fragments like replace we rely on UniversalIsomorphismTester . doc may contain several replace - sets and a replace - set may contain several replace fragments which will all be normalized according to replacement .<CODESPLIT>1
protected void write Tracee To ( ) { ( backend Empty ( ) backend get ( ) Process ( Async Dispatch ) ) { , backend get ( ) ( backend copy To Map ( ) , Async Dispatch ) ; final String context As String = http Header Serialization . render ( filtered Context ) ; message . set String Property ( Tracee Constants . TPIC _ HEADER , context As String ) ; } }<CODESPLIT>Writes the current TraceeContext to the given javaee message . This method is idempotent .<CODESPLIT>1
public void product ( Int Long Vector ) { ( ; ; ) { i + start ] *= other . get ( i ) ; } }<CODESPLIT>/ * This method is used to get PHSFellowshipSupplemental12 XMLObject and set the data to it from DevelopmentProposal data .<CODESPLIT>0
public static Signature Filter build Signature Filter ( Resource Resource Location ) throws { ( ! Resource . Resource Exist ( Resource Location ) ) { . ( Resource [{}] cannot located , Resource Location ) ; return ; } key Provider List = Array List Key Provider ( ) ; key Provider List . add ( RSA Key Value Provider ( ) ) ; key Provider List . add ( DSA Key Value Provider ( ) ) ; key Provider List . add ( DER Encoded Key Value Provider ( ) ) ; key Provider List . add ( X 509 Data Provider ( ) ) ; LOGGER . debug ( " Attempting to resolve credentials from [{}]" , signature Resource Location ) ; val credential = build Credential For Metadata Signature Validation ( signature Resource Location ) ; LOGGER . info ( " Successfully resolved credentials from [{}]" , signature Resource Location ) ; val resolver = new Static Credential Resolver ( credential ) ; val trust Engine = new Explicit Key Signature Trust Engine ( resolver , key Info Resolver ) ; LOGGER . debug ( " Adding signature validation filter based on the configured trust engine " ) ; val signature Validation Filter = new Signature Validation Filter ( trust Engine ) ; LOGGER . debug ( " Added metadata Signature Validation Filter with signature from [{}]" , signature Resource Location ) ; return signature Validation Filter ; }<CODESPLIT>Build signature validation filter if needed .<CODESPLIT>1
public static URL make URL ( String specification ) URL { ( retrieving URL specification '{}'" , specification ) ; ( specification With ( :" ) ) { trace ( " URL is of type ' classpath '" ) ; return new URL ( null , specification , new Class Path URL Stream Handler ( ) ) ; } return new URL ( specification ) ; }<CODESPLIT>Returns an URL object for the given URL specification .<CODESPLIT>1
public void ( Throwable ) { ( ( LEVEL DEBUG ) ) { log ( LOG _ LEVEL _ DEBUG , message , t ) ; } }<CODESPLIT><p > Log a message with debug log level . < / p ><CODESPLIT>1
protected String Locale ( Locale ) { ( Locale ) { ; } String language get ( ) ; String get Country ( ) ; String variant . get Variant ( ) ; if ( language == "" && country == "" && variant == "" ) { return "" ; } String Builder sb = new String Builder ( ) ; if ( variant != "" ) { } else if ( country != "" ) { sb . append ( language ) . append ( ' ' ) . append ( country ) ; } else { sb . append ( language ) ; } return sb . to String ( ) ; }<CODESPLIT>Convert locale to string with language_country [ _variant ]<CODESPLIT>1
public Facet with Facet Attribute attributes ) { attributes ) { set < Facet Attribute > ( attributes . length ) ) ; } for ( Facet Attribute ele : attributes ) { this . attributes . add ( ele ) ; } return this ; }<CODESPLIT><p > Associates an Identity and Access Management ( IAM ) role from an Neptune DB cluster . < / p ><CODESPLIT>0
public Autofit add On Text Change ( On Text Change listener ) { ( ) { On Text Size Change Listener > ( ) ; } m Listeners . add ( listener ) ; return this ; }<CODESPLIT>Adds an {<CODESPLIT>1
public void merge Vertices ( vertex , Graph , Combinator combinator , Graph Toolkit Graph , , toolkit ) { ( vertex ( ) <= ) { ; } ( ) ; ( Iterator < Edge Type > i = g . edge Iterator ( ) ; i . has Next ( ) ; ) { Edge Type e = i . next ( ) ; edge Set . add ( e ) ; } Vertex Type composite Vertex = combinator . combine Vertices ( vertex Set ) ; for ( Edge Type e : edge Set ) { Vertex Type source = vertex Set . contains ( e . get Source ( ) ) ? composite Vertex : e . get Source ( ) ; Vertex Type target = vertex Set . contains ( e . get Target ( ) ) ? composite Vertex : e . get Target ( ) ; continue ; } if ( g . lookup Edge ( source , target ) != null ) { continue ; } Edge Type composite Edge = g . create Edge ( source , target ) ; toolkit . copy Edge ( e , composite Edge ) ; } for ( Vertex Type a Vertex Set : vertex Set ) { g . remove Vertex ( a Vertex Set ) ; } }<CODESPLIT>Resolve an annotation into AnnotationValues representing any type qualifier ( s ) the annotation resolves to . Detects annotations which are directly marked as TypeQualifier annotations and also resolves the use of TypeQualifierNickname annotations .<CODESPLIT>0
public void visit ( ) throws { ( Ast Function ) { Method ; ( fn ) { fn resolve Function ( func get Prefix ( ) , func get Name ( ) ) ; } ( func get Prefix ( ) ( ) ) { var Mapper . resolve Variable ( func Node . get Local Name ( ) ) ; return ; } if ( this . fn Mapper == null ) { throw new EL Exception ( Message Factory . get ( " error . fn Mapper . null " ) ) ; } if ( m == null ) { throw new EL Exception ( Message Factory . get ( " error . fn Mapper . method " , func Node . get Output Name ( ) ) ) ; } int method Parameter Count = m . get Parameter Types ( ) . length ; int input Parameter Count = node . jjt Get Child ( 0 ) . jjt Get Num Children ( ) ; if ( m . is Var Args ( ) && input Parameter Count < method Parameter Count - 1 || ! m . is Var Args ( ) && input Parameter Count != method Parameter Count ) { } } else if ( node instanceof Ast Identifier && this . var Mapper != null ) { String variable = ( ( Ast Identifier ) node ) . get Image ( ) ; this . var Mapper . resolve Variable ( variable ) ; } }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public get Details Async team ) get Details With Async team ) map new Func 1 < Service Response < Job > , Job > ( ) { @ Override public Job call ( Service Response < Job > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Get the Job Details for a Job Id .<CODESPLIT>0
private void check Indices ( , ) { ( >= ) Out Of ( + row ) ; else if ( col < 0 || col >= cols ) throw new Array Index Out Of Bounds Exception ( " column : " + col ) ; }<CODESPLIT>Check that the indices of a requested cell are within bounds .<CODESPLIT>1
private void create Parent Child Relationships ( , Map String , Account description Map , Map String , Array List String seq Map ) throws { Array List String Id Array List String ( ) ; Id add ( Account ACCOUNT ) ; ( Id ( ) ) { String Id Id get ( ) ; Account Account description Map get ( Id ) ; parent Id Stack . remove ( 0 ) ; if ( parent Id . compare To ( Account . ROOT _ ACCOUNT _ URI ) != 0 ) { if ( parent Account != null ) { if ( db . find Account By Id ( parent Id ) == null ) { Account parent Parent Account = db . find Parent ( parent Account ) ; if ( parent Parent Account == null ) { logger . warning ( " Seq Node [" + parent Id + "] does not have a parent , will be dropped " ) ; parent Account = null ; } } } else { } } else { parent Account = db . get Root Account ( ) ; } if ( parent Account != null ) { for ( String child Id : seq Map . get ( parent Id ) ) { Account child Account = description Map . get ( child Id ) ; if ( child Account != null ) { if ( ! parent Account . has Child ( child Account ) ) { parent Account . get Children ( ) . add ( child Account ) ; if ( seq Map . contains Key ( child Account . get Id ( ) ) ) { parent Id Stack . add ( child Id ) ; child Account . set Is Folder ( true ) ; } } else { } } else { logger . warning ( " Cannot find RDF : Description for '" + child Id + "', it will be dropped " ) ; } } } } }<CODESPLIT><p > Specifies the type of the array components so that the adequate array functions can be offered . < / p ><CODESPLIT>0
private Decimal Format get Number ( Transformer transformer , int context Node ) throws Transformer { Locale = ( Locale ) get Locale ( transformer , context Node ) . clone ( ) ; Decimal Format = ; ( ( Group Sep Value != ) ( ! _ grouping _ avt . is ( ) ) ( Group Sep Value . ( ) != 1 ) ) { transformer . get ( ) . ( this , XSLT Error Resources . WG _ ILLEGAL _ ATTRIBUTE _ VALUE , Object [ ] { . ATTRNAME _ NAME , _ grouping _ avt . get Name ( ) } ) ; } ( ( != digit Group Sep Value ) && ( null != n Digits Per Group Value ) && ( digit Group Sep Value . length ( ) > 0 ) ) { try { formatter = ( Decimal Format ) Number Format . get Number Instance ( locale ) ; formatter . set Grouping Size ( Integer . value Of ( n Digits Per Group Value ) . int Value ( ) ) ; Decimal Format Symbols symbols = formatter . get Decimal Format Symbols ( ) ; symbols . set Grouping Separator ( digit Group Sep Value . char At ( 0 ) ) ; formatter . set Decimal Format Symbols ( symbols ) ; formatter . set Grouping Used ( true ) ; } catch ( Number Format Exception ex ) { formatter . set Grouping Used ( false ) ; } } return formatter ; }<CODESPLIT>Get the number formatter to be used the format the numbers<CODESPLIT>1
public static Commerce Template Models Commerce Template Soap Models ) { Models ) { ; Commerce Template models Array List < Commerce Notification Template > ( soap Models . length ) ; for ( Commerce Notification Template Soap soap Model : soap Models ) { models . add ( to Model ( soap Model ) ) ; return models ;<CODESPLIT>Converts the soap model instances into normal model instances .<CODESPLIT>1
public static Double Double ( value ) { ( value ) ; ( value Date ) ( double ) ( ( Date ) value ) get ( ) ; ( value ) ( double ) ( ( ) value ) ( ) ; ( value ) return ( double ) ( ( int ) value ) ; if ( value instanceof Short ) return ( double ) ( ( short ) value ) ; if ( value instanceof Long ) return ( double ) ( ( long ) value ) ; if ( value instanceof Float ) return ( double ) ( ( float ) value ) ; if ( value instanceof Double ) return ( double ) value ; if ( value instanceof String ) try { return Double . parse Double ( ( String ) value ) ; } catch ( Number Format Exception ex ) { return null ; } return null ; }<CODESPLIT>Converts value into doubles or returns default value when conversion is not possible .<CODESPLIT>0
public Http Command Processor get Command Processor ( ) { String command Processor Name = command Processor Names . get ( ) ; ( command Processor Name == ) { Panic In The Cougar ( No HTTP Command Processor has configured " + protocol ) ; } Http Command Processor command Processor = ( Http Command Processor ) application Context . get Bean ( command Processor Name ) ; if ( command Processor == null ) { } return command Processor ; }<CODESPLIT>Returns the command processor assocated with the supplied protocol<CODESPLIT>1
public get Parameters ) get Common Constructor Parameters ) "," ." get ) From ()" "," ; result += " this ." + this . get Name ( ) + " To ()" ; result += "," ; result += this . get Owner ( ) . get Finder Class Name ( ) + "." + this . get Name ( ) + " Infinity " ; result += "," ; result += this . future Expiring Rows Exist ( ) ; result += "," ; result += this . is To Is Inclusive ( ) ; result += "," ; result += "," ; result += this . is Processing Date ( ) ; result += "," ; result += this . is Infinity Null ( ) ; return result ; }<CODESPLIT>/ * String attributeName String dataClassName String busClassName boolean isNullable boolean hasBusDate RelatedFinder relatedFinder Map<String Object > properties boolean transactional boolean isOptimistic<CODESPLIT>1
public boolean set Active ) { boolean Active ) ; ) { Locator Locator get ) get ) ) set El get Title ) ) ; Locator Element . set Info Message ( get Path Builder ( ) . get Text ( ) + " Tab " ) ; activated = title Element . click ( ) ; if ( activated ) { LOGGER . info ( " set Active : " + to String ( ) ) ; return activated ;<CODESPLIT>example new DataField () . setDate ( 19 05 2013 )<CODESPLIT>0
public String Converter find Converter ( Class ) { ( Byte [ . class ) { Byte Array String Converter . INSTANCE ; } return null ; }<CODESPLIT>Creates a new conversion manager including the extended standard set of converters . <p > The returned converter is a new instance that includes additional converters : <ul > <li > JDK converters <li > { @link NumericArrayStringConverterFactory } <li > { @link NumericObjectArrayStringConverterFactory } <li > { @link CharObjectArrayStringConverterFactory } <li > { @link ByteObjectArrayStringConverterFactory } <li > { @link BooleanArrayStringConverterFactory } <li > { @link BooleanObjectArrayStringConverterFactory } < / ul > <p > The convert instance is mutable in a thread - safe manner . Converters may be altered at any time including the JDK converters . It is strongly recommended to only alter the converters before performing actual conversions .<CODESPLIT>0
public Disassociate Resources disassociate Resources Disassociate Resources Request request ) { request Client request ) ; return execute Disassociate S 3 Resources ( request ) ; }<CODESPLIT><p > Removes specified S3 resources from being monitored by Amazon Macie . If memberAccountId isn t specified the action removes specified S3 resources from Macie for the current master account . If memberAccountId is specified the action removes specified S3 resources from Macie for the specified member account . < / p ><CODESPLIT>1
public static double cdf double double k double lambda double theta ) { theta ) exp Math . pow ( ( val - theta ) / lambda , k ) ) ) : val == val ? 0 . 0 : Double . Na N ; }<CODESPLIT>CDF of Weibull distribution<CODESPLIT>1
public static void equalize Col ( Gray U , int , int start X , Gray U output , I work ) { int width = 2 ; int area = width width ; int Value = work . ( ) ; int [ histogram = work . ( ) ; int [ = work . ( ) ; int 0 = start X ; int = start X width ; ( 1 > input . width ) { } local Histogram ( input , hist 0 , 0 , hist 1 , width , histogram ) ; int sum = 0 ; for ( int i = 0 ; i < histogram . length ; i ++ ) { transform [ i ] = sum += histogram [ i ] ; } int index In = input . start Index + radius * input . stride + start X ; int index Out = output . start Index + radius * output . stride + start X ; for ( int x = 0 ; x < radius ; x ++ ) { int input Value = input . data [ index In ++ ] & 0 xff ; } for ( int y = radius + 1 ; y < input . height - radius ; y ++ ) { for ( int x = hist 0 ; x < hist 1 ; x ++ ) { histogram [ input . data [ index In + x ] & 0 x FFFF ] -- ; } index In += width * input . stride ; for ( int x = hist 0 ; x < hist 1 ; x ++ ) { histogram [ input . data [ index In + x ] & 0 x FFFF ] ++ ; for ( int i = 0 ; i < histogram . length ; i ++ ) { transform [ i ] = sum += histogram [ i ] ; for ( int x = 0 ; x < radius ; x ++ ) { int input Value = input . data [ index In ++ ] & 0 xff ; work Arrays . recycle ( histogram ) ; work Arrays . recycle ( transform ) ;<CODESPLIT>Local equalization along a row . Image must be at least the histogram s width ( 2 * r + 1 ) in width and height .<CODESPLIT>0
public static Array ( index , array Length , String message ) { ( index index >= array Length ) { Out Of Bounds Exception ( message ) ; } return index ; }<CODESPLIT>Throws an { @link IndexOutOfBoundsException } if { @code sliceFrom } or { @code sliceLength } is negative or the sum of both is greater than { @code arrayLength } . Note that this means that a slice of length zero starting at array length is a valid slice .<CODESPLIT>0
public static Q Sync create ( ) { create ( host , port , true , true ) ; }<CODESPLIT>ファイルが1904年始まりの設定かどうか。<CODESPLIT>0
private T T add ( String , T , long Diskspace , boolean inherit ) throws Quota Exceeded { get Path ( ) ; set Name ( path ) ; Name ( ) ; Node [ ] inodes = new I Node [ components . length ] ; write Lock ( ) ; try { root Dir . get Existing Path I Nodes ( components , inodes ) ; return add Child ( inodes , inodes . length - 1 , child , child Diskspace , inherit Permission ) ; } finally { write Unlock ( ) ; } }<CODESPLIT>Add a node child to the namespace . The full path name of the node is src . childDiskspace should be - 1 if unknown . QuotaExceededException is thrown if it violates quota limit<CODESPLIT>1
public Vector add ( w ) { return add ( x , y , z , w , this Or New ( ) ) ; }<CODESPLIT>Increment the components of this vector by the given values .<CODESPLIT>1
public Detect detect mime ) { ) ) { TEMPLATE validate , " detect Language " ) ; } Detect Language Request request = Detect Language Request . new Builder ( ) . set Parent ( parent ) . set Model ( model ) . set Mime Type ( mime Type ) . build ( ) ; return detect Language ( request ) ; }<CODESPLIT>Formats a string containing the fully - qualified path to represent a location resource .<CODESPLIT>0
protected void common Z Matrix Maj ) { set Expected , A . num Cols ) ; QR . set ( A ) ; }<CODESPLIT><p > Computes the householder vector u for the first column of submatrix j . Note this is a specialized householder for this problem . There is some protection against overflow and underflow . < / p > <p > Q = I - &gamma ; uu<sup > H< / sup > < / p > <p > This function finds the values of u and &gamma ; . < / p ><CODESPLIT>0
public Esa Resource Writable parse File To Resource ( File asset File , File File , String content Url ) throws Repository { Artifact Metadata artifact Metadata = explode Artifact ( asset File , File ) ; { feature = Esa Feature . construct Instance ( asset File ) ; } ( ) { Esa Resource Writable resource = Writable Resource Factory . create Esa ( ) ; String symbolic Name = feature . get Symbolic Name ( ) ; String version = feature . get Version ( ) . to String ( ) ; String Name = feature . get Header ( Name , Locale . ENGLISH ) ; String short Name = feature . get Ibm Short Name ( ) ; String Name = artifact Metadata != artifact Metadata . get Name ( ) : ; final String name ; ( Name != ! Name . is Empty ( ) ) { } else ( Name != null && ! subsystem Name . is Empty ( ) ) { } else if ( short Name != null && ! short Name . is Empty ( ) ) { } else { } resource . set Name ( name ) ; String short Description = null ; String overridden Display Policy = null ; if ( artifact Metadata != null ) { short Description = artifact Metadata . get Short Description ( ) ; resource . set Description ( artifact Metadata . get Long Description ( ) ) ; resource . set Vanity URL ( artifact Metadata . get Property ( PROP _ VANITY _ URL ) ) ; overridden Display Policy = artifact Metadata . get Property ( PROP _ DISPLAY _ POLICY ) ; } if ( short Description == null ) { short Description = feature . get Header ( " Subsystem - Description " , Locale . ENGLISH ) ; } resource . set Short Description ( short Description ) ; resource . set Version ( version ) ; process Icons ( asset File , feature , resource ) ; String provider = feature . get Header ( " Subsystem - Vendor " ) ; if ( provider != null && ! provider . is Empty ( ) ) { resource . set Provider Name ( provider ) ; if ( " IBM " . equals ( provider ) ) { resource . set Provider Url ( " http :// www . ibm . com " ) ; } } else { } resource . set Provide Feature ( symbolic Name ) ; resource . set Applies To ( artifact Metadata . get Property ( " IBM - Applies To " ) ) ; else { resource . set Applies To ( feature . get Header ( " IBM - Applies To " ) ) ; else { resource . set Visibility ( visibility ) ; if ( feature . is Auto Feature ( ) ) { resource . set Provision Capability ( feature . get Header ( " IBM - Provision - Capability " ) ) ; String IBM Install Policy = feature . get Header ( " IBM - Install - Policy " ) ; else { resource . set Install Policy ( install Policy ) ; if ( is Beta ( resource . get Applies To ( ) ) ) { resource . set Web Display Policy ( Display Policy . HIDDEN ) ; else { resource . set Web Display Policy ( web Display Policy ) ; if ( overridden Display Policy != null ) { display Policy = Display Policy . value Of ( overridden Display Policy ) ; resource . set Display Policy ( display Policy ) ; String required Fixes = feature . get Header ( " IBM - Require - Fix " ) ; if ( required Fixes != null && ! required Fixes . is Empty ( ) ) { String [ ] fixes = required Fixes . split ( "," ) ; for ( String fix : fixes ) { fix = fix . trim ( ) ; if ( ! fix . is Empty ( ) ) { resource . add Require Fix ( fix ) ; resource . set Short Name ( short Name ) ; for ( Feature Resource feature Resource : required Features ) { List < String > tolerates = feature Resource . get Tolerates ( ) ; String required Feature Symbolic Name = feature Resource . get Symbolic Name ( ) ; resource . add Require Feature With Tolerates ( required Feature Symbolic Name , tolerates ) ; String superseded By = feature . get Superseded By ( ) ; if ( superseded By != null && ! superseded By . trim ( ) . is Empty ( ) ) { String [ ] superseded By Array = superseded By . split ( "," ) ; for ( String f : superseded By Array ) { if ( f . starts With ( "[" ) ) { f = f . substring ( 1 , f . length ( ) - 1 ) ; resource . add Superseded By Optional ( f ) ; else { resource . add Superseded By ( f ) ; if ( artifact Metadata != null ) { attach License Data ( artifact Metadata , resource ) ; set Java Requirements ( asset File , resource ) ; String attachment Name = symbolic Name + ". esa " ; add Content ( resource , asset File , attachment Name , artifact Metadata , content Url ) ; try { process L Aand LI ( asset File , resource , feature ) ; catch ( IO Exception e ) { resource . set License Id ( feature . get Header ( " Subsystem - License " ) ) ; resource . set Singleton ( Boolean . to String ( feature . is Singleton ( ) ) ) ; resource . set IBM Install To ( feature . get Header ( " IBM - Install To " ) ) ; return resource ;<CODESPLIT>Look in the esa for bundles with particular java version requirements . Create an aggregate requirement of the esa as a whole and write the data into the supplied resource<CODESPLIT>0
public static invoke Method ( Object Method method Object ) { { ( ) method invoke ( ) ; } catch ( Exception e ) { throw Exception Util . unwrap And Unchecked ( e ) ; } }<CODESPLIT>调用构造函数 .<CODESPLIT>0
public add Common Configs ( ) { ( Config . get Cipher Suites ( ) != Config . get Cipher Suites ( ) . length > 0 ) { engine . set Enabled Cipher Suites ( ssl Config . get Cipher Suites ( ) ) ; } engine . set Enabled Protocols ( ssl Config . get Enable Protocols ( ) ) ; } engine . set Enable Session Creation ( ssl Config . is Enable Session Creation ( ) ) ; return engine ; }<CODESPLIT>Add common configs for both client and server ssl engines .<CODESPLIT>1
public static Internal ( kbase Kie ) { new Knowledge Base Impl ( kbase Id , ( Rule Base Configuration ) conf ) ; }<CODESPLIT>TODO : FIXME : make it consistent with above<CODESPLIT>0
private T void add Internal ( @ Nonnull Iterable T ) { ( iterator ( ) has Next ( ) ) { ; ( newer Than older Than ) { Iterator T iterator ( ) ; ( has Next ( ) ) { add ( next ( ) ) ; if ( is Full ( ) ) { break ; } has Down Page = iter . has Next ( ) ; else if ( newer Than != null ) { int to Fill Count = get Fill Count ( ) ; if ( to Fill Count > 0 ) { Iterator < Item T > iter = items . iterator ( ) ; while ( iter . has Next ( ) ) { Item T item = iter . next ( ) ; items To Add . add Last ( item ) ; items To Add . remove First ( ) ; has Up Page = true ; } } else { break ; } } if ( items To Add . size ( ) == 0 ) { has Down Page = true ; } else { if ( items To Add . size ( ) < to Fill Count ) { Iterator < Item T > skipped Iter = items . iterator ( ) ; Iterators . skip ( skipped Iter , items To Add . size ( ) ) ; Item T item = skipped Iter . next ( ) ; items To Add . add Last ( item ) ; } } has Down Page = iter . has Next ( ) ; for ( Object item : items To Add ) { add ( item ) ; } } } } else if ( older Than != null ) { Iterator < Item T > iter = items . iterator ( ) ; while ( iter . has Next ( ) ) { Object item = iter . next ( ) ; has Up Page = true ; } else { add ( item ) ; if ( is Full ( ) ) { has Down Page = iter . has Next ( ) ; break ;<CODESPLIT>Add run items and queued items to the History page .<CODESPLIT>0
private Artifact get Management ( ) { Management Management = get ( ) . get Management ( ) ; if ( dependency Management != null ) { for ( Dependency dependency : dependency Management . get Dependencies ( ) ) { result . add ( to Artifact ( dependency ) ) ; } } return result ; }<CODESPLIT>Returns all dependency artifacts in all modules excluding all reactor artifacts ( including attached ) .<CODESPLIT>0
public void add Rec field ) { ) field ; get ) get ) REFRESH AND LOCK _ ON _ CHANGE _ STRATEGY ) != DB Constants . OPEN _ REFRESH _ AND _ LOCK _ ON _ CHANGE _ STRATEGY ) || ( record . is Refreshed Record ( ) ) ) this . restore Main Record ( record , true ) ; super . add ( record ) ; }<CODESPLIT>Add this record ( Always called from the record class ) .<CODESPLIT>1
protected void set Throwable ) { compare And Int COMPLETING ) ) { outcome t ; U . put Ordered Int ( this , STATE , EXCEPTIONAL ) ; finish Completion ( ) ; } }<CODESPLIT>Sets the result of this future to the given value unless this future has already been set or has been cancelled .<CODESPLIT>0
public static get ( , String ) { Resource Instance . get Resource ( class Loader , path ) ; }<CODESPLIT>Replies the input stream of a resource .<CODESPLIT>0
static , Map , dynamically Cast Map ( Map , map , , value ) { ( map ) { ; } assert check ( map ( ) , ) The map contains keys with other than " + key Type . get Name ( ) ; assert check Collection Members ( map . values ( ) , value Type ) : " The map contains values with a type other than " + value Type . get Name ( ) ; return ( Map < K , V > ) map ;<CODESPLIT>=====<CODESPLIT>0
public liferay commerce product CP Option Value Rel get CP Option Value By Uuid And Company ( String uuid , long company ) { Definition Option Value Rel Local Service . get CP Definition Option Value Rels By Uuid And Company Id ( uuid , company Id ) ; }<CODESPLIT>Returns a range of cp definition option value rels matching the UUID and company .<CODESPLIT>0
public void set Compliance ( String compliance ) { ( compliance ) { compliance null ; return ; } this . compliance Status = new java . util . Array List < String Filter > ( compliance Status ) ; }<CODESPLIT><p > The details of a resource that does not have a specific sub - field for the resource type defined . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setResourceDetailsOther ( java . util . Collection ) } or { @link #withResourceDetailsOther ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
Class [ int Class = init ( ) ; { Class current = . get Class ( ) ; Method method = ; ( current Object . class ) { { method = current . get Method ( method Name , int Class ) ; ; } ( No Method ) { current = current . get Superclass ( ) ; } } ( method ) { No Method ( " Mehtod is not found in " + current ) ; } method . set Accessible ( true ) ; method . invoke ( obj , args ) ; } catch ( final Invocation Target Exception e ) { throw new Invocation Target Exception ( e . get Cause ( ) ) ; } catch ( final Exception e ) { throw new Invocation Target Exception ( e ) ; } }<CODESPLIT>Checks if is class avilable in class path .<CODESPLIT>0
public boolean ( File ) { String filename get ( ) ; With Case ( filename , ". xes " ) ; }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public Product Sets Paged Product Sets ( ) { Product Sets Request request Product Sets Request ( ) set Parent ( : parent . to String ( ) ) . build ( ) ; return list Product Sets ( request ) ; }<CODESPLIT>Lists ProductSets in an unspecified order .<CODESPLIT>1
public Matrix ( Matrix ) { ( . get Row ( ) != ) { Argument ( Matrix row dimensions must agree ." ) ; } ( ! isspd ) { ( Matrix is not symmetric positive definite ." ) ; } double [ ] [ ] X = . get Array ( ) ; int = B . get Column Dimension ( ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { for ( int i = 0 ; i < k ; i ++ ) { } X [ k ] [ j ] /= L [ k ] [ k ] ; } } for ( int k = n - 1 ; k >= 0 ; k -- ) { for ( int j = 0 ; j < nx ; j ++ ) { for ( int i = k + 1 ; i < n ; i ++ ) { } } } return new Matrix ( X , n , nx ) ; }<CODESPLIT>Solve A * X = B<CODESPLIT>1
public Patch get Patches ( ) { ( Patches ) { Patches new com . amazonaws . internal . Sdk Internal List < Record Patch > ( ) ; } return record Patches ; }<CODESPLIT>A list of patch operations .<CODESPLIT>1
private void process Fields ( ) { Field Introspection get Fields ( embeddable ) ; ( Field field ) { ( field ( Embedded . class ) ) { process Embedded Field ( field ) ; } else { process Simple Field ( field ) ;<CODESPLIT>Processes the given simple ( or primitive ) field and updates the metadata .<CODESPLIT>0
public Operation update Explicit Async item Update Explicit Parameter update Explicit Parameter ) { update Explicit With Async , version Id , entity Id , item Id , update Explicit List Item Optional Parameter ) . map ( new Func 1 < Service Response < Operation Status > , Operation Status > ( ) { @ Override public Operation Status call ( Service Response < Operation Status > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Updates an explicit list item for a Pattern . Any entity .<CODESPLIT>1
public void register ( Diagnostics Plugin ) { check Not Null ( , ) ; ( ) { ; } long period get Period ( ) ; ( period ) { } finest ( get Class ( ) to String ( ) is ( period DISABLED ? " disabled " : " enabled " ) ) ; if ( period Millis == DISABLED ) { return ; } plugins Map . put ( plugin . get Class ( ) , plugin ) ; plugin . on Start ( ) ; if ( period Millis > 0 ) { scheduler . schedule At Fixed Rate ( new Write Plugin Task ( plugin ) , 0 , period Millis , MILLISECONDS ) ; } else { add Static Plugin ( plugin ) ; } }<CODESPLIT>Registers a { @link DiagnosticsPlugin } . <p > This method is thread - safe . <p > There is no checking for duplicate registration . <p > If the { @link Diagnostics } is disabled the call is ignored .<CODESPLIT>1
public clean Area Async ( ) { task Cache Manager Task ( this , get Cleaning Action ( ) , bb , zoom Min , zoom Max ) ; task . add Callback ( get Cleaning Dialog ( ctx , task ) ) ; return execute ( task ) ; }<CODESPLIT>Remove all cached tiles in the specified area .<CODESPLIT>1
public static List External Graphic From Graphic ( Graphic graphic ) { List External Graphic List = Array List External Graphic ( ) ; ( Graphical gs graphic . graphical ( ) ) { ( ( gs ) && ( gs instanceof External Graphic ) ) { g List . add ( external Graphic ) ; } } return g List ; }<CODESPLIT>Creates a default { @link Style } for a featurecollection .<CODESPLIT>0
public get ( array ) { Info = get Delayable Class Info ( array Type . get Element Type ( ) ) ; return new Array Class Info ( type Class Name , element Class Info ) ; }<CODESPLIT>For array types the previous implementation used the element name .<CODESPLIT>0
public void ( ) { ( ) get Sub Screen ( , class ) ; if ( panel != null ) panel . free ( ) ; super . free ( ) ; }<CODESPLIT>Free the sub = components .<CODESPLIT>1
public void rule X Member Feature ( ) throws Recognition { stack keep ( ) ; { { ( backtracking 0 ) { ( grammar Access get X Member Feature Access ( ) get Group ( ) ) ; Follow ( FOLLOW 2 ) ; rule __ X Member Feature __ Group __ 0 ( ) ; state . _ fsp -- ; if ( state . failed ) return ; if ( state . backtracking == 0 ) { catch ( Recognition Exception re ) { report Error ( re ) ; recover ( input , re ) ; } finally { restore Stack Size ( stack Size ) ; } return ;<CODESPLIT>InternalXbase . g : 633 : 1 : entryRuleXMemberFeatureCall : ruleXMemberFeatureCall EOF ;<CODESPLIT>0
protected String sign And Encode ( , String , Signing algorithm ) throws Sdk Client { { sign ( , get ( 8 ) , algorithm ) ; encode As String ( ) ; ( Exception e ) { throw new Sdk Client Exception ( " Unable to calculate a request signature : " + e . get Message ( ) , e ) ;<CODESPLIT>Computes an RFC 2104 - compliant HMAC signature for an array of bytes and returns the result as a Base64 encoded string .<CODESPLIT>1
private void Process Next ( ) { ( ) { _ SOURCE _ _ DEST _ ( Catalog To Select ( ) ) { f Main . show ( ) ; return ; } ; f Main . show ( ) ; return ; } ; . set ( Transfer " ) ; } else if ( i Transfer Mode == TRFM _ DUMP ) { b Start . set Label ( " Start Dump " ) ; } else if ( i Transfer Mode == TRFM _ RESTORE ) { b Start . set Label ( " Start Restore " ) ; } b Start . invalidate ( ) ; b Start . set Enabled ( false ) ; l Table . set Multiple Mode ( false ) ; Refresh Main Display ( ) ; break ; default : break ; } }<CODESPLIT>Method declaration<CODESPLIT>0
Representation Repr ( Representation payload Repr ) { Representation Repr Representation ( ) ; Representation metadata Repr = Json Representation . new Map ( ) ; event Repr . map Put ( " metadata " , metadata Repr ) ; metadata Repr . map Put ( " id " , metadata . get Id ( ) ) ; metadata Repr . map Put ( " transaction Id " , metadata . get Transaction Id ( ) ) ; metadata Repr . map Put ( " sequence " , metadata . get Sequence ( ) ) ; metadata Repr . map Put ( " user " , metadata . get User ( ) ) ; event Repr . map Put ( " payload " , payload Repr ) ; return event Repr ; }<CODESPLIT>Set up the screen fields ( default = set them all up for the current record ) .<CODESPLIT>0
public float ( Int Float Vector ) { ( Int Float Vector ) { Int Float Vector other = ( ( Int Float Vector ) ) ; float = 0 ; int oc = 0 ; ( int = 0 ; ; ) { ( oc other . used ) { if ( other . indices [ oc ] < indices [ c ] ) { oc ++ ; } dot += values [ c ] * other . values [ oc ] ; break ; else { break ; } } } return dot ; else { float dot = 0 ; dot += this . values [ c ] * y . get ( indices [ c ] ) ; return dot ;<CODESPLIT>Computes the dot product of this vector with the other vector .<CODESPLIT>1
protected Prc Refresh Catalog Get Prc Refresh Catalog ( Map String , Object Param ) { Prc Refresh Catalog proc ( Prc Refresh Catalog ) processors Map get ( ) ; ( proc ) { proc Prc Refresh Catalog ( ) ; proc get ( ) add ( fct Bn Trade Processors Get Prc Webstore Page ( Add Param ) ) ; this . processors Map . put ( bean Name , proc ) ; this . logger . info ( null , Fct Bn Trade Processors . class , bean Name + " has been created ." ) ; } return proc ; }<CODESPLIT><p > Lazy get PrcRefreshCatalog . < / p ><CODESPLIT>1
private static build ( ) { ( ) { MESSAGE ; } return format ( INVALID _ MSG _ FMT , id ) ; }<CODESPLIT>Build the exception s message using the <tt > id< / tt > value .<CODESPLIT>1
public double get Moneyness As Offsets ( ) { Double Stream moneyness get Nodes Per Moneyness ( ) ( ) ( ) map To Double ( :: double Value ) ; ( quoting Convention Quoting Convention PAYERVOLATILITYLOGNORMAL ) { moneyness moneyness map ( Double Unary ( ) { @ Override public double apply As Double ( double ) { * 0 . 01 ; } } ) ; } else if ( quoting Convention == Quoting Convention . RECEIVERPRICE ) { moneyness = moneyness . map ( new Double Unary Operator ( ) { @ Override public double apply As Double ( double x ) { return - x * 0 . 0001 ; } } ) ; } else { } return moneyness . to Array ( ) ; }<CODESPLIT>Return all valid maturities for a given moneyness . Uses the fixing times of the fix schedule to determine fractions .<CODESPLIT>0
public Frustum set To Projection ( double double double double double near double Vector near Normal boolean ortho boolean mirrored ) { double nfnx near Normal ( ) nfny near Normal ( ) nfnz near Normal ( ) ; ( ortho ) { vertices . set ( left , bottom , xl + yb - near ) ; _ vertices [ mirrored ? 3 : 1 ] . set ( right , bottom , xr + yb - near ) ; _ vertices [ 2 ] . set ( right , top , xr + yt - near ) ; _ vertices [ mirrored ? 1 : 3 ] . set ( left , top , xl + yt - near ) ; _ vertices [ 4 ] . set ( left , bottom , xl + yb - far ) ; _ vertices [ mirrored ? 7 : 5 ] . set ( right , bottom , xr + yb - far ) ; _ vertices [ 6 ] . set ( right , top , xr + yt - far ) ; _ vertices [ mirrored ? 5 : 7 ] . set ( left , top , xl + yt - far ) ; } else { double z 0 = nz / ( nfnx * lrn + nfny * brn - nfnz ) ; _ vertices [ 0 ] . set ( - z 0 * lrn , - z 0 * brn , z 0 ) ; double z 1 = nz / ( nfnx * rrn + nfny * brn - nfnz ) ; _ vertices [ mirrored ? 3 : 1 ] . set ( - z 1 * rrn , - z 1 * brn , z 1 ) ; double z 2 = nz / ( nfnx * rrn + nfny * trn - nfnz ) ; _ vertices [ 2 ] . set ( - z 2 * rrn , - z 2 * trn , z 2 ) ; double z 3 = nz / ( nfnx * lrn + nfny * trn - nfnz ) ; double z 4 = fz / ( nfnx * lrn + nfny * brn - nfnz ) ; _ vertices [ 4 ] . set ( - z 4 * lrn , - z 4 * brn , z 4 ) ; double z 5 = fz / ( nfnx * rrn + nfny * brn - nfnz ) ; double z 6 = fz / ( nfnx * rrn + nfny * trn - nfnz ) ; _ vertices [ 6 ] . set ( - z 6 * rrn , - z 6 * trn , z 6 ) ; double z 7 = fz / ( nfnx * lrn + nfny * trn - nfnz ) ; } update Derived State ( ) ; return this ; }<CODESPLIT>Sets this frustum to an orthographic one pointing in the Z - direction with the specified parameters determining its size ( see the OpenGL documentation for <code > glOrtho< / code > ) .<CODESPLIT>0
private String To String ( Object param ) { ( param ) { ; } ( param Date ) { format Date ( ( Date ) param ) ; } ( param Collection ) { for ( Object o : ( Collection ) param ) { if ( b . length ( ) > 0 ) { b . append ( "," ) ; } } return b . to String ( ) ; else { return String . value Of ( param ) ; }<CODESPLIT>Reads a buffer .<CODESPLIT>0
public static validate Not ( value , error Template , Object ... ) { ( ( value ) ) { new Validate Exception ( error Msg Template , params ) ; } return value ; }<CODESPLIT>检查指定值是否为<code > null< / code ><CODESPLIT>0
public void set Commit Trigger Commit Trigger commit Trigger ) commit Trigger commit Trigger )   . commit Trigger != null ) { this . commit Trigger . remove Commit Trigger Listener ( commit Trigger Handler ) ; this . commit Trigger = null ; } if ( commit Trigger != null ) { if ( this . commit Trigger Handler == null ) { } this . commit Trigger . add Commit Trigger Listener ( commit Trigger Handler ) ; } }<CODESPLIT>Sets the <code > CommitTrigger< / code > that triggers the commit and flush events .<CODESPLIT>1
public static get Relative Sub Path ( , ) { ; Cms join ( , ) ; path = Cms String Util . join Paths ( path , "/" ) ; if ( path . starts With ( base ) ) { result = path . substring ( base . length ( ) ) ; } if ( result != null ) { if ( result . ends With ( "/" ) ) { } if ( ! result . starts With ( "/" ) ) { } } return result ; }<CODESPLIT>Returns <code > true< / code > if the provided Objects are either both <code > null< / code > or equal according to { @link Object#equals ( Object ) } . <p ><CODESPLIT>0
private void read More From Stream ( ) throws { ( Stream Has More ) { ; } Available In Buffer ; ( Space Available <= 0 ) { return ; int bytes Read = stream . read ( buffer , bytes In Buffer , buffer Space Available ) ; if ( bytes Read == - 1 ) { } else { bytes In Buffer += bytes Read ;<CODESPLIT>Fill the buffer with more data from the InputStream if there is any .<CODESPLIT>1
public Get get Get Request request ) request Client request ) ; return execute Get Plan ( request ) ; }<CODESPLIT><p > Retrieves a specified security configuration . < / p ><CODESPLIT>0
public void ( ) { print ( ) ; . writer . print ( "\ r \ n " ) ; this . writer . flush ( ) ; }<CODESPLIT>{<CODESPLIT>0
public void set Peer Peer Marshaller ) Peer Marshaller ovalue peer ; Attribute PEER , value , ovalue ) ; this . peer Service = value ; }<CODESPLIT>Requests that the <code > bootStamp< / code > field be set to the specified value . The local value will be updated immediately and an event will be propagated through the system to notify all listeners that the attribute did change . Proxied copies of this object ( on clients ) will apply the value change when they received the attribute changed notification .<CODESPLIT>0
public String Doc Root ( String htmlstr ) { index htmlstr index Of ( "{@" ) ; ( index ) { htmlstr ; } Matcher docroot Matcher docroot Pattern ( htmlstr ) ; ( docroot Matcher find ( ) ) { htmlstr ; } String String ( ) ; 0 ; do { int match = docroot Matcher . start ( ) ; buf . append ( htmlstr . substring ( prev End , match ) ) ; prev End = docroot Matcher . end ( ) ; if ( configuration . docrootparent . length ( ) > 0 && htmlstr . starts With ( "/.." , prev End ) ) { buf . append ( configuration . docrootparent ) ; prev End += 3 ; } else { } buf . append ( ' ' ) ; } } while ( docroot Matcher . find ( ) ) ; buf . append ( htmlstr . substring ( prev End ) ) ; return buf . to String ( ) ; }<CODESPLIT>Programmatic interface .<CODESPLIT>0
public static List String get Property Names ( Object ) { ( ) { property Names ; } { List < Object > cycle Detect = new Array List < Object > ( ) ; perform Get Property Names ( obj , null , property Names , cycle Detect ) ; return property Names ; } }<CODESPLIT>Recursively gets names of all properties implemented in specified object and its subobjects .<CODESPLIT>1
public boolean Locks boolean exclusive ) { Parents exclusive ) ( exclusive , depth ) ) { return true ; } return false ; }<CODESPLIT>checks if a lock of the given exclusivity can be placed only considering children up to depth<CODESPLIT>1
private static void create Instance ( ) { { ( MP EVALUATOR ) ; instance ( MP ) Instance ( ) ; } ( ) { FFDC ( e , " com . ibm . ws . sib . processor . MP Selector Evaluator Factory . create Factory Instance " , " 100 " ) ; throw new SI Error Exception ( e ) ; } }<CODESPLIT>Create the singleton Factory instance .<CODESPLIT>1
public Chain basic Uniform Distribution Uniform Distribution Uniform Distribution Chain msgs ) { Internal ) get Mixed ) ) basic Bpsim . Literals . DOCUMENT _ ROOT __ UNIFORM _ DISTRIBUTION , new Uniform Distribution , msgs ) ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>1
private Entity get Entity ( ) { Entity em ; em = ( Entity ) . get ( Name ) ; ( em ) { em = create Entity ( ) ; . put Resource ( unit Name , em ) ; } else { validate Compatible Sync Types ( em ) ; } } else { em = non Tx Em Holder . get Entity Manager ( ) ; if ( em == null ) { em = create Entity Manager ( ) ; non Tx Em Holder . set Entity Manager ( em ) ; } } return em ; }<CODESPLIT>Subscribes to an event dispatcher and starts a watch for a given key .<CODESPLIT>0
public get ) { ) ) item ) Missing ( " item List " , " de . julielab . jules . types . List " ) ; return ( FS Array ) ( jcas Type . ll _ cas . ll _ get FS For Ref ( jcas Type . ll _ cas . ll _ get Ref Value ( addr , ( ( List _ Type ) jcas Type ) . cas Feat Code _ item List ) ) ) ; }<CODESPLIT>setter for itemList - sets contains items of the level 1 . The items of the level 1 could contain further items of next level and so on in order to represent an iterative structure of list items .<CODESPLIT>0
public Push Rules create Push Rules Or Push Rules Rule ) Git Lab { Git Lab Git Lab ) with Param delete Rule get Deny ) ) with Param Rule get Member ) ) with Param secrets Rule get Secrets ) ) with Param commit Rule get Commit ) ) with Param branch push Rule . get Branch Name Regex ( ) ) . with Param ( " author _ email _ regex " , push Rule . get Author Email Regex ( ) ) . with Param ( " file _ name _ regex " , push Rule . get File Name Regex ( ) ) . with Param ( " max _ file _ size " , push Rule . get Max File Size ( ) ) ; Response response = post ( Response . Status . CREATED , form Data , " projects " , get Project Id Or Path ( project Id Or Path ) , " push _ rule " ) ; return ( response . read Entity ( Push Rules . class ) ) ; }<CODESPLIT>Adds a push rule to a specified project .<CODESPLIT>1
public static Recurrence Date of ( int count , Plain Date start , Date ) { check ( count ) ; ( start ) { Null ( Missing start of recurrent interval ." ) ; } Recurrent Date ( count , TYPE _ START _ DURATION , start , duration ) ; }<CODESPLIT>/ * [ deutsch ] <p > Erzeugt eine Sequenz von wiederkehrenden Datumsintervallen mit der angegebenen Dauer . < / p ><CODESPLIT>1
private static String upper ( String ) { char chars . to Char Array ( ) ; int . ( ) ; ( chars ) { case ' ' : chars [ i ] = ' ' ; break ; case ' ' : chars [ i ] = ' ' ; break ; case ' ' : chars [ i ] = ' ' ; break ; case ' ' : chars [ i ] = ' ' ; break ; case ' ' : chars [ i ] = ' ' ; break ; break ; return new String ( chars ) ;<CODESPLIT>/ * Efficiently converts a string containing a hexadecimal number from lower case to upper case<CODESPLIT>1
check analytics ) ; check ) ; check Page Title ) ; check Page ) ; check ) ; check ) ; check ) ; check billing ) ; check Hostname ) ; check ) ; Value ) ; add Value 1 " ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ PROPERTY _ ID , analytics Id ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ TYPE , VALUE _ TYPE _ PAGEVIEW ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ IS _ NON _ INTERACTIVE , VALUE _ FALSE ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ CACHEBUSTER , Long . to String ( random . next Long ( ) ) ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ EVENT _ TYPE , event Type ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ EVENT _ NAME , event Name ) ) ; if ( client Hostname . is Present ( ) && ! client Hostname . get ( ) . is Empty ( ) ) { list Builder . add ( new Basic Name Value Pair ( PARAM _ HOSTNAME , client Hostname . get ( ) ) ) ; } list Builder . add ( new Basic Name Value Pair ( PARAM _ CLIENT _ ID , client Id ) ) ; if ( project Number Hash . is Present ( ) && ! project Number Hash . get ( ) . is Empty ( ) ) { list Builder . add ( new Basic Name Value Pair ( PARAM _ PROJECT _ NUM _ HASH , project Number Hash . get ( ) ) ) ; } if ( billing Id Hash . is Present ( ) && ! billing Id Hash . get ( ) . is Empty ( ) ) { list Builder . add ( new Basic Name Value Pair ( PARAM _ BILLING _ ID _ HASH , billing Id Hash . get ( ) ) ) ; } list Builder . add ( new Basic Name Value Pair ( PARAM _ USER _ SIGNED _ IN , to Value ( is User Signed In ) ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ USER _ INTERNAL , to Value ( is User Internal ) ) ) ; if ( is User Trial Eligible . is Present ( ) ) { } list Builder . add ( new Basic Name Value Pair ( PARAM _ IS _ VIRTUAL , VALUE _ TRUE ) ) ; list Builder . add ( new Basic Name Value Pair ( PARAM _ PAGE , virtual Page Name ) ) ; if ( ! virtual Page Title . is Empty ( ) ) { } return list Builder . build ( ) ; }<CODESPLIT>Adds more data providers to the validator .<CODESPLIT>0
public void insert ( Char Sequence text ) throws { ln text ( ) ; ( ln ) { ; } ( ln >= ( end ) ) { } ( != end ) { make Room ( ln ) ; } for ( int ii = 0 ; ii < ln ; ii ++ ) { set ( ( cursor + ii ) , text . char At ( ii ) ) ; } end += ln ; }<CODESPLIT>Inserts text at cursor position<CODESPLIT>1
public void on Tab ( Ajax Request Target tab index ) { ( ( index ) ( index >= get ( ) size ( ) ) ) { } get Tabs ( ) . add ( index , tab ) ; set Selected Tab ( index ) ; target . add ( this ) ; }<CODESPLIT>On new tab .<CODESPLIT>1
public static void output Image ( int , int , Output Stream os , String code ) throws { int verify code ( ) ; Image image Image ( , , Image TYPE RGB ) ; Random Random ( ) ; 2 2 image create ( ) ; 2 set Rendering Hint ( Rendering Hints ANTIALIASING , Rendering Hints ANTIALIAS ) ; Color colors Color 5 ; Color Color { ; float [ ] fractions = new float [ colors . length ] ; for ( int i = 0 ; i < colors . length ; i ++ ) { fractions [ i ] = rand . next Float ( ) ; } Arrays . sort ( fractions ) ; g 2 . set Color ( Color . GRAY ) ; g 2 . fill Rect ( 0 , 0 , w , h ) ; Color c = get Rand Color ( 200 , 250 ) ; g 2 . set Color ( c ) ; g 2 . fill Rect ( 0 , 2 , w , h - 4 ) ; Random random = new Random ( ) ; g 2 . set Color ( get Rand Color ( 160 , 200 ) ) ; for ( int i = 0 ; i < 20 ; i ++ ) { int x = random . next Int ( w - 1 ) ; int y = random . next Int ( h - 1 ) ; int xl = random . next Int ( 6 ) + 1 ; int yl = random . next Int ( 12 ) + 1 ; g 2 . draw Line ( x , y , x + xl + 40 , y + yl + 20 ) ; } float yawp Rate = 0 . 05 f ; int area = ( int ) ( yawp Rate * w * h ) ; for ( int i = 0 ; i < area ; i ++ ) { int x = random . next Int ( w ) ; int y = random . next Int ( h ) ; int rgb = get Random Int Color ( ) ; image . set RGB ( x , y , rgb ) ; } shear ( g 2 , w , h , c ) ; g 2 . set Color ( get Rand Color ( 100 , 160 ) ) ; int font Size = h - 4 ; g 2 . set Font ( font ) ; char [ ] chars = code . to Char Array ( ) ; for ( int i = 0 ; i < verify Size ; i ++ ) { Affine Transform affine = new Affine Transform ( ) ; g 2 . set Transform ( affine ) ; } g 2 . dispose ( ) ; Image IO . write ( image , " jpg " , os ) ; }<CODESPLIT>生成指定验证码图像文件<CODESPLIT>0
public Object find Closest Object ( int , int y , int [ ] distance ) { ( _ size == 0 ) { return ; } int sr = ( ) , sl = sr ; int mindist = Integer . _ VALUE , minidx = ; for ( boolean expanded = ; expanded ; ) { expanded = false ; ( sr _ size ) { ( rec . < mindist ) { int dist = distance ( rec . x , rec . y , x , y ) ; if ( dist < mindist ) { } sr += 1 ; expanded = true ; } } if ( sl >= 0 ) { if ( x - rec . x < mindist ) { if ( dist < mindist ) { } expanded = true ; } } } if ( minidx == - 1 ) { throw new Runtime Exception ( " Proximity algorithm failed !" ) ; } if ( distance != null && distance . length > 0 ) { } return _ records [ minidx ] . object ; }<CODESPLIT>Removes from the tracker the object that is equal to ( <code > o1 . equals ( object ) < / code > ) the specified object .<CODESPLIT>0
public void set Golden Grammar ) { Golden Golden ) ) golden Grammar ) Missing ( " golden Grammar Errors " , " cogroo . uima . Golden Sentence " ) ; jcas Type . ll _ cas . ll _ set Ref Value ( addr , ( ( Golden Sentence _ Type ) jcas Type ) . cas Feat Code _ golden Grammar Errors , jcas Type . ll _ cas . ll _ get FS Ref ( v ) ) ; }<CODESPLIT>setter for goldenGrammarErrors - sets<CODESPLIT>1
Map Cms Principal Bean , String get Responsibles ( Cms Object cms , Cms res ) { Map Cms Principal Bean , String Map Cms Principal Bean , String ( ) ; List Cms Resources Array List Cms ( ) ; { Resources cms read Path ( res , Cms Filter IGNORE EXPIRATION ) ; } ( Cms ) { error ( get Message ( ) , e ) ; for ( Cms Resource resource : parent Resources ) { String stored Site Root = cms . get Request Context ( ) . get Site Root ( ) ; String site Path = cms . get Request Context ( ) . remove Site Root ( resource . get Root Path ( ) ) ; try { cms . get Request Context ( ) . set Site Root ( "/" ) ; for ( Cms Access Control Entry ace : entries ) { if ( ace . is Responsible ( ) ) { I _ Cms Principal principal = cms . lookup Principal ( ace . get Principal ( ) ) ; if ( principal != null ) { if ( ! resource . get Root Path ( ) . equals ( res . get Root Path ( ) ) ) { if ( resource . get Root Path ( ) . starts With ( stored Site Root ) ) { result . put ( prin Bean , site Path ) ; } else { result . put ( prin Bean , resource . get Root Path ( ) ) ; } } else { result . put ( prin Bean , null ) ; } } } } } catch ( Cms Exception e ) { } finally { cms . get Request Context ( ) . set Site Root ( stored Site Root ) ; } return result ;<CODESPLIT>Returns the responsibles . <p ><CODESPLIT>1
public static Router ( Template , ) { route ( ) . post ( uri Template , handler ) ; }<CODESPLIT>Performs mapping for all routers .<CODESPLIT>0
int Singular ( , ) ; check Svd Matrix ( U , tran U , , , tran ) ; ( int 0 ; Singular ; ) { int big Index ; ( int ; j < num Singular ; j ++ ) { double v = W . get ( j , j ) ; if ( v > big Value ) { big Value = v ; } } if ( big Index == i ) continue ; if ( big Index == - 1 ) { break ; } double tmp = W . get ( i , i ) ; W . set ( i , i , big Value ) ; W . set ( big Index , big Index , tmp ) ; if ( V != null ) { swap Row Or Col ( V , tran V , i , big Index ) ; } if ( U != null ) { swap Row Or Col ( U , tran U , i , big Index ) ; } } }<CODESPLIT>Computes the SVD and sorts singular values in descending order . While easier to use this can reduce performance when performed on small matrices numerous times .<CODESPLIT>0
public stop Monitoring ( Monitoring stop Monitoring ) { > resp = stop Monitoring With Http Info ( stop Monitoring Data ) ; return resp . get Data ( ) ; }<CODESPLIT>Start recording a call Start recording the specified call . Recording stops when the call is completed or you send [ / voice / calls / { id } / stop - recording ] ( / reference / workspace / Voice / index . html#stopRecording ) on either the call or the DN .<CODESPLIT>0
public get Attribute ( ) { Object attributes get ( ) ; ( o == null ) { return null ; } else { return ( String ) o ;<CODESPLIT>Get the value for a given attribute .<CODESPLIT>1
public static CP Option Value find By Group start ) { get Persistence ( ) . find By Group Id ( group Id , start , end ) ; }<CODESPLIT>Returns a range of all the cp option values where groupId = &#63 ; .<CODESPLIT>1
private static void handle Singleton Class ( String , String value ) { Object handle Value ( value ) ; ( contains ( "," ) ) { ( String an ) { Map . put ( an Interface , object ) ; } } else { service Map . put ( key , object ) ; } }<CODESPLIT>Send email with a string content and attachment<CODESPLIT>0
public static ( , separator , boolean Quotes ) { strtok ( , Str Matcher . char Matcher ( separator ) , Str Matcher . quote Matcher ( ) ) ; return strtok . get Token Array ( ) ; }<CODESPLIT>Normalize and collapse whitespaces from string buffer .<CODESPLIT>0
public Comparison get Lt From Like ( ) { COMPARE LESSTHAN ; comparand extract And Like ( ) ; return range Filter From Prefix Like ( m _ left , range Comparator , comparand ) ; }<CODESPLIT>/ Construct the upper bound comparison filter implied by a prefix LIKE comparison .<CODESPLIT>1
public void show Forgot View ( Token ) { { Cms Token Cms Token ( ) ; ( Result ) { Cms User user get User ( ) ; ( user ( ) ) { Cms Dialog dlg Cms Dialog ( Cms user get Locale ( ) ) ; Cms get ( ) set Content To Dialog ( Messages get ( ) get ( Cms get ( ) get Locale ( ) ) ( Messages GUI PWCHANGE ) user get ( ) dlg ) ; } { show ( Cms Vaadin Utils . get Message Text ( Messages . ERR _ USER _ NOT _ SELF _ MANAGED _ 1 , user . get Name ( ) ) , Type . ERROR _ MESSAGE ) ; } } else { A _ Cms UI . get ( ) . set Error ( Messages . get ( ) . get Bundle ( A _ Cms UI . get ( ) . get Locale ( ) ) . key ( Messages . GUI _ PWCHANGE _ INVALID _ TOKEN _ 0 ) ) ; LOG . info ( " Invalid authorization token : " + auth Token + " / " + validation Result ) ; } } catch ( Exception e ) { LOG . error ( e . get Localized Message ( ) , e ) ; } }<CODESPLIT>Initializes the login view . <p ><CODESPLIT>0
public C table Hints ( Server Table Hints ... table Hints ) { ( table Hints . > 0 ) { add Join Flag ( , Join Flag . Position . END ) ; } return ( C ) this ; }<CODESPLIT>Set the table hints<CODESPLIT>1
private void populate ( Field field , Object , String Value ) { field set ( ) ; { Class field Type field get Type ( ) ; Object value Type Converter . convert ( string Value ) . to ( field Type ) ; field . set ( target , value ) ; } catch ( Illegal Access Exception e ) { } }<CODESPLIT>Populates the specified field on the target with the value from the given option .<CODESPLIT>1
public Object get Parameter ( String name ) { { Q Name qname Q Name . get Q Name From String ( name ) ; ( user ) ; ( int ; >= 0 ; i -- ) { Arg arg = ( Arg ) m _ user Params . element At ( i ) ; if ( arg . get Q Name ( ) . equals ( qname ) ) { return arg . get Val ( ) . object ( ) ; } } return null ; } return null ; } }<CODESPLIT>Reset parameters that the user specified for the transformation . Called during transformer . reset () after we have cleared the variable stack . We need to make sure that user params are reset so that the transformer object can be reused .<CODESPLIT>0
private Multipart Content create Content Problem Input  set Parameter BOUNDARY create  Multipart Content Multipart Content set add Part build Part CSRF ) ) ) . add Part ( Http Request Executor . build File Part ( ANSWER _ PARAMETER , output ) ) . add Part ( Http Request Executor . build File Part ( SOURCE _ FILE _ PARAMETER , source ) ) . add Part ( Http Request Executor . build Data Part ( SOURCE _ FILE _ NAME _ PARAMETER , source File Path ) ) . add Part ( Http Request Executor . build Data Part ( COMMAND _ PARAMETER _ NAME , SUBMIT _ COMMAND ) ) . add Part ( Http Request Executor . build Data Part ( PROBLEM _ PARAMETER _ NAME , input . get Problem ( ) . get Id ( ) ) ) . add Part ( Http Request Executor . build Data Part ( INPUT _ ID _ PARAMETER _ NAME , String . value Of ( input . get Number ( ) ) ) ) . add Part ( Http Request Executor . build Data Part ( NUM _ SOURCE _ FILE _ PARAMETER , DEFAULT _ NUM _ SOURCE _ FILE ) ) . add Part ( Http Request Executor . build Data Part ( AGENT _ PARAMETER _ NAME , DEFAULT _ AGENT ) ) ; return content ; }<CODESPLIT><p > Created and returns a valid { @link MultipartContent } instance that contains data required for submission . < / p ><CODESPLIT>1
public boolean ( E ) { ( cnt In >= ) { buckets add ( ( E ) Object ) ; } buckets . get Last ( ) [ cnt In Bucket ++ ] = e ; size ++ ; return true ; }<CODESPLIT>This method verifies that this GO has no PCI representation or that the PCI representation is not dirty or new . Otherwise it will throw an exception in order to prevent the dirty state of the GO and the PC to result in conflicting updates in the database .<CODESPLIT>0
static ( DTO DTO ) { ( DTO get ( ) ) ; ( DTO Datasource DTO get Datasources ( ) ) { ( ds . get Heartbeat ( ) != null ) { r Descriptor . datasource ( ds . get Label ( ) , ds . get Source ( ) , ds . get Heartbeat ( ) , ds . get Function ( ) ) ; } else { } } for ( Result Descriptor DTO . Expression expr : r Descriptor DTO . get Expressions ( ) ) { r Descriptor . expression ( expr . get Label ( ) , expr . get Expression ( ) ) ; } r Descriptor . export ( r Descriptor DTO . get Exports ( ) ) ; return r Descriptor ; }<CODESPLIT>Visits all nodes in the resource tree bellow the given resource using depth - first search .<CODESPLIT>0
public boolean handle Criteria ( boolean Include File Param ) { get ( ) ; ( null ) return ( ( File Listener ) next Listener ) . do Remote Criteria ( str Filter , b Include File Name , v Param List ) ; else return this . do Remote Criteria ( str Filter , b Include File Name , v Param List ) ; }<CODESPLIT>Check to see if this record should be skipped . Generally you use a remote criteria .<CODESPLIT>0
@ Consumes ( Media ) @ Produces ( Media ) public register Windows ( Windows windows @ Path Param ( App ) @ ) { ( App ) { status ( NOT ) ( Could not find Push Entity ) build ( ) ; { validate ( windows ) ; ( Constraint Violation Exception cve ) { logger . trace ( " Unable to create Windows variant " ) ; Response . Response Builder builder = create Bad Request Response ( cve . get Constraint Violations ( ) ) ; return builder . build ( ) ; logger . trace ( " Register Windows variant with Push Application '{}'" , push Application ID ) ; variant Service . add Variant ( windows Variant ) ; push App Service . add Variant ( push App , windows Variant ) ; return Response . created ( uri Info . get Absolute Path Builder ( ) . path ( String . value Of ( windows Variant . get Variant ID ( ) ) ) . build ( ) ) . entity ( windows Variant ) . build ( ) ;<CODESPLIT>Get a global integer property . This method will first try to get the value from an environment variable and if that does not exist it will look up a system property .<CODESPLIT>0
public static get Offline ) { Genomics genomics Genomics ) build ) . from Offline Auth ( auth ) ; return Paginator . References . create ( genomics ) . search ( new Search References Request ( ) . set Reference Set Id ( reference Set Id ) ) ; }<CODESPLIT>Gets VariantSetIds from a given datasetId using the Genomics API .<CODESPLIT>0
public void ( File remote Target ) { ( [ ] { local File } , remote Target Directory , " 0600 " ) ; }<CODESPLIT>Copy a local file to a remote directory uses mode 0600 when creating the file on the remote side .<CODESPLIT>1
public synchronized void throttle ( int Rpc Target ) { ( is Throttling ) { ; } long high Target = ( long ) ( Rpc Target . 2 ) ; long low Target = ( long ) ( Rpc Target 0 . 8 ) ; set Current In Flight Rpcs ( get Current In Flight Rpcs ( ) / ) ; Runnable = Runnable ( ) { @ Override public void run ( ) { long mean = get Mean ( stats . get Timer ( ) ) ; ( mean >= Rpc Target ) { reduce Parallelism ( mean , absolute In Flight Rpcs * 3 / 10 ) ; } else if ( mean Latency Ms >= high Target Ms ) { reduce Parallelism ( mean Latency Ms , absolute Max In Flight Rpcs / 10 ) ; } else if ( get Mean Ms ( stats . get Throttling Timer ( ) ) > 1 ) { if ( mean Latency Ms <= low Target Ms ) { increase Parallelism ( mean Latency Ms , absolute Max In Flight Rpcs / 20 ) ; } increase Parallelism ( mean Latency Ms , absolute Max In Flight Rpcs / 50 ) ; } } } private long get Mean Ms ( Timer timer ) { return Time Unit . NANOSECONDS . to Millis ( ( long ) timer . get Snapshot ( ) . get Mean ( ) ) ; } private void reduce Parallelism ( long mean Latency Nanos , int step ) { int minimum Rpc Count = Math . max ( absolute Max In Flight Rpcs / 100 , 1 ) ; int new Value = Math . max ( current In Flight Max Rpcs - step , minimum Rpc Count ) ; set Parallelism ( mean Latency Nanos , " Reducing " , new Value ) ; } private void increase Parallelism ( long mean Latency Nanos , int increment Step ) { int new Value = Math . min ( current In Flight Max Rpcs + increment Step , absolute Max In Flight Rpcs ) ; set Parallelism ( mean Latency Nanos , " Increasing " , new Value ) ; } private void set Parallelism ( long mean Latency Nanos , String type , int new Value ) { int current Value = get Current In Flight Max Rpcs ( ) ; if ( new Value != current Value ) { set Current In Flight Max Rpcs ( new Value ) ; } } } ; is Throttling = true ; }<CODESPLIT>Enable an experimental feature that will throttle requests made from {<CODESPLIT>1
public static Unchecked Binary from Base ( String base ) { char = base . char At ( ) ; ( == ) = ' ; if ( c == ' ' ) c = ' ' ; if ( c == ' ' ) c = ' ' ; normalized Base 64 . append ( c ) ; } while ( normalized Base 64 . length ( ) % 4 != 0 ) { normalized Base 64 . append ( ' ' ) ; } byte [ ] bytes = Datatype Converter . parse Base 64 Binary ( normalized Base 64 . to String ( ) ) ; return Binary . from ( bytes ) ; }<CODESPLIT>Reads standard and URL / filename - safe Base 64 dialects as described in RFC 4686 . Additionally it accepts not Base 64 encoded strings without padding or allows to use dot character ( . ) as padding character .<CODESPLIT>1
boolean is Match ( , Object ) { equals ( this . bean Type ) && id Match ( id ) ; }<CODESPLIT>Checks that the supplied parameter is not null . Throws a {<CODESPLIT>0
private ( value ) { ; ( value ) { priority Types Locale get ( , Locale PRIORITY TYPES ) ; int priority = value . get Value ( ) ; if ( priority < Priority . LOWEST ) { priority = Priority . LOWEST ; } else { if ( priority > Priority . DO _ NOT _ LEVEL ) { priority = Priority . DO _ NOT _ LEVEL ; } } priority /= 100 ; } return ( result ) ;<CODESPLIT>This method is called to format a task type .<CODESPLIT>0
public static Memcpy Peer Udeviceptr dst Device Ucontext dst Udeviceptr Device Ucontext Byte ) { return cu Memcpy Peer Native ( dst Device , dst Context , src Device , src Context , Byte Count ) ; }<CODESPLIT>Copies device memory between two contexts .<CODESPLIT>1
private Centric has ( Titan Object ) { check Not ( ) ; check Not ( ) ; check ( Valid ( condition ) , " Invalid condition : % s " , condition ) ; constraints . add ( new Predicate Condition <> ( key , predicate , condition ) ) ; return this ; }<CODESPLIT>/ * --------------------------------------------------------------- Query Execution ---------------------------------------------------------------<CODESPLIT>0
private void Replicas ) { execute ) -> { ( ) > this . term . term ( ) ) { this . term = term ; consumer . register ( term . primary ( ) . member Id ( ) ) ; } } ) ; }<CODESPLIT>Handles a replica change event .<CODESPLIT>1
public void ( translation ) { 03 translation get ( ) ; this . m 13 += translation . get Y ( ) ; this . m 23 += translation . get Z ( ) ;<CODESPLIT>Translate the position .<CODESPLIT>1
public static get Float Value Value ) { return Math . min ( max Value , Math . max ( min Value , value ) ) ; }<CODESPLIT>Return a float value within the range . <p > This is just a wrapper for Math . min () and Math . max () . This may be useful if you feel it confusing ( Which is min and which is max? ) . < / p ><CODESPLIT>1
public void ( ) { Object preferences To Gdx Sets ( ) ; ( Entry , Preference < ? > > preference : preferences ) { preferences To Flush . add ( preferences File ) ; preference . value . save ( preference . key , preferences File ) ; } for ( final Preferences preferences File : preferences To Flush ) { preferences File . flush ( ) ; } }<CODESPLIT>Saves all current preferences . This is a reasonably heavy operation as it flushes all preferences files - by default this is done once before the application is closed .<CODESPLIT>1
public void unsubscribe ( Subscription T subscription ) { T = subscription . get Token ( ) ; . log ( Level . FINER , Remote { 0 } { }" , Object [ { this . name , } ) ; ( ) { this . transport . register Error Handler ( null ) ; } else if ( token instanceof Tuple 2 ) { this . tuple To Handler Map . remove ( token ) ; } else if ( token instanceof Class ) { this . msg Type To Handler Map . remove ( token ) ; } else { } }<CODESPLIT>Unsubscribes a handler .<CODESPLIT>1
public static Dna ( Sequence sequence ) { check Not ( sequence ) ; DNA create DNA ( sequence get Value ( ) replace All ( "\\ s +" , "" ) ) ; }<CODESPLIT>Convert the specified HML Sequence element into a DNA symbol list .<CODESPLIT>1
private boolean process Arguments ( String [ ] args ) { ( args . < 1 ) { . err . println ( . get ( argument _ needed ) ) ; return false ; } set Custom Message File From Environment ( ) ; Pattern arg Pattern = Pattern . compile ( "--?(.*)" ) ; for ( int = 0 ; < args . ; ) { Matcher arg Match = arg Pattern . ( args [ ] ) ; ( arg Match . ( ) ) { ( arg Match . group ( 1 ) ) { v : ( 1 < args . ) { } } else { out Writer . println ( . get ( display _ help ) ) ; ( Version ( Version . UNSUPPORTED _ VERSION ) ) ; } } else { out Writer . println ( . get ( display _ help ) ) ; Exception ( messages . get ( " version _ argument _ expected " ) ) ; } break ; case " m " : case " mode " : if ( i + 1 < args . length ) { expanded = mode . equals ( " exp " ) ; } else { out Writer . println ( messages . get ( " display _ help " ) ) ; throw new Runtime Exception ( messages . get ( " mode _ argument _ expected " ) ) ; } break ; case " p " : case " profile " : if ( i + 1 < args . length ) { String profile Str = args [ ++ i ] ; try { profile = EPUB Profile . value Of ( profile Str . to Upper Case ( Locale . ROOT ) ) ; } catch ( Illegal Argument Exception e ) { System . err . println ( messages . get ( " mode _ version _ ignored " , profile Str ) ) ; } } else { out Writer . println ( messages . get ( " display _ help " ) ) ; throw new Runtime Exception ( messages . get ( " profile _ argument _ expected " ) ) ; } break ; case " s " : case " save " : keep = true ; break ; file Out = new File ( args [ ++ i ] ) ; } file Out = null ; i ++ ; } else { File path File = new File ( path ) ; if ( path File . is Directory ( ) ) { } else { file Out = new File ( path + " check . xml " ) ; } } xml Output = true ; break ; file Out = new File ( args [ ++ i ] ) ; } file Out = null ; i ++ ; } else { File path File = new File ( path ) ; if ( path File . is Directory ( ) ) { } else { file Out = new File ( path + " check . json " ) ; } } json Output = true ; break ; file Out = new File ( args [ ++ i ] ) ; } file Out = null ; i ++ ; } else { File path File = new File ( path ) ; if ( path File . is Directory ( ) ) { } else { file Out = new File ( path + " check . xmp " ) ; } } xmp Output = true ; break ; case " i " : case " info " : reporting Level = Reporting Level . Info ; break ; case " f " : case " fatal " : reporting Level = Reporting Level . Fatal ; break ; case " e " : case " error " : reporting Level = Reporting Level . Error ; break ; case " w " : case " warn " : reporting Level = Reporting Level . Warning ; break ; case " u " : case " usage " : reporting Level = Reporting Level . Usage ; break ; case " q " : case " quiet " : out Writer . set Quiet ( true ) ; break ; case " failonwarnings " : String fw = args [ i ] . substring ( "-- failonwarnings " . length ( ) ) ; fail On Warnings = ( fw . compare To ( "-" ) != 0 ) ; break ; case " r " : case " redir " : if ( i + 1 < args . length ) { file Out = new File ( args [ ++ i ] ) ; } break ; case " c " : case " custom Messages " : if ( i + 1 < args . length ) { String file Name = args [ i + 1 ] ; if ( " none " . compare To ( file Name . to Lower Case ( Locale . ROOT ) ) == 0 ) { custom Message File = null ; } else if ( ! file Name . starts With ( "-" ) ) { custom Message File = new File ( file Name ) ; use Custom Message File = true ; } else { display Help ( ) ; return false ; } } break ; case " l " : case " list Checks " : if ( i + 1 < args . length ) { if ( ! args [ i + 1 ] . starts With ( "-" ) ) { list Checks Out = new File ( args [ ++ i ] ) ; } else { list Checks Out = null ; } } list Checks = true ; break ; case " locale " : if ( i + 1 < args . length ) { if ( args [ i + 1 ] . starts With ( "-" ) ) { display Help ( ) ; return false ; } else { String lang Tag = args [ ++ i ] ; this . locale = Locale . for Language Tag ( lang Tag ) ; this . messages = Messages . get Instance ( this . locale ) ; } } else { System . err . println ( String . format ( messages . get ( " missing _ locale " ) ) ) ; display Help ( ) ; return false ; break ; case " h " : case "?" : case " help " : display Help ( ) ; break ; case " version " : display Version ( ) ; break ; display Help ( ) ; return false ; else { if ( path == null ) { else { display Help ( ) ; return false ; if ( ( xml Output && xmp Output ) || ( xml Output && json Output ) || ( xmp Output && json Output ) ) { System . err . println ( messages . get ( " output _ type _ conflict " ) ) ; return false ; if ( path != null ) { String Builder sb = new String Builder ( ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { if ( path . char At ( i ) == ' ' ) { sb . append ( ' ' ) ; else { sb . append ( path . char At ( i ) ) ; path = sb . to String ( ) ; if ( path == null ) { if ( list Checks ) { return true ; else { System . err . println ( messages . get ( " no _ file _ specified " ) ) ; return false ; else if ( path . matches ( ".+\\.[ Ee ][ Pp ][ Uu ][ Bb ]" ) ) { if ( mode != null || version != EPUB Version . VERSION _ 3 ) { System . err . println ( messages . get ( " mode _ version _ ignored " ) ) ; mode = null ; else if ( mode == null && profile == null ) { out Writer . println ( messages . get ( " mode _ required " ) ) ; return false ; return true ;<CODESPLIT>recursively get the values stored for the given {<CODESPLIT>0
public move ( Rel Position ) { Logical Position POSITION ; get ( ) move ( Rel Position ) ; Current Position Position ; ( Rel Position ) Current Position ; ( Rel Position DB Constants . LAST _ RECORD ) { if ( m _ i End Of File Index == UNKNOWN _ POSITION ) { i Current Position = UNKNOWN _ POSITION ; } else i Current Position = m _ i End Of File Index - 1 ; } else i Current Position += i Rel Position ; if ( ( record == null ) && ( ( i Rel Position == DB Constants . FIRST _ RECORD ) || ( i Rel Position == DB Constants . NEXT _ RECORD ) ) ) m _ i End Of File Index = i Current Position ; else { if ( i Current Position != - 1 ) this . add Record Reference ( i Current Position ) ; return record ; }<CODESPLIT>Find this bookmark in one of the lists .<CODESPLIT>0
public void register ( long index Runnable ) { Runnable index Queries compute If ( index -> new Linked List <> ( ) ) ; queries . add ( query ) ; }<CODESPLIT>Registers a causal session query .<CODESPLIT>0
public static populate ( command , String ... ) { cli ( command , Default Factory ( ) ) ; cli . parse ( args ) ; return command ; }<CODESPLIT><p > Convenience method that initializes the specified annotated object from the specified command line arguments . < / p > <p > This is equivalent to < / p > <pre > CommandLine cli = new CommandLine ( command ) ; cli . parse ( args ) ; return command ; < / pre ><CODESPLIT>1
public Event get ( ) { ( ) { Event ; } { Event [ ] events = new Log Event [ m Log Events . size ( ) ] ; return ( Log Event [ ] ) m Log Events . to Array ( events ) ;<CODESPLIT>Finds a template based on the given URI . If path ends in a slash revert to loading default template . If default not found or not specified return null .<CODESPLIT>0
@ Ensures ( ) protected instrument With Contracts ( , Contract contracts ) { Class Reader reader Class Reader ( ) ; Class Writer writer new Non Loading Class Writer ( reader , Class Writer . COMPUTE _ FRAMES | Class Writer . COMPUTE _ MAXS ) ; reader . accept ( adapter , Class Reader . EXPAND _ FRAMES ) ; return writer . to Byte Array ( ) ; }<CODESPLIT>Processes the specified reader and returns extracted contracts .<CODESPLIT>0
public void dissociate ( ) { ( Trace Component Tracing ( ) ( ) ) { Sib Tr ( , dissociate ) ; } final Object object = iterator . next ( ) ; if ( object instanceof Jms Jca Session Impl ) { ( ( Jms Jca Session Impl ) object ) . dissociate ( ) ; iterator . remove ( ) ; } } if ( Trace Component . is Any Tracing Enabled ( ) && TRACE . is Entry Enabled ( ) ) { Sib Tr . exit ( this , TRACE , " dissociate Connections " ) ; }<CODESPLIT>Returns the current global or container local transaction if any for this managed connection . If there is currently no transaction associated with this managed connection calls <code > lazyEnlist< / code > to ensure that one has not been started .<CODESPLIT>0
public ads adwords 201809 . cm . String _ String Map Entry [ ] get Display Value ( ) { return display Value ; }<CODESPLIT>Gets the parentDimensionValue value for this ProductBiddingCategoryData .<CODESPLIT>0
public Void delete Instance Async ( instance ) { instance Instance ( instance ) ; bigtable Instance Request request bigtable Instance Request new Builder ( ) . set Name ( instance Name ) . build ( ) ; return Api Futures . transform ( stub . delete Instance Callable ( ) . future Call ( request ) , new Api Function < Empty , Void > ( ) { @ Override public Void apply ( Empty input ) { return null ; } } , More Executors . direct Executor ( ) ) ; }<CODESPLIT>Asynchronously lists all of the instances in the current project .<CODESPLIT>0
boolean contains ) { ) ; ( ) < normalized Root . length ( ) ) return false ; return normalized Path . region Matches ( 0 , normalized Root , 0 , normalized Root . length ( ) ) ; }<CODESPLIT>Check if the provided path is contained within this root s hierarchy .<CODESPLIT>1
private static boolean check Validity ( Client from expected ) { from >= client . get State ( ) == expected ; }<CODESPLIT>Check if the client is in a valid state .<CODESPLIT>1
public Request Vpc Classic Request get Dry Run Request ) Request Vpc Classic Request request Vpc Classic Request Marshaller ) marshall ) ; request add Parameter " Dry Run " , Boolean . to String ( true ) ) ; return request ; }<CODESPLIT><p > One or more filters to limit the type of sessions returned by the request . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setFilters ( java . util . Collection ) } or { @link #withFilters ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
private String generate Method Key ( Ct Method method ) throws Not Found { String class Name method get Class ( ) get Name ( ) ; String method Name method . get Name ( ) ; return Test Method . generate Method Key ( class Qualified Name , method Simple Name , arg Class Qualified Names ) ; }<CODESPLIT>( for example when class of method argument type has not been loaded by class loader )<CODESPLIT>0
public static void ( ) { ( Factory . indirect Get ( ) , format , arguments ) ; }<CODESPLIT>Info等级日志，小于Warn<br > 由于动态获取Log，效率较低，建议在非频繁调用的情况下使用！！<CODESPLIT>1
private static find Option ) { Command Line Argument . values ( ) ) { if ( command Line Argument . match ( arg ) ) { return command Line Argument ; } } return null ; }<CODESPLIT>Not needed until workers support dynamic removal ( currently reload required )<CODESPLIT>0
public void add Summary Content ) { Content get MEMBER ) ; Content Content utils ) get Text ( " doclet . Fields _ Inherited _ From _ Class " ) : configuration . get Text ( " doclet . Fields _ Inherited _ From _ Interface " ) ) ; Content label Heading = Html Tree . HEADING ( Html Constants . INHERITED _ SUMMARY _ HEADING , label ) ; label Heading . add Content ( Contents . SPACE ) ; label Heading . add Content ( class Link ) ; inherited Tree . add Content ( label Heading ) ; }<CODESPLIT>{<CODESPLIT>0
public static make Link ) { get Current Link ) contains Parameter ) ) { += ( link . contains ( "?" ) ? "&" : "?" ) + PARAM _ REMOTE _ CONNECTION + "=" + get Current Remote Connection Link ( ) ; } return link ; }<CODESPLIT>Adds remote connection parameter to link GET query if parameter yet not present in this link .<CODESPLIT>1
public static Object convert ( String property Name , String , Class , Class property Editor Class ) throws { { ( ) { ; } ( property Editor Class ) { get Value From Bean Property Editor ( , property Name , , property Editor Class ) ; } ( . equals ( Boolean . class ) . equals ( Boolean . TYPE ) ) { " ; return new Boolean ( s ) ; } else if ( t . equals ( Byte . class ) || t . equals ( Byte . TYPE ) ) { return new Byte ( s ) ; } else if ( t . equals ( Character . class ) || t . equals ( Character . TYPE ) ) { return s . length ( ) > 0 ? new Character ( s . char At ( 0 ) ) : null ; } else if ( t . equals ( Short . class ) || t . equals ( Short . TYPE ) ) { return new Short ( s ) ; } else if ( t . equals ( Integer . class ) || t . equals ( Integer . TYPE ) ) { return new Integer ( s ) ; } else if ( t . equals ( Float . class ) || t . equals ( Float . TYPE ) ) { return new Float ( s ) ; } return new Long ( s ) ; } return new Double ( s ) ; } else if ( t . equals ( String . class ) ) { return s ; } else if ( t . equals ( java . io . File . class ) ) { return new java . io . File ( s ) ; } return new Object [ ] { s } ; } else { return get Value From Property Editor Manager ( t , property Name , s ) ; } } catch ( Exception ex ) { throw new Jsp Core Exception ( ex ) ; } }<CODESPLIT>{<CODESPLIT>0
public boolean is Instance ( ) { boolean ; ( Instance ) { } ( get Parent Type ( ) != null ) { ret = get Parent Type ( ) . is General Instance ( ) ; } return ret ; }<CODESPLIT>Getter method for the instance variable { @link #generalInstance } .<CODESPLIT>1
public List < Cms Property Config > get Property Configuration ( ) { Cms ADE Config Data parent Data = parent ( ) ; List < Cms Property Config > parent Properties ; ( ( parent Data != ) ! _ data . is Discard Inherited Properties ( ) ) { parent Properties = parent Data . get Property Configuration ( ) ; } { parent Properties = Collections . List ( ) ; } return result ; }<CODESPLIT>Gets the configuration for the available properties . <p ><CODESPLIT>1
public static void remove Consecutive Separators ( Popup popup ) { ( is Popup Separator ( popup Menu . get Component ( i ) ) ) { if ( is Popup Menu Separator ( popup Menu . get Component ( i - 1 ) ) ) { popup Menu . remove ( i ) ; i -- ; } } } }<CODESPLIT>Removes all top separators from the given pop up menu . <p > For example calling the method on the given menu : <pre > Separator Separator Menu Entry Separator Menu Entry Separator Menu Entry < / pre > would result in : <pre > Menu Entry Separator Menu Entry Separator Menu Entry < / pre ><CODESPLIT>0
protected void write Numbers ( Output Stream ) { ( ) { write ( Rtf LIST _ LEVEL _ NUMBER ) ; result . write ( int To Byte Array ( list Level ) ) ; }<CODESPLIT>Write the indentation values for this <code > RtfList< / code > .<CODESPLIT>0
private String build Internal Form ( ) { Cms ; boolean internal ; { get Cms ( ) . read ( get Param ( ) , Cms Filter . ALL ) ; internal . is Internal ( ) ; } ( Cms ) { . error ( . get ( ) ) ; } ( ( ) ( . is File ( ) ) ) { . append ( "< border =\" 0 =\" %\">\ ) ; . append ( "< tr >\ ) ; . append ( "\ t < td class =\" dialogpermissioncell \">" ) . append ( key ( Messages . GUI _ PERMISSION _ INTERNAL _ 0 ) ) ; result . append ( " < input type =\" checkbox \" name =\"" ) ; result . append ( PARAM _ INTERNAL ) ; result . append ( "\" value =\" true \"" ) ; if ( internal ) { result . append ( " checked =\" checked \"" ) ; } if ( ! get Editable ( ) ) { result . append ( " disabled =\" disabled \"" ) ; } result . append ( " ></ td >\ n " ) ; if ( get Editable ( ) ) { } result . append ( "</ td >\ n " ) ; result . append ( "</ tr >\ n " ) ; result . append ( "</ table >\ n " ) ; set Param Action ( DIALOG _ INTERNALUSE ) ; set Param Type ( null ) ; set Param Name ( null ) ; result . append ( params As Hidden ( ) ) ; result . append ( "</ form >\ n " ) ; } return result . to String ( ) ; }<CODESPLIT>Builds a String with HTML code to display the form to add a new access control entry for the current resource . <p ><CODESPLIT>1
public Integration with Integration Responses ( , Integration integration Responses ) { set Integration Responses ( integration Responses ) ; this ; }<CODESPLIT><p > Specifies the integration s responses . < / p > <div class = remarks > <p / > <h4 > Example : Get integration responses of a method< / h4 > <h5 > Request< / h5 > <p / ><CODESPLIT>1
public static String get Style ( Cms Resource state ) { String state Style = ; ( state ) { ( state . is Deleted ( ) ) { state Style = Cms Theme . STATE _ DELETED ; } else if ( state . is New ( ) ) { } else if ( state . is Changed ( ) ) { } } return state Style ; }<CODESPLIT>Gets the CSS style name for the given resource state . <p ><CODESPLIT>1
public Closeable Master Client acquire Master Client ) Closeable Master Client Master Client acquire ( ) ) { @ Override public void close ( ) { m Block Master Client Pool . release ( get ( ) ) ; } } ; }<CODESPLIT>Releases a block worker client to the client pools .<CODESPLIT>0
public void set Recommendations Reservation Purchase Recommendation recommendations ) { recommendations ) { recommendations ; ; } this . recommendations = new java . util . Array List < Reservation Purchase Recommendation > ( recommendations ) ; }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public static find findme tolerance ) get ) ; >= findme Width ) { final int image Height = image . get Height ( ) ; final int findme Height = findme . get Height ( ) ; if ( image Height >= findme Height ) { return find Image ( get RGB ( image ) , image Width , image Height , get RGB ( findme ) , findme Width , findme Height , tolerance ) ; } } return null ; }<CODESPLIT>Gets the RGB pixels for the given image into a new array .<CODESPLIT>0
protected void fire Entry ( , value ) { ( listeners ) { ( Map , listener : this . listeners . get Listeners ( D Map Listener . class ) ) { listener . entry Removed ( key , value ) ; } } }<CODESPLIT>Fire the removal event .<CODESPLIT>1
public void set Welcome ( welcome ) { ( welcome ) { welcome Arrays . copy Of ( welcome Files , welcome Files . length ) ; } }<CODESPLIT>CHECKSTYLE : OFF<CODESPLIT>0
public static void set One ) { null ) { Configs . debug Configs = debug Configs Obj ; } if ( debug Config Absolute Class Path != null ) { Configs . debug Configs . init Configs ( Configs . debug Config Absolute Class Path ) ; } else if ( debug Configs != null ) { Configs . debug Configs . init Configs ( Configs . debug Config Absolute Class Path ) ; } }<CODESPLIT><p > Set self define debug configs . < / p > Can use self debug configs path or self class extends { @link OneProperties } .<CODESPLIT>1
public Style get Style ( String style Name ) { String style get ( style Name ) ; ( style ) { style . load Style ( this , this . client Http Request Factory , style Ref ) ; } else { return Optional . empty ( ) ; }<CODESPLIT>Retrieve the configuration of the named template .<CODESPLIT>0
public For License For License For License Request request ) { request Client Execution ( request ) ; return execute List Usage For License Configuration ( request ) ; }<CODESPLIT><p > Modifies the attributes of an existing license configuration object . A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager . Components include specifications for the license type ( Instances cores sockets VCPUs ) tenancy ( shared or Dedicated Host ) host affinity ( how long a VM is associated with a host ) the number of licenses purchased and used . < / p ><CODESPLIT>0
public Hub Consumer Group create Hub Consumer Group Group Hub ) { create Hub Consumer Group With Service Response Async ( resource Group Name , resource Name , event Hub Endpoint Name , name ) . to Blocking ( ) . single ( ) . body ( ) ; }<CODESPLIT>Add a consumer group to an Event Hub - compatible endpoint in an IoT hub . Add a consumer group to an Event Hub - compatible endpoint in an IoT hub .<CODESPLIT>1
public Constant add Constant ( Constant constant ) { Constant = ( Constant ) . get ( constant ) ; ( ) { ; } if ( m Indexed Constants != null && m Preserve Order ) { m Indexed Constants . set Size ( size + entry Count ) ; m Indexed Constants . set ( size , constant ) ; } m Constants . put ( constant , constant ) ; m Entries += entry Count ; return constant ; }<CODESPLIT>Perform an HTTP GET at the given path returning the results of the response .<CODESPLIT>0
public void visit ) { Value get ) ; Value true " ) || string Value . equals Ignore Case ( " false " ) ) { set Value ( Boolean . value Of ( string Value ) , Types . BOOLEAN ) ; } }<CODESPLIT>Booleans are not recognized by the parser but are seen as column names .<CODESPLIT>1
private Hod Result add Domain ( Iterable Name index Identifiers , Hod Result ) { String index get ( ) ; String domain ; ( Name index Identifier index Identifiers ) { domain index Identifier get Domain ( ) ; ; } } ( domain ) { domain = PUBLIC _ INDEX _ NAMES . contains ( index ) ? Resource Name . PUBLIC _ INDEXES _ DOMAIN : get Domain ( ) ; } return document . to Builder ( ) . domain ( domain ) . build ( ) ; }<CODESPLIT>Add a domain to a FindDocument given the collection of indexes which were queried against to return it from HOD<CODESPLIT>1
private initiate Resumable Upload Upload ) Batch Request http Transport create Request headers create ) headers set Content ) headers set goog resumable start ) set headers ) set Logging ) )  Request http Request build Post Request Generic ( batch Job Upload Url ) , new Empty Content ( ) ) ; Http Response response = http Request . execute ( ) ; if ( response . get Headers ( ) == null || response . get Headers ( ) . get Location ( ) == null ) { throw new Batch Job Exception ( " Initiate upload failed . Resumable upload URI was not in the response ." ) ; } return URI . create ( response . get Headers ( ) . get Location ( ) ) ; } catch ( IO Exception e ) { throw new Batch Job Exception ( " Failed to initiate upload " , e ) ; } }<CODESPLIT>Post - processes the request content to conform to the requirements of Google Cloud Storage .<CODESPLIT>0
protected get Selected Value Cms cms Cms Select Widget Option Value ) param Value Value ; Cms param Value ) ) Cms Select Widget Option option = Cms Select Widget Option . get Default Option ( select Options ) ; if ( option != null ) { param Value = option . get Value ( ) ; } return param Value ;<CODESPLIT>Returns the currently selected value of the select widget . <p ><CODESPLIT>1
public void marshall ( List Bootstrap Actions Request list Bootstrap Actions Request , Protocol Marshaller Marshaller ) { ( list Bootstrap Actions Request == ) { Sdk Client ( argument passed to marshall (...)" ) ; } { Marshaller . marshall ( list Bootstrap Actions Request . get Cluster Id ( ) , CLUSTERID _ BINDING ) ; Marshaller . marshall ( list Bootstrap Actions Request . get Marker ( ) , MARKER _ BINDING ) ; } catch ( Exception e ) { } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public static License license ( To License ) { ( Pro ( ) ) { License ( ) { @ Override public boolean initialize From ( license ) { ; @ Override public boolean Of Trial ( ) { ; @ Override public boolean Pro Trial ( ) { ; } @ Override public boolean Enterprise Trial ( ) { ; } @ Override public Hostcount ( ) { ; } @ Override public expires ( ) { get Instance ( ) ; add ( YEAR ) ; result ; } @ Override public boolean verify ( ) { return true ; } @ Override public boolean is Dr Replication Allowed ( ) { return false ; } @ Override public boolean is Dr Active Active Allowed ( ) { return false ; } @ Override public boolean is Command Logging Allowed ( ) { return false ; } @ Override public boolean is AWS Marketplace ( ) { return false ; @ Override public boolean is Enterprise ( ) { return false ; @ Override public boolean is Pro ( ) { return false ; @ Override public String licensee ( ) { return " Volt DB Community Edition User " ; @ Override public Calendar issued ( ) { Calendar result = Calendar . get Instance ( ) ; return result ; @ Override public String note ( ) { return "" ; @ Override public boolean hard Expiration ( ) { return false ; @ Override public boolean secondary Initialization ( ) { return true ; if ( license Api == null ) { return null ; File license File = new File ( path To License ) ; if ( license File . exists ( ) == false ) { return null ; if ( license Api . initialize From File ( license File ) == false ) { host Log . fatal ( " Unable to load license file : could not parse license ." ) ; return null ; try { if ( license Api . verify ( ) == false ) { return null ; catch ( License Exception lex ) { host Log . fatal ( lex . get Message ( ) ) ; return null ; return license Api ;<CODESPLIT>Simple code to copy a file from one place to another ... Java should have this built in ... stupid java ...<CODESPLIT>0
public Modify Instance modify Instance Modify Instance Request request ) { request Client Execution ( request ) ; return execute Modify Instance Event Start Time ( request ) ; }<CODESPLIT><p > Modifies the placement attributes for a specified instance . You can do the following : < / p > <ul > <li > <p > Modify the affinity between an instance and a <a href = https : // docs . aws . amazon . com / AWSEC2 / latest / UserGuide / dedicated - hosts - overview . html > Dedicated Host< / a > . When affinity is set to <code > host< / code > and the instance is not associated with a specific Dedicated Host the next time the instance is launched it is automatically associated with the host on which it lands . If the instance is restarted or rebooted this relationship persists . < / p > < / li > <li > <p > Change the Dedicated Host with which an instance is associated . < / p > < / li > <li > <p > Change the instance tenancy of an instance from <code > host< / code > to <code > dedicated< / code > or from <code > dedicated< / code > to <code > host< / code > . < / p > < / li > <li > <p > Move an instance to or from a <a href = https : // docs . aws . amazon . com / AWSEC2 / latest / UserGuide / placement - groups . html > placement group< / a > . < / p > < / li > < / ul > <p > At least one attribute for affinity host ID tenancy or placement group name must be specified in the request . Affinity and tenancy can be modified in the same request . < / p > <p > To modify the host ID tenancy placement group or partition for an instance the instance must be in the <code > stopped< / code > state . < / p ><CODESPLIT>0
public static Int > obj Int Obj Predicate ( Consumer < L Obj Int Obj Predicate < T 1 , T 2 > > consumer ) { return new L Obj Int Obj Predicate Builder ( consumer ) ; }<CODESPLIT>One of ways of creating builder . This might be the only way ( considering all _functional_ builders ) that might be utilize to specify generic params only once .<CODESPLIT>1
public get Or Create ) { get Or Create interceptors ) ; < Ejb Jar Descriptor > interceptors = new Interceptors Type Impl < Ejb Jar Descriptor > ( this , " interceptors " , model , node ) ; return interceptors ; }<CODESPLIT>If not already created a new <code > interceptors< / code > element with the given value will be created . Otherwise the existing <code > interceptors< / code > element will be returned .<CODESPLIT>1
protected static Action find Action ( E Object grammar Component , String assignment Name ) { ( Grammar is Assigned Action ( ) ) { ( . equals ( assignment Name , action . get Feature ( ) ) ) { return action ; } } } return null ; }<CODESPLIT>Replies the assignment component with the given nazme in the given grammar component .<CODESPLIT>1
public get Medium Int ( ) { get ( ) ; get ( ) ; ( is Big ) { ( 1 << 16 ) | ( b 2 << 8 ) | b 3 ; } else { return ( b 3 << 16 ) | ( b 2 << 8 ) | b 1 ; } }<CODESPLIT>Returns an unsigned three - byte medium int from the buffer at the current position<CODESPLIT>1
public void ) { { Rolling modify ) ; ldap modify dn compensating Modifications ) ; } Exception e ) { log . warn ( " Failed to rollback Modify Attributes operation , dn : " + dn ) ; } }<CODESPLIT>/ *<CODESPLIT>1
static XML ( , ) { Property ( Xml Node . Namespace . create ( uri ) , local Name ) ; }<CODESPLIT>TODO : marked deprecated by original implementor<CODESPLIT>0
public synchronized void Transaction ( ) throws Database Exception { { get Connection ( ) ; ( ! . get Auto Commit ( ) ) { . debug ( " There ' s one transaction active " ) ; return ; } . set Auto Commit ( false ) ; } catch ( final Exception ex ) { } }<CODESPLIT>Closes a { @link MappedEntity } logging a warning if an { @link Exception } is thrown . <p > It flushes before closing the { @link MappedEntity } .<CODESPLIT>0
public List . mangoo . models . get All ( ) throws Mangoo Scheduler { . Non Null ( this . quartz Scheduler , Required . SCHEDULER . to String ( ) ) ; List . mangoo . models . = Array List ( ) ; { for ( Key Key : get All Job Keys ( ) ) { List < Trigger > triggers = ( List < Trigger > ) this . quartz Scheduler . get Triggers Of Job ( job Key ) ; Trigger trigger = triggers . get ( 0 ) ; Trigger State trigger State = quartz Scheduler . get Trigger State ( trigger . get Key ( ) ) ; boolean active = ( Trigger State . NORMAL == trigger State ) ? true : false ; } } catch ( Scheduler Exception e ) { throw new Mangoo Scheduler Exception ( e ) ; } return jobs ; }<CODESPLIT>Pauses a job by a given name @param name The name of the job to pause<CODESPLIT>0
public void flush ( ) { { Outstanding Records ; ( Batch batches ) { Outstanding Records get Records ( ) ( ) ; } ( on {} batches with {} records " , batches . size ( ) , num Outstanding Records ) ; for ( Batch batch : batches ) { batch . await ( ) ; } } catch ( Exception e ) { LOG . error ( " Error happened while flushing batches " ) ; } }<CODESPLIT>This will block until all the incomplete batches are acknowledged<CODESPLIT>1
static double compute Angular Similarity Double Double ) { acos ( compute Cosine Similarity ( t 0 , t 1 ) ) / Math . PI ; }<CODESPLIT>Get the keysize . If no key size specified this will return the default key size .<CODESPLIT>0
public static boolean xor ( boolean ... array ) { ( Array . is Empty ( array ) ) { Argument ( The Array must not ) ; } boolean = ; ( boolean : array ) { } return result ; }<CODESPLIT>对Boolean数组取或<CODESPLIT>0
public static Shared User User ) Shared User > ) Context Manager . get Instance ( ) . get Shared Context ( User Context . class . get Name ( ) ) ; }<CODESPLIT>Returns the managed user context .<CODESPLIT>1
public void copy Selenium browser cookie ) browser : browser Cookies ) { Client Cookie cookie = convert Cookie ( browser Cookie ) ; cookie Store . add Cookie ( cookie ) ; } }<CODESPLIT>Converts Selenium cookie to Apache http client .<CODESPLIT>0
private In Macro Macro macro To Blocks ) { Macro macro To get ( ) , macro Block To Wrap . get Parameters ( ) , macro Block To Wrap . get Content ( ) , new Blocks , macro Block To Wrap . is Inline ( ) ) ; }<CODESPLIT>TODO : support more than strings<CODESPLIT>0
public void abort ( ) throws { ( == ) { ( " Missing executor " ) ; if ( this . closed ) { return ; this . closed = true ;<CODESPLIT>アノテーションを元にフォーマッタを作成する。<CODESPLIT>0
public Json Value general Json Value ( Point ) { String name = get Name ( ) ; Json Value json Value = wrap Value ( value ) ; return json Value ; }<CODESPLIT>Return the indicated claim value as a JsonValue<CODESPLIT>1
public get ( Temporal field ) { ( field Chrono ) { ( ( Chrono ) field ) { INSTANT Temporal ( field get method get Long instead ) ; _ SECONDS : return get Offset ( ) . get Total Seconds ( ) ; } return date Time . get ( field ) ; } return Temporal . super . get ( field ) ; }<CODESPLIT>Gets the value of the specified field from this date - time as an { @code int } . <p > This queries this date - time for the value of the specified field . The returned value will always be within the valid range of values for the field . If it is not possible to return the value because the field is not supported or for some other reason an exception is thrown . <p > If the field is a { @link ChronoField } then the query is implemented here . The { @link #isSupported ( TemporalField ) supported fields } will return valid values based on this date - time except { @code NANO_OF_DAY } { @code MICRO_OF_DAY } { @code EPOCH_DAY } { @code PROLEPTIC_MONTH } and { @code INSTANT_SECONDS } which are too large to fit in an { @code int } and throw a { @code DateTimeException } . All other { @code ChronoField } instances will throw an { @code UnsupportedTemporalTypeException } . <p > If the field is not a { @code ChronoField } then the result of this method is obtained by invoking { @code TemporalField . getFrom ( TemporalAccessor ) } passing { @code this } as the argument . Whether the value can be obtained and what the value represents is determined by the field .<CODESPLIT>1
public void relocate ( ) { int 200 , 235 ; enable Connection . set Location ( , ) ; Host . set Location ( , + 40 ) ; sql Host Field . set Location ( x + 110 , y + 40 ) ; sql Database Label . set Location ( x , y + 70 ) ; sql Database Field . set Location ( x + 110 , y + 70 ) ; sql User Label . set Location ( x , y + 100 ) ; sql User Field . set Location ( x + 110 , y + 100 ) ; sql Password Label . set Location ( x , y + 130 ) ; sql Password Field . set Location ( x + 110 , y + 130 ) ; }<CODESPLIT>A call of this method should validate the positions of the panels components .<CODESPLIT>1
public void fixate Distorted ( ) { for ( int row = 0 ; row ; row ) { Cache = get ( row , col ) ; compute Average Q ( cache ) ; model . compute Deformed ( cache , col , row ) ; } } }<CODESPLIT>Precompute the portion of the equation which only concerns the undistorted location of each point on the grid even the current undistorted location of each control point .<CODESPLIT>0
public Redis Patch get Group ) { get With Async Group Name , name ) . to Blocking ( ) . single ( ) . body ( ) ; }<CODESPLIT>Create or replace the patching schedule for Redis cache ( requires Premium SKU ) .<CODESPLIT>0
public void ( int feature ID ) { ( feature ID ) { Afplib Package . MCF 1 RG __ _ LID set CF Lid ( CF _ LID _ EDEFAULT ) ; return ; case Afplib Package . MCF 1 RG __ SECTID : set Sectid ( SECTID _ EDEFAULT ) ; return ; case Afplib Package . MCF 1 RG __ CF _ NAME : set CF Name ( CF _ NAME _ EDEFAULT ) ; return ; case Afplib Package . MCF 1 RG __ CP _ NAME : set CP Name ( CP _ NAME _ EDEFAULT ) ; return ; return ; return ; } super . e Unset ( feature ID ) ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>0
public void convert Operation Parameter ( Value Node operation , Transformation Context context ) { convert Attribute ( address , attribute Name , attribute Value , context ) ; }<CODESPLIT>{<CODESPLIT>1
public If Available Exclude get Or Create If Available ) { get available ) ; && node List . size ( ) > 0 ) { return new If Class Available Impl < Exclude < T > > ( this , " if - class - available " , child Node , node List . get ( 0 ) ) ; } return create If Class Available ( ) ; }<CODESPLIT>If not already created a new <code > if - class - available< / code > element will be created and returned . Otherwise the first existing <code > if - class - available< / code > element will be returned .<CODESPLIT>1
public static void set pool ) { pool != pool ) { shutdown ( ) ; Concurrency Tools . pool = pool ; } }<CODESPLIT>Sets thread pool to given size .<CODESPLIT>0
public Thymeleaf P set ( ) { Resolvers ( ) . clear ( ) ; message Resolvers ( ) . add ( message Resolver ) ; return this ; }<CODESPLIT><p > Sets a single message resolver for this template engine . < / p > <p > Calling this method is equivalent to calling { @link #setMessageResolvers ( Set ) } passing a Set with only one message resolver . < / p > <p > This operation can only be executed before processing templates for the first time . Once a template is processed the template engine is considered to be <i > initialized< / i > and from then on any attempt to change its configuration will result in an exception . < / p ><CODESPLIT>1
public static Gray U To Binary Gray Image Gray U Image Labels selected ) { boolean selected Blobs boolean Labels ; 0 ; i < selected . length ; i ++ ) { selected Blobs [ selected [ i ] ] = true ; } return label To Binary ( label Image , binary Image , selected Blobs ) ; }<CODESPLIT>Scans through the labeled image and adds the coordinate of each pixel that has been labeled to a list specific to its label .<CODESPLIT>0
public get Ifc Faceted Brep ( ) { ( ifc Faceted Brep ) { ifc Faceted Brep ( ) get ( Ifc 3 tc 1 Package . e NS _ URI ) . get E Classifiers ( ) . get ( 225 ) ; } return ifc Faceted Brep E Class ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>1
public void marshall ( Dominant Language Detection Job Request describe Dominant Language Detection Job Request , Protocol Marshaller protocol Marshaller ) { ( describe Dominant Language Detection Job Request == ) { Sdk Client Exception ( " argument passed to marshall (...)" ) ; } { protocol Marshaller . marshall ( describe Dominant Language Detection Job Request . get Job Id ( ) , JOBID _ BINDING ) ; } ( Exception e ) { } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public get Link ) { ) { Cms Value Wrapper Link m _ cms , m _ cms . get Site Path ( m _ resource ) ) ; } else { return "" ; } }<CODESPLIT>Gets a lazy map which maps locales to attachment beans for that locale . <p ><CODESPLIT>0
private Map Stream , repartition ( Group By name To By Mode , Parallelism ) { Map Stream , merge Map ( Parallelism ) ; ( ; i < new Parallelism ; ++ i ) { merge Map List . add ( new Hash Map <> ( ) ) ; } Map < String , List < Tuple 2 < Stream State Handle , Operator State Handle . State Meta Info > > > name To Distribute State = name To State By Mode . get By Mode ( Operator State Handle . Mode . SPLIT _ DISTRIBUTE ) ; repartition Split State ( name To Distribute State , new Parallelism , merge Map List ) ; Map < String , List < Tuple 2 < Stream State Handle , Operator State Handle . State Meta Info > > > name To Union State = name To State By Mode . get By Mode ( Operator State Handle . Mode . UNION ) ; repartition Union State ( name To Union State , merge Map List ) ; repartition Broadcast State ( name To Broadcast State , merge Map List ) ; return merge Map List ; }<CODESPLIT>Repartition SPLIT_DISTRIBUTE state .<CODESPLIT>0
private String Parameters ( Value Map String , String Parameters ) { ( Entry String , String Parameters ( ) iterator ( ) ; has Next ( ) ; ) { Entry String , String ( ) ; String Name get Key ( ) ; List < String > collected Values = entry . get Value ( ) ; sorted Encoded Parameters . put ( oauth Encode ( collected Name ) , encoded Values ) ; for ( Iterator < String > value It = collected Values . iterator ( ) ; value It . has Next ( ) ; ) { String value = value It . next ( ) ; encoded Values . add ( value != null ? oauth Encode ( value ) : "" ) ; } Collections . sort ( encoded Values ) ; } String Builder params Builder = new String Builder ( ) ; Entry < String , List < String > > entry = entry It . next ( ) ; String name = entry . get Key ( ) ; List < String > values = entry . get Value ( ) ; for ( Iterator < String > value It = values . iterator ( ) ; value It . has Next ( ) ; ) { String value = value It . next ( ) ; params Builder . append ( name ) . append ( ' ' ) . append ( value ) ; if ( value It . has Next ( ) ) { params Builder . append ( "&" ) ; } } if ( entry It . has Next ( ) ) { params Builder . append ( "&" ) ; } } return params Builder . to String ( ) ;<CODESPLIT>internal helpers<CODESPLIT>1
public void remove ( TCP end Point ) { ( Trace Component . is Tracing ( ) tc . is Entry ( ) ) { Tr . ( tc , remove : end Point . get Server ( ) ) ; } synchronized ( this ) { NB Accept Channel Selector accept = end Point To Accept . get ( end Point ) ; ( accept != ) { ( 3100 <= accept . ) { ( Trace Component . is Tracing ( ) tc . is Event ( ) ) { Tr . event ( tc , Ignoring remove call on fatal / system . exit path " ) ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) { Tr . exit ( tc , " remove Port " ) ; return ; } synchronized ( work Sync ) { if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Event Enabled ( ) ) { } accept . add Work ( work ) ; try { work Sync . wait ( ) ; } catch ( Interrupted Exception x ) { } } if ( accept == shared Accept && accept . get Usage Count ( ) <= 0 ) { shared Accept = null ; } else { if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Event Enabled ( ) ) { Tr . event ( tc , " Throwing Illegal Argument Exception " ) ; throw iae ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) { Tr . exit ( tc , " remove Port " ) ;<CODESPLIT>Removes an end point from the set of end points that we are accepting connections on . This has the effect of removing the server socket from the selector and closing it .<CODESPLIT>1
public Auditing create Or Update Async Group Auditing parameters ) create Or Update Async Group parameters ) map ( new Func 1 < Service Response < Extended Server Blob Auditing Policy Inner > , Extended Server Blob Auditing Policy Inner > ( ) { @ Override public Extended Server Blob Auditing Policy Inner call ( Service Response < Extended Server Blob Auditing Policy Inner > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Creates or updates an extended server s blob auditing policy .<CODESPLIT>0
public String , String get To ( String , String map ) { ( map ) map ( ) ; String , String map = map ; header . for Each ( ( k , v ) -> map 0 . put ( k , v ) ) ; return map 0 ;<CODESPLIT>获取指定的header值 没有返回默认值<CODESPLIT>0
public Artifact create Artifact artifact ) { repository create Artifact ( group Id , artifact Id , " RELEASE " , " jar " ) ; }<CODESPLIT>Replies the dependencies for the given artifact .<CODESPLIT>0
eclipse xtext Singleton Binding ( eager ) public Class eclipse xtext generator antlr validation Antlr Java Validator > bind Simple Antlr Java Validator ( ) { return org . eclipse . xtext . generator . parser . antlr . debug . validation . Simple Antlr Java Validator . class ; }<CODESPLIT>contributed by org . eclipse . xtext . generator . validation . JavaValidatorFragment<CODESPLIT>1
public void marshall ( Create Group Request create Group Request , Marshaller Marshaller ) { ( create Group Request ) { } { Marshaller marshall ( create Group Request get ( ) , APPLICATIONNAME BINDING ) ; Marshaller marshall ( create Group Request get Group ( ) , DEPLOYMENTGROUPNAME _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Deployment Config Name ( ) , DEPLOYMENTCONFIGNAME _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Ec 2 Tag Filters ( ) , EC 2 TAGFILTERS _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get On Premises Instance Tag Filters ( ) , ONPREMISESINSTANCETAGFILTERS _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Auto Scaling Groups ( ) , AUTOSCALINGGROUPS _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Service Role Arn ( ) , SERVICEROLEARN _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Trigger Configurations ( ) , TRIGGERCONFIGURATIONS _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Alarm Configuration ( ) , ALARMCONFIGURATION _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Auto Rollback Configuration ( ) , AUTOROLLBACKCONFIGURATION _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Deployment Style ( ) , DEPLOYMENTSTYLE _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Blue Green Deployment Configuration ( ) , BLUEGREENDEPLOYMENTCONFIGURATION _ BINDING ) ; protocol Marshaller . marshall ( create Deployment Group Request . get Load Balancer Info ( ) , LOADBALANCERINFO _ BINDING ) ; } catch ( Exception e ) { } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public void prepend @ Nonnull EJS JS @ Nonnull Has JS ) { Value Enforcer not JS JS ) ; Value Enforcer not New Handler , " New Handler " ) ; Collecting JS Code Provider a Code = m _ a Events . get ( e JS Event ) ; if ( a Code == null ) { m _ a Events . put ( e JS Event , a Code ) ; } a Code . prepend ( a New Handler ) ; }<CODESPLIT>Add an additional handler for the given JS event . If an existing handler is present the new handler is appended at front .<CODESPLIT>1
public static @ Integer , Integer Dimensions ( Input Stream is ) { check Not Null ( is ) ; Byte Buffer Buffer DECODE acquire ( ) ; ( Buffer ) { Buffer Byte Buffer ( DECODE BUFFER ) ; } Decode ; { Temp byte Buffer . array ( ) ; Bitmap Factory . decode Stream ( is , null , options ) ; return ( options . out Width == - 1 || options . out Height == - 1 ) ? null : new Pair <> ( options . out Width , options . out Height ) ; } finally { DECODE _ BUFFERS . release ( byte Buffer ) ; } }<CODESPLIT>Decodes the bounds of an image and returns its width and height or null if the size can t be determined<CODESPLIT>1
public static execute ( Request request ) { not ( request request !" ) ; Client Client create ( ) set Redirect Strategy ( new Default Redirect Strategy ( ) ) . build ( ) ; return client . execute ( request ) ; }<CODESPLIT>Execute http response .<CODESPLIT>1
private static void sort start boolean descending ) { start ) { ; } sort Array , start , middle , descending ) ; Merge . sort ( byte Array , middle + 1 , end , descending ) ; if ( descending ) { Merge . merge Descending ( byte Array , start , middle , end ) ; } else { Merge . merge ( byte Array , start , middle , end ) ;<CODESPLIT>Merge two sorted arrays into a bigger array in ascending order . This routine runs in O ( n ) time .<CODESPLIT>0
public void write Throwable ( Output Stream , Throwable value ) { write Object ( ) ; write Serialized Field ( , OM THROWABLE , value ) ; sw String Writer ( ) ; write String Field ( out , OM _ STACKTRACE , sw . to String ( ) ) ; write End Object ( out ) ; }<CODESPLIT>Encode a Throwable instance as JSON : { throwable : Base64 stackTrace : String }<CODESPLIT>1
protected String render Radio ( Context faces Context , Input ui Component , String value , boolean , boolean , boolean render Id , Integer item ) { String client Id ui Component get Client Id ( faces Context ) ; Response writer faces Context get Response ( ) ; writer start Element ( HTML INPUT ELEM , ui Component ) ; ( item Id ) { writer write Attribute ( HTML , item Id , ) ; } ( render Id ) { writer write Attribute ( HTML , client Id , ) ; writer write Attribute ( HTML TYPE _ ATTR , HTML . INPUT _ TYPE _ RADIO , null ) ; writer . write Attribute ( HTML . NAME _ ATTR , client Id , null ) ; if ( disabled ) { writer . write Attribute ( HTML . DISABLED _ ATTR , HTML . DISABLED _ ATTR , null ) ; } if ( checked ) { writer . write Attribute ( HTML . CHECKED _ ATTR , HTML . CHECKED _ ATTR , null ) ; } if ( value != null ) { writer . write Attribute ( HTML . VALUE _ ATTR , value , null ) ; } else { writer . write Attribute ( HTML . VALUE _ ATTR , "" , null ) ; } Map < String , List < Client Behavior > > behaviors = null ; if ( ui Component instanceof Client Behavior Holder ) { behaviors = ( ( Client Behavior Holder ) ui Component ) . get Client Behaviors ( ) ; long common Properties Marked = 0 L ; if ( is Common Properties Optimization Enabled ( faces Context ) ) { common Properties Marked = Common Property Utils . get Common Properties Marked ( ui Component ) ; } if ( behaviors . is Empty ( ) && is Common Properties Optimization Enabled ( faces Context ) ) { Common Property Utils . render Change Event Property ( writer , common Properties Marked , ui Component ) ; Common Property Utils . render Event Properties ( writer , common Properties Marked , ui Component ) ; Common Property Utils . render Field Event Properties Without Onchange ( writer , common Properties Marked , ui Component ) ; } else { Html Renderer Utils . render Behaviorized Onchange Event Handler ( faces Context , writer , ui Component , behaviors ) ; if ( is Common Events Optimization Enabled ( faces Context ) ) { Long common Events Marked = Common Event Utils . get Common Events Marked ( ui Component ) ; } else { Html Renderer Utils . render Behaviorized Event Handlers ( faces Context , writer , ui Component , behaviors ) ; Html Renderer Utils . render Behaviorized Field Event Handlers Without Onchange ( faces Context , writer , ui Component , behaviors ) ; } } else { if ( is Disabled ( faces Context , ui Component ) ) { writer . end Element ( HTML . INPUT _ ELEM ) ; return item Id ;<CODESPLIT>Renders the given SelectItem ( Group )<CODESPLIT>0
public Source get Source ( String Source Name ) Locator { Source Source ; { Source ( Source ) ic ( data Source Name ) ; } catch ( Naming Exception ne ) { throw new Service Locator Exception ( ne ) ; } catch ( Exception e ) { } return data Source ; }<CODESPLIT>This method obtains the topc itself for a caller<CODESPLIT>0
private void build Hosts ( , servers , , Kundera kundera ) { get ( ) ; hosts ; As String = null ; if ( external Properties != null ) { hosts = ( String ) external Properties . get ( Persistence Properties . KUNDERA _ NODES ) ; port As String = ( String ) external Properties . get ( Persistence Properties . KUNDERA _ PORT ) ; } if ( hosts == null ) { hosts = ( String ) props . get ( Persistence Properties . KUNDERA _ NODES ) ; } if ( port As String == null ) { port As String = ( String ) props . get ( Persistence Properties . KUNDERA _ PORT ) ; } if ( hosts != null && port As String != null ) { build Hosts ( hosts , port As String , this . hosts List ) ; } build Hosts ( servers , this . hosts List ) ; } }<CODESPLIT>Build host array .<CODESPLIT>1
public String get Presentation ML ( ) throws State { ( message ML == ) { } Byte Array Output Stream bout = Byte Array Output Stream ( ) ; Xml Print Stream out = Xml Print Stream ( bout ) ; out . set No Indent ( true ) ; out . set No Nl ( true ) ; message ML . as Presentation ML ( out ) ; out . close ( ) ; return bout . to String ( ) ; }<CODESPLIT>Parse a Markdown message into its MessageMLV2 representation . Generates document tree structures for serialization into output formats with the respective get () methods .<CODESPLIT>0
private void show Facebook App Error ) { Toast make get . wings _ facebook __ error _ facebook _ app ) , Toast . LENGTH _ SHORT ) . show ( ) ; }<CODESPLIT>Links an account .<CODESPLIT>0
public static GPX read ( Input Stream ) { reader ( , Mode . STRICT ) . read ( input ) ; }<CODESPLIT>Read an GPX object from the given { @code input } stream .<CODESPLIT>0
protected void _ add Row ( Connection , String table , String [ , String [ , boolean [ numeric ) throws { String = String ( 128 ) ; ( int = 0 ; . ; ) { ( 0 ) { . append ( ) ; } . append ( [ ) ; . append ( ") VALUES (" ) ; for ( int i = 0 ; i < columns . length ; i ++ ) { if ( i > 0 ) { sql . append ( ", " ) ; if ( values [ i ] == null ) { sql . append ( " NULL " ) ; else { sql . append ( ' ' ) ; sql . append ( ' ' ) ; if ( logger . is Debug Enabled ( ) ) { Prepared Statement stmt = conn . prepare Statement ( sql . to String ( ) ) ; try { int var Index = 0 ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] != null ) { var Index ++ ; if ( numeric != null && numeric [ i ] ) { else { stmt . set String ( var Index , values [ i ] ) ; stmt . execute Update ( ) ; finally { close Statement ( stmt ) ;<CODESPLIT>Get a long string which could be a TEXT or CLOB type . ( CLOBs require special handling -- this method normalizes the reading of them )<CODESPLIT>0
get Position Of Paragraph start Of Position ) { an ) { an Of Paragraph == number Of Paragraph && an Entry . start Of Sentence Position == start Of Sentence Position ) { return an Entry . next Sentence Position ; } } return - 1 ; }<CODESPLIT>get Proofreading errors of sentence out of paragraph matches from cache<CODESPLIT>0
private void Refresh ) Refreshing compare And ) )  executor submit Runnable ) Override public void run ) Value ( ) ; } finally { async Refreshing . set ( false ) ; } } } ) ; } catch ( Runtime Exception ex ) { async Refreshing . set ( false ) ; throw ex ; } } }<CODESPLIT>Invokes the callback to get a new value .<CODESPLIT>0
public Expression get ( ) { ( is Trace On tc is Entry ( ) ) Tr ( tc , get ) ; check Timer Access ( ) ; Timer task get Timer ( CACHED _ GET _ SCHEDULE ) ; Parsed Schedule Expression parsed Schedule = task Handler . get Parsed Schedule ( ) ; if ( parsed Schedule == null ) { if ( is Trace On && tc . is Entry Enabled ( ) ) Tr . exit ( tc , " get Schedule : " + ise ) ; throw ise ; } Schedule Expression schedule = EJS Container . get Default Container ( ) . iv Object Copier . copy ( parsed Schedule . get Schedule ( ) ) ; if ( is Trace On && tc . is Entry Enabled ( ) ) Tr . exit ( tc , " get Schedule : " + schedule ) ; return schedule ; }<CODESPLIT>Query whether this timer has persistent semantics .<CODESPLIT>0
public void marshall ( Operating operating , Marshaller Marshaller ) { ( operating ) { } { Marshaller marshall ( operating get ( ) , BINDING ) ; Marshaller marshall ( operating get ( ) , ID _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Type ( ) , TYPE _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Configuration Managers ( ) , CONFIGURATIONMANAGERS _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Reported Name ( ) , REPORTEDNAME _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Reported Version ( ) , REPORTEDVERSION _ BINDING ) ; protocol Marshaller . marshall ( operating System . get Supported ( ) , SUPPORTED _ BINDING ) ; } catch ( Exception e ) { } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
private static void resolve Config ( Config Config ) { String Host Config get Bound Host ( ) ; ( Host ) { String Config get Host ( ) ; ( String is ( ) ) { get Host ( ) ; Config set Host ( ) ; Host System Info . is Windows ( ) ? host : Net Utils . ANYHOST ; } else { } server Config . set Bound Host ( bound Host ) ; } if ( server Config . is Adaptive Port ( ) ) { int ori Port = server Config . get Port ( ) ; if ( port != ori Port ) { if ( LOGGER . is Info Enabled ( ) ) { LOGGER . info ( " Changed port from {} to {} because the config port is disabled " , ori Port , port ) ; } server Config . set Port ( port ) ; } } }<CODESPLIT>初始化Server实例<CODESPLIT>0
public static String blur ( int , int sigma ) { ( ) { } ( 150 ) { Argument ( Radius must lower or equal 150 ." ) ; } if ( sigma < 0 ) { throw new Illegal Argument Exception ( " Sigma must be greater than zero ." ) ; } return FILTER _ BLUR + "(" + radius + "," + sigma + ")" ; }<CODESPLIT>This filter uses a 9 - patch to overlay the image .<CODESPLIT>0
public void send ( @ Nonnull String ) { check Connected ( ) ; . send ( data ) ; }<CODESPLIT>{<CODESPLIT>0
public void throttle boolean ) ) Last 5000 ) ) ) ) observed ) ) ) ) ) ) ) ) Buckets ) sl Buckets ) ; long ec = this . End . get Execution Count ( ) - this . Start . get Execution Count ( ) ; long elsum = 0 ; for ( int i = 0 ; i < 25 ; i ++ ) { elsum += el [ i ] ; long slsum = 0 ; for ( int i = 0 ; i < 25 ; i ++ ) { slsum += sl [ i ] ; } if ( ( ( double ) ( elsum - slsum ) / ( double ) ec ) > 0 . 97 ) { long outlier Execution Duration = 0 ; long outlier Execution Count = 0 ; for ( int i = 25 ; i < 109 ; i ++ ) { outlier Execution Count += ( el [ i ] - sl [ i ] ) ; if ( i >= 100 ) outlier Execution Duration += ( el [ i ] - sl [ i ] ) * 50 l ; else outlier Execution Duration += ( el [ i ] - sl [ i ] ) ; } tuning Latency = ( double ) ( this . End . get Total Execution Duration ( ) - this . Start . get Total Execution Duration ( ) - outlier Execution Duration ) / ( double ) ( this . End . get Execution Count ( ) - this . Start . get Execution Count ( ) - outlier Execution Count ) ; } long old Rate = this . Rate ; if ( tuning Latency > this . Target Latency * 2 . 0 ) this . Rate = ( long ) ( this . Rate * 0 . 8 ) ; else if ( tuning Latency > this . Target Latency * 1 . 25 ) this . Rate = ( long ) ( this . Rate * 0 . 95 ) ; else if ( tuning Latency > this . Target Latency * 1 . 1 ) this . Rate = ( long ) ( this . Rate * 0 . 999 ) ; else if ( tuning Latency < this . Target Latency * 0 . 5 ) this . Rate = ( long ) ( this . Rate * 1 . 1 ) ; else if ( tuning Latency < this . Target Latency * 0 . 75 ) this . Rate = ( long ) ( this . Rate * 1 . 01 ) ; else if ( tuning Latency < this . Target Latency * 0 . 9 ) this . Rate = ( long ) ( this . Rate * 1 . 001 ) ; this . Start = ( Perf Counter ) this . End . clone ( ) ; this . End = Client Connection Pool . get Statistics ( this . Connection ) . get ( this . Procedure ) ; this . Last Check = System . current Time Millis ( ) ; this . Limiter . throttle ( this . Rate ) ;<CODESPLIT>Throttle the execution process and re - adjust the rate requirement on the fly . The limiter will automatically re - adjust the rate internally by using a basic { @link RateLimiter } after analysis of the latency data gathered from the performance tracking .<CODESPLIT>1
private Print Stream create Output Stream ( ) { ( output Filename ) { { File Output Stream fout = File Output Stream ( output Filename , false ) ; ( encoding ) { return Print Stream ( bos , false , encoding ) ; } { return Print Stream ( bos , false ) ; } } ( Exception e ) { } } is System Out = true ; if ( encoding != null ) { try { return new Print Stream ( System . out , false , encoding ) ; } catch ( Unsupported Encoding Exception e ) { } } return System . out ; }<CODESPLIT>Utility method to skip a given amount of bytes from the input stream . This will return the index after the skip ( which may or may not be able to skip the entire requested amount ) .<CODESPLIT>0
public static boolean are Not Empty ( String ... ) { boolean ; ( . 0 ) { } { for ( String value : values ) { result &= ! is Empty ( value ) ; } } return result ;<CODESPLIT>检查指定的字符串列表是否不为空。<CODESPLIT>1
public static String get ( Http Request request ) { String Path request get Path ( ) ; String context Path request get Context Path ( ) ; ( Path ( ) <= ) { context Path Path ; } int context Path Len context Path . length ( ) ; final String request URI = request . get Request URI ( ) ; final char [ ] request Uri Chars = request URI . to Char Array ( ) ; final String Builder servlet URI = new String Builder ( context Path ) ; int request Uri Char Index = context Path Len ; for ( char ch : servlet Path . to Char Array ( ) ) { if ( ch == ' ' ) { servlet URI . append ( ' ' ) ; request Uri Char Index += 1 ; } } return servlet URI . to String ( ) ;<CODESPLIT>Get request s servlet URI encoded based on results from { @link HttpServletRequest#getContextPath () } and { @link HttpServletRequest#getRequestURI () } which are both encoded URI / path and { @link HttpServletRequest#getServletPath () } which is DECODED path . We cannot just concatenate context path and servlet path to get the proper result because of these encoding / decoding differences especially if the Servlet path contains encoded characters . @param request @return servlet URI ( meant to be equivalent to contextPath + URLEncoded ( servletPath ))<CODESPLIT>1
public void set ( ) { ; ( . HTML . equals ( this . mode ) ) { this . case Sensitive = false ; } }<CODESPLIT>This method will try to avoid creating new strings for each structure name ( element / attribute )<CODESPLIT>0
private void create Map ( ) { ( ) ; Map String , Summarized sub Map Map String , Summarized ( ) ; sub Map ( Suite Summary , Suites ) ; sub Map ( Test Summary , Tests ) ; sub Map ( Classwise Summary , ) ; sub Map ( Groupwise Summary , Groups ) ; Map Summarized Summary = new Report Map < Summarized Data > ( Report Sheet Names . TESTSUMMARYREPORT . get Name ( ) , sub Report Map , 0 ) ; full Report Map . add ( test Summary Report ) ; List < Summarized Data > groups Clone = new Array List < Summarized Data > ( l Groups ) ; List < Summarized Data > class Data ; Summarized Data na Group Data = new Summarized Data ( ) ; na Group Data . sets Name ( Test Case Result . NA ) ; groups Clone . add ( na Group Data ) ; sub Report Map = new Linked Hash Map < String , List < Summarized Data > > ( ) ; for ( Summarized Data group : groups Clone ) { String s Group Name = group . gets Name ( ) ; class Data = new Array List < Summarized Data > ( ) ; for ( String s Group Class Name : mp Group Class Data . key Set ( ) ) { if ( s Group Class Name . substring ( 0 , s Group Name . length ( ) ) . equals ( s Group Name ) ) { class Data . add ( mp Group Class Data . get ( s Group Class Name ) ) ; } } sub Report Map . put ( s Group Name , class Data ) ; } Report Map < Summarized Data > second Report = new Report Map < Summarized Data > ( Report Sheet Names . GROUPSUMMARYREPORT . get Name ( ) , sub Report Map , 0 ) ; full Report Map . add ( second Report ) ; Map < String , List < List < String > > > sub Detail Report Map = new Linked Hash Map < String , List < List < String > > > ( ) ; sub Detail Report Map . put ( " Passed TC List " , tc Passed Data ) ; sub Detail Report Map . put ( " Failed TC List " , tc Failed Data ) ; sub Detail Report Map . put ( " Skipped TC List " , tc Skipped Data ) ; Report Map < List < String > > third Report = new Report Map < List < String > > ( Report Sheet Names . TESTCASEREPORT . get Name ( ) , sub Detail Report Map , 1 ) ; full Report Map . add ( third Report ) ; lst Defect Reports . put ( " Defect Summary " , tc Defect Data ) ; full Report Map . add ( fourth Report ) ; Base Report < List < String > > b R = ( Base Report < List < String > > ) full Report Map . get ( full Report Map . size ( ) - 1 ) . get Generated Report ( ) . iterator ( ) . next ( ) ; b R . set Col Titles ( ls Titles ) ; fifth Test Output Sub Report Map . put ( " Test Output " , tc Output Data ) ; full Report Map . add ( fifth Report Sheet ) ; logger . exiting ( ) ; }<CODESPLIT>Generates all summarized counts for various reports<CODESPLIT>0
public Processor create Processor ( Context Context ) throws { Web Module ( ( Web App Config Extended ) ( Context get Web App Config ( ) ) ) get ( ) ; Jax Rs Module jax Rs Module Jax Rs get Jax Rs Module ( ) ; ( jax Rs Module ) { ; } Non Persistent overlay Context get Module Container ( ) ( Non Persistent class ) ; Jax Rs Module jax Rs Module ( Jax Rs Module ) overlay . get From Cache ( Jax Rs Module Info . class ) ; if ( jax Rs Module Info == null || jax Rs Module Info . endpoint Info Size ( ) == 0 ) { if ( tc . is Debug Enabled ( ) ) { Tr . debug ( tc , " No JAX - RS service is found in the web module , will not create web service processor " ) ; } return null ; } Container publisher Module Container = servlet Context . get Module Container ( ) ; publisher Context . set Attribute ( Jax Rs Server Constants . SERVLET _ CONTEXT , servlet Context ) ; Web App web App = ( Web App ) servlet Context ; publisher Context . set Attribute ( Jax Rs Constants . COLLABORATOR , web App . get Collaborator Helper ( ) . get Web App Name Space Collaborator ( ) ) ; Endpoint Publisher endpoint Publisher = endpoint Publisher SR . get Service With Exception ( ) ; for ( Endpoint Info endpoint Info : jax Rs Module Info . get Endpoint Infos ( ) ) { endpoint Publisher . publish ( endpoint Info , publisher Context ) ; } for ( Jax Rs Web App Configurator jax Rs Web App Configurator : jax Rs Web App Configurators ) { jax Rs Web App Configurator . configure ( jax Rs Module Info , servlet Context . get Web App Config ( ) ) ; } return new Jax Rs Extension Processor ( servlet Context ) ; }<CODESPLIT>{<CODESPLIT>1
private void Every ( visitor ) { get From ( ) ; ( ) ; ( ; ; ) { get ( get ( ) , ) ; ( ) State Exception ( " Edge " + edge Ids . get ( i ) + " was empty when requested with node " + tmp Node + ", array index :" + i + ", edges :" + edge Ids . size ( ) ) ; tmp Node = edge Base . get Base Node ( ) ; edge Base = graph . get Edge Iterator State ( edge Base . get Edge ( ) , tmp Node ) ; visitor . next ( edge Base , i , prev Edge Id ) ; prev Edge Id = edge Base . get Edge ( ) ; } visitor . finish ( ) ; }<CODESPLIT>Returns the list of all edges .<CODESPLIT>0
public static guess fkeys boolean Quote check ) { guess fkeys GUESS _ INFO , GUESS _ SEP , single Quote , check Header , GUESS _ COL _ CNT , null , new Parse Writer . Parse Err [ 0 ] ) ) ; }<CODESPLIT>Discover the parse setup needed to correctly parse all files . This takes a ParseSetup as guidance . Each file is examined individually and then results merged . If a conflict exists between any results all files are re - examined using the best guess from the first examination .<CODESPLIT>0
public static boolean ) { Boolean Of get Configuration Keys . METRICS _ ENABLED _ KEY , Configuration Keys . DEFAULT _ METRICS _ ENABLED ) ) ; }<CODESPLIT>Check whether metrics collection and reporting are enabled or not .<CODESPLIT>1
static , Dao , create Dao ( Source Source , Class clazz ) throws { return new Base Dao Impl < T , ID > ( connection Source , clazz ) { } ; }<CODESPLIT>Helper method to create a Dao object without having to define a class . Dao classes are supposed to be convenient but if you have a lot of classes they can seem to be a pain .<CODESPLIT>0
public void set ( String timecode ) Timecode Timecode { clear ( ) ; set Hours ( get Token ( timecode , ) ) ; set Minutes ( get Token ( timecode , ) ) ; set ( get Token ( timecode , 2 ) ) ; set Frames ( get Token ( timecode , ) ) ; ( Samples ( ) ) { { set Frames Per ( ) ; } } } normalize ( ) ; }<CODESPLIT>Sets the object based on a string in the form HH : MM : SS : FF<CODESPLIT>1
private void extract ( Json Object ) { Json Object get As Json Object ( ) ; ( ) { Json = meta . get As Json Primitive ( " msg " ) ; if ( msg != null ) { this . message = msg . get As String ( ) ; return ; } } Json Primitive error = object . get As Json Primitive ( " error " ) ; if ( error != null ) { return ; } }<CODESPLIT>Performs an XAuth authentication .<CODESPLIT>0
public static update nitro gslbparameter ) { gslbparameter updateresource gslbparameter ) ; updateresource ldnsentrytimeout = resource . ldnsentrytimeout ; updateresource . rtttolerance = resource . rtttolerance ; updateresource . ldnsmask = resource . ldnsmask ; updateresource . ldnsprobeorder = resource . ldnsprobeorder ; updateresource . dropldnsreq = resource . dropldnsreq ; return updateresource . update _ resource ( client ) ; }<CODESPLIT>Use this API to fetch lbvserver_tmtrafficpolicy_binding resources of given name .<CODESPLIT>0
protected synchronized void activate ( Context context , Map String , Object ) { String Name ( String ) . get ( Name ) ; String Value ( String ) . get ( value ) ; boolean ( Boolean ) . get ( ) ; ( Name Name . is Empty ( ) Value Value . is Empty ( ) ) { ( Trace Component . is Tracing ( ) tc . is Debug Enabled ( ) ) { return ; String value = original Value ; if ( decode ) { try { value = Password Util . decode ( original Value ) ; } catch ( Exception e ) { Tr . error ( tc , " jndi . decode . failed " , original Value , e ) ; Object parsed Value = Literal Parser . parse ( value ) ; String value Class Name = parsed Value . get Class ( ) . get Name ( ) ; final Object service Object = decode ? new Decode ( original Value ) : parsed Value ; Dictionary < String , Object > properties For Jndi Service = new Hashtable < String , Object > ( ) ; properties For Jndi Service . put ( " osgi . jndi . service . name " , jndi Name ) ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Debug Enabled ( ) ) { this . service Registration = context . register Service ( value Class Name , service Object , properties For Jndi Service ) ;<CODESPLIT>Registers the JNDI service for the supplied properties as long as the jndiName and value are set<CODESPLIT>1
public , get WMI Object ( WMI wmi ) { get WMI Object List ( wmi Class . get Name ( ) ) ; }<CODESPLIT>Query a list of object data for an specific class <br ><CODESPLIT>1
public static void close Transport ) { { Connected ) ) . close ( ) ; } catch ( Throwable e ) { Exception Util . rethrow If Necessary ( e ) ; } }<CODESPLIT>close Writer without a Exception<CODESPLIT>1
public static Element Matcher Junction is Parent Of ( ) { BOOTSTRAP _ CLASSLOADER ? Element Matchers . < T > is Bootstrap Class Loader ( ) : new Class Loader Parent Matcher < T > ( class Loader ) ; }<CODESPLIT>Matches all class loaders in the hierarchy of the matched class loader against a given matcher .<CODESPLIT>0
public void marshall ( Batch Get Object Attributes Response batch Get Object Attributes Response , Protocol Marshaller protocol Marshaller ) { ( batch Get Object Attributes Response == ) { Sdk Client Exception ( " Invalid argument passed to marshall (...)" ) ; } { protocol Marshaller . marshall ( batch Get Object Attributes Response . get Attributes ( ) , ATTRIBUTES _ BINDING ) ; } ( Exception e ) { } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public void handle Input Stream ( final Input Stream is ) throws IO { LOG . ( " Handling input stream ." ) ; final Output Stream os = File Output Stream ( this . _ file ) ; { LOG . ( " Wrote " bytes Written " to file : " + this . m _ file ) ; } finally { IO Utils . close Quietly ( is ) ; IO Utils . close Quietly ( os ) ; } }<CODESPLIT>{<CODESPLIT>0
public Sync Rule ) Rule ) ; Each Rule Rule get Exist Rule ) ; List . add ( exist Rule != null ? exist Rule : rule ) ; } ) ; this . validation Rules . remove All ( rule List ) ; this . temp Rules . add All ( this . validation Rules ) ; this . validation Rules = rule List ; this . validation Rules . sort ( new Rule Sorter ( ) ) ; return this ; }<CODESPLIT>Find list parent validation data .<CODESPLIT>0
protected List String get Data Type ( ) { ( all Data Type ) { all Data Type . add All ( Data Types . DATATYPE _ START _ WORDS ) ; all Data Type Start Words . add All ( get Custom Data Type Start Words ( ) ) ; } return all Data Type Start Words ; }<CODESPLIT>Returns a list of data type start words which can be used to help identify a column definition sub - statement .<CODESPLIT>1
protected void Toolbar Elements ( Tool Bar toolbar ) { ; Insets insets Insets ( , , , 2 ) ; add Tool Bar Elements ( toolbar , TOOLBAR , ) ; toolbar add ( get Context Select ( ) , Layout get GBC ( x ++ , 0 , 1 , 0 , insets ) ) ; x = this . add Tool Bar Elements ( toolbar , TOOLBAR _ LOCATION _ AFTER _ CONTEXTS _ SELECT , x ) ; toolbar . add ( new J Label ( ) , Layout Helper . get GBC ( x ++ , 0 , 1 , 1 . 0 ) ) ; if ( has Options ( ) ) { toolbar . add ( get Options Button ( ) , Layout Helper . get GBC ( x ++ , 0 , 1 , 0 , insets ) ) ; } this . add Tool Bar Elements ( toolbar , TOOLBAR _ LOCATION _ END , x ) ; }<CODESPLIT>Gets the Context select combo box .<CODESPLIT>0
private int parse Trailer ( [ ] , int Offset , List Byte Buffer list ) throws Data Format { ( Trace Component . is Tracing ( ) tc . is Debug ( ) ) { Tr . ( tc , trailer , =" this . parse Offset =" this . parse Int ) ; } int = Offset ; long = 0 L ; ( 8 this . parse Offset . ) { switch ( this . parse Offset ) { case 0 : case 2 : case 4 : case 6 : this . parse First Byte = input [ offset ] & 0 xff ; break ; break ; if ( this . checksum . get Value ( ) != val ) { String msg = " Checksum does not match ; crc =" + this . checksum . get Value ( ) + " trailer =" + val ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Debug Enabled ( ) ) { Tr . debug ( tc , msg ) ; } release ( list ) ; throw new Data Format Exception ( msg ) ; } break ; if ( this . inflater . get Bytes Written ( ) != val ) { String msg = " Bytes Written does not match ; inflater =" + this . inflater . get Bytes Written ( ) + " trailer =" + val ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Debug Enabled ( ) ) { Tr . debug ( tc , msg ) ; } release ( list ) ; throw new Data Format Exception ( msg ) ; } this . reset Needed To Proceed = true ; break ; default : break ; } offset ++ ; this . parse Offset ++ ; } return offset ; }<CODESPLIT>Parse past the GZIP trailer information . This is the two ints for the CRC32 checksum validation .<CODESPLIT>1
public Deleted get Deleted Async ) get Deleted With Async ) map ( new Func 1 < Service Response < Deleted Secret Bundle > , Deleted Secret Bundle > ( ) { @ Override public Deleted Secret Bundle call ( Service Response < Deleted Secret Bundle > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Permanently deletes the specified secret . The purge deleted secret operation removes the secret permanently without the possibility of recovery . This operation can only be enabled on a soft - delete enabled vault . This operation requires the secrets / purge permission .<CODESPLIT>0
public void add Class To Id ( final Class clazz , final String id ) { . not Null ( clazz , Class cannot ) ; . has Text ( id , ( id ) cannot or contain only whitespaces ) ; ( class To Id . contains Key ( clazz ) ) { throw new Illegal Argument Exception ( " Class " + clazz + " has already defined alias ( id ) " + class To Id . get ( clazz ) + " cannot set another alias " + id ) ; } if ( id To Class . contains Key ( id ) ) { } class To Id . put ( clazz , id ) ; id To Class . put ( id , clazz ) ; }<CODESPLIT>Adds single mapping : class < - > alias ( id ) .<CODESPLIT>1
void submit ( ) { ; ( All ( ) ) { Cms Flex CLEAR ONLINE ; } { Cms Flex CLEAR ONLINE ENTRIES ; } Cms fire Cms ( Cms ( Cms . EVENT _ FLEX _ CACHE _ CLEAR , Collections . < String , Object > singleton Map ( Cms Flex Cache . CACHE _ ACTION , new Integer ( action ) ) ) ) ; }<CODESPLIT>Set defautl values to vaadin components . <p ><CODESPLIT>0
public Shutdown Gateway shutdown Gateway Shutdown Gateway Request ) Client ) ; return execute Shutdown Gateway ( request ) ; }<CODESPLIT><p > Shuts down a gateway . To specify which gateway to shut down use the Amazon Resource Name ( ARN ) of the gateway in the body of your request . < / p > <p > The operation shuts down the gateway service component running in the gateway s virtual machine ( VM ) and not the host VM . < / p > <note > <p > If you want to shut down the VM it is recommended that you first shut down the gateway component in the VM to avoid unpredictable conditions . < / p > < / note > <p > After the gateway is shutdown you cannot call any other API except <a > StartGateway< / a > <a > DescribeGatewayInformation< / a > and <a > ListGateways< / a > . For more information see <a > ActivateGateway< / a > . Your applications cannot read from or write to the gateway s storage volumes and there are no snapshots taken . < / p > <note > <p > When you make a shutdown request you will get a <code > 200 OK< / code > success response immediately . However it might take some time for the gateway to shut down . You can call the <a > DescribeGatewayInformation< / a > API to check the status . For more information see <a > ActivateGateway< / a > . < / p > < / note > <p > If do not intend to use the gateway again you must delete the gateway ( using <a > DeleteGateway< / a > ) to no longer pay software charges associated with the gateway . < / p ><CODESPLIT>1
For static Client create Client ) { Settings settings Settings ) set Transport Instantiating Grpc Builder ( ) . set Header Provider ( OPENCENSUS _ USER _ AGENT _ HEADER _ PROVIDER ) . build ( ) ) ; if ( credentials != null ) { settings Builder . set Credentials Provider ( Fixed Credentials Provider . create ( credentials ) ) ; } return Metric Service Client . create ( settings Builder . build ( ) ) ; }<CODESPLIT>Resets exporter to null . Used only for unit tests .<CODESPLIT>0
public List Connection get ( Connection Mode Mode , String Source Name , int ) throws { Data Source Source get Data Source Map ( ) get ( Source Name ) ; check ( Source , Missing the source name '% '" , Source Name ) ; Collection Connection connections ; synchronized ( cached Connections ) { connections = cached Connections . get ( data Source Name ) ; } List < Connection > result ; if ( connections . size ( ) >= connection Size ) { result = new Array List <> ( connections ) . sub List ( 0 , connection Size ) ; } else if ( ! connections . is Empty ( ) ) { result = new Array List <> ( connection Size ) ; result . add All ( connections ) ; result . add All ( new Connections ) ; synchronized ( cached Connections ) { cached Connections . put All ( data Source Name , new Connections ) ; } } else { synchronized ( cached Connections ) { cached Connections . put All ( data Source Name , result ) ; } } return result ; }<CODESPLIT>Get database connections .<CODESPLIT>1
public void copy start Row start destination Row Offset , int destination Column Offset ) { source . copy To ( backend , start Row Index , rows , start Column Index , columns , destination Row Offset , destination Column Offset ) ; }<CODESPLIT>Copies the content from a TextImage into this buffer .<CODESPLIT>1
public Date Weeks ( long weeks ) { ( weeks Long Weeks ( Long VALUE ) . plus Weeks ( 1 ) : plus Weeks ( - weeks ) ) ; }<CODESPLIT>Returns a copy of this { @code LocalDateTime } with the specified number of months subtracted . <p > This method subtracts the specified amount from the months field in three steps : <ol > <li > Subtract the input months from the month - of - year field< / li > <li > Check if the resulting date would be invalid< / li > <li > Adjust the day - of - month to the last valid day if necessary< / li > < / ol > <p > For example 2007 - 03 - 31 minus one month would result in the invalid date 2007 - 04 - 31 . Instead of returning an invalid result the last valid day of the month 2007 - 04 - 30 is selected instead . <p > This instance is immutable and unaffected by this method call .<CODESPLIT>0
public static String concat ( String ... strs ) { ( String strs ) { sb . append ( str ) ; } return sb . to String ( ) ; }<CODESPLIT>快速连接参数中的字符串 .<CODESPLIT>1
public static build Object ( , extended , > extended Interface Wrapper Class , Collection < String > class Names Iterator , T default Object ) { return build Application Object ( interface Class , extended Interface Class , extended Interface Wrapper Class , class Names Iterator , default Object , null ) ; }<CODESPLIT>Creates ApplicationObjects like NavigationHandler or StateManager and creates the right wrapping chain of the ApplicationObjects known as the decorator pattern .<CODESPLIT>0
public synchronized Record read ( long session , long url ) { { Read set Long ( , session ) ; Read set Long ( 2 , url ) ; ( Result ps Read . execute Query ( ) ) { Record Structure result = build ( rs ) ; return result ; } } catch ( SQL Exception e ) {<CODESPLIT>This method initializes this<CODESPLIT>0
public process ( Map String , Object Param , Entity , Request Request ) throws { String field Path Name Request get Parameter ( field Name File Path ) ; Method Field Path getters Rapi get For ( Entity . get Class ( ) , field Path Name ) ; String file Path = ( String ) getter Field Path . invoke ( p Entity ) ; if ( file Path != null ) { File file To Del = new File ( file Path ) ; if ( file To Del . exists ( ) && ! file To Del . delete ( ) ) { } } this . srv Orm . delete Entity ( p Add Param , p Entity ) ; return null ; }<CODESPLIT><p > Process entity request . < / p ><CODESPLIT>1
protected int get Transaction Isolation ( ) { String . get ( PROPS ) ; - 1 : Integer . parse Int ( val ) ; }<CODESPLIT>transactionIsolationオプションの指定<CODESPLIT>1
public static kronecker ( Big Big ) { get ( ) . kronecker Impl ( a , p ) ; }<CODESPLIT>Verifies this library is loaded properly .<CODESPLIT>0
private static void parse bounds bounds bounds set Bounds ( new Point ( bounds Object . get JSON Object ( " lower Right " ) . get Double ( " x " ) , bounds Object . get JSON Object ( " lower Right " ) . get Double ( " y " ) ) , new Point ( bounds Object . get JSON Object ( " upper Left " ) . get Double ( " x " ) , bounds Object . get JSON Object ( " upper Left " ) . get Double ( " y " ) ) ) ) ; } }<CODESPLIT>creates a point array of all dockers and add it to the current shape<CODESPLIT>0
public Parse Result parse ( Reader reader , Attribute Source ) throws { Parse Result res = Parse Result ( ) ; String = String ( ) ; char [ ] = char [ 128 ] ; int cnt ; ( ( cnt = reader . read ( ) ) 0 ) { . append ( , 0 , cnt ) ; iterator = . get Iterator ( ) ; ( iterator iterator . has Next ( ) ) { res . = . get Stored String Value ( ) ; res . bin = . get Stored Bin Value ( ) ; { res . = ; res . bin = ; . close ( ) ; return res ; } parent . clear Attributes ( ) ; while ( iterator . has Next ( ) ) { Mtas Update Request Processor Result Item item = iterator . next ( ) ; if ( item . token Term != null ) { Char Term Attribute catt = parent . add Attribute ( Char Term Attribute . class ) ; catt . append ( item . token Term ) ; } if ( item . token Flags != null ) { Flags Attribute flags = parent . add Attribute ( Flags Attribute . class ) ; flags . set Flags ( item . token Flags ) ; } if ( item . token Pos Incr != null ) { patt . set Position Increment ( item . token Pos Incr ) ; if ( item . token Payload != null ) { Payload Attribute p = parent . add Attribute ( Payload Attribute . class ) ; Offset Attribute offset = parent . add Attribute ( Offset Attribute . class ) ; State state = parent . capture State ( ) ; res . states . add ( state . clone ( ) ) ; parent . clear Attributes ( ) ; catch ( IO Exception e ) { log . debug ( e ) ; return res ;<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public String get ( String code ) { assert code ; Missing Resource error = ; Resource [ ] bundles = get ( ) ; { return bundles [ ] . get String ( code ) ; } ( Missing Resource e ) { if ( error != null ) { error = e ; } } } assert error != null ; throw error ; }<CODESPLIT>An implementation of { @link Parser } s abstract { @link Parser#flatten ( Options String [] boolean ) flatten } method . <p > The following are the rules used by this flatten method . <ol > <li > if <code > stopAtNonOption< / code > is <b > true< / b > then do not burst anymore of <code > arguments< / code > entries just add each successive entry without further processing . Otherwise ignore <code > stopAtNonOption< / code > . < / li > <li > if the current <code > arguments< / code > entry is <b > -- < / b > just add the entry to the list of processed tokens< / li > <li > if the current <code > arguments< / code > entry is <b > - < / b > just add the entry to the list of processed tokens< / li > <li > if the current <code > arguments< / code > entry is two characters in length and the first character is <b > - < / b > then check if this is a valid { @link Option } id . If it is a valid id then add the entry to the list of processed tokens and set the current { @link Option } member . If it is not a valid id and <code > stopAtNonOption< / code > is true then the remaining entries are copied to the list of processed tokens . Otherwise the current entry is ignored . < / li > <li > if the current <code > arguments< / code > entry is more than two characters in length and the first character is <b > - < / b > then we need to burst the entry to determine its constituents . For more information on the bursting algorithm see { @link GroovyInternalPosixParser#burstToken ( String boolean ) burstToken } . < / li > <li > if the current <code > arguments< / code > entry is not handled by any of the previous rules then the entry is added to the list of processed tokens . < / li > < / ol ><CODESPLIT>0
public find All ( @ sort ) { not ( sort sort of find All not ) ; Document Document ( Criteria get Instance ( Criteria ) ) . with ( sort ) ; return operation . find ( query , information . get Java Type ( ) , information . get Collection Name ( ) ) ; }<CODESPLIT>Returns all entities sorted by the given options .<CODESPLIT>1
void ) { ) ; user ) ; ) ; . get Config ( ) . with Fallback ( user . get Config ( ) ) . with Fallback ( system . get Config ( ) ) ; dump 2 debug Log ( " MERGED " , config ) ; }<CODESPLIT>end of class ConfigSource<CODESPLIT>0
private void append ( String , Level , String , String ) { append ( ) ; append ( ) ; append ( Class Graph . get Simple Name ( ) ) ; buf . append ( ' ' ) ; final int num Dashes = 2 * ( indent Level - 1 ) ; buf . append ( ' ' ) ; } if ( num Dashes > 0 ) { buf . append ( ' ' ) ; } buf . append ( line ) ; buf . append ( ' ' ) ; }<CODESPLIT>Add a child log node .<CODESPLIT>0
static public create ( Url , Instruction , modifies , TE ) { set ( ) ; ( Instruction ) { set Instruction ( Dom . get Element ( parser Instruction ) ) ; mc . set Modifies Response ( Boolean . parse Boolean ( modifies Response ) ) ; } LOGR . log ( Level . CONFIG , " Configured monitor without test :\ n { 0 }" , mc ) ; return "" ; }<CODESPLIT>Monitor without parser that doesn t trigger a test<CODESPLIT>0
public void add To Cms Cms Cms Cms boolean import ) Cms { Defined In Content ) ) { Cms Messages get ) Messages RELATION remove Site get ) ) remove Site get ) ) get get Request Context ( ) . get Locale ( ) ) ) ) ; } Cms Relation relation = new Cms Relation ( resource , target , type ) ; get Vfs Driver ( dbc ) . create Relation ( dbc , dbc . current Project ( ) . get Uuid ( ) , relation ) ; if ( ! import Case ) { log ( dbc , new Cms Log Entry ( dbc , resource . get Structure Id ( ) , Cms Log Entry Type . RESOURCE _ ADD _ RELATION , new String [ ] { relation . get Source Path ( ) , relation . get Target Path ( ) } ) , false ) ; set Date Last Modified ( dbc , resource , System . current Time Millis ( ) ) ; } }<CODESPLIT>Adds a resource to the given organizational unit . <p ><CODESPLIT>0
public void marshall Associate Product With Portfolio Request associate Product With Portfolio Request Marshaller Marshaller ) associate Product With Portfolio Request ) Sdk Client marshall (...)" ) ;   Marshaller marshall associate Product With Portfolio Request get Accept Language ( ) , ACCEPTLANGUAGE _ BINDING ) ; protocol Marshaller . marshall ( associate Product With Portfolio Request . get Product Id ( ) , PRODUCTID _ BINDING ) ; protocol Marshaller . marshall ( associate Product With Portfolio Request . get Portfolio Id ( ) , PORTFOLIOID _ BINDING ) ; protocol Marshaller . marshall ( associate Product With Portfolio Request . get Source Portfolio Id ( ) , SOURCEPORTFOLIOID _ BINDING ) ; } catch ( Exception e ) { }<CODESPLIT><p > To help organize your resources you can assign your own metadata to the resources that you create . Each tag is a key - value pair . < / p ><CODESPLIT>0
public static void swap ) 1 [ array 1 Index ] != int Array 2 [ array 2 Index ] ) { int hold = int Array 1 [ array 1 Index ] ; int Array 1 [ array 1 Index ] = int Array 2 [ array 2 Index ] ; int Array 2 [ array 2 Index ] = hold ; } }<CODESPLIT>Helper method that swaps all the elements of the arrays . This method runs in O ( <code > Math . min ( array1 . length array2 . length< / code > ) time .<CODESPLIT>1
public void marshall ( Delete User Request delete User Request , Protocol Marshaller Marshaller ) { ( delete User Request == ) { Sdk Client ( argument passed to marshall (...)" ) ; } { Marshaller . marshall ( delete User Request . get User Name ( ) , USERNAME _ BINDING ) ; protocol Marshaller . marshall ( delete User Request . get Authentication Type ( ) , AUTHENTICATIONTYPE _ BINDING ) ; } catch ( Exception e ) { } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
protected void add Webuser ( Cms Select Query select , Cms Organizational , Table ) { String webuser Template ; ( has Webuser ( ) ) { webuser Template "( % $ s >= 32768 AND % 1 $ s < 65536 )" ; } else { } String webuser Condition = String . format ( webuser Condition Template , users . column ( col Flags ( ) ) ) ; select . add Condition ( webuser Condition ) ; }<CODESPLIT>Adds a check for the web user condition to an SQL query . <p ><CODESPLIT>1
void add ( Less Extend Extend , String ) { Extend get Selectors ( ) ; } { merge ( , Extend get Selectors ( ) ) ; } ( less Extend . is All ( ) ) { Less Extend Result extend = new Less Extend Result ( main Selector , extending Selector ) ; Selector Tokenizer tokenizer = tokenizers . poll Last ( ) . init ( extending Selector ) ; do { String token = tokenizer . next ( ) ; if ( token == null ) { break ; } all . add ( token , extend ) ; } while ( true ) ; tokenizers . add Last ( tokenizer ) ; } else { exact . add ( extending Selector , main Selector ) ; } }<CODESPLIT>Add to the given selectors all possible extends and return the resulting selectors .<CODESPLIT>0
JMF [ get Schemas ( ) throws Encode Failed { ( Trace Component . is Tracing ( ) tc . is Entry ( ) ) Sib Tr . ( this , tc , get Schemas ) ; JMF [ ; { JMF [ = ( ( JMF ) header Part . jmf Part ) . get Schemata ( ) ; JMF [ 2 = ; int Size = result 1 . length ; if ( payload Part != null ) { result 2 = ( ( JMF Message ) payload Part . jmf Part ) . get Schemata ( ) ; result Size += result 2 . length ; } result = new JMF Schema [ result Size ] ; System . arraycopy ( result 1 , 0 , result , 0 , result 1 . length ) ; if ( payload Part != null ) { System . arraycopy ( result 2 , 0 , result , result 1 . length , result 2 . length ) ; } } catch ( JMF Exception e ) { if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Debug Enabled ( ) ) Sib Tr . debug ( this , tc , " get Encoding Schemas failed : " + e ) ; throw new Message Encode Failed Exception ( e ) ; } if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) Sib Tr . exit ( this , tc , " get Encoding Schemas " ) ; return result ; }<CODESPLIT>Get a list of the JMF schemas needed to decode this message<CODESPLIT>1
public boolean add ( int value ) { ( size ) { ( This Int of is ) ; } int index = int ( value , mask ) ; ( [ index ] != missing Value ) { if ( values [ index ] == value ) { return false ; } index = next ( index ) ; } size ++ ; return true ; }<CODESPLIT>Splits a { @link ClientMessage } into frames of a maximum size .<CODESPLIT>0
private void delete ( propname ) Dev Failed { ( Access ( ) ) check Access ( ) ; [ ] array ; array = new String [ 1 ] ; array [ 0 ] = propname ; delete _ obj _ property ( database , name , type , array ) ; }<CODESPLIT>==========================================================================<CODESPLIT>1
public static Ctrl Or ) Page Current ) ( ) ; if ( web Browser . is Mac OSX ( ) ) { return Shortcut Action . Modifier Key . META ; } return Shortcut Action . Modifier Key . CTRL ; }<CODESPLIT>Dynamic styles for window .<CODESPLIT>0
public User resolve User ( long user Id ) { user mark ( ) ; ( user ) { user Cache Hits . mark ( ) ; return user ; } else { user = select User ( user Id ) ; if ( user != null ) { user Cache . put ( user Id , user ) ; } return user ; }<CODESPLIT>Resolves a user by username possibly with the internal cache .<CODESPLIT>1
public static build Cleaned Parameters Representation apache commons httpclient Spider Param Parameters Option handle Parameters boolean handle Parameters Visited ) { handle Parameters Parameters Option USE ) ) { ) ; } handle Parameters . equals ( Handle Parameters Option . IGNORE _ COMPLETELY ) ) { return create Base Uri With Cleaned Path ( uri , handle Parameters , handle O Data Parameters Visited ) ; } if ( handle Parameters . equals ( Handle Parameters Option . IGNORE _ VALUE ) ) { String cleaned Query = get Cleaned Query ( uri . get Escaped Query ( ) ) ; if ( cleaned Query . length ( ) > 0 ) { ret Val . append ( ' ' ) . append ( cleaned Query ) ; } return ret Val . to String ( ) ; } return uri . to String ( ) ; }<CODESPLIT>Tells whether or not the given port is the default for the given scheme . <p > <strong > Note : < / strong > Only HTTP and HTTPS schemes are taken into account .<CODESPLIT>0
public int run ( String arg , boolean stdin , boolean force ) throws { Output Stream output Stream = ; Input Stream Stream = ; { ( command ) { CREATE ( ks Exists ( ) ) { ( == false ) { prompt . ( Exiting without ) ; return 0 ; } Wrapper = Keystore Wrapper . Store ( ) . build ( ) ; output Stream = open Write ( ) ; Wrapper . save Keystore ( output Stream ) ; return 0 ; LIST ( ! ks Exists ( ) ) { return 5 ; } Stream = open Read ( ) ; Wrapper = Keystore Wrapper . load Store ( Stream ) . build ( ) ; for ( String Wrapper . list Entries ( ) ) { prompt . ( ) ; } return 0 ; ADD ( ! ks Exists ( ) ) { return 5 ; Stream = open Read ( ) ; Wrapper = Keystore Wrapper . load Store ( input Stream ) . build ( ) ; if ( keystore Wrapper . contains Entry ( arg ) && force == false ) { if ( proceed == false ) { prompt . println ( " Exiting without modifying keystore " ) ; return 0 ; if ( stdin ) { String data = prompt . read Line ( ) ; keystore Wrapper . set Secure Setting ( arg , data ) ; else { char [ ] data = prompt . read Password ( " Enter value for % s :" , arg ) ; keystore Wrapper . set Secure Setting ( arg , new String ( data ) ) ; Arrays . fill ( data , ( char ) 0 ) ; output Stream = open Write ( ) ; keystore Wrapper . save Keystore ( output Stream ) ; return 0 ; case REMOVE : if ( ! ks Exists ( ) ) { return 5 ; input Stream = open Read ( ) ; keystore Wrapper = Keystore Wrapper . load Store ( input Stream ) . build ( ) ; if ( keystore Wrapper . contains Entry ( arg ) == false ) { prompt . printf ( " ERROR : Setting [% s ] does not exist in the keystore .% n " , arg ) ; return 6 ; keystore Wrapper . remove Secure Setting ( arg ) ; output Stream = open Write ( ) ; keystore Wrapper . save Keystore ( output Stream ) ; return 0 ; default : prompt . println ( " ERROR : Unsupported command " + command . get Text ( ) ) ; return 7 ; catch ( Es Hadoop Security Exception ehse ) { prompt . println ( " ERROR Could not load keystore file : " + ehse . get Message ( ) ) ; return 8 ; catch ( File Not Found Exception fnfe ) { return 9 ; catch ( IO Exception ioe ) { prompt . println ( " ERROR : " + ioe . get Message ( ) ) ; return 10 ; finally { if ( output Stream != null ) { output Stream . close ( ) ; if ( input Stream != null ) { input Stream . close ( ) ;<CODESPLIT>{<CODESPLIT>0
private boolean update Stream Blacklist ( processing Blacklist Stream ) { boolean ; ( Stream get ( ) ) { ( ! initial Stream Ids . remove ( stream . get Id ( ) ) ) { added Streams = true ; } else { processing Blacklist . add ( tuple ( message . get Id ( ) , stream . get Id ( ) ) ) ; } } return added Streams ;<CODESPLIT>Evaluates all pipelines that apply to the given messages based on the current stream routing of the messages .<CODESPLIT>0
protected boolean Firehose Drainable By Closing Firehose firehose firehose Receiver Firehose firehose Shutoff Firehose Firehose Drainable By Closing Shutoff Firehose firehose . get Delegate Factory ( ) ) ) || ( firehose Factory instanceof Clipped Firehose Factory && is Firehose Drainable By Closing ( ( ( Clipped Firehose Factory ) firehose Factory ) . get Delegate ( ) ) ) ; }<CODESPLIT>Is a firehose from this factory drainable by closing it? If so we should drain on stopGracefully rather than abruptly stopping . <p > This is a hack to get around the fact that the Firehose and FirehoseFactory interfaces do not help us do this . <p > Protected for tests .<CODESPLIT>1
public boolean ) { GVR Cursor controller get get Device ( ) ) ; if ( controller != null ) { return controller . dispatch Key Event ( event ) ; } return false ; }<CODESPLIT>returns controller if a new device is found<CODESPLIT>0
public boolean is Derivation ( , ) { ( ( ) ) { ; } ( Type . Nominal ) { Decl . Type decl = t . get Link ( ) . get Target ( ) ; return is Derivation ( parent , decl . get Type ( ) ) ; } else { return false ; } }<CODESPLIT>Check whether one type is a derivation of another . For example in this scenario :<CODESPLIT>1
public void set Selected ( selected ) { get ( ) ( Property Keys . selected Class , selected Class ) ; }<CODESPLIT><p > Return the value of the <code > selectedClass< / code > property . < / p > <p > Contents : CSS style class to apply to the rendered label on selected options .<CODESPLIT>0
public static Predicates In ( Function , function , Iterable > iterable ) { return new Attribute Predicate < T , Object > ( function , Predicates . in ( iterable ) ) ; }<CODESPLIT>Creates a predicate which returns true if an attribute selected from an object passed to accept method is contained in the iterable .<CODESPLIT>1
private void validate Request Download Request dreq ) Error { dreq get ) ; With XML FILENAME ) || path . index Of ( "__" ) != - 1 ) { throw new Error Response Exception ( Download Response . get No Content Response ( ) ) ; } }<CODESPLIT>Make sure that it is a valid request . This is also the place to implement the reverse IP lookup<CODESPLIT>1
public Autofit set ( boolean ) { ( ) { ; ( ) { View . add Text Changed Listener ( m Text Watcher ) ; m Text View . add On Layout Change Listener ( m On Layout Change Listener ) ; autofit ( ) ; } else { m Text View . remove Text Changed Listener ( m Text Watcher ) ; m Text View . remove On Layout Change Listener ( m On Layout Change Listener ) ; } } return this ; }<CODESPLIT>Set the enabled state of automatically resizing text .<CODESPLIT>1
public static void check If Unmodified ( Unmodified , modified ) { parse Date ( Unmodified ) ; ( modified truncated To ( ) is After ( time ) ) { throw new Client Error Exception ( status ( PRECONDITION _ FAILED ) . build ( ) ) ; }<CODESPLIT>Check for a conditional operation .<CODESPLIT>1
public void set Progress Cms Upload Progess ) { get Current ) ; ; ) { { >= Filenames To Upload ) ) { Length ) { Length get Content Length ) ; Filename Filenames To Upload get File Index ) ; String content Length = Cms Upload Button . format Bytes ( m _ content Length ) ; int file Count = m _ ordered Filenames To Upload . size ( ) ; String read Bytes = Cms Upload Button . format Bytes ( get Bytes Read ( info . get Percent ( ) ) ) ; m _ bar . set Value ( info . get Percent ( ) ) ; if ( ! m _ started ) { m _ started = true ; m _ fileinfo . set HTML ( 0 , 0 , "< b >" + Messages . get ( ) . key ( Messages . GUI _ UPLOAD _ PROGRESS _ CURRENT _ FILE _ 0 ) + "</ b >" ) ; m _ fileinfo . set HTML ( 1 , 0 , "< b >" + Messages . get ( ) . key ( Messages . GUI _ UPLOAD _ PROGRESS _ UPLOADING _ 0 ) + "</ b >" ) ; m _ fileinfo . set HTML ( 2 , 0 , "" ) ; m _ fileinfo . set Text ( 0 , 1 , "" ) ; m _ fileinfo . set Text ( 1 , 1 , "" ) ; m _ fileinfo . set Text ( 2 , 1 , "" ) ; m _ fileinfo . get Column Formatter ( ) . set Width ( 0 , " 100 px " ) ; m _ fileinfo . set Text ( 0 , 1 , curr Filename ) ; m _ fileinfo . set Text ( 2 , 1 , Messages . get ( ) . key ( Messages . GUI _ UPLOAD _ PROGRESS _ UPLOADING _ VALUE _ 2 , read Bytes , content Length ) ) ;<CODESPLIT>Returns the file text . <p ><CODESPLIT>0
public static void escape ( ) { ( ; ( ) ; ) { hi At ( ) ; ( hi hi hi ( hi >= hi ) ( hi >= hi ) ( ( hi >= High Surrogate ( hi ) ) ) ) { rval . append ( String . format ( "\\ u % 04 x " , ( int ) hi ) ) ; } else if ( Character . is High Surrogate ( hi ) ) { final char lo = str . char At ( ++ i ) ; rval . append ( String . format ( "\\ U % 08 x " , c ) ) ; } else { switch ( hi ) { case ' ' : rval . append ( "\\ b " ) ; break ; case ' ' : rval . append ( "\\ n " ) ; break ; case ' ' : rval . append ( "\\ t " ) ; break ; case ' ' : rval . append ( "\\ f " ) ; break ; case ' ' : rval . append ( "\\ r " ) ; break ; case ' ' : rval . append ( "\\\"" ) ; break ; case ' ' : rval . append ( "\\\\" ) ; break ; default : rval . append ( hi ) ; break ; } } } }<CODESPLIT>Parses the authority for the pre - parsed given JsonLdUrl .<CODESPLIT>0
public static void send ( Byte < Void > callback ) { Close Message sm = new Close Message ( data ) ; send Close ( sm , ws Channel , callback ) ; }<CODESPLIT>Sends a complete close message invoking the callback when complete<CODESPLIT>0
public get Inverse ) Set ( ) ; n . forbidden Characters = characters ; n . characters = forbidden Characters ; return n ;<CODESPLIT>Write VCF record with the specified print writer .<CODESPLIT>0
protected boolean read Feature Parameters ( Element ) { { List childrent get Child Nodes ( ) ; cpnames Vector String ( ) ; paras Vector Vector Integer ( ) ; Element ( Element ) childrent item ( ) ; String value get Attribute ( value ) ; String parastr value split ( ":" ) ; Vector Integer para = new Vector < Integer > ( ) ; for ( int j = 3 ; j < parastr . length ; ++ j ) { para . add ( Integer . parse Int ( parastr [ j ] ) ) ; cpnames . add ( parastr [ 2 ] ) ; paras . add ( para ) ; } catch ( Exception e ) { System . out . println ( e . get Message ( ) ) ; e . print Stack Trace ( ) ; return false ; return true ;<CODESPLIT>Read feature parameters .<CODESPLIT>1
public insert Before ( Child , Child ) throws { error ( XML Error Resources ER FUNCTION NOT SUPPORTED ) ; return null ; }<CODESPLIT>Unimplemented . See org . w3c . dom . Node<CODESPLIT>1
public static Auth Token basic ( String username , String password , String ) { . Non Null ( username , Username ) ; . Non Null ( password , Password can ' t be null " ) ; map . put ( SCHEME _ KEY , value ( " basic " ) ) ; map . put ( PRINCIPAL _ KEY , value ( username ) ) ; map . put ( CREDENTIALS _ KEY , value ( password ) ) ; if ( realm != null ) { } return new Internal Auth Token ( map ) ; }<CODESPLIT>The basic authentication scheme using a username and a password .<CODESPLIT>1
private Statement add To Placeholder ( map Standalone ) { To ( map placeholder Compiler compile To Soy Value ( map Key , node , Extra Code Compiler . NO _ OP , Extra Code Compiler . NO _ OP ) ) ; }<CODESPLIT>See go / soy - element - keyed - roots for reasoning on why this is disallowed .<CODESPLIT>0
public void marshall ( Metric Definition metric Definition , Protocol Marshaller protocol Marshaller ) { ( metric Definition == ) { Sdk Client Exception ( " argument passed to marshall (...)" ) ; } { protocol Marshaller . marshall ( metric Definition . get Name ( ) , NAME _ BINDING ) ; protocol Marshaller . marshall ( metric Definition . get ( ) , REGEX _ BINDING ) ; } ( Exception e ) { } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
static String [ ] split ( remote , String , @ Nullable String default Branch ) { String host = remote . get Host ( ) ; ( host == ! remote . get ( ) . With ( "+ file ) ) { Argument ( no host remote remote ) ; } String path = remote . get Raw Path ( ) ; ( path == ) { Argument ( " no path in remote Uri : " + remote Uri ) ; } final Matcher matcher = Pattern . compile ( " (.*?\\." + suffix + ")(?:$|/)" ) . matcher ( path ) ; if ( ! matcher . find ( ) ) { } final String new Remote Uri ; final int port = remote Uri . get Port ( ) ; if ( host != null ) { if ( port > 0 ) { } else { new Remote Uri = remote Uri . get Scheme ( ) + "://" + host + matcher . group ( 1 ) ; } } else { new Remote Uri = remote Uri . get Scheme ( ) + "://" + matcher . group ( 1 ) ; } final String remote Path ; try { decoded = normalize Path ( decoded ) ; } catch ( Unsupported Encoding Exception e ) { throw new Error ( e ) ; } final String fragment = remote Uri . get Fragment ( ) ; final String remote Branch = fragment != null ? fragment : default Branch ; return new String [ ] { new Remote Uri , remote Path , remote Branch } ; }<CODESPLIT>Splits the specified remoteUri into : - the actual remote repository URI - the path in the remote repository - the branch name .<CODESPLIT>1
public static List Class resolve ( Class type ) { List Class res . new Array List ( ) ; while ( ! Object . class . equals ( current ) && current != null ) { res . add ( current ) ; current = current . get Superclass ( ) ; } return res ; }<CODESPLIT>Assigns base class in scheme for provided model type ( for example to make class vertex type it must extend V ) .<CODESPLIT>0
public void set Refreshing ( boolean refreshing ) { ( refreshing Refreshing refreshing ) { end Target ; ( Using ) { ( Direction ) { BOTTOM end Target get Measured ( ) ( ) ( Spinner Final ) ; ; TOP end Target ( int ) ( m Spinner Final Offset - Math . abs ( m Original Offset Top ) ) ; break ; } } else { } set Target Offset Top And Bottom ( end Target - m Current Target Offset Top , true ) ; start Scale Up Animation ( m Refresh Listener ) ; } else { set Refreshing ( refreshing , false ) ; } }<CODESPLIT>Notify the widget that refresh state has changed . Do not call this when refresh is triggered by a swipe gesture .<CODESPLIT>1
private Field [ get All Instance Fields ( Object ) { Field [ fields = instance Fields By Class . get ( . get Class ( ) ) ; ( fields ) { List Field field List = . get All Fields ( obj , exclude Static , exclude Transient ) ; instance Fields By Class . put ( obj . get Class ( ) , fields ) ; } return fields ; }<CODESPLIT>Visits all the keys and entries of the given map .<CODESPLIT>0
private Map Vector Layer , Filter dto Attribute Criterion To Filters ( Attribute Criterion criterion ) Geomajas { Map Vector Layer , Filter filters Map Vector Layer , Filter ( ) ; Filter f ; Vector Layer configuration get Vector Layer ( criterion get Layer ( ) ) ; ( ) { Geomajas ( LAYER NOT , criterion . get Server Layer Id ( ) ) ; } String operator = criterion . get Operator ( ) ; if ( " LIKE " . equals ( operator . to Upper Case ( ) ) ) { f = filter Service . create Like Filter ( criterion . get Attribute Name ( ) , criterion . get Value ( ) ) ; } f = filter Service . parse Filter ( criterion . to String ( ) ) ; } else { f = filter Service . create Compare Filter ( criterion . get Attribute Name ( ) , criterion . get Operator ( ) , criterion . get Value ( ) ) ; } filters . put ( l , f ) ; return filters ; }<CODESPLIT>Prune impossible combinations . ( eg . If And criteria filter different layers they will return nothing so they are pruned ) .<CODESPLIT>0
public Session create Session ( username ) { generate ( ) ; ( Host ( ) ) ; put ( transport Strategy . property Name Port ( ) , String . value Of ( port ) ) ; if ( username != null ) { props . put ( transport Strategy . property Name Username ( ) , username ) ; } if ( password != null ) { return Session . get Instance ( props , new Authenticator ( ) { @ Override protected Password Authentication get Password Authentication ( ) { return new Password Authentication ( username , password ) ; } } ) ; } else { return Session . get Instance ( props ) ; } }<CODESPLIT>Actually instantiates and configures the { @link Session } instance . Delegates resolving transport protocol specific properties to the { @link #transportStrategy } in two ways : <ol > <li > request an initial property list which the strategy may pre - populate< / li > <li > by requesting the property names according to the respective transport protocol it handles ( for the host property name it would be <em > mail . smtp . host < / em > for SMTP and <em > mail . smtps . host < / em > for SMTPS ) < / li > < / ol ><CODESPLIT>1
List configurations = Array List ( ) ; Map String , Object Settings = Map ( ) ; Settings . put ( GCC _ WARN _ ABOUT _ _ TYPE , YES ) ; Settings . put ( GCC _ WARN _ UNUSED _ , YES ) ; Settings . put ( PREBINDING , NO ) ; configurations . add ( Config ) ; Map String , Object release Settings = Map ( ) ; release Settings . put ( GCC _ WARN _ UNUSED _ , YES ) ; release Settings . put ( PREBINDING , NO ) ; configurations . add ( release Config ) ; PBX Object Ref configuration List = create XC Configuration List ( configurations ) ; final Map project Configuration List Properties = configuration List . get Properties ( ) ; project Configuration List Properties . put ( " default Configuration Is Visible " , " 0 " ) ; project Configuration List Properties . put ( " default Configuration Name " , " Debug " ) ; final File [ ] include Dirs = compiler Config . get Include Path ( ) ; if ( include Dirs . length > 0 ) { final List < String > include Paths = new Array List <> ( ) ; final Map < String , String > include Path Map = new Hash Map <> ( ) ; for ( final File include Dir : include Dirs ) { if ( ! C Util . is System Path ( include Dir ) ) { final String abs Path = include Dir . get Absolute Path ( ) ; if ( ! include Path Map . contains Key ( abs Path ) ) { if ( abs Path . starts With ( "/ usr /" ) ) { include Paths . add ( C Util . to Unix Path ( abs Path ) ) ; } else { include Paths . add ( rel Path ) ; } include Path Map . put ( abs Path , abs Path ) ; } } } include Paths . add ( "${ inherited )" ) ; debug Settings . put ( " HEADER _ SEARCH _ PATHS " , include Paths ) ; release Settings . put ( " HEADER _ SEARCH _ PATHS " , include Paths ) ; } final String [ ] pre Args = compiler Config . get Pre Arguments ( ) ; final List < String > defines = new Array List <> ( ) ; for ( final String pre Arg : pre Args ) { if ( pre Arg . starts With ( "- D " ) ) { defines . add ( pre Arg . substring ( 2 ) ) ; } } if ( defines . size ( ) > 0 ) { defines . add ( "$( inherited )" ) ; debug Settings . put ( " GCC _ PREPROCESSOR _ DEFINITIONS " , defines ) ; release Settings . put ( " GCC _ PREPROCESSOR _ DEFINITIONS " , defines ) ; } if ( linker Config != null ) { final Map < String , String > library Search Map = new Hash Map <> ( ) ; final List < String > library Search Paths = new Array List <> ( ) ; final List < String > other Ld Flags = new Array List <> ( ) ; final String [ ] linker Args = linker Config . get End Arguments ( ) ; for ( final String linker Arg : linker Args ) { if ( linker Arg . starts With ( "- L " ) ) { final String lib Dir = linker Arg . substring ( 2 ) ; if ( ! library Search Map . contains Key ( lib Dir ) ) { if ( ! lib Dir . equals ( "/ usr / lib " ) ) { } library Search Map . put ( lib Dir , lib Dir ) ; } else if ( linker Arg . starts With ( "- l " ) ) { final String lib Name = linker Arg . substring ( 2 ) ; boolean found = false ; for ( final Dependency Def dependency : dependencies ) { if ( lib Name . starts With ( dependency . get Name ( ) ) ) { final File dependency File = dependency . get File ( ) ; found = true ; break ; if ( ! found ) { other Ld Flags . add ( linker Arg ) ; debug Settings . put ( " LIBRARY _ SEARCH _ PATHS " , library Search Paths ) ; debug Settings . put ( " OTHER _ LDFLAGS " , other Ld Flags ) ; release Settings . put ( " LIBRARY _ SEARCH _ PATHS " , library Search Paths ) ; release Settings . put ( " OTHER _ LDFLAGS " , other Ld Flags ) ; return configuration List ;<CODESPLIT>Add project configuration list .<CODESPLIT>1
public get Privileges ) { ) ; Volt vtable Volt CAT Volt ) SCHEM Volt ) , new Column Info ( " TABLE _ NAME " , Volt Type . STRING ) , new Column Info ( " GRANTOR " , Volt Type . STRING ) , new Column Info ( " GRANTEE " , Volt Type . STRING ) , new Column Info ( " PRIVILEGE " , Volt Type . STRING ) , new Column Info ( " IS _ GRANTABLE " , Volt Type . STRING ) ) ; JDBC 4 Result Set res = new JDBC 4 Result Set ( this . sys Catalog , vtable ) ; return res ; }<CODESPLIT>Retrieves a description of the access rights for each table available in a catalog .<CODESPLIT>1
public Account Account Async Group account Account ) Account With Async Group account Account Name ) . map ( new Func 1 < Service Response < Storage Account Info Inner > , Storage Account Info Inner > ( ) { @ Override public Storage Account Info Inner call ( Service Response < Storage Account Info Inner > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Gets the specified Azure Storage account linked to the given Data Lake Analytics account .<CODESPLIT>1
private static double Q ( double xa double xb ) { ( ) ( ( xa ) 5 ) ; double epsilon xa EIGHTHS ; double sint SINE ; double sint SINE TABLE _ B [ idx ] ; final double cost A = COSINE _ TABLE _ A [ idx ] ; final double cost B = COSINE _ TABLE _ B [ idx ] ; double sin Eps A = epsilon ; double sin Eps B = poly Sine ( epsilon ) ; final double cos Eps A = 1 . 0 ; final double cos Eps B = poly Cosine ( epsilon ) ; final double temp = sin Eps A * HEX _ 40000000 ; double temp 2 = ( sin Eps A + temp ) - temp ; sin Eps B += sin Eps A - temp 2 ; sin Eps A = temp 2 ; double result ; double a = 0 ; double b = 0 ; double t = sint A ; double c = a + t ; double d = - ( c - a - t ) ; a = c ; b = b + d ; t = cost A * sin Eps A ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; if ( xb != 0 . 0 ) { c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; } result = a + b ; return result ; }<CODESPLIT>Compute sine over the first quadrant ( 0 < x < pi / 2 ) . Use combination of table lookup and rational polynomial expansion .<CODESPLIT>1
public void set Executors ( @ Nonnegative ) throws , { ( 0 ) { ( Incorrect field \"# of executors \": ". should a negative ." ) ; } if ( this . num Executors != n ) { this . num Executors = n ; update Computer List ( ) ; save ( ) ; } }<CODESPLIT>{ @inheritDoc } .<CODESPLIT>0
private static boolean Name Matches File Name ( , ) { toplevel sourcefile is Name ( c . name . to String ( ) , Java File Object . Kind . SOURCE ) ; }<CODESPLIT>Does class have the same name as the file it appears in?<CODESPLIT>1
@ Json ( value Page Link ) @ ( value ." position = 4 ) public Page Request Link Dto get Next Page Link ( ) { return next Page Link ; }<CODESPLIT>Returns the next pagination link .<CODESPLIT>1
public static Homoglyph build ( @ Nonnull @ Will Close Reader a Reader ) throws { Value Enforcer . not Null ( a Reader , reader ) ; ( Non Blocking Buffered Reader a BR = Non Blocking Buffered Reader ( a Reader ) ) { I Commons List Int a List = Commons Array List ( ) ; String Line ; ( ( Line = a BR . read Line ( ) ) ) { Line = Line . trim ( ) ; ( s Line . starts With ( "#" ) || s Line . length ( ) == 0 ) continue ; final Int Set a Set = new Int Set ( s Line . length ( ) / 3 ) ; if ( n Val >= 0 ) a Set . add ( n Val ) ; a List . add ( a Set ) ; return new Homoglyph ( a List ) ;<CODESPLIT>Consumes the supplied Reader and uses it to construct a populated Homoglyph object .<CODESPLIT>1
private boolean has Nullified FK ( Field fk Field Object fk Values ) { boolean ; ( ; fk Values ; ) { ( pb Broker ( ) . represents Null ( fk Field Descriptors [ i ] , fk Values [ i ] ) ) { result = false ; break ; } } return result ; }<CODESPLIT>to avoid creation of unmaterializable proxies<CODESPLIT>1
public Historic Date get Begin Of Year ( Historic Era era year Of Era ) { Historic Date Year get Year ( ) Year ( era year Of Era ) ; ( Valid ( Year ) ) { Plain Date convert ( Year ) ; Historic Era preferred Era era . get Preferred Era ( new Year , date ) ; if ( preferred Era != era ) { int yoe = preferred Era . year Of Era ( new Year . get Era ( ) , new Year . get Year Of Era ( ) ) ; } return new Year ; } else { throw new Illegal Argument Exception ( " Cannot determine valid New Year : " + era + "-" + year Of Era ) ; } }<CODESPLIT>/ * [ deutsch ] <p > Determines the date of New Year . < / p ><CODESPLIT>1
protected static void ) ( ( Object ) array ) ; for ( Object o : array ) { check Not Null ( o ) ; } }<CODESPLIT>Validate the specified arguments .<CODESPLIT>1
private static String get Extent Of Participation Mention ( List event List , List List , process NAF vars ) { List Wf event Word List get The WF List By Terms From Target List ( event List , vars ) ; List Wf Word List get The WF List By Terms From Target List ( List , vars ) ; List Wf merged Word List List Wf > ( ) ; int char Start Of Event = Integer . parse Int ( event Word List . get First ( ) . get Offset ( ) ) ; if ( char Start Of Event <= char Start Of Role ) { } else { for ( Wf w : first WL ) { if ( ! merged Word List . contains ( w ) ) { merged Word List . add ( w ) ; for ( Wf w : second WL ) { if ( ! merged Word List . contains ( w ) ) { merged Word List . add ( w ) ; } String Buffer extent = new String Buffer ( ) ; for ( Wf w : merged Word List ) { extent . append ( w . getvalue ( ) + " " ) ; String s Extent = extent . to String ( ) ; return s Extent . substring ( 0 , s Extent . length ( ) - 1 ) ;<CODESPLIT>/ * similar to generateTheMIdAndSetID () but specific for ParticipationMention<CODESPLIT>1
public Config set Txns Expiration Timeout ( int ) { ( 0 1000 ) { } set Setting ( ENV _ MONITOR _ TXNS _ EXPIRATION _ TIMEOUT , timeout ) ; if ( timeout > 0 && timeout < get Env Monitor Txns Check Freq ( ) ) { set Env Monitor Txns Check Freq ( timeout ) ; } return this ; }<CODESPLIT>Sets the maximum size of page of B + Tree . Default value is { @code 128 } . Only sizes in the range [ 16 .. 1024 ] are accepted . <p > Mutable at runtime : yes<CODESPLIT>0
public static void add Type ( Class clz , Class mapper ) { synchronized ( class ) { Class < ? > > h = class Mapper . get ( clz ) ; if ( h == null ) { class Mapper . put ( clz , h ) ; } h . add ( mapper ) ; } }<CODESPLIT>Field type convertor for all classes<CODESPLIT>1
public static Document Document Document factory ) { { Document factory Document ) ; ; } Exception e ) { throw MESSAGES . unable To Create Instance Of ( e , Document Builder . class . get Name ( ) ) ; } }<CODESPLIT>Parse the given XML string and return the root Element This uses the document builder associated with the current thread .<CODESPLIT>0
public synchronized void clear ( ) { ( ) { } { clear ( ) ; fc ( ) ( ) ( ) ; close ( ) ; open ( ) ; } catch ( Exception e ) { log . error ( " Exception in clear ()" , e ) ; } }<CODESPLIT>Read value from file<CODESPLIT>0
void send Migration Event ( Migration status ) { int Id = get Id ( ) ; = get ( ) ; Member Member = node Engine . get Local Member ( ) ; final Migration Event event = new Migration Event ( partition Id , null , local Member , status ) ; final Event Service event Service = node Engine . get Event Service ( ) ; event Service . publish Event ( SERVICE _ NAME , registrations , event , partition Id ) ; }<CODESPLIT>Sends a {<CODESPLIT>1
private void process Constraint ( Constraint Object violations , Binding Errors Errors , Context Object validation Context ) { ( Constraint Object violation violations ) { String field = violation . get Property Path ( ) . to String ( ) ; Constraint Descriptor cd = violation . get Constraint Descriptor ( ) ; String [ ] error = determine Error Code ( cd ) ; Map String , Object error = create Variable For Constraint ( cd ) ; ( is Field ( field , validation Context ) ) { Csv Field Error field Error = binding Errors . get First Field Error ( field ) ; if ( field Error != null && field Error . is Processing Failure ( ) ) { continue ; } error Vars . put ( " line Number " , validation Context . get Csv Context ( ) . get Line Number ( ) ) ; error Vars . put ( " column Number " , column Mapping . get Number ( ) ) ; error Vars . put ( " label " , column Mapping . get Label ( ) ) ; error Vars . compute If Absent ( " printer " , key -> column Mapping . get Formatter ( ) ) ; final Object field Value = violation . get Invalid Value ( ) ; error Vars . compute If Absent ( " validated Value " , key -> field Value ) ; String default Message = determine Defalt Message ( error Vars , violation ) ; } else { binding Errors . reject ( error Codes , error Vars , violation . get Message ( ) ) ;<CODESPLIT>BeanValidationの検証結果をSheet用のエラーに変換する<CODESPLIT>1
public static void write To File ( @ Null File , @ Null String content ) { { writer write ( content ) ; writer flush ( ) ; } ( ) { Log . e ( LOG _ TAG , ioe . to String ( ) ) ; } finally { try { writer . close ( ) ; } catch ( IO Exception ioe ) { Log . e ( LOG _ TAG , ioe . to String ( ) ) ; } } }<CODESPLIT>Delete file .<CODESPLIT>0
public static String extract Text ( String ) { Img With Alt ( ) ; html = safe Remove All Tags ( html ) ; return html ; }<CODESPLIT>Extracts the title of the page .<CODESPLIT>0
public static Rule get Rule ( String inequality , String field , String value ) { Level Inequality Rule get Rule ( inequality , value ) ; } ( field ( Logging Event Field Resolver . TIMESTAMP _ FIELD ) ) { return Timestamp Inequality Rule . get Rule ( inequality Symbol , value ) ; } else { return new Inequality Rule ( inequality Symbol , field , value ) ; } }<CODESPLIT>Create new instance from top two elements on stack .<CODESPLIT>0
public void create Equi Angle ( float , Rotations , Samples , float jitter , d ) { float spacing Rotations ; ( sample ; sample Samples ; sample ) { float angle ( float ) ( sample Rotations ) Samples ; float = radius * sample / ( num Samples - 1 ) + ( rnd . next Float ( ) * 2 . 0 f - 1 . 0 f ) * spacing * jitter ; float x = ( float ) Math . sin _ roquen _ 9 ( angle + 0 . 5 f * ( float ) Math . PI ) * r ; callback . on New Sample ( x , y ) ; } }<CODESPLIT>Create <code > numSamples< / code > number of samples on a spiral with maximum radius <code > radius< / code > around the center using <code > numRotations< / code > number of rotations along the spiral and call the given <code > callback< / code > for each sample generated . <p > The generated sample points are distributed with equal angle differences around the spiral so they concentrate towards the center . <p > Additionally the radius of each sample point is jittered by the given <code > jitter< / code > factor .<CODESPLIT>1
private void read Object ( Object Input Stream ) , Not Found { Read Object ( ) ; summary ; detail ; ordinal in . read Int ( ) ; if ( ordinal == SEVERITY _ INFO . get Ordinal ( ) ) { } else if ( ordinal == SEVERITY _ WARN . get Ordinal ( ) ) { } else if ( ordinal == SEVERITY _ ERROR . get Ordinal ( ) ) { } else if ( ordinal == SEVERITY _ FATAL . get Ordinal ( ) ) { } summary = ( String ) in . read Object ( ) ; detail = ( String ) in . read Object ( ) ; rendered = ( Boolean ) in . read Object ( ) ; }<CODESPLIT><p > Reconstruct {<CODESPLIT>1
public void For ( String log String , Time ) Timeout { For For ( Log Checker ( this , log Search String ) , wait Time , describe ( ) ) ; }<CODESPLIT>Stop and wait till given string will show in container output .<CODESPLIT>1
public from ( Expression from ) { ( from ) { this ; } this . from Columns . add All ( from Columns ) ; return this ; }<CODESPLIT>Adds the FROM columns .<CODESPLIT>1
public void get Element Settings ( Cms Cms Element Settings ) { Cms Rpc Cms Element Settings Cms Rpc Cms Element Settings ( ) { @ Override public void execute ( ) { start ( ) ; get Containerpage ( ) get Element Settings ( get ( ) get Rpc ( ) Id , container Id , get Page State ( ) , get Locale ( ) , this ) ; @ Override protected void on Response ( Cms Element Settings Config result ) { if ( result != null ) { callback . execute ( result ) ; stop ( false ) ; action . execute ( ) ;<CODESPLIT>Requests the element settings config data for a container element specified by the client id . The data will be provided to the given call - back function . <p ><CODESPLIT>1
protected synchronized void copy ( Writable other ) { ( other ) { { Data Output Buffer Data Output Buffer ( ) ; other . write ( ) ; Data Input Buffer Data Input Buffer ( ) ; . reset ( . get Data ( ) , . get Length ( ) ) ; read Fields ( ) ; } ( IO Exception e ) { } } else { throw new Illegal Argument Exception ( " source map cannot be null " ) ; } }<CODESPLIT>Used by child copy constructors .<CODESPLIT>1
public Cell , ( Value , ) { = width ; pref Width = width ; max Width = width ; return this ; }<CODESPLIT>Sets the minWidth prefWidth and maxWidth to the specified value .<CODESPLIT>0
public void create Reference Reference ) Green Pepper { { start Session ) ; Transaction ) ; repository get ) get ) get Uid ) ) ; create Reference reference ) ; session Service . commit Transaction ( ) ; log . debug ( " Created Reference : " + reference . get Requirement ( ) . get Name ( ) + "," + reference . get Specification ( ) . get Name ( ) ) ; } catch ( Exception ex ) { session Service . rollback Transaction ( ) ; } finally { session Service . close Session ( ) ; } }<CODESPLIT>{<CODESPLIT>0
public static Document build PDF Document ( snowtide pdf Document pdf , Lucene PDF Configuration ) throws { String Writer String Writer ( ) ; pdf pipe ( Output Target ( ) ) ; Document Document ( ) ; LUCENE INTERFACE add Field ( , get Body Text Field Name ( ) , to String ( ) , Body Text ( ) , index Body Text ( ) , Body Text ( ) ) ; ( Map Entry String , Object Entry pdf get Attribute Map ( ) ( ) ) { String Prop Name Entry get Key ( ) ; String field Name get Metadata Field Mapping ( Prop Name ) ; ( field Name null ) { if ( config . copy All PDF Metadata ( ) ) { field Name = doc Prop Name ; } else { continue ; } } Object value = metadata Entry . get Value ( ) ; String value Str ; if ( value == null ) { if ( LOG _ DEBUG ) log . debug ( " Null document property value found for name [" + doc Prop Name + "] (" + pdf . get Name ( ) + ' ' ) ; continue ; } else if ( value instanceof String ) { if ( doc Prop Name . equals ( com . snowtide . pdf . Document . ATTR _ MOD _ DATE ) || doc Prop Name . equals ( com . snowtide . pdf . Document . ATTR _ CREATION _ DATE ) ) { try { value Str = Date Tools . date To String ( PDF Date Parser . parse Date String ( ( String ) value ) , Date Tools . Resolution . MILLISECOND ) ; } catch ( Exception e ) { } } else { } } else if ( value instanceof Number ) { value Str = value . to String ( ) ; } else { continue ; } LUCENE _ INTERFACE . add Field ( doc , field Name , value Str , config . store Metadata ( ) , config . index Metadata ( ) , config . tokenize Metadata ( ) ) ; } return doc ; }<CODESPLIT>Creates a new Lucene Document instance using the PDF text and metadata provided by the PDFxStream Document using a default {<CODESPLIT>0
protected void remove Target ( ) { remove Mouse ( ) ; remove Mouse ( ) ; ( ) { cont remove Listener ( _ child Listener ) ; for ( int ii = 0 , nn = cont . get Component Count ( ) ; ii < nn ; ii ++ ) { remove Target Listeners ( cont . get Component ( ii ) ) ; } } }<CODESPLIT>Check to see if we need to do component - level cursor setting and take care of it if needed .<CODESPLIT>0
public delete By Async ) { delete By With Async ) map Func Service Response < Policy Assignment Inner > , Policy Assignment Inner > ( ) { @ Override public Policy Assignment Inner call ( Service Response < Policy Assignment Inner > response ) { return response . body ( ) ; } } ) ; }<CODESPLIT>Deletes a policy assignment by ID . When providing a scope for the assigment use / subscriptions / { subscription - id } / for subscriptions / subscriptions / { subscription - id } / resourceGroups / { resource - group - name } for resource groups and / subscriptions / { subscription - id } / resourceGroups / { resource - group - name } / providers / { resource - provider - namespace } / { resource - type } / { resource - name } for resources .<CODESPLIT>0
private void get Fights ( Document , Event ) { Sherdog Object Event Sherdog Object ( ) ; Event set Name ( get Name ( ) ) ; Event set Sherdog Url ( get Sherdog Url ( ) ) ; List Fight fights Array List ( ) ; main Fight Element select ( ". content ) ; fighters main Fight Element select ( a ) ; Sherdog Object main Fighter 1 = new Sherdog Base Object ( ) ; Element main Fighter 1 Element = fighters . get ( 0 ) ; main Fighter 1 . set Sherdog Url ( main Fighter 1 Element . attr ( " abs : href " ) ) ; main Fighter 1 . set Name ( main Fighter 1 Element . select ( " span [ itemprop =\" name \"]" ) . html ( ) ) ; Sherdog Base Object main Fighter 2 = new Sherdog Base Object ( ) ; Element main Fighter 2 Element = fighters . get ( 1 ) ; main Fighter 2 . set Sherdog Url ( main Fighter 2 Element . attr ( " abs : href " ) ) ; main Fighter 2 . set Name ( main Fighter 2 Element . select ( " span [ itemprop =\" name \"]" ) . html ( ) ) ; Fight main Fight = new Fight ( ) ; main Fight . set Event ( s Event ) ; main Fight . set Fighter 1 ( main Fighter 1 ) ; main Fight . set Fighter 2 ( main Fighter 2 ) ; main Fight . set Result ( Parser Utils . get Fight Result ( main Fight Element . first ( ) ) ) ; Elements main Td = main Fight Element . select ( " td " ) ; if ( main Td . size ( ) > 0 ) { } main Fight . set Date ( event . get Date ( ) ) ; fights . add ( main Fight ) ; logger . info ( " Fight added : {}" , main Fight ) ; logger . info ( " Found {} fights " , fights . size ( ) ) ; Elements tds = doc . select ( ". event _ match table tr " ) ; fights . add All ( parse Event Fights ( tds , event ) ) ; event . set Fights ( fights ) ; }<CODESPLIT>parses an event from a jsoup document<CODESPLIT>0
public Property Descriptor [ get Tea Bean Property ( Class Class ) { ( Class == ) { NO _ PROPERTIES ; } Property Descriptor [ properties = ; Map String , Property Descriptor all Props = ; { } ( Throwable ) { NO _ PROPERTIES ; } Iterator Map . Entry String , Property Descriptor it = all Props . ( ) . iterator ( ) ; while ( it . has Next ( ) ) { Map . Entry < String , Property Descriptor > entry = it . next ( ) ; String name = entry . get Key ( ) ; Property Descriptor desc = entry . get Value ( ) ; if ( name == null || name . length ( ) == 0 || " class " . equals ( name ) ) { continue ; } if ( desc instanceof Keyed Property Descriptor ) { try { desc = new Array Index Property Descriptor ( bean Class , type ) ; } catch ( Throwable t ) { continue ; } } else if ( ! bean Class . is Array ( ) && desc . get Read Method ( ) == null ) { continue ; } clean Props . add ( desc ) ; } properties = clean Props . to Array ( new Property Descriptor [ clean Props . size ( ) ] ) ; sort Property Descriptors ( properties ) ; return properties ; }<CODESPLIT>A function that returns an array of all the available properties on a given class . <p > <b > NOTE : < / b > If possible the results of this method should be cached by the caller .<CODESPLIT>1
public synchronized void Stopping ( ) { ( Trace Component is Tracing ( ) tc is Entry ( ) ) { Tr ( tc , Stopping , generate progress generate In Progress ) ; } Is Stopping ; { Thread . sleep ( 500 ) ; } catch ( Interrupted Exception e ) { i = 40 ; } } if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) { Tr . exit ( tc , " server Stopping " ) ; } }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
void flatten To Sub Message Buffer ( Byte Buffer ) throws { assert ( _ != ) ; assert ( ! _ . is Empty ( ) ) ; . put ( Volt Message Factory . FRAGMENT _ TASK _ ID ) ; . flatten To Buffer ( ) ; for ( Fragment Data item : _ ) { ( item . _ Dep Id != 1 ) { Input Dep ; } ( item . _ output Dep Id != ) { Output Dep Ids ++ ; if ( item . m _ fragment Plan != null ) { n Unplanned ++ ; } } buf . put Short ( ( short ) m _ items . size ( ) ) ; buf . put Short ( n Unplanned ) ; buf . put ( m _ task Type ) ; if ( m _ proc Name To Load != null ) { buf . put Short ( ( short ) m _ proc Name To Load . length ) ; buf . put ( m _ proc Name To Load ) ; } else { buf . put Short ( ( short ) - 1 ) ; } buf . put Long ( m _ restart Timestamp ) ; buf . put Long ( m _ last Sp Unique Id ) ; for ( Fragment Data item : m _ items ) { buf . put ( item . m _ plan Hash ) ; for ( Fragment Data item : m _ items ) { if ( item . m _ stmt Name == null ) { buf . put Short ( ( short ) - 1 ) ; else { assert ( item . m _ stmt Name . length <= Short . MAX _ VALUE ) ; buf . put Short ( ( short ) item . m _ stmt Name . length ) ; buf . put ( item . m _ stmt Name ) ; for ( Fragment Data item : m _ items ) { buf . put Int ( item . m _ parameter Set . remaining ( ) ) ; if ( n Output Dep Ids > 0 ) { for ( Fragment Data item : m _ items ) { buf . put Int ( item . m _ output Dep Id ) ; if ( n Input Dep Ids > 0 ) { for ( Fragment Data item : m _ items ) { if ( item . m _ input Dep Id == - 1 ) { buf . put Short ( ( short ) 0 ) ; else { buf . put Short ( ( short ) 1 ) ; buf . put Int ( item . m _ input Dep Id ) ; if ( m _ procedure Name == null ) { buf . put Short ( ( short ) - 1 ) ; else { assert ( m _ procedure Name . length <= Short . MAX _ VALUE ) ; buf . put Short ( ( short ) m _ procedure Name . length ) ; buf . put ( m _ procedure Name ) ; buf . put Int ( m _ current Batch Index ) ; if ( m _ batch Timeout == Batch Timeout Override Type . NO _ TIMEOUT ) { else { buf . put Int ( m _ batch Timeout ) ; buf . put Short ( ( short ) m _ involved Partitions . size ( ) ) ; for ( int pid : m _ involved Partitions ) { buf . put Int ( pid ) ; if ( m _ initiate Task Buffer != null ) { Byte Buffer dup = m _ initiate Task Buffer . duplicate ( ) ; buf . put Int ( dup . remaining ( ) ) ; buf . put ( dup ) ; else { buf . put Int ( 0 ) ; Fragment Data item = m _ items . get ( index ) ; if ( item . m _ fragment Plan != null ) { buf . put Short ( index ) ; buf . put Int ( item . m _ fragment Plan . length ) ; buf . put ( item . m _ fragment Plan ) ; assert ( item . m _ stmt Text != null ) ; buf . put Int ( item . m _ stmt Text . length ) ; buf . put ( item . m _ stmt Text ) ;<CODESPLIT>/ * Serialization Format [ description : type : byte count ]<CODESPLIT>0
public read Row ( Reader Reader Error parse Error ) { check Entity ( ) ; Reader read ( ) ; ( ) { return null ; } else { return process Row ( line , buffered Reader , parse Error , get Line Number ( buffered Reader ) ) ; }<CODESPLIT>Read in all of the entities in the reader passed in but without the header .<CODESPLIT>0
private int To RTF ( Template Element template Parent , DTM dtm Frag ) throws Transformer { Content Handler rtf Handler dtm Frag get Content Handler ( ) ; int Fragment ; To Handler To XMLSAX Handler ( ) ; set Content Handler ( rtf Handler ) ; set Transformer ( this ) ; serialization Handler ; { rth . start Document ( ) ; rth . flush Pending ( ) ; try { execute Child Templates ( template Parent , true ) ; rth . flush Pending ( ) ; result Fragment = dtm Frag . get Document ( ) ; } finally { rth . end Document ( ) ; } } catch ( org . xml . sax . SAX Exception se ) { throw new Transformer Exception ( se ) ; } finally { } return result Fragment ; }<CODESPLIT>Take the contents of a template element process it and convert it to a string .<CODESPLIT>0
public static void encode Length ( Byte Array Output Stream , int ) { ( , encode Length , Object { , } ) ; int Count 0 ; long Length 0 ; do { Length ( ) ( & 0 7 f ) ; length >>= 7 ; byte Count ++ ; } while ( length > 0 ) ; do { byte encoded Byte = ( byte ) ( encoded Length & 0 xff ) ; if ( byte Count != 1 ) { } out . write ( encoded Byte ) ; while ( -- byte Count > 0 ) ; }<CODESPLIT>/ * Length - bytes are written out in order from most to least significant but are computed most efficiently ( using bit shifts ) from least to most significant . An integer serves as a temporary storage which is then written out in reversed order .<CODESPLIT>1
public static synchronized Ping get Instance For ( XMPP Connection ) { Ping ping INSTANCES get ( ) ; ( ping Manager == null ) { INSTANCES . put ( connection , ping Manager ) ; } return ping Manager ; }<CODESPLIT>Gets the account registration info from the server . @throws XMPPErrorException @throws NoResponseException @throws NotConnectedException @throws InterruptedException<CODESPLIT>0
public T List T Query ( Query Query ) { Layout Persistence . find With Dynamic Query ( dynamic Query ) ; }<CODESPLIT>Returns the number of rows matching the dynamic query .<CODESPLIT>0
public void write ( String , off , ) { writer write ( , off , ) ; } { ensure ( ) ; Buffer append ( s . substring ( off , off + len ) ) ; next Char += len ; } }<CODESPLIT>Write a portion of a String .<CODESPLIT>1
public void concat ( trg boolean restricted ) { namesystem . concat ( trg , src , restricted ) ; }<CODESPLIT>{<CODESPLIT>0
public Execute Provisioned Product execute Provisioned Product Execute Provisioned Product Request request ) request Client request ) ; return execute Execute Provisioned Product Service Action ( request ) ; }<CODESPLIT><p > Executes a self - service action against a provisioned product . < / p ><CODESPLIT>1
private get Wrapped Publisher Publisher flexible Publisher ) flexible Publisher Flexible Publisher ) ) Publisher of '% '. Found '% '" Flexible Publisher flexible Publisher get ) ) ) } List < Conditional Publisher > conditions = ( ( Flexible Publisher ) flexible Publisher ) . get Publishers ( ) ; for ( Conditional Publisher condition : conditions ) { if ( type . is Instance ( condition . get Publisher ( ) ) ) { return type . cast ( condition . get Publisher ( ) ) ; } } return null ; }<CODESPLIT>Gets the publisher wrapped by the specofoed FlexiblePublisher .<CODESPLIT>1
public Iterable Contact By Updated Date ( Date Date ) { By ( parent , D Contact Mapper . Field . UPDATEDDATE . get Field Name ( ) , updated Date ) ; }<CODESPLIT>query - by method for field updatedDate<CODESPLIT>1
static boolean Get Or ) get Token ) ) GETTER DEF SETTER DEF ; COMPUTED : return node . get Boolean Prop ( Node . COMPUTED _ PROP _ GETTER ) || node . get Boolean Prop ( Node . COMPUTED _ PROP _ SETTER ) ; default : break ; } return false ; }<CODESPLIT>Determines whether a node represents an object literal get or set key ( e . g . key1 in { get key1 () {} set key2 ( a ) {} ) .<CODESPLIT>1
private boolean Ct Ct ) { { get ) get get ) ) ) get ) ( cp . get ( List . class . get Name ( ) ) ) || ct Field . get Type ( ) . equals ( cp . get ( Set . class . get Name ( ) ) ) ; } catch ( Not Found Exception e ) { e . print Stack Trace ( ) ; return false ; } }<CODESPLIT>Add Method to ConstPool . If method was not in the ConstPool will add and return index otherwise will return index of already existing entry of constpool<CODESPLIT>0
public static void ( File , ) { not ( , ) ; ( is Readable ( path ) ) { throw new Illegal Argument Exception ( message ) ; } }<CODESPLIT>FIXME me animal sniffer this is 1 . 6 API only<CODESPLIT>0
public Modify Subscription modify Subscription Modify Subscription Request ) Client ( request ) ; return execute Modify Event Subscription ( request ) ; }<CODESPLIT><p > Modifies the replication instance to apply new settings . You can change one or more parameters by specifying these parameters and the new values in the request . < / p > <p > Some settings are applied during the maintenance window . < / p > <p / ><CODESPLIT>0
public Inventory Deletion get Inventory ( ) { ( inventory ) { inventory com . amazonaws . internal . Sdk Internal List < Inventory Deletion Status Item > ( ) ; } return inventory Deletions ; }<CODESPLIT><p > A list of status items for deleted inventory . < / p ><CODESPLIT>0
public static boolean validate Service Name ( Configuration conf , String name Service Id ) { ( nameservice != ! nameservice . is Empty ( ) ) { ( name Service Id == ) { . err . ( Need to input a nameservice id " ) ; return false ; } else if ( ! nameservice Ids . contains ( name Service Id ) ) { System . err . println ( " An invalid nameservice id : " + name Service Id ) ; return false ; } } else if ( name Service Id != null ) { return false ; } return true ; }<CODESPLIT>Valide if the input service name is valid<CODESPLIT>1
public OUTPUT Instance ( , INPUT ) FAILURE { ( ) append ( get ( ) get ( ) ) append ( ". Instance ( < String , Input >) is unsupported ." ) ; throw new Unsupported Operation Exception ( builder . to String ( ) ) ; }<CODESPLIT><p > <b > Unsupported< / b > . Override to provide an implementation . < / p ><CODESPLIT>1
long get Proposed ( ) throws IO { { return p ; } ( File Not Found ) { . ( File not exist , initialize acknowledged epoch to - 1 " ) ; return - 1 ; } catch ( IO Exception e ) { LOG . error ( " IO Exception encountered when access acknowledged epoch " ) ; throw e ; } }<CODESPLIT>Gets the last proposed epoch .<CODESPLIT>1
public Parameterizable Request delegation ( ) { parse ( get ( ) ) ( ) add ( DELEGATION ) build ( ) ; > parameters = Parameter Builder . new Builder ( ) . set Client Id ( get Client Id ( ) ) . set Grant Type ( Parameter Builder . GRANT _ TYPE _ JWT ) . as Dictionary ( ) ; return factory . raw POST ( url , client , gson , auth Error Builder ) . add Parameters ( parameters ) ; }<CODESPLIT>Performs a custom <a href = https : // auth0 . com / docs / api / authentication#delegation > delegation< / a > request that will yield a delegation token . Example usage : <pre > { @code client . delegation () . addParameter ( api_type firebase ) . start ( new BaseCallback<Map<String Object >> () { { @literal } Override public void onSuccess ( Map<String Object > payload ) {}<CODESPLIT>1
public void Token ( ) throws Auth , Auth Problem { clean Error ( ) ; ( Token Token ) { } Onelogin URL Connection Client http Client Onelogin URL Connection Client ( ) ; Map String , String headers Map String , String ( ) ; headers put ( Auth . Header Type . CONTENT _ TYPE , O Auth . Content Type . JSON ) ; headers . put ( " User - Agent " , this . user Agent ) ; Map < String , Object > params = new Hash Map < String , Object > ( ) ; params . put ( " grant _ type " , Grant Type . REFRESH _ TOKEN ) ; params . put ( " access _ token " , access Token ) ; params . put ( " refresh _ token " , refresh Token ) ; String body = JSON Utils . build JSON ( params ) ; request . set Body ( body ) ; update Tokens ( http Client , request , headers ) ; }<CODESPLIT>Refreshing tokens provides a new set of access and refresh tokens .<CODESPLIT>1
public void Contact To ) { Reference fld Contact Reference ) get ) get CONTACT ) ; String str Contact Type Param = fld Contact Type . get Field Name ( ) ; this . sync Record To Main Field ( fld Contact Type , null , str Contact Type Param ) ; }<CODESPLIT>Read the current file in the header record given the current detail record .<CODESPLIT>0
) public Chrono Zoned Date International Fixed Date zoned Date Temporal temporal ) { Chrono Zoned Date Time < International Fixed Date > ) super . zoned Date Time ( temporal ) ; }<CODESPLIT>A property tied to the map updated when the idle state event is fired .<CODESPLIT>0
private Network ( File [ ] networks ) { ( PHASE 2 _ STAGE _ HDR , , NUM _ PHASES ) ; int netct = networks . ; String bldr = String ( ) ; bldr . append ( Merging ) ; bldr . append ( netct ) ; bldr . append ( network ) ; ( netct ) { bldr . append ( ) ; } stage Output ( bldr . to String ( ) ) ; long t 1 = current Time Millis ( ) ; Collection < Proto Network Descriptor > nds = sized Array List ( netct ) ; for ( final File network : networks ) { final String root = network . get Absolute Path ( ) ; final File network Bin = new File ( net Path ) ; nds . add ( new Binary Proto Network Descriptor ( network Bin ) ) ; } Proto Network ret = p 2 . stage 1 Merger ( nds ) ; if ( with Debug ( ) ) { try { Text Proto Network Externalizer text Externalizer = new Text Proto Network Externalizer ( ) ; } catch ( Proto Network Error e ) { error ( " Could not write out equivalenced proto network ." ) ; } long t 2 = current Time Millis ( ) ; bldr . set Length ( 0 ) ; mark Time ( bldr , t 1 , t 2 ) ; mark End Stage ( bldr ) ; stage Output ( bldr . to String ( ) ) ; return ret ;<CODESPLIT>Stage one merger of networks returning the merged proto - network .<CODESPLIT>1
public Streaming Hls Streaming boolean ) Content Store { Streaming Parameters task Streaming Parameters ) ; task set ) ; task . set Secure ( secure ) ; return Enable Streaming Task Result . deserialize ( content Store . perform Task ( Storage Task Constants . ENABLE _ HLS _ TASK _ NAME , task Params . serialize ( ) ) ) ; }<CODESPLIT>{<CODESPLIT>1
public static Map Entry String , Map String , get Bars Command ( ) { Map Entry ( _ SYSTEM _ BARS , Immutable Map . of ( ) ) ; }<CODESPLIT>This method forms a { @link Map } of parameters for the getting of a network connection value .<CODESPLIT>0
public Response Query ( String , Input Stream , String resource , Http http ) { Jax = . get Instance ( ) ; final Document doc = new Schema Checker ( " post " ) . check ( input ) ; final Map < Query Parameter , String > param = get Parameters ( doc , impl ) ; return create Response ( impl , path ) ; }<CODESPLIT>This method will be called when a HTTP client sends a POST request to an existing resource with application / query + xml as Content - Type .<CODESPLIT>1
public boolean Value index ) { ) { index ) ) . size ( ) ; } else if ( m _ base Collection instanceof Sorted Map ) { return index < ( ( Sorted Map < ? , ? > ) m _ base Collection ) . size ( ) ; } return false ;<CODESPLIT>Prepares this widget dialog parameter to be committed . <p ><CODESPLIT>0
public void marshall ( Direct Connect Gateway Associations Request Direct Connect Gateway Associations Request , Marshaller Marshaller ) { ( Direct Connect Gateway Associations Request ) { Sdk Client ( argument passed to marshall (...)" ) ; } { Marshaller marshall ( Direct Connect Gateway Associations Request get Association Id ( ) , ASSOCIATIONID BINDING ) ; protocol Marshaller . marshall ( describe Direct Connect Gateway Associations Request . get Associated Gateway Id ( ) , ASSOCIATEDGATEWAYID _ BINDING ) ; protocol Marshaller . marshall ( describe Direct Connect Gateway Associations Request . get Direct Connect Gateway Id ( ) , DIRECTCONNECTGATEWAYID _ BINDING ) ; protocol Marshaller . marshall ( describe Direct Connect Gateway Associations Request . get Max Results ( ) , MAXRESULTS _ BINDING ) ; protocol Marshaller . marshall ( describe Direct Connect Gateway Associations Request . get Next Token ( ) , NEXTTOKEN _ BINDING ) ; } catch ( Exception e ) { } }<CODESPLIT><p > The sources for the applications ( up to 10 ) . If you specify scaling plan names you cannot specify application sources . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setApplicationSources ( java . util . Collection ) } or { @link #withApplicationSources ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
public Object ( String ) { { script ( ")" ) ; } ( Script e ) { throw new Bundling Process Exception ( " Error while evaluating a script " , e ) ; } }<CODESPLIT>Returns the JSON object from a string<CODESPLIT>0
public Map Server Group , EV Cache Server Group Config discover ( String Name ) throws { String property Name = Name "- NODES ; ( log . is Debug ( ) ) log . ( List of Nodes = List String ) ; ( node List String != null && node List String . length ( ) > 0 ) return bootstrap From System Property ( node List String ) ; if ( env != null && region != null ) return bootstrap From Eureka ( app Name ) ; return Collections . < Server Group , EV Cache Server Group Config > empty Map ( ) ; }<CODESPLIT>Netflix specific impl so we can load from eureka .<CODESPLIT>0
private boolean distinguished Equals dsn dsn ) { 500 Principal dsn ) . equals ( new X 500 Principal ( dsn 2 ) ) ; }<CODESPLIT>Compare two DSN<CODESPLIT>1
public static Bloom Filter deserialize ( Input Stream ) throws { ( == ) { ( Input stream is ) ; } { Data Input Stream data Input Stream = Data Input Stream ( ) ; int Hash Func = data Input Stream . read Byte ( ) ; int bitset Array Len = data Input Stream . read Int ( ) ; long [ ] data = new long [ bitset Array Len ] ; data [ i ] = data Input Stream . read Long ( ) ; } return new Bloom K Filter ( data , num Hash Func ) ; catch ( Runtime Exception e ) { io . init Cause ( e ) ; throw io ; } }<CODESPLIT>Deserialize a bloom filter Read a byte stream which was written by { @linkplain #serialize ( OutputStream BloomKFilter ) } into a { @code BloomKFilter }<CODESPLIT>1
public void set Restore Last Valid ( boolean restore Last Valid ) { ( has ) ( Last text restore filed has ) ; ( restore Last Valid ) { ( restore Listener == null ) restore Focus Listener = new Last Valid Focus Listener ( ) ; add Listener ( restore Focus Listener ) ; } else { remove Listener ( restore Focus Listener ) ; } }<CODESPLIT>Adds vertical or horizontal {<CODESPLIT>0
public static Long Exact Long Value ) create Long ) Math . decrement Exact ( a . get ( ) ) , a ) ; }<CODESPLIT>Binding for { @link java . lang . Math#decrementExact ( long ) }<CODESPLIT>1
public static String dgst ( Input Stream is , ) { check Not Null ( is ) ; dgst dgst ( is , ) ; base 16 ( ) . encode ( dgst Bytes ) ; }<CODESPLIT>Calculates digest and returns the value as a hex string .<CODESPLIT>1
( ! the Output Directory . ( ) ) { the Output Directory . ( ) ; } ( ! the Output Directory . is Directory ( ) ) { ( the Output Directory is not a directory ) ; } String value Name = the Value Tm . get Class Name ( ) ; String = Filename Prefix ; String = Filename Suffix ; ( the Target Target Type . SOURCE ) { ( ! . With ( ". java ) ) { += ". java ; String file Name = value Name ; File f = File ( the Output Directory , file Name ) ; our Log . debug ( " Writing file : {}" , f . get Absolute Path ( ) ) ; Velocity Context ctx = new Velocity Context ( ) ; Input Stream template Is = null ; ctx . put ( " value Set " , the Value Set Tm ) ; ctx . put ( " package Base " , the Package Base ) ; ctx . put ( " esc " , new Escape Tool ( ) ) ; Velocity Engine v = Velocity Helper . configure Velocity Engine ( my Template File , my Velocity Path , my Velocity Properties ) ; if ( my Template File != null ) { template Is = new File Input Stream ( my Template File ) ; } else { String template Name = my Template ; if ( null == template Name ) { template Is = this . get Class ( ) . get Resource As Stream ( template Name ) ; v . evaluate ( ctx , w , "" , template Reader ) ; w . close ( ) ;<CODESPLIT>}<CODESPLIT>1
public void issue ) issue ) ) Input ) Input Input Default Input File ) issue . primary Location ( ) . input Component ( ) ; if ( should Skip Storage ( default Input File ) ) { return ; default Input File . set Published ( true ) ; module Issues . init And Add Issue ( issue ) ;<CODESPLIT>Thread safe assuming that each issues for each file are only written once .<CODESPLIT>1
public Class get Class From Collection ( String collection ) { Mapped Class mcs = mapped By Collection . get ( collection ) ; ( mcs == mcs . is Empty ( ) ) { } ( mcs . size ( ) 1 ) { ( . is Info ( ) ) { LOG . info ( format ( " Found more than one class mapped to collection '% s '% s " , collection , mcs ) ) ; } } return mcs . iterator ( ) . next ( ) . get Clazz ( ) ; }<CODESPLIT>Converts a DBObject back to a type - safe java object ( POJO )<CODESPLIT>0
private Token eventually Match Token kind ) { check Not Eof ) ; Token get index ) ; ( token . kind != kind ) { return null ; } else { return token ; } }<CODESPLIT>Match a given sequence of tokens whilst moving passed any whitespace encountered inbetween . In the case that meet the end of the stream or we don t match the expected tokens in the expected order then an error is thrown .<CODESPLIT>0
public static Waehrung of ) { Waehrung ) { Waehrung ) Unit ; } else { return of ( currency Unit . get Currency Code ( ) ) ; }<CODESPLIT>Gibt die entsprechende Currency als Waehrung zurueck .<CODESPLIT>1
private Content Param ( boolean , Param Tag param , String , String , Taglet writer , String Documented ) { Content writer get Output Instance ( ) ; ( param ) { ( ; param ; ) { Param Tag param ; String param Name = is Non Type Params ? pt . parameter Name ( ) : "<" + pt . parameter Name ( ) + ">" ; if ( ! rank Map . contains Key ( pt . parameter Name ( ) ) ) { writer . get Msg Retriever ( ) . warning ( pt . position ( ) , is Non Type Params ? " doclet . Parameters _ warn " : " doclet . Type _ Parameters _ warn " , param Name ) ; } String rank = rank Map . get ( pt . parameter Name ( ) ) ; if ( rank != null && already Documented . contains ( rank ) ) { } result . add Content ( process Param Tag ( is Non Type Params , writer , pt , pt . parameter Name ( ) , already Documented . size ( ) == 0 ) ) ; already Documented . add ( rank ) ; } } return result ; }<CODESPLIT>Checks the current system time against the time limit throwing an InterruptedException if the time is up .<CODESPLIT>0
public void set Versions ( String ) { ( ) { ; return ; } this . versions = new com . amazonaws . internal . Sdk Internal List < String > ( versions ) ; }<CODESPLIT><p > The version numbers of one or more launch template versions to delete . < / p ><CODESPLIT>0
private static Script Runner get Runner ( ) throws { ( Runner get ( ) ) { Script Runner Script Runner Factory create Runner ( ) ; { load Script ( CSL class . get Resource ( " dump . js " ) ) ; runner . load Script ( CSL . class . get Resource ( " citeproc . js " ) ) ; runner . load Script ( CSL . class . get Resource ( " formats . js " ) ) ; } catch ( Script Runner Exception e ) { } shared Runner . set ( runner ) ; } return shared Runner . get ( ) ; }<CODESPLIT>Calculates a list of available citation locales<CODESPLIT>0
public Print Query add ( Select select Bldr , ... ) throws E Faps { ( phrase UUID : _ msg Phrase ) { msgphrases . add ( Msg Phrase . get ( phrase UUID ) ) ; } return add Msg Phrase ( _ select Bldr , msgphrases . to Array ( new Msg Phrase [ msgphrases . size ( ) ] ) ) ; }<CODESPLIT>Adds the msg phrase .<CODESPLIT>1
private extract Soy ) { attributes ) ; MESSAGE ATTRIBUTE matcher ( msg . get Desc ( ) ) ; while ( matcher . find ( ) ) { attributes . append ( matcher . group ( ) ) ; return attributes . to String ( ) ;<CODESPLIT>Extracts message attributes from the message description . Returns an empty {<CODESPLIT>1
Volt Table execute Slow Homogeneous Batch ( List Queued , boolean ) { assert ( txn ) ; ( int 0 ; ( ) ; ) { Queued queued get ( ) ; assert ( queued stmt ) ; int collector Output Dep Id txn get Next Id ( ) ; Byte Buffer param ; { param Byte Buffer ( queued params get Serialized ( ) ) ; queued params flatten To Buffer ( param ) ; } ( e ) { } assert ( param Buf != null ) ; param Buf . flip ( ) ; state . add Statement ( i , queued SQL . stmt , param Buf , m _ site ) ; } m _ txn State . setup Procedure Resume ( state . m _ deps To Resume ) ; for ( int i = 0 ; i < state . m _ deps For Local Task . length ; i ++ ) { if ( state . m _ deps For Local Task [ i ] < 0 ) { continue ; } state . m _ local Task . set Input Dep Id ( i , state . m _ deps For Local Task [ i ] ) ; } m _ txn State . create Local Fragment Work ( state . m _ local Task , state . m _ local Frags Are Non Transactional && final Task ) ; if ( ! state . m _ distributed Task . is Empty ( ) ) { state . m _ distributed Task . set Batch ( m _ batch Index ) ; m _ txn State . create All Participating Fragment Work ( state . m _ distributed Task ) ; } Map < Integer , List < Volt Table > > map Results = m _ site . recursable Run ( m _ txn State ) ; assert ( map Results != null ) ; assert ( state . m _ deps To Resume != null ) ; assert ( state . m _ deps To Resume . length == batch . size ( ) ) ; for ( int i = 0 ; i < batch . size ( ) ; i ++ ) { List < Volt Table > matching Tables For Id = map Results . get ( state . m _ deps To Resume [ i ] ) ; assert ( matching Tables For Id != null ) ; assert ( matching Tables For Id . size ( ) == 1 ) ; state . m _ results [ i ] = matching Tables For Id . get ( 0 ) ; return state . m _ results ;<CODESPLIT>/ * Execute a batch of homogeneous queries i . e . all reads or all writes .<CODESPLIT>1
public Grpc start ( ) { Retry retry ( Starting RPC , ( ) -> start ( ) , Exponential Backoff Retry ( , 500 , 5 ) ) ; = true ; return this ; }<CODESPLIT>Start serving .<CODESPLIT>1
public close ) { chk ) ; vec Appendable Vec ) ( Appendable Vec ) _ vec ) . close Chunk ( this ) ; return chk ; }<CODESPLIT>Slow - path append data<CODESPLIT>0
public static , , Entry ( . Entry < K , V > > p ) { return for Entries ( Predicates . < Map . Entry < K , V > > any ( p ) ) ; }<CODESPLIT>Returns a predicate that evaluates to {<CODESPLIT>0
public static U Bi U ( Bi T , U > predicate ) { return bi Predicate ( predicate , THROWABLE _ TO _ RUNTIME _ EXCEPTION ) ; }<CODESPLIT>Wrap a {<CODESPLIT>0
private Fu By Janto ) { Tile janto Tile get Janto ) get Tile ) ; ; janto Tile == general Situation . get Bakaze ( ) ) { tmp += 2 ; } if ( janto Tile == personal Situation . get Jikaze ( ) ) { tmp += 2 ; } tmp += 2 ; } return tmp ; }<CODESPLIT>待ちの種類による可符<CODESPLIT>0
public To Instance add To Instance To Instance Request request ) request Client Execution ( request ) ; return execute Add Role To DB Instance ( request ) ; }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public static get Value index ) { not not ) ; Ldap ldap Or Construct Ldap From ) ; Rdn rdn ldap get Rdn index ) ; rdn ) ) { . warn ( " Rdn at position " + index + " of dn '" + name + "' is multi - value - returned value is not to be trusted . " + " Consider using name - based get Value method instead " ) ; } return rdn . get Value ( ) ; }<CODESPLIT>Get the value of the Rdn with the requested key in the supplied Name as a String .<CODESPLIT>0
