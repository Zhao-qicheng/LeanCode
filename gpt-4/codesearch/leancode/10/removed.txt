public InputStream getResourceAsStream ( String resourceName ) { InputStream is = null ; String realPath = getRealResourcePath ( resourceName ) ; if ( isFileSystemPath ( resourceName realPath ) ) { { is = new FileInputStream ( realPath ) ; } ( FileNotFoundException ) { LOGGER. debug (The resource realPath + has not found ) ; } } if ( is == null ) { is = super. getResourceAsStream ( realPath ) ; } return is ; }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>0
public static void register ( Binder binder, Class <? > clazz, Class <? extends Annotation > annotation ) { registerKey ( binder. ( clazz annotation ) ) ; }<CODESPLIT>Registers a class / annotation combination to instantiate eagerly . Classes mentioned here will be pulled out of the injector with an injector . getInstance () call when the lifecycle is created .<CODESPLIT>1
public static br_restoreconfig [ ] restoreconfig ( nitro_service client, br_restoreconfig [ ] resources ) throws Exception { if ( resources == null ) throw new Exception (Null resource array ) ; if ( resources. length == 1 ) return ( ( brrestoreconfig ) resources. performoperation ( client,restoreconfig ) ) ; return ( ( br_restoreconfig [ ] ) perform_operation_bulk_request ( client, resources, "restoreconfig" ) ) ; }<CODESPLIT><pre > Use this operation to restore config from file on Repeater Instances . < / pre ><CODESPLIT>0
public Page findPageParameter ( Object paramObj ) { Page page = null ; if ( paramObj Page ) page = ( Page ) paramObj ; } if ( paramObj Map ) { Map m = ( Map ) paramObj ; for ( o m. values ( ) ) { if ( o Page ) { page = ( Page ) o ; ; } } } if ( page null ) { PAGETHREADLOCAL. set ( page ) ; } return page ; }<CODESPLIT>从传递的参数中找Page对象，并返回<CODESPLIT>1
public static InputStream getResourceAsStream ( Class <? > clazz, String fn ) throws IOException { InputStream stream = clazz. getResourceAsStream ( fn ) ; if ( stream == null ) { throw new IOException ( "resource fn relative to " clazz " found." ) ; } return unpackStream ( stream, fn ) ; }<CODESPLIT>Get an input stream to read the raw contents of the given resource remember to close it : )<CODESPLIT>1
public static < T, R > Supplier < R > compose ( Function < T, R > f, Supplier < T > g ) { dbc. precondition ( f null, compose supplier with a null function ) ; dbc. precondition ( g null, compose function with a null supplier ) ; return ( ) f. apply ( g. get ( ) ) ; }<CODESPLIT>Composes a function with a ternary function .<CODESPLIT>0
public void getChars ( int srcBegin, int srcEnd, char dst [ ], int dstBegin ) { int destIndex = dstBegin ; for ( srcBegin ; srcEnd ; ) { dst [ destIndex ++ ] = m_str. charAt ( i ) ; } }<CODESPLIT>Copies characters from this string into the destination character array .<CODESPLIT>1
public String getRedirectURL ( FacesContext context, String viewId, Map String, List String parameters, boolean includeViewParams ) { return getActionURL ( context, viewId ) ; }<CODESPLIT><p class = changed_added_2_0 > Return a JSF action URL derived from the <code > viewId< / code > argument that is suitable to be used by the { @link NavigationHandler } to issue a redirect request to the URL using a NonFaces request . Compliant implementations must implement this method as specified in section JSF . 7 . 6 . 2 . The default implementation simply calls through to { @link #getActionURL } passing the arguments <code > context< / code > and <code > viewId< / code > . < / p ><CODESPLIT>1
@ Override public EClass getServerInfo ( ) { if ( serverInfoEClass == null ) serverInfoEClass = ( EClass ) EPackage. Registry.. ( StorePackage. eNS ). getEClassifiers ( ). ( 45 ) ; } return serverInfoEClass ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>0
public void addMaybeStartHandler ( Handler handler, Stage stage ) throws Exception { synchronized ( handlers ) { if ( started ( ) ) if ( currStage == null stage compareTo ( currStage ) < ) { handler. start ( ) ; } } handlers. ( stage ). add ( handler ) ; } }<CODESPLIT>This will materialize the entire sequence in memory . Use at your own risk .<CODESPLIT>0
@ SuppressWarnings ( {unused,WeakerAccess } ) public static CleverTapAPI instanceWithConfig ( Context context, @ NonNull CleverTapInstanceConfig config ) { if ( config == null ) { Logger. v (CleTapInstanceConfig null ) ; return null ; } if ( instances == null ) { instances = new HashMap ( ) ; } CleTapAPI instance = instances. ( config.AccountId ( ) ) ; if ( instance == null ) { instance = new CleTapAPI ( context, config ) ; instances. put ( config. getAccountId ( ), instance ) ; } return instance ; }<CODESPLIT>Lifecycle<CODESPLIT>0
public ElemTemplate getCurrentTemplate ( ) { ElemTemplateElement elem = getCurrentElement ( ) ; while ( ( elem ) ( elem.SLToken ( ) Constants. ELEMTEMPLATE ) ) { elem = elem. getParentElem ( ) ; } return ( ElemTemplate ) elem ; }<CODESPLIT>This method retrieves the xsl : template that is in effect which may be a matched template or a named template .<CODESPLIT>1
public static boolean normalize ( IAtomContainer ac, Document doc ) throws InvalidSmilesException, CDKException { NodeList nl = doc. getElementsByTagName ( "replace-set" ) ; SmilesParser sp = new SmilesParser ( ac. getBuilder ( ) ) ; boolean change = false ; for ( nl. ( ) ) { Element child = ( Element ) nl. item ( ) ; NodeList replaces = child. getElementsByTagName ( "replace" ) ; NodeList replacement = child. getElementsByTagName ( "replacement" ) ; String replacementstring = replacement. item ( 0 ). getFirstChild ( ). getNodeValue ( ) ; if ( replacementstring. ('' ) > - 1 replacementstring. length ( ) < 1 ) { replacementstring = replacement. item ( 0 ). getFirstChild ( ). getNextSibling ( ). getNodeValue ( ) ; } IAtomContainer replacementStructure = sp. parseSmiles ( replacementstring ) ; for ( replaces. ( ) ) { Element replace = ( Element ) replaces. item ( k ) ; String replacestring = replace. getFirstChild ( ). getNodeValue ( ) ; if ( replacestring. ('' ) > - 1 replacestring. length ( ) < 1 ) { replacestring = replace. getFirstChild ( ). getNextSibling ( ). getNodeValue ( ) ; } IAtomContainer replaceStructure = sp. parseSmiles ( replacestring ) ; List RMap l = null ; UniversalIsomorphTester universalIsomorphTester = new UniversalIsomorphTester ( ) ; while ( ( universalIsT.Map ( ac, replaceStructure ) ) ) { List RMap l2 = universalIsomorphTester. makeAtomsMapOfBondsMap ( l, ac, replaceStructure ) ; Iterator RMap bondit = l. iterator ( ) ; while (. ( ) ) { RMap rmap = bondit. next ( ) ; IBond acbond = ac. getBond ( rmap. getId1 ( ) ) ; IBond replacebond = replacementStructure. getBond ( rmap. getId2 ( ) ) ; ac. setOrder ( replace. getOrder ( ) ) ; change = true ; } Iterator RMap atomit = l2. iterator ( ) ; while ( atom. ( ) ) { RMap rmap = atomit. next ( ) ; acatom = ac. getAtom ( rmap. getId1 ( ) ) ; replaceatom = replacementStructure. getAtom ( rmap. getId2 ( ) ) ; acatom. setFormalCharge ( replaceatom. getFormalCharge ( ) ) ; change = true ; } } } } return ( change ) ; }<CODESPLIT>The method takes an XML files like the following : <br > &lt ; replace - set&gt ; <br > &lt ; replace&gt ; O = N = O&lt ; / replace&gt ; <br > &lt ; replacement&gt ; [ O - ] [ N + ] = O&lt ; / replacement&gt ; <br > &lt ; / replace - set&gt ; <br > All parts in ac which are the same as replace will be changed according to replacement . Currently the following changes are done : BondOrder FormalCharge . For detection of fragments like replace we rely on UniversalIsomorphismTester . doc may contain several replace - sets and a replace - set may contain several replace fragments which will all be normalized according to replacement .<CODESPLIT>1
protected void writeTraceeContextToMessage ( Message message ) throws JMSException { if ( backend isEmpty ( ) backend getConfiguration ( ). shouldProcessContext ( AsyncDispatch ) ) { Map String, String filteredContext = backend. getConfiguration ( ). filterDeniedParams ( backend. copyToMap ( ), AsyncDispatch ) ; String contextAsString = httpHeaderSerialization. render ( filteredContext ) ; message. setStringProperty ( Trace. TPICHEADER, contextAsString ) ; } }<CODESPLIT>Writes the current TraceeContext to the given javaee message . This method is idempotent .<CODESPLIT>1
public void product ( IntLongVector other ) { for ( int ; < size ; ++ ) { elements [ i + start ] *= other. get ( i ) ; } }<CODESPLIT>/ * This method is used to get PHSFellowshipSupplemental12 XMLObject and set the data to it from DevelopmentProposal data .<CODESPLIT>0
public static SignatureValidationFilter buildSignatureValidationFilter ( final Resource signatureResourceLocation ) throws Exception { ( ResourceResourceExist ( signatureResourceLocation ) ). (Resource cannot be located signatureResourceLocation ) ; return null ; } val keyInfoProviderList = new ArrayList KeyInfoProvider ( ) ; keyInfoProviderList add ( new RSAKeyValueProvider ( ) ) ; keyInfoProviderList. add ( new DSAKeyValueProvider ( ) ) ; keyInfoProviderList. add ( new DEREncodedKeyValueProvider ( ) ) ; keyInfoProviderList. add ( new InlineX509 ( ) ) ;. debug (Attempting to resolve credentials from signatureResourceLocation ) ; val credential = buildCredentialForMetadataSignatureValidation ( signatureResourceLocation ) ;. info (Successfully resolved credentials from signatureResourceLocation ) ;. debug (Configuring credential resolver for key signature trust engine @, credential. getCredentialType ( ). ( ) ) ; val resolver = new StaticCredentialResolver ( credential ) ; val keyInfoResolver = new BasicProviderKeyInfoCredentialResolver ( keyInfoProviderList ) ; val trustEngine = new ExplicitKeySignatureTrustEngine ( resolver, keyInfoResolver ) ; LOGGER. (Adding signature validation filter based on the configured trust engine ) ; val signatureValidationFilter = new SignatureValidationFilter ( trustEngine ) ; signatureValidationFilter. setDefaultCriteria ( new SignatureValidationCriteriaSetFactoryBean ( ). getObject ( ) ) ;. debug (Added metadata SignatureValidationFilter with signature from signatureResourceLocation ) ; return signatureValidationFilter ; }<CODESPLIT>Build signature validation filter if needed .<CODESPLIT>1
public static URL makeURL ( String specification ) throws MalformedURLException { logger. trace (retrieving URL specification '{}'", specification ) ; if ( specification. (classpath ) ) { logger. trace ( "URL of typeclasspath'" ) ; return new URL ( null, specification, new ClassPathURLStreamHandler ( ) ) ; } logger. trace ( "URL of normal type ) ; return new URL ( specification ) ; }<CODESPLIT>Returns an URL object for the given URL specification .<CODESPLIT>1
public final void debug ( Object message, Throwable t ) { if ( isLevelEnabled (LEVELDEBUG ) ) { log ( LOGLEVELDEBUG, message, t ) ; } }<CODESPLIT><p > Log a message with debug log level . < / p ><CODESPLIT>1
protected final String toLocaleStr ( Locale locale ) { if ( locale == Locale ROOT ) { return "" ; } String language = locale. getLanguage ( ) ; String country = locale. getCountry ( ) ; String variant = locale.Variant ( ) ; if ( language == "" country == "" variant == "" ) { return "" ; } StringBuilder sb = new StringBuilder ( ) ; if ( variant "" ) { sb. ( language ). ( ). ( country ). append ( ). append ( variant ) ; } if ( country "" ) { sb. append ( language ). append ( ). append ( country ) ; } { sb. append ( language ) ; } return sb. toString ( ) ; }<CODESPLIT>Convert locale to string with language_country [ _variant ]<CODESPLIT>1
public ListFacetAttributesResult withAttributes ( FacetAttribute... attributes ) { ( this attributes == null ) setAttributes ( new java. util. ArrayList FacetAttribute ( attributes. length ) ) ; } for (Attribute ele attributes ) { this. attributes. add ( ele ) ; } return this ; }<CODESPLIT><p > Associates an Identity and Access Management ( IAM ) role from an Neptune DB cluster . < / p ><CODESPLIT>0
public AutofitHelper addOnTextSizeChangeListener ( OnTextSizeChangeListener listener ) { ( mListeners null ) mListeners = new ArrayListTextSizeChangeListener ( ) ; } mListeners. add ( listener ) ; return this ; }<CODESPLIT>Adds an {<CODESPLIT>1
public void mergeVertices ( Set < VertexType > vertexSet, GraphType g, VertexCombinator < VertexType > combinator, GraphToolkit < GraphType, EdgeType, VertexType > toolkit ) { if ( vertexSet. size ( ) <= ) { return ; } TreeSet EdgeType edgeSet = new TreeSet ( ) ; for ( EdgeType g. edgeIterator ( ). ( ) ) { EdgeType =. next ( ) ; if ( vertexSet. contains ( e. getSource ( ) ) vertexSet. contains ( e. getTarget ( ) ) ) { edgeSet. add ( ) ; } } VertexType compositeVertex = combinator. combineVertices ( vertexSet ) ; for ( EdgeType edgeSet ) { VertexType source = vertexSet. contains (. getSource ( ) ) compositeVertex :. getSource ( ) ; VertexType target = vertexSet. contains (. getTarget ( ) ) compositeVertex :. getTarget ( ) ; if ( source == compositeVertex target == compositeVertex e. getSource ( ) e. getTarget ( ) ) { ; } if ( g. lookupEdge ( source, target ) null ) { ; } EdgeType compositeEdge = g. createEdge ( source, target ) ; toolkit. copyEdge ( e, compositeEdge ) ; } for ( VertexType aVertexSet vertexSet ) { g. removeVertex ( aVertexSet ) ; } }<CODESPLIT>Resolve an annotation into AnnotationValues representing any type qualifier ( s ) the annotation resolves to . Detects annotations which are directly marked as TypeQualifier annotations and also resolves the use of TypeQualifierNickname annotations .<CODESPLIT>0
@ Override public void visit ( Node node ) throws ELException { if ( node AstFunction ) { AstFunction funcNode = ( AstFunction ) node ; Method m = null ; if ( this. fnMapper null ) { m = fnMapper. resolveFunction ( funcNode. getPrefix ( ), funcNode. getLocalName ( ) ) ; } if ( m == null this. varMapper null funcNode. getPrefix ( ). length ( ) == ) { this. varMapper. resolveVariable ( funcNode. getLocalName ( ) ) ; return ; } if ( this. fnMapper == null ) { throw ELException ( MessageFactory. get ( "errorfnMappernull ) ) ; } if ( m == null ) { throw ELException ( MessageFactory. get ( "errorfnMappermethod funcNode. getOutputName ( ) ) ) ; } methodParameterCount = m. getParameterTypes ( ). length ; inputParameterCount = node. jjtGetChild ( 0 ). jjtGetNumChildren ( ) ; if ( m. isVarArgs ( ) inputParameterCount < methodParameterCount - 1! m. isVarArgs ( ) inputParameterCount methodParameterCount ) { throw ELException ( MessageFactory. get ( "errorfnMapperparamcount funcNode. getOutputName ( ) methodCount node. jjtGetChild ( ). jjtGetNumChildren ( ) ) ) ; } } if ( node AstIdentifier this. varMapper!= null ) { String variable = ( ( AstIdentifier ) node ). getImage ( ) ; this. varMapper. resolveVariable ( variable ) ; } }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public Observable < Job > getJobDetailsAsync ( String teamName, String jobId ) { return getJobDetailsWithServiceResponseAsync ( teamName, jobId ). map ( new1 ServiceResponse Job, Job ( ) @ Override public Job call ( ServiceResponse < Job > response ) { return. body ( ) ; } } ) ; }<CODESPLIT>Get the Job Details for a Job Id .<CODESPLIT>0
private void checkIndices ( int row, int col ) { if ( row < row >= rows ) throw new ArrayIndexOutOfBoundsException ( "row " + row ) ; if ( col < 0 col >= cols ) throw new ArrayIndexOutOfBoundsException ( "column " + col ) ; }<CODESPLIT>Check that the indices of a requested cell are within bounds .<CODESPLIT>1
private void createParentChildRelationships ( Database db, HashMap < String, Account > descriptionMap, HashMap < String, ArrayList < String > > seqMap ) throws Exception { ArrayList String parentIdStack = new ArrayList String ( ) ; if (! seqMap. containsKey ( Account. ROOTACCOUNTURI ) ) throw new Exception ( "File does not contain the root account, + Account. ROOTACCOUNTURI + ) ; parentIdStack. add ( Account. ROOT_ACCOUNT_URI ) ; while ( parentIdStack. size ( ) > ) { String parentId = parentIdStack. get ( 0 ) ; Account parentAccount = descriptionMap. get ( parentId ) ; parentIdStack. remove ( 0 ) ; if ( parentId. compareTo ( Account. ROOTACCOUNTURI )!= ) { if ( parentAccount!= null ) { if ( db. findAccountById ( parentId ) == null ) { Account parentParentAccount = db. findParent ( parentAccount ) ; if ( parentParentAccount == null ) { logger. warning ( "SeqNode + + a parent, will dropped" ) ; parentAccount = null ; } } } { logger. warning ( "SeqNode + + a matching RDFDescription node, will dropped" ) ; } } { parentAccount = db. getRootAccount ( ) ; } if ( parentAccount!= null ) { for ( String childId : seqMap. get ( ) ) { Account childAccount = descriptionMap. get ( childId ) ; if ( childAccount!= null ) { if (! parentAccount. hasChild ( childAccount ) ) { parentAccount. getChildren ( ). add ( childAccount ) ; if ( seqMap. containsKey ( childAccount. getId ( ) ) ) { parentIdStack. add ( childId ) ; childAccount. setIsFolder ( true ) ; } } { logger. warning ( "Duplicate child + childId + found of parent + parentAccount. ( ) + ) ; } } { logger. warning ( " find RDFDescription for + childId + will dropped" ) ; } } } } }<CODESPLIT><p > Specifies the type of the array components so that the adequate array functions can be offered . < / p ><CODESPLIT>0
private DecimalFormat getNumberFormatter ( TransformerImpl transformer, int contextNode ) throws TransformerException { Locale locale = ( Locale ) getLocale ( transformer, contextNode ). clone ( ) ; DecimalFormat formatter = null ; String digitGroupSepValue = ( null mgroupingSeparatoravt ) mgroupingSeparatoravt. evaluate ( transformer. getXPathContext ( ), contextNode, this ) : null ; if ( ( digitGroupSepValue null ) ( mgroupingSeparatoravt. isSimple ( ) ) ( digitGroupSepValue. length ( ) 1 ) ) { transformer. getMsgMgr ( ). warn ( this, XSLTErrorResources. WGILLEGALATTRIBUTEVALUE, new Object { Constants. ATTRNAME_NAME, m_Separator_avt. getName ( ) } ) ; } String nDigitsPerGroupValue = ( null mgroupingSizeavt ) mgroupingSizeavt. evaluate ( transformer. getXPathContext ( ), contextNode, this ) : null ; if ( ( null digitGroupSepValue ) ( null nDigitsPerGroupValue ) ( digitGroupSepValue. length ( ) > ) ) { try { formatter = ( DecimalFormat ) NumberFormat. getNumberInstance ( locale ) ; formatter. setGroupingSize ( Integer. ( nDigitsGroupValue ). ( ) ) ; DecimalFormatSymbols symbols = formatter. getDecimalFormatSymbols ( ) ; symbols. setGroupingSeparator ( digitGroupValue. ( 0 ) ) ; formatter. setDecimalFormatSymbols ( symbols ) ; formatter. setGroupingUsed ( true ) ; } ( NumberFormatException ) { formatter. setGroupingUsed ( false ) ; } } return formatter ; }<CODESPLIT>Get the number formatter to be used the format the numbers<CODESPLIT>1
public static List < CommerceNotificationTemplate > toModels ( CommerceNotificationTemplateSoap [ ] soapModels ) { if ( soapModels == null ) { return null ; } ListNotificationTemplate models = new ArrayListNotificationTemplate ( soapModels. length ) ; for (NotificationTemplateSoap soapModel soapModels ) { models. add ( toModel ( soapModel ) ) ; } return models ; }<CODESPLIT>Converts the soap model instances into normal model instances .<CODESPLIT>1
public static Double toNullableDouble ( Object value ) { if ( value == null ) return null ; if ( value Date ) return ( double ) ( ( Date ) value ). ( ) ; if ( value Calendar ) return ( double ) ( ( Calendar ) value ). getTimeInMillis ( ) ; if ( value Duration ) return ( double ) ( ( Duration ) value ). ( ) ; if ( value Boolean ) return ( boolean ) value ; if ( value Integer ) return ( double ) ( ( int ) value ) ; if ( value Short ) return ( double ) ( ( short ) value ) ; if ( value Long ) return ( double ) ( ( long ) value ) ; if ( value Float ) return ( double ) ( ( float ) value ) ; if ( value Double ) return ( double ) value ; if ( value String ) try { return Double. parseDouble ( ( String ) value ) ; } ( NumberFormatException ) { return null ; } return null ; }<CODESPLIT>Converts value into doubles or returns default value when conversion is not possible .<CODESPLIT>0
@ Override public HttpCommandProcessor getCommandProcessor ( Protocol protocol ) { String commandProcessorName = commandProcessorNames. get ( protocol ) ; if ( commandProcessorName == null ) { throw PanicInTheCo ( "No HTTP Command Processor configured protocol " protocol ) ; } HttpCommandProcessor commandProcessor = ( HttpCommandProcessor ) applicationContext. getBean ( commandProcessorName ) ; if ( commandProcessor == null ) { throw PanicInTheCo ( "No HTTP Command Processor has configured name " commandProcessorName ) ; } return commandProcessor ; }<CODESPLIT>Returns the command processor assocated with the supplied protocol<CODESPLIT>1
public String getGeneratorParameters ( ) { String result = this. getCommonConstructorParameters ( ) ; result += "," ; result +=this." this. getName ( )From()" ; result += "," ; result +=this." this. getName ( ) "To()" ; result += "," ; result += this. getOwner ( ). getFinderClassName ( ) "." this. getName ( ) "Infinity ; result += "," ; result += this. futureExpiringRowsExist ( ) ; result += "," ; result += this.ToIsInclusive ( ) ; result += "," ; result += this. getOwner ( ). getFinderClassName ( ) "." this. getName ( ) "Default ; result += "," ; result += this.Processing ( ) ; result += "," ; result += this.finityNull ( ) ; return result ; }<CODESPLIT>/ * String attributeName String dataClassName String busClassName boolean isNullable boolean hasBusDate RelatedFinder relatedFinder Map<String Object > properties boolean transactional boolean isOptimistic<CODESPLIT>1
@ Override public boolean setActive ( ) { activated = isActive ( ) ; ( activated ) WebLocator locator1 = new WebLocator ( getPathBuilder ( ). getContainer ( ) ). setElPath ( getTitlePath ( false ) ) ; WebLocator title = locator1. setInfoMessage ( getPathBuilder ( ). getText ( ) + Tab ) ; activated = titleElement. click ( ) ; } ( activated ) LOGGER. info (setActive : toString ( ) ) ; } return activated ; }<CODESPLIT>example new DataField () . setDate ( 19 05 2013 )<CODESPLIT>0
@ Override public StringConverter <? > findConverter ( Class <? > cls ) { if ( cls == Byte ) return ByteArrayStringConverter. INSTANCE ; } return null ; }<CODESPLIT>Creates a new conversion manager including the extended standard set of converters . <p > The returned converter is a new instance that includes additional converters : <ul > <li > JDK converters <li > { @link NumericArrayStringConverterFactory } <li > { @link NumericObjectArrayStringConverterFactory } <li > { @link CharObjectArrayStringConverterFactory } <li > { @link ByteObjectArrayStringConverterFactory } <li > { @link BooleanArrayStringConverterFactory } <li > { @link BooleanObjectArrayStringConverterFactory } < / ul > <p > The convert instance is mutable in a thread - safe manner . Converters may be altered at any time including the JDK converters . It is strongly recommended to only alter the converters before performing actual conversions .<CODESPLIT>0
@ Override public DisassociateS3ResourcesResult disassociateS3Resources ( DisassociateS3ResourcesRequest request ) { request beforeClientExecution ( request return executeDisassociateResources ( request ) ; }<CODESPLIT><p > Removes specified S3 resources from being monitored by Amazon Macie . If memberAccountId isn t specified the action removes specified S3 resources from Macie for the current master account . If memberAccountId is specified the action removes specified S3 resources from Macie for the specified member account . < / p ><CODESPLIT>1
public static double cdf ( double val, double k, double lambda, double theta ) { return ( val theta ) ( 10 - FastMath. exp ( - FastMath. pow ( ( val - theta ) / lambda, k ) ) ) val == val 00 Double. NaN ; }<CODESPLIT>CDF of Weibull distribution<CODESPLIT>1
public static void equalizeLocalCol ( GrayU16 input, int radius, int startX, GrayU16 output, IWorkArrays workArrays ) { int width = 2 * radius + 1 ; int area = width * width ; int maxValue = workArrays. length ( ) - 1 ; int [ ] histogram = workArrays. pop ( ) ; int [ ] transform = workArrays. pop ( ) ; int hist0 = startX ; int hist1 = startX + width ; if ( hist1 > input. width ) { hist1 = input. width ; hist0 = hist1 - width ; } localHistogram ( input, hist0, 0, hist1, width, histogram ) ; int sum = 0 ; for ( histogram. length ) { transform [ ] = sum += histogram [ ] ; } int indexIn = input. startIndex + radius * input. stride + startX ; int indexOut = output. startIndex + radius * output. stride + startX ; for ( x x radius x ) { int inputValue = input. data [ indexIn ++ ] & 0xff ; output. data [ indexOut ++ ] = ( short ) ( ( transform [ inputValue ] * maxValue ) / area ) ; } for ( radius + 1 input. height - radius ) { indexIn = input. startIndex + ( y - radius - 1 ) * input. stride ; for ( x hist0 x hist1 x ) { histogram [ input. data [ indexIn + x ] & 0xFFFF ] -- ; } indexIn += width * input. stride ; for ( x hist0 ; x hist1 ; x ) { histogram [ input. data [ indexIn + x ] & 0xFFFF ] ++ ; } sum = 0 ; for ( ; histogram. length ; ) { transform [ ] = sum += histogram [ ] ; } indexIn = input. startIndex + y * input. stride + startX ; indexOut = output. startIndex + y * output. stride + startX ; for ( x ; x radius ; x ) { int inputValue = input. data [ indexIn ++ ] & 0xff ; output. data [ indexOut ++ ] = ( short ) ( ( transform [ inputValue ] * maxValue ) / area ) ; } } workArrays. recycle ( histogram ) ; workArrays. recycle ( transform ) ; }<CODESPLIT>Local equalization along a row . Image must be at least the histogram s width ( 2 * r + 1 ) in width and height .<CODESPLIT>0
public static int validArrayIndex ( final int index, final int arrayLength, final String message ) { if ( index < index arrayLength ) { IndexOutOfBoundsException ( message ) ; } return index ; }<CODESPLIT>Throws an { @link IndexOutOfBoundsException } if { @code sliceFrom } or { @code sliceLength } is negative or the sum of both is greater than { @code arrayLength } . Note that this means that a slice of length zero starting at array length is a valid slice .<CODESPLIT>0
public static QConnectorSync create ( String host, int port ) { return create (, port, true, true ) ; }<CODESPLIT>ファイルが1904年始まりの設定かどうか。<CODESPLIT>0
private < T extends INode > T addNode ( String src, T child, long childDiskspace, boolean inheritPermission ) throws QuotaExceededException { byte components = INode. getPathComponents ( src ) ; byte [ path = components [ components. length - 1 ; child. setLocalName ( path ) ; cacheName ( child ) ; INode inodes = new INode components. length ; writeLock ( ) ; try { rootDir. getExistingPath ( components, in ) ; return addChild ( inodes, inodes. length - 1, child, childDiskspace, inheritPermission ) ; } { writeUnlock ( ) ; } }<CODESPLIT>Add a node child to the namespace . The full path name of the node is src . childDiskspace should be - 1 if unknown . QuotaExceededException is thrown if it violates quota limit<CODESPLIT>1
public Vector4f add ( float x, float y, float z, float w ) { return add (,,,, thisOrNew ( ) ) ; }<CODESPLIT>Increment the components of this vector by the given values .<CODESPLIT>1
public final DetectLanguageResponse detectLanguage ( String parent, String model, String mimeType ) { ( parent isEmpty ( ) ) LOCATIONPATHTEMPLATE. validate ( parent,detectLanguage ) ; } DetectLanguageRequest request = DetectLanguageRequest newBuilder ( ). setParent ( parent ). setModel ( model ). setMimeType ( mimeType ). build ( ) ; return detectLanguage ( request ) ; }<CODESPLIT>Formats a string containing the fully - qualified path to represent a location resource .<CODESPLIT>0
protected void commonSetup ( ZMatrixRMaj A ) { setExpectedMaxSize ( A, A. ) ; QR set ( A ) ; }<CODESPLIT><p > Computes the householder vector u for the first column of submatrix j . Note this is a specialized householder for this problem . There is some protection against overflow and underflow . < / p > <p > Q = I - &gamma ; uu<sup > H< / sup > < / p > <p > This function finds the values of u and &gamma ; . < / p ><CODESPLIT>0
@ Override public EsaResourceWritable parseFileToResource ( File assetFile, File metadataFile, String contentUrl ) throws RepositoryException { ArtifactMetadata artifactMetadata = explodeArtifact ( assetFile, metadataFile ) ; ProvisioningFeatureDefinition feature ; try { feature = EsaSubsystemFeatureDefinitionImpl. constructInstance ( assetFile ) ; } ( IOException ) { throw RepositoryArchiveIOException (. ( ) assetFile ) ; } EsaResourceWritable resource = WritableResourceFactory. createEsa ( null ) ; String symbolicName = feature. getSyName ( ) ; String version = feature. getVersion ( ). toString ( ) ; String subsystemName = feature. getHeader ( "SubsystemName, Locale. ) ; String shortName = feature. getIbmShortName ( ) ; String metadataName = artifactMetadata null artifactMetadata. getName ( ) : null ; String name ; if ( metadataName null metadataName. isEmpty ( ) ) { name = metadataName ; } if ( subsystemName null subsystemName. isEmpty ( ) ) { name = subsystemName ; } if ( shortName null shortName. isEmpty ( ) ) { name = shortName ; } { name = symbolicName ; } resource. setName ( name ) ; String shortDescription = null ; String overriddenDisplayPolicy = null ; if ( artifactMetadata null ) { shortDescription = artifactMetadata. getShortDescription ( ) ; resource. setDescription ( artifactMetadata. getLongDescription ( ) ) ; resource. setVanityURL ( artifactMetadata. getProperty (VANURL ) ) ; overriddenDisplayPolicy = artifactMetadata. getProperty ( PROP_DISPLAY_POLICY ) ; } if ( shortDescription == null ) { shortDescription = feature. getHeader (SubsystemDescription, Locale. ) ; } resource. setShortDescription ( shortDescription ) ; resource. setVersion ( version ) ; processIcons ( assetFile, feature, resource ) ; String provider = feature. getHeader ( "SubsystemVendor ) ; if ( provider null provider. isEmpty ( ) ) { resource. setProviderName ( provider ) ; if (IBM. ( provider ) ) { resource. setProviderUrl (httpibm ) ; } } { throw InvalidParameterException ( "SubsystemVendor set manifest headers ) ; } resource. setProvideFeature ( symbolicName ) ; if ( artifactMetadata null artifactMetadata. getProperty (IBMAppliesTo ) null ) { resource. setAppliesTo ( artifactMetadata. getProperty (IBMAppliesTo ) ) ; } { resource. setAppliesTo ( feature. getHeader (IBMAppliesTo ) ) ; } Visibility visibility ; DisplayPolicy displayPolicy ; DisplayPolicy webDisplayPolicy ; if ( com. ibm. ws. kernel. feature. Visibility. PUBLIC. ( feature.Visibility ( ) ) ) { visibility = Visibility. PUBLIC ; displayPolicy = DisplayPolicy. VISIBLE ; webDisplayPolicy = DisplayPolicy. VISIBLE ; } if ( com. ibm. ws. kernel. feature. Visibility. PROTECTED. ( feature.Visibility ( ) ) ) { visibility = Visibility. PROTECTED ; displayPolicy = DisplayPolicy. HIDDEN ; webDisplayPolicy = DisplayPolicy. HIDDEN ; } if ( com. ibm. ws. kernel. feature. Visibility. INSTALL. ( feature.Visibility ( ) ) ) { visibility = Visibility. INSTALL ; displayPolicy = DisplayPolicy. VISIBLE ; webDisplayPolicy = DisplayPolicy. HIDDEN ; } { visibility = Visibility. PRIVATE ; displayPolicy = DisplayPolicy. HIDDEN ; webDisplayPolicy = DisplayPolicy. HIDDEN ; } resource. setVisibility ( visibility ) ; if ( feature. isAutoFeature ( ) ) { resource. setProvisionCapability ( feature. getHeader (IBMProvisionCapability ) ) ; String IBMInstallPolicy = feature. getHeader ( "IBMInstallPolicy ) ; InstallPolicy installPolicy ; if ( IBMInstallPolicy null (whensatisfied. ( IBMInstallPolicy ) ) ) { installPolicy = InstallPolicy. WHEN_SATISFIED ; } { installPolicy = InstallPolicy. MANUAL ; displayPolicy = DisplayPolicy. VISIBLE ; webDisplayPolicy = DisplayPolicy. VISIBLE ; } resource. setInstallPolicy ( installPolicy ) ; } if ( isBeta ( resource.AppliesTo ( ) ) ) { resource. setWebDisplayPolicy (Policy. HIDDEN ) ; } { resource. setWebDisplayPolicy ( webDisplayPolicy ) ; } if ( overriddenDisplayPolicy null ) { displayPolicy = DisplayPolicy. valueOf ( overriddenDisplayPolicy ) ; } resource. setDisplayPolicy ( displayPolicy ) ; String requiredFixes = feature. getHeader ( "IBMRequireFix ) ; if ( requiredFixes null requiredFixes. isEmpty ( ) ) { String fixes = requiredFixes. split ( "," ) ; for ( fixes ) { fix = fix. trim ( ) ; if ( fix. isEmpty ( ) ) { resource. addRequireFix ( fix ) ; } } } resource. setShortName ( shortName ) ; Collection FeatureResource requiredFeatures = feature. getConstituents ( SubsystemContentType. FEATURETYPE ) ; for ( FeatureResource featureResource requiredFeatures ) { List String tolerates = featureResource. getTolerates ( ) ; String requiredFeatureSyName = featureResource. getSyName ( ) ; resource. addRequireFeatureWithTolerates ( requiredFeatureSymbolicName, tolerates ) ; } String supersededBy = feature. getSupersededBy ( ) ; if ( superseBy null superseBy. trim ( ). isEmpty ( ) ) { String supersededByArray = supersededBy. split ( "," ) ; for ( superseByArray ) { if ( f. startsWith ( "[" ) ) { f = f. ( 1, f. length ( ) - 1 ) ; resource. addSupersededByOptional ( f ) ; } { resource. addSupersededBy ( f ) ; } } } if ( artifactMetadata null ) { attachLicenseData ( artifactMetadata, resource ) ; } setJavaRequirements ( assetFile, resource ) ; String attachmentName = symbolicName + ".esa ; addContent ( resource, assetFile, attachmentName, artifactMetadata, contentUrl ) ; try { processLAandLI ( assetFile, resource, feature ) ; } ( IOException ) { throw RepositoryArchiveIOException (. ( ) assetFile ) ; } resource. setLicenseId ( feature. getHeader (SubsystemLicense ) ) ; resource. setSingleton ( Boolean. toString ( feature. isSingleton ( ) ) ) ; resource. setIBMInstallTo ( feature. getHeader (IBMInstallTo ) ) ; return resource ; }<CODESPLIT>Look in the esa for bundles with particular java version requirements . Create an aggregate requirement of the esa as a whole and write the data into the supplied resource<CODESPLIT>0
public static < T > T invokeMethod ( final Object obj, Method method, Object... args ) { try { return ( T ) method. invoke ( obj, args ) ; } ( ) { throwUtil. unwrapAndUn ( ) ; } }<CODESPLIT>调用构造函数 .<CODESPLIT>0
public SSLEngine addCommonConfigs ( SSLEngine engine ) { if ( sslConfig. getCSuites ( ) null sslConfig. getCSuites ( ). length > ) { engine. setEnabledCipherSuites ( sslConfig.Suites ( ) ) ; } if ( sslConfig.EnableProtocols ( ) null sslConfig.EnableProtocols ( ). length > ) { engine. setEnabledProtocols ( sslConfig.EnableProtocols ( ) ) ; } engine. setEnableSessionCreation ( sslConfig. isEnableSessionCreation ( ) ) ; return engine ; }<CODESPLIT>Add common configs for both client and server ssl engines .<CODESPLIT>1
public static InternalKnowledgeBase newKnowledgeBase ( String kbaseId, KieBaseConfiguration conf ) { returnBaseImpl (base, ( RuleBaseConfiguration ) conf ) ; }<CODESPLIT>TODO : FIXME : make it consistent with above<CODESPLIT>0
private < ItemT > void addInternal ( @ Nonnull Iterable < ItemT > items ) { if ( items. iterator ( ). hasNext ( ) ) { return ; } nextBuildNumber = getNextBuildNumber ( items. iterator ( ). next ( ) ) ; if ( newerThan == null olderThan == null ) { Iterator ItemT = items. iterator ( ) ; while (. ( ) ) { add ( iter. next ( ) ) ; if ( isFull ( ) ) { ; } } hasDownPage = iter. hasNext ( ) ; } if ( newerThan null ) { toFillCount = getFillCount ( ) ; if ( toFillCount > ) { LinkedList ItemT itemsToAdd = new LinkedList ( ) ; Iterator ItemT iter = items. iterator ( ) ; while (. ( ) ) { ItemT item = iter. next ( ) ; if ( HistoryPageEntry. getEntryId ( item ) > newerThan ) { itemsToAdd. addLast ( item ) ; if ( itemsToAdd. size ( ) > toFillCount ) { itemsToAdd. removeFirst ( ) ; hasUpPage = true ; } } { ; } } if ( itemsToAdd. size ( ) == ) { hasDownPage = true ; } { if ( itemsToAdd. size ( ) < toFillCount ) { Iterator ItemT skippedIter = items. iterator ( ) ; Iterators. skip ( skippedIter, itemsToAdd. size ( ) ) ; for ( itemsToAdd. ( ) to skipped. ( ) ) { ItemT item = skippedIter. next ( ) ; itemsToAdd. addLast ( item ) ; } } hasDownPage = iter. hasNext ( ) ; for ( Object item itemsToAdd ) { add ( item ) ; } } } } if ( olderThan null ) { Iterator ItemT iter = items. iterator ( ) ; while (. ( ) ) { Object item = iter. next ( ) ; if ( HistoryPageEntry. getEntryId ( item ) olderThan ) { hasUpPage = true ; } { add ( item ) ; if ( isFull ( ) ) { hasDownPage = iter. hasNext ( ) ; ; } } } } }<CODESPLIT>Add run items and queued items to the History page .<CODESPLIT>0
private Set < Artifact > getProjectDependencyManagement ( ) { Set Artifact result = new LinkedHashSet Artifact ( ) ; DependencyManagement dependencyManagement = getProject ( ).DependencyManagement ( ) ; if ( dependencyManagement null ) for ( Dependency dependency dependencyManagement. getDependencies ( ) ) { result. add ( toArtifact ( dependency ) ) ; } } return result ; }<CODESPLIT>Returns all dependency artifacts in all modules excluding all reactor artifacts ( including attached ) .<CODESPLIT>0
public void add ( Rec fieldList ) throws DBException { Record record = ( Record ) fieldList ; if ( ( ( this. getRecord ( ). getOpenMode ( ) & DBConstants. OPENREFRESHANDLOCKONCHANGESTR )!= DBConstants. OPENREFRESHAND_LOCK_ON_CHANGE_STR ) ( record. isRefreshedRecord ( ) ) ) this. restoreMainRecord ( record, true ) ; super. add ( record ) ; }<CODESPLIT>Add this record ( Always called from the record class ) .<CODESPLIT>1
protected void setException ( Throwable t ) { if ( U. compareAndSwapInt ( this NEW COMP ) ) { outcome = t ; U. putOrderedInt ( this, STATE, EXCEPTIONAL ) ; finishCompletion ( ) ; } }<CODESPLIT>Sets the result of this future to the given value unless this future has already been set or has been cancelled .<CODESPLIT>0
@ Pure public static URL getResource ( ClassLoader classLoader, String path ) { returnResource getResource ( classLoader, path ) ; }<CODESPLIT>Replies the input stream of a resource .<CODESPLIT>0
@ SuppressWarnings ( "unchecked" ) static < K, V > Map < K, V > dynamicallyCastMap ( Map <?,? > map, Class < K > keyType, Class < V > valueType ) { ( map == null ) return null ; } assert checkCollectionMembers ( map. keySet ( ), keyType ) : map contains keys with a type other keyType. getName ( ) ; assert checkCollectionMembers ( map. values ( ), valueType ) : map contains values with a type other valueType. getName ( ) ; return ( Map K, V ) map ; }<CODESPLIT>=====<CODESPLIT>0
@ Override public java util. List com. liferay.. product. model.OptionValueRel > getCPDefinitionOptionValueRelsByUuidAndCompanyId ( String uuid, long companyId ) { return _DefinitionOptionValueRelLocalService getCPDefinitionOptionValueRelsByUuidAndCompanyId ( uuid, companyId ) ; }<CODESPLIT>Returns a range of cp definition option value rels matching the UUID and company .<CODESPLIT>0
public void setComplianceStatus ( java. util. Collection < StringFilter > complianceStatus ) { ( complianceStatus null ) this. complianceStatus = null ; return ; } this. complianceStatus = new java. util. ArrayListFilter ( complianceStatus ) ; }<CODESPLIT><p > The details of a resource that does not have a specific sub - field for the resource type defined . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setResourceDetailsOther ( java . util . Collection ) } or { @link #withResourceDetailsOther ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
public static void callMethod ( final Object obj, final String methodName, final boolean includePrivateMehtods, final Object... args ) throws InvocationTargetException { Class [ intArgsClass = initParamsClasses ( args ) ; try { Class current = obj. getClass ( ) ; Method method = null ; while ( current Object. class ) { try { method = current. getDeclaredMethod ( methodName, intArgsClass ) ; ; } ( final NoSuchMethodException ) { current = current. getSuperclass ( ) ; } } if ( method == null ) { throw new NoSuchMethodException ( "Mehtod found in " current ) ; } method. setAccessible ( true ) ; method. invoke ( obj, args ) ; } ( final InvocationTargetException ) { throw new InvocationTargetException (. getCause ( ) ) ; } ( final ) { throw new InvocationTargetException ( ) ; } }<CODESPLIT>Checks if is class avilable in class path .<CODESPLIT>0
@ Override public boolean canParse ( File file ) { filename = file ( ) ; return endsWithIgnoreCase ( filename, ".es" ) ; }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public final ListProductSetsPagedResponse listProductSets ( LocationName parent ) { ListProductSetsRequest request = ListProductSetsRequest newBuilder ( ) setParent ( parent null null parent toString ( ) ). build ( ) ; return listProductSets ( request ) ; }<CODESPLIT>Lists ProductSets in an unspecified order .<CODESPLIT>1
public Matrix solve ( Matrix B ) { if ( B. getRowDimension ( )!= n ) { throw new IllegalArgumentException ( "Matrix row dimensions must agree." ) ; } if (! isspd ) { throw new RuntimeException ( "Matrix is not symmetric positive definite." ) ; } double [ ] [ ] X = B. getArrayCopy ( ) ; int nx = B. getColumnDimension ( ) ; for ( k ; k < n ; k ++ ) { for ( ; < nx ; ++ ) { for ( ; < k ; ++ ) { X [ k ] [ j ] -= X [ i ] [ j ] * L [ k ] [ i ] ; } X [ k ] [ j ] /= L [ k ] [ k ] ; } } for ( k n - 1 ; k >= ; k -- ) { for ( ; < nx ; ++ ) { for ( int k + 1 ; < n ; ++ ) { X [ k ] [ j ] -= X [ i ] [ j ] * L [ i ] [ k ] ; } X [ k ] [ j ] /= L [ k ] [ k ] ; } } return new Matrix ( X, n, nx ) ; }<CODESPLIT>Solve A * X = B<CODESPLIT>1
public java. util. List < RecordPatch > getRecordPatches ( ) { ( recordPatches null ) recordPatches = new com. amazonaws. internal. SdkInternalList RecordPatch ( ) ; } return recordPatches ; }<CODESPLIT>A list of patch operations .<CODESPLIT>1
private void processFields ( ) { List Field fields = IntrospectionUtils. getPersistableFields ( embeddableClass ) ; for ( Field field fields ) { if ( field isAnnotationPresent ( Embedded ) ) { processEmbeddedField ( field ) ; } { processSimpleField ( field ) ; } } }<CODESPLIT>Processes the given simple ( or primitive ) field and updates the metadata .<CODESPLIT>0
public Observable < OperationStatus > updateExplicitListItemAsync ( UUID appId, String versionId, UUID entityId, long itemId, UpdateExplicitListItemOptionalParameter updateExplicitListItemOptionalParameter ) { return updateExplicitListItemWithServiceResponseAsync ( appId, versionId, entityId, itemId, updateExplicitListItemOptionalParameter ). map ( new ServiceResponse, ( ) @ Override public OperationStatus call ( ServiceResponse < OperationStatus > response ) { return. body ( ) ; } } ) ; }<CODESPLIT>Updates an explicit list item for a Pattern . Any entity .<CODESPLIT>1
public void register ( DiagnosticsPlugin plugin ) { checkNotNull ( plugin,plugin can null ) ; if (! enabled ) { return ; } long periodMillis = plugin. getPerMillis ( ) ; if ( periodMillis < 1 ) { throw IllegalArgumentException ( plugin " return periodMillis smaller1 ) ; } logger. finest ( plugin. getClass ( ). toString ( ) + " is " + ( period == DISABLED "disabled" "enabled" ) ) ; if ( periodMillis == DISABLED ) { return ; } pluginsMap. put ( plugin. getClass ( ), plugin ) ; plugin. onStart ( ) ; if ( periodMillis > ) { scheduler. scheduleAtFixedRate ( new WritePluginTask ( plugin ), 0, periodMillis, MILLISECONDS ) ; } { addStaticPlugin ( plugin ) ; } }<CODESPLIT>Registers a { @link DiagnosticsPlugin } . <p > This method is thread - safe . <p > There is no checking for duplicate registration . <p > If the { @link Diagnostics } is disabled the call is ignored .<CODESPLIT>1
public CacheManagerTask cleanAreaAsync ( Context ctx, BoundingBox bb, int zoomMin, int zoomMax ) { CacheManagerTask task = new CacheManagerTask ( this getCleAction ( ) bb zoomMin zoomMax ) ; task. addCallback ( getCleingDialog ( ctx, task ) ) ; return execute ( task ) ; }<CODESPLIT>Remove all cached tiles in the specified area .<CODESPLIT>1
public static List < ExternalGraphic > externalGraphicsFromGraphic ( Graphic graphic ) { List ExternalGraphic gList = new ArrayList ExternalGraphic ( ) ; for ( GraphSymbol gs : graphic. graphSymbols ( ) ) { if ( ( gs null ) ( gs External ) ) { ExternalGraphic externalGraphic = ( ExternalGraphic ) gs ; gList. add ( externalGraphic ) ; } } return gList ; }<CODESPLIT>Creates a default { @link Style } for a featurecollection .<CODESPLIT>0
public ArrayClassInfo getArrayClassInfo ( String typeClassName, Type arrayType ) {Impl elementClassInfo getDelClassInfo ( arrayType getElementType ( ) ) ; return new ArrayClassInfo ( typeClassName, elementClassInfo ) ; }<CODESPLIT>For array types the previous implementation used the element name .<CODESPLIT>0
public void free ( ) { CalendarPanel panel = ( CalendarPanel ) JBasePanel getSubScreen ( this, CalendarPanel. ) ; ( panel null ) panel free ( ) ; super. free ( ) ; }<CODESPLIT>Free the sub = components .<CODESPLIT>1
public final void ruleXMemberFeatureCall ( ) throws RecognitionException { stackSize = keepStackSize ( ) ; { { { if ( state backtracking == ) { before ( grammarAccess. getXMemberFeatureCallAccess ( ). getGroup ( ) ) ; } { (2 ) ; rule__XMemberFeatureCall__Group__0 ( ) ;fsp -- ; if ( state. ) return ; } if ( state. backtracking == ) { after ( grammarAccess. getXMemberFeatureCallAccess ( ). getGroup ( ) ) ; } } } } ( RecognitionException ) { reportError ( re ) ; recover ( input, re ) ; } { restoreStackSize ( stackSize ) ; } return ; }<CODESPLIT>InternalXbase . g : 633 : 1 : entryRuleXMemberFeatureCall : ruleXMemberFeatureCall EOF ;<CODESPLIT>0
protected String signAndBase64Encode ( byte [ ] data, String key, SigningAlgorithm algorithm ) throws SdkClientException { try { byte [ ] signature = sign ( data, key. getBytes ( UTF8 ), algorithm ) ; return Base64. encodeAsString ( signature ) ; } catch ( ) { throw new SdkClientException ( " to calculate a request signature ". ( ) ) ; } }<CODESPLIT>Computes an RFC 2104 - compliant HMAC signature for an array of bytes and returns the result as a Base64 encoded string .<CODESPLIT>1
private void ProcessNextStep ( ) { switch ( iSelectionStep ) { SELECT_SOURCE_CATALOG SELECT_DEST_CATALOG ( CatalogToSelect ( ) ) fMain. show ( ) ; return ; } ; SELECT_DEST_SCHEMA SELECT_SOURCE_SCHEMA ( SchemaToSelect ( ) ) fMain. show ( ) ; return ; } ; SELECT_SOURCE_TABLES (TransferMode == TRFM_TRANSFER ) bStart. setLabel ( "Start Transfer" ) ; } if ( iTransferMode == TRFM_DUMP ) { bStart. setLabel ( "Start Dump" ) ; } if ( iTransferMode == TRFM_RESTORE ) { bStart. setLabel ( "Start Restore" ) ; } bStart. invalidate ( ) ; bStart. setEnabled ( false ) ; lTable. setMultipleMode ( false ) ; RefreshMainDisplay ( ) ; ; default : break ; } }<CODESPLIT>Method declaration<CODESPLIT>0
JsonRepresentation asEventRepr ( EventMetadata metadata, final JsonRepresentation payloadRepr ) { JsonRepresentation eventRepr = JsonRepresentation. newMap ( ) ; JsonRepresentation metadataRepr = JsonRepresentation. newMap ( ) ; eventRe. mapPut (metadata, metadataRe ) ; metadataRepr. mapPut (id, metadata. getId ( ) ) ; metadataRepr. mapPut (transactionId, metadata. getTransactionId ( ) ) ; metadataRepr. mapPut (sequence, metadata. getSequence ( ) ) ; metadataRepr. mapPut (eventType, metadata. getEventType ( ) ) ; metadataRepr. mapPut (user, metadata. getUser ( ) ) ; metadataRepr. mapPut (timestamp, metadata. getTimestamp ( ) ) ; eventRepr. mapPut (payload, payloadRepr ) ; return eventRepr ; }<CODESPLIT>Set up the screen fields ( default = set them all up for the current record ) .<CODESPLIT>0
public float dot ( IntFloatVector y ) { if ( y instanceof IntFloatSortedVector ) { IntFloatSortedVector other = ( ( IntFloatSortedVector ) y ) ; float dot = 0 ; int oc = 0 ; for ( c c used c ) { while ( oc < other. used ) { if ( other. indices [ oc ] < indices [ c ] ) { ++ ; } else if ( indices [ c ] == other. indices [ oc ] ) { dot += values [ c ] * other. values [ ] ; ; } else { ; } } } return dot ; } else { float dot = 0 ; for ( c c used c ) { dot += this. values [ c ] * y. get ( indices [ c ] ) ; } return dot ; } }<CODESPLIT>Computes the dot product of this vector with the other vector .<CODESPLIT>1
protected final PrcRefreshCatalog lazyGetPrcRefreshCatalog ( final Map < String, Object > pAddParam ) throws Exception { beanName = PrcRefreshCatalog. class. ( ) ; PrcRefreshCatalog proc = ( PrcRefreshCatalog ) this. processorsMap. ( beanName ) ; ( null ) proc = new PrcRefreshCatalog ( ) ; proc.Listeners ( ). add ( this.BPublicTradeProcessors. lazyGetPrcWebstorePage ( pAddParam ) ) ; this. processorsMap. put ( beanName, proc ) ; this. logger. info ( null, FBTradeProcessors. class, beanName has created." ) ; } return proc ; }<CODESPLIT><p > Lazy get PrcRefreshCatalog . < / p ><CODESPLIT>1
private static String buildMessage ( final String id ) { ( id ) return NULL_MESSAGE ; } return format ( INVALID_MSG_FMT, id ) ; }<CODESPLIT>Build the exception s message using the <tt > id< / tt > value .<CODESPLIT>1
public double [ ] getMoneynessAsOffsets ( ) { DoubleStream moneyness = getGridNodesPerMoneyness ( ). keySet ( ). stream ( ). mapToDouble ( Integer doubleValue ) ; ( quotingConvention QuConvention PAYVOLNORMAL ) moneyness = moneyness. map ( new DoubleUnaryOperator ( ) { @ Override public double applyAsDouble ( double x ) { return x * 0.01 ; } } ) ; } ( quotingConvention QuConvention REIPRI ) moneyness = moneyness. map ( new DoubleUnaryOperator ( ) { @ Override public double applyAsDouble ( double x ) { return - x * 0.0001 ; } } ) ; } moneyness = moneyness. map ( new DoubleUnaryOperator ( ) { @ Override public double applyAsDouble ( double x ) { return x * 0.0001 ; } } ) ; } return moneyness. toArray ( ) ; }<CODESPLIT>Return all valid maturities for a given moneyness . Uses the fixing times of the fix schedule to determine fractions .<CODESPLIT>0
public Frustum setToProjection ( double left, double right, double bottom, double top, double near, double far, IVector3 nearFarNormal, boolean ortho, boolean mirrored ) { double nx = nearFarNormal. x ( ), ny = nearFarNormal. y ( ), nz = nearFarNormal. z ( ) ; if (o ) { double nrz = - 1f / nz ; double xl = nx * left * nrz, xr = nx * right * nrz ; double yb = ny * bottom * nrz, yt = ny * top * nrz ; _vertices [ 0. set ( left, bottom, xl + yb - near ) ; _vertices [ mirrored? 3 : 1. set ( right, bottom, xr + yb - near ) ; _vertices [ 2. set ( right, top, xr + yt - near ) ; _vertices [ mirrored? 1 : 3. set ( left, top, xl + yt - near ) ; _vertices [. set ( left, bottom, xl + yb - far ) ; _vertices [ mirrored? 7 : 5. set ( right, bottom, xr + yb - far ) ; _vertices [ 6. set ( right, top, xr + yt - far ) ; _vertices [ mirrored? 5 : 7. set ( left, top, xl + yt - far ) ; } { double = 1f / near ; double lrn = left *, rrn = right * ; double brn = bottom *, trn = top * ; double nz = near * nz ; double z0 = nz / ( nx lrn + ny brn - nz ) ; _vertices [ 0. set ( - z0 lrn, - z0 brn, z0 ) ; double z1 = nz / ( nx rrn + ny brn - nz ) ; _vertices [ mirrored? 3 : 1. set ( - z1 rrn, - z1 brn, z1 ) ; double z2 = nz / ( nx rrn + ny trn - nz ) ; _vertices [ 2. set ( - z2 rrn, - z2 trn, z2 ) ; double z3 = nz / ( nx lrn + ny trn - nz ) ; _vertices [ mirrored? 1 : 3. set ( - z3 lrn, - z3 trn, z3 ) ; double fz = far * nz ; double z4 = fz / ( nx lrn + ny brn - nz ) ; _vertices [. set ( - z4 lrn, - z4 brn, z4 ) ; double z5 = fz / ( nx rrn + ny brn - nz ) ; _vertices [ mirrored? 7 : 5. set ( - z5 * rrn, - z5 * brn, z5 ) ; double z6 = fz / ( nx rrn + ny trn - nz ) ; _vertices [ 6. set ( - z6 * rrn, - z6 * trn, z6 ) ; double z7 = fz / ( nx lrn + ny trn - nz ) ; _vertices [ mirrored? 5 : 7. set ( - z7 * lrn, - z7 * trn, z7 ) ; } updateDerivedState ( ) ; return this ; }<CODESPLIT>Sets this frustum to an orthographic one pointing in the Z - direction with the specified parameters determining its size ( see the OpenGL documentation for <code > glOrtho< / code > ) .<CODESPLIT>0
private String parameterToString ( Object param ) { if ( param == null ) { return "" ; } if ( param Date ) { return formatDate ( ( Date ) param ) ; } if ( param Collection ) { StringBuilder b = new StringBuilder ( ) ; for ( o ( Collection ) param ) { if ( b length ( ) ) { b. ( "," ) ; } b. ( String. valueOf ( o ) ) ; } return b. toString ( ) ; } { return String. valueOf ( param ) ; } }<CODESPLIT>Reads a buffer .<CODESPLIT>0
public static < T > T validateNotNull ( T value, String errorMsgTemplate, Object... params ) throws ValidateException { ( isNull ( value ) ) ValidateException ( errorMsgTemplate params ) ; } return value ; }<CODESPLIT>检查指定值是否为<code > null< / code ><CODESPLIT>0
public final void setCommitTrigger ( CommitTrigger commitTrigger ) { ( this commitTrigger == commitTrigger ) return ; } ( this commitTrigger null ) this. commitTrigger. removeCommitTriggerListener ( commitTriggerHandler ) ; this. commitTrigger = null ; } ( commitTrigger null ) if ( this commitTriggerHandler == null ) this. commitTriggerHandler = new CommitTriggerHandler ( ) ; } this. commitTrigger = commitTrigger ; this. commitTrigger. addCommitTriggerListener ( commitTriggerHandler ) ; } }<CODESPLIT>Sets the <code > CommitTrigger< / code > that triggers the commit and flush events .<CODESPLIT>1
public static String getRelativeSubPath ( String base, String path ) { String result = null ; base = CmsStringUtil. joinPaths ( base, "/" ) ; path = CmsStringUtil. joinPaths ( path, "/" ) ; if ( path ( base ) ) result = path. ( base. length ( ) ) ; } if ( result null ) if ( result endsWith ( "/" ) ) result = result. (, result. length ( ) - 1 ) ; } if ( result ( "/" ) ) { result = "/" + result ; } } return result ; }<CODESPLIT>Returns <code > true< / code > if the provided Objects are either both <code > null< / code > or equal according to { @link Object#equals ( Object ) } . <p ><CODESPLIT>0
private void readMoreBytesFromStream ( ) throws IOException { if ( innerStreamHasMoreData ) return ; } bufferSpaceAvailable = buffer. length - bytesInBuffer ; if ( bufferSpaceAvailable <= ) { return ; } = stream. read ( buffer, bytesInBuffer, bufferSpaceAvailable ) ; if ( == ) { innerStreamHasMoreData = false ; } { bytesInBuffer += bytesRead ; } }<CODESPLIT>Fill the buffer with more data from the InputStream if there is any .<CODESPLIT>1
@ Override public GetPlanResult getPlan ( GetPlanRequest request ) { request beforeClientExecution ( request return executeGetPlan ( request ) ; }<CODESPLIT><p > Retrieves a specified security configuration . < / p ><CODESPLIT>0
public void println ( final String str ) throws IOException { this. writer. print ( str ) ; this. writer. print (r ) ; this writer. flush ( ) ; }<CODESPLIT>{<CODESPLIT>0
@ Generated ( value = {comthreeringspresentstoolsGenDObjectTask } ) public void setPeerService ( PeerMarshaller value ) { PeerMarshaller ovalue = this. peerService ; requestAttributeChange ( PEERSERVICE, value, ovalue ) ; this. peerService = value ; }<CODESPLIT>Requests that the <code > bootStamp< / code > field be set to the specified value . The local value will be updated immediately and an event will be propagated through the system to notify all listeners that the attribute did change . Proxied copies of this object ( on clients ) will apply the value change when they received the attribute changed notification .<CODESPLIT>0
public String replaceDocRootDir ( String htmlstr ) { index = htmlstr. indexOf (@" ) ; if ( index < ) { return htmlstr ; } docrootMatcher = docrootPattern. ( htmlstr ) ; if ( docrootMatcher. find ( ) ) { return htmlstr ; } StringBuilder buf = new StringBuilder ( ) ; prevEnd = 0 ; do { match = docrootMatcher. start ( ) ; buf. append ( htmlstr. ( prevEnd, match ) ) ; prevEnd = docrootMatcher. end ( ) ; if ( configuration. docrootparent. length ( ) > htmlstr. ( "/ prevEnd ) ) { buf. append ( configuration. docrootparent ) ;End += ; } { buf. append ( pathToRoot. isEmpty ( ) "." : pathToRoot. getPath ( ) ) ; } if ( prevEnd < htmlstr. length ( ) htmlstr. ( prevEnd ) ) { buf. append ('' ) ; } } while ( docroot. ( ) ) ; buf. append ( htmlstr. ( prevEnd ) ) ; return buf. toString ( ) ; }<CODESPLIT>Programmatic interface .<CODESPLIT>0
public static List < String > getPropertyNames ( Object obj ) { List String propertyNames = new ArrayList String ( ) ; if ( obj == null ) { return propertyNames ; } else { List Object cycleDetect = new ArrayList Object ( ) ; performGetPropertyNames ( obj, null, propertyNames, cycleDetect ) ; return propertyNames ; } }<CODESPLIT>Recursively gets names of all properties implemented in specified object and its subobjects .<CODESPLIT>1
public boolean checkLocks ( boolean exclusive, int depth ) { ( checkParents ( exclusive ) checkChildren ( exclusive depth ) ) return true ; } return false ; }<CODESPLIT>checks if a lock of the given exclusivity can be placed only considering children up to depth<CODESPLIT>1
private static void createFactoryInstance ( ) { try { Class cls = Class. forName ( MP_SELECTOR_EVALUATOR_FACTORY_CLASS ) ; instance = ( MPSelectorEvaluatorFactory ) cls. newInstance ( ) ; } catch ( ) { FFDCFilter. ( e, "comibmwssibprocessorMPSelectorEvaluatorFactorycreateFactoryInstance", "100" ) ; throw new SIErrorException ( ) ; } }<CODESPLIT>Create the singleton Factory instance .<CODESPLIT>1
public NotificationChain basicSetUniformDistribution ( UniformDistributionType newUniformDistribution, NotificationChain msgs ) { return ( ( FeatureMap Internal ) getMixed ( ) ) basicAdd ( BpsimPackage DOCUMENT_ROOTUNIFORM_DISTRIBUTION, newUniformDistribution, msgs ) ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>1
private EntityManager getEntityManager ( ) { EntityManager em ; ( TxUtils isActive ( transactionManager ) ) em = ( EntityManager ) transactionSynchronizationRegistry. getResource ( unitName ) ; ( em == null ) em = createEntityManager ( ) ; transactionSynchronizationRegistry. registerInterSynchronization ( new TxSynchronization ( em ) ) ; transactionSynchronizationRegistry. putResource ( unitName, em ) ; } validateCompatibleSyncTypes ( em ) ; } } em = nonTxEmHolder. getEntityManager ( ) ; ( em == null ) em = createEntityManager ( ) ; nonEmHolder setEntityManager ( em ) ; } } return em ; }<CODESPLIT>Subscribes to an event dispatcher and starts a watch for a given key .<CODESPLIT>0
public FSArray getItemList ( ) { if ( ListType. featOkTst ( ( ListType ) jcasType ). casFeatitemList == null ) jcasType. jcas. throwFeatMissing (itemList", "dejulielabjtypesList" ) ; return ( FSArray ) ( jcasType. ll_cas. ll_getFSForRef ( jcasType. ll_cas. ll_get ( addr, ( ( List_Type ) jcasType ). casFeatCode_itemList ) ) ) ; }<CODESPLIT>setter for itemList - sets contains items of the level 1 . The items of the level 1 could contain further items of next level and so on in order to represent an iterative structure of list items .<CODESPLIT>0
public PushRules createPushRules ( Object projectIdOrPath, PushRules pushRule ) throws GitLabApiException { GitLabApiForm formData = new GitLabApiForm ( ). withParam ( "denydeletetag, pushRule. getDyDeleteTag ( ) ). withParam ( "membercheck, pushRule. getMemberCheck ( ) ). withParam ( "preventsecrets, pushRule. getPreSecrets ( ) ). withParam ( "commitmessageregex, pushRule. getCommitMessageRegex ( ) ). withParam ( "branchnameregex, pushRule. getBranchNameRegex ( ) ). withParam ( "authoremailregex", pushRule. getAuthorEmailRegex ( ) ). withParam ( "filenameregex", pushRule. getFileNameRegex ( ) ). withParam ( "maxfilesize", pushRule. getMaxFileSize ( ) ) ; Response response = post ( Response. Status. CREATED, formData, "projects, getProjectIdOrPath ( projectIdOrPath ), "push_ ) ; return ( response. readEntity ( PushRules. class ) ) ; }<CODESPLIT>Adds a push rule to a specified project .<CODESPLIT>1
public static IsoRecurrence < DateInterval > of ( int count, PlainDate start, Duration <? extends IsoDateUnit > duration ) { check ( count ) ; ( start null ) NullPointerException (Missing start recurrent interval ) ; } return new RecurrentDateIntervals ( count, TYPE_START_DURATION, start, duration ) ; }<CODESPLIT>/ * [ deutsch ] <p > Erzeugt eine Sequenz von wiederkehrenden Datumsintervallen mit der angegebenen Dauer . < / p ><CODESPLIT>1
private static String upperCaseHex ( String s ) { char chars [ ] = s. toCharArray ( ) ; int length = s. length ( ) ; for ( ; length ; ) { switch ( chars [ i ] ) { case'' : chars [ ] ='' ; ; case'' : chars [ ] ='' ; break ; case'' : chars [ ] ='' ; break ; case'' : chars [ ] ='' ; break ; case'' : chars [ ] ='' ; break ; case'' : chars [ ] ='' ; break ; } } return new String ( chars ) ; }<CODESPLIT>/ * Efficiently converts a string containing a hexadecimal number from lower case to upper case<CODESPLIT>1
static ImmutableList < NameValuePair > buildParameters ( String analyticsId, String clientId, String virtualPageName, String virtualPageTitle, String eventType, String eventName, boolean isUserSignedIn, boolean isUserInternal, Optional < Boolean > isUserTrialEligible, Optional < String > projectNumberHash, Optional < String > billingIdHash, Optional < String > clientHostname, Random random ) { checkNotNull ( analyticsId ) ; checkNotNull ( clientId ) ; checkNotNull ( virtualPageTitle ) ; checkNotNull ( virtualPageName ) ; checkNotNull ( eventType ) ; checkNotNull ( eventName ) ; checkNotNull ( projectNumberHash ) ; checkNotNull ( billingIdHash ) ; checkNotNull ( clientHostname ) ; checkNotNull ( random ) ; ImmutableList. Builder NameValuePair listBuilder = new ImmutableList. Builder ( ) ; listBuilder. add ( new BasicNameValuePair ( PARAMPROTOCOL,1 ) ) ; listBuilder. add ( new BasicNameValuePair ( PARAMPROPERTYID, analyticsId ) ) ; listBuilder. add ( new BasicNameValuePair ( PARAMTYPE, VALUETYPEPAGEVIEW ) ) ; listBuilder. add ( new BasicNameValuePair ( PARAMISNONINTERACTIVE, VALUEFALSE ) ) ; listBuilder. add ( new BasicNameValuePair ( PARAMCACHEBUSTER, Long. toString ( random. nextLong ( ) ) ) ) ; listBuilder. add ( new BasicNameValuePair ( PARAMEVENTTYPE, eventType ) ) ; listBuilder. add ( new BasicNameValuePair ( PARAMEVENT, eventName ) ) ; if ( clientHostname isPresent ( ) clientHostname ( ) isEmpty ( ) ) { listBuilder. add ( new BasicNameValuePair ( PARAMHOST, clientHostname. ( ) ) ) ; } listBuilder. add ( new BasicNameValuePair ( PARAMCLIENTID, clientId ) ) ; if ( projectNumberHash isPresent ( ) projectNumberHash ( ) isEmpty ( ) ) { listBuilder. add ( new BasicNameValuePair ( PARAMPROJECTNUMHASH, projectNumberHash. ( ) ) ) ; } if ( billingIdHash isPresent ( ) billingIdHash ( ). isEmpty ( ) ) { listBuilder. add ( new BasicNameValuePair ( PARAMBILLIDHASH, billingIdHash. ( ) ) ) ; } listBuilder. add ( new BasicNameValuePair ( PARAMUSERSIGNEDIN, toValue ( isUserSignedIn ) ) ) ; listBuilder. add ( new BasicNameValuePair ( PARAMUSERINTERNAL, toValue ( isUserInternal ) ) ) ; if ( isUserTriEligible. isPresent ( ) ) { listBuilder. add ( new BasicNameValuePair ( PARAMUSERTRIALELIGIBLE, toValue ( isUserTrialEligible. ( ) ) ) ) ; } listBuilder. add ( new BasicNameValuePair ( PARAMISVIRTUAL, VALUETRUE ) ) ; listBuilder. add ( new BasicNameValuePair ( PARAMPAGE, virtualPageName ) ) ; if ( virtualPageTitle. isEmpty ( ) ) { listBuilder. add ( new BasicNameValuePair ( PARAMPAGETITLE, virtualPageTitle ) ) ; } return listBuilder. build ( ) ; }<CODESPLIT>Adds more data providers to the validator .<CODESPLIT>0
@ Override public void insert ( CharSequence text ) throws IOException { int ln = text. length ( ) ; if ( ln == 0 ) { return ; } if ( ln >= size - ( end - cursor ) ) { throw new IOException ( text " doesn fit in the buffer" ) ; } if ( cursor!= end ) { makeRoom ( ln ) ; } for ( ln ) { set ( ( cursor + ii ), text. charAt ( ii ) ) ; } end += ln ; }<CODESPLIT>Inserts text at cursor position<CODESPLIT>1
public void onNewTab ( final AjaxRequestTarget target, final T tab, final int index ) { if ( ( index < ) ( index getTabs ( ) ( ) ) ) IndexOutOfBoundsException ( ) ; } getTabs ( ). add ( index, tab ) ; setSelectedTab ( index ) ; target. add ( this ) ; }<CODESPLIT>On new tab .<CODESPLIT>1
public static void outputImage ( int w, int h, OutputStream os, String code ) throws IOException { verifySize = code. length ( ) ; BufferedImage image = new BufferedImage ( w, h, BufferedImage. TYPE_INT_RGB ) ; Random rand = new Random ( ) ; Graphics2D g2 = image. createGraphics ( ) ; g2. setRenderingHint (.ANTIALIASING,.ANTIALIASON ) ; Color [ colors = new Color [ 5 ; Color [ colorSpaces = new Color [ { Color. WHITE, Color. CYAN, Color. GRAY, Color. LIGHT_GRAY, Color. MAGENTA, Color. ORANGE, Color. PINK, Color. YELLOW } ; float [ fractions = new float [ colors. length ; for ( colors. length ) { colors [ i ] = colorSpaces [ rand. nextInt ( colorSpaces. length ) ] ; fractions [ ] = rand. nextFloat ( ) ; } Arrays. sort ( fractions ) ; g2. setColor ( Color. GRAY ) ; g2. fillRect ( 0, 0, w, h ) ; Color c = getRandColor ( 200, 250 ) ; g2. setColor ( c ) ; g2. fillRect ( 0, 2, w, h - 4 ) ; Random random = new Random ( ) ; g2. setColor ( getRandColor ( 160, 200 ) ) ; for ( 20 ) { x = random. nextInt ( w - 1 ) ; y = random. nextInt ( h - 1 ) ; xl = random. nextInt ( 6 ) + 1 ; yl = random. nextInt ( 12 ) + 1 ; g2. drawLine ( x, y, x + xl + 40, y + yl + 20 ) ; } float yawpRate = 005f ; area = ( ) ( yawpRate * w * h ) ; for ( area ) { x = random. nextInt ( w ) ; y = random. nextInt ( h ) ; rgb = getRandomIntColor ( ) ; image. setRGB ( x, y, ) ; } shear ( g2, w, h, c ) ; g2. setColor ( getRandColor ( 100, 160 ) ) ; fontSize = h - 4 ; Font font = new Font ( "Algerian", Font. IIC, fontSize ) ; g2. setFont ( font ) ; char [ ] chars = code. toCharArray ( ) ; for ( verifySize ) { AffineTransform affine = new AffineTransform ( ) ; affine. setToRotation ( Math. PI / * rand. nextDouble ( ) * ( rand. nextBoolean ( )? 1 : - 1 ), ( w / verifySize ) * + fontSize / 2, h / 2 ) ; g2. setTransform ( affine ) ; g2. drawChars ( chars,, 1, ( ( w - 10 ) / verifySize ) * + 5, h / 2 + fontSize / 2 - 10 ) ; } g2. dispose ( ) ; ImageIO. write ( image, "jpg", os ) ; }<CODESPLIT>生成指定验证码图像文件<CODESPLIT>0
public Object findClosestObject ( int x, int y, int [ ] distance ) { if ( _size == ) { return null ; } sr = binarySearch ( x ), sl = sr - 1 ; mindist = Integer. MAXVALUE, min = - 1 ; for ( boolean expanded true expanded ) { expanded = false ; if ( sr < _size ) { Record rec = _records [ sr ; if ( rec. x x < mindist ) { dist = distance ( rec. x, rec. y, x, y ) ; if ( dist < mindist ) { minidx = sr ; mindist = dist ; } += ; expanded = true ; } } if ( sl ) { Record rec = _records [ sl ; if ( x rec. x < mindist ) { dist = distance ( rec. x, rec. y, x, y ) ; if ( dist < mindist ) { minidx = sl ; mindist = dist ; } sl -= 1 ; expanded = true ; } } } if ( min == ) { throw (Proximity algorithm!" ) ; } if ( distance null distance. length > ) { distance [ 0 = mindist ; } return _records [ minidx ]. object ; }<CODESPLIT>Removes from the tracker the object that is equal to ( <code > o1 . equals ( object ) < / code > ) the specified object .<CODESPLIT>0
public void setGoldenGrammarErrors ( FSArray v ) { if ( GoldenSentenceType. featOkTst ( ( GoldenSentenceType ) jcasType ). casFeatgoldenGrammarErrors == null ) jcasType. jcas. throwFeatMissing (goldenGrammarErrors,cogrouimaGoldenSentence ) ; jcasType. llcas. llsetRefValue ( addr, ( ( GoldenSentence_Type ) jcasType ). casFeatCode_goldenGrammarErrors, jcasType. ll_cas. ll_getFSRef ( v ) ) ; }<CODESPLIT>setter for goldenGrammarErrors - sets<CODESPLIT>1
Map < CmsPrincipalBean, String > getResponsibles ( CmsObject cms, CmsResource res ) { Map CmsPrincipalBean, String result = new HashMap CmsPrincipalBean, String ( ) ; List CmsResource parentResources = new ArrayList CmsResource ( ) ; try { parentResources = cms. readPath ( res, CmsResourceFilter._EXPI ) ; } ( CmsException ) { LOG. error (. ( ), ) ; } for ( CmsResource resource parentResources ) { String storedSiteRoot = cms. ( ). getSiteRoot ( ) ; String sitePath = cms. ( ). removeSiteRoot ( resource. getRootPath ( ) ) ; try { cms. ( ). setSiteRoot ( "/" ) ; List CmsAccessControlEntry entries = cms. getAccessControlEntries ( resource. getRootPath ( ), false ) ; for ( CmsAccessControl ace entries ) { if ( ace. isRessible ( ) ) { I_CmsPrincipal principal = cms. lookupPrincipal ( ace. getPrincipal ( ) ) ; if ( principal null ) { CmsPrincipalBean prinBean = new CmsPrincipalBean ( principal. getName ( ), principal. getDescription ( ), principal. isGroup ( ) ) ; if (! resource. ( ). ( res. ( ) ) ) { if ( resource. ( ). startsWith ( storedSiteRoot ) ) { result. put ( prinBean, sitePath ) ; } { result. put ( prinBean, resource. getRootPath ( ) ) ; } } { result. put ( prinBean, null ) ; } } } } } ( CmsException ) { LOG. info ( " with reading responsible users for " + resource. ( ) + " " +. ( ), ) ; } finally { cms. ( ). setSiteRoot (SiteRoot ) ; } } return result ; }<CODESPLIT>Returns the responsibles . <p ><CODESPLIT>1
public static Router post ( String uriTemplate, final ContextHandler handler ) { return ( ) post ( uriTemplate, handler ) ; }<CODESPLIT>Performs mapping for all routers .<CODESPLIT>0
public static void descendingOrder ( DMatrixRMaj U, boolean tranU, DMatrixRMaj W, DMatrixRMaj V, boolean tranV ) { int numSingular = Math. min ( W. numRows, W. numCols ) ; checkSvdMatrixSize ( U, tranU, W, V, tranV ) ; for ( numSingular ) { double bigValue = - 1 ; int bigIndex = - 1 ; for ( numSingular ) { double v = W. get ( j, j ) ; if ( v > bigValue ) { bigValue = v ; bigIndex = j ; } } if ( bigIndex == i ) continue ; if ( bigIndex == - 1 ) { ; } double tmp = W. get (, ) ; W. set (,, bigValue ) ; W. set ( bigIndex, bigIndex, tmp ) ; if ( V!= null ) { swapRowOrCol ( V, tranV, i, bigIndex ) ; } if ( U!= null ) { swapRowOrCol ( U, tranU, i, bigIndex ) ; } } }<CODESPLIT>Computes the SVD and sorts singular values in descending order . While easier to use this can reduce performance when performed on small matrices numerous times .<CODESPLIT>0
public ApiSuccessResponse stopMonitoring ( StopMonitoringData stopMonitoringData ) throws ApiException { ApiResponse ApiSuccessResponse resp stopMonitoringWithHttpInfo ( stopMonitoringData ) ; return. getData ( ) ; }<CODESPLIT>Start recording a call Start recording the specified call . Recording stops when the call is completed or you send [ / voice / calls / { id } / stop - recording ] ( / reference / workspace / Voice / index . html#stopRecording ) on either the call or the DN .<CODESPLIT>0
public String getAttributeString ( String attName ) { o = attributes. ( attName ) ; if ( o == null ) return null ; } return ( String ) o ; } }<CODESPLIT>Get the value for a given attribute .<CODESPLIT>1
public static ListOptionValue findByGroupId ( long groupId, int start, int end ) { return getPersistence ( ) findByGroupId ( groupId, start, end ) ; }<CODESPLIT>Returns a range of all the cp option values where groupId = &#63 ; .<CODESPLIT>1
private static void handleSingletonClass ( String key, String value ) throws Exception { object = handleValue ( value ) ; if ( key contains ( "," ) ) String interfaces = key. split ( "," ) ; for (Interface interfaces ) { serviceMap. put ( anInterface, object ) ; } } { serviceMap. put ( key, object ) ; } }<CODESPLIT>Send email with a string content and attachment<CODESPLIT>0
public static String [ ] split ( final String string, final char separator, final boolean ignoreQuotes ) { Str str = new Str ( string StrMatcher charMatcher ( separator ), StrMatcher quoteMatcher ( ) ) ; return strtok. getTokenArray ( ) ; }<CODESPLIT>Normalize and collapse whitespaces from string buffer .<CODESPLIT>0
public ComparisonExpression getLtFilterFromPrefixLike ( ) { ExpressionType rangeComparator = ExpressionType. COM_LESSTHAN ; com extractIncrementLikePatternPrefix ( ) ; return rangeFilterFromPrefixLike ( m_left, rangeComparator, comand ) ; }<CODESPLIT>/ Construct the upper bound comparison filter implied by a prefix LIKE comparison .<CODESPLIT>1
public void showForgotPasswordView ( String authToken ) { try { CmsTokenValidator validator = new CmsTokenValidator ( ) ; String validationResult = validator. validateToken ( ACmsUI. getCmsObject ( ), authToken, OpenCms. getLoginManager ( ). getTokenLifetime ( ) ) ; if ( validationResult == null ) { CmsUser user = validator. getUser ( ) ; if ( user. isManaged ( ) ) { CmsSetPasswordDialog dlg = new CmsSetPasswordDialog ( madminCms, user, getLocale ( ) ) ; ACmsUI. ( ). setContentToDialog ( Messages. ( ). getBundle ( ACmsUI. ( ). ( ) ). key ( Messages. GUIPWCHANGEHEADER0 ) + user. getName ( ), dlg ) ; } { Notification. show ( CmsVaadinUtils. getMessageText ( Messages. ERR_USER_NOT_SELF_MANAGED_1, user. getName ( ) ), Type. ERROR_MESSAGE ) ; } } { ACmsUI. ( ). setError ( Messages. ( ). getBundle ( ACmsUI. ( ). ( ) ). key ( Messages. GUIPWCHANGEINVALIDTOKEN0 ) ) ; LOG. info ( "Invalid authorization token " + authToken + " / " + validationResult ) ; } } ( ) { LOG. error (. ( ), ) ; } }<CODESPLIT>Initializes the login view . <p ><CODESPLIT>0
@ WithBridgeMethods ( value SQLServerQuery. class, castRequired = true ) public C tableHints ( SQLServerTableHints... tableHints ) { ( tableHints length ) hints = SQLServerGrammar. tableHints ( tableHints ) ; addJoinFlag ( hints, JoinFlag.. END ) ; } return ( C ) this ; }<CODESPLIT>Set the table hints<CODESPLIT>1
private void populate ( Field field, Object target, String stringValue ) { field. setAccessible ( true ) ; try { Class fieldType = field. getType ( ) ; Object value = TypeConverter. convert ( stringValue ). to ( fieldType ) ; field. set ( target, value ) ; } ( IllegalAccessException ) { throw new RuntimeException ( " populate field " field ) ; } }<CODESPLIT>Populates the specified field on the target with the value from the given option .<CODESPLIT>1
public Object getParameter ( String name ) { try { QName qname = QName. getQNameFromString ( name ) ; if ( null == m_userParams ) return null ; int n = m_userParams. size ( ) ; for ( n - 1 -- ) { Arg arg = ( Arg ) m_userParams. elementAt ( i ) ; if ( arg. getQName ( ). equals ( qname ) ) { return arg. getVal ( ). object ( ) ; } } return null ; } catch ( java util NoSuchElementException ) { return null ; } }<CODESPLIT>Reset parameters that the user specified for the transformation . Called during transformer . reset () after we have cleared the variable stack . We need to make sure that user params are reset so that the transformer object can be reused .<CODESPLIT>0
private MultipartContent createContent ( final ProblemInput input, final File output, final File source ) throws IOException { HttpMediaType type = new HttpMediaType ( MEDIATYPE ) ; type. setParameter ( BOUND, createBoundary ( ) ) ; String sourceFilePath = new StringBuilder ( PATHPREFIX ). append ( source. getName ( ) ). toString ( ) ; MultipartContent content = new MultipartContent ( ). setMediaType ( type ). addPart ( HttpRequestExecutor. buildDataPart ( CSRFPARAMETERNAME, values. getToken ( ) ) ). addPart ( HttpRequestExecutor. buildFilePart ( ANSWERPARAMETER, output ) ). addPart ( HttpRequestExecutor. buildFilePart ( SOURCEFILEPARAMETER, source ) ). addPart ( HttpRequestExecutor. buildDataPart ( SOURCEFILENAMEPARAMETER, sourceFilePath ) ). addPart ( HttpRequestExecutor. buildDataPart ( COMMANDPARAMETERNAME, SUBMITCOMMAND ) ). addPart ( HttpRequestExecutor. buildDataPart ( PROBPARAMETERNAME, input. getProblem ( ). getId ( ) ) ). addPart ( HttpRequestExecutor. buildDataPart ( INPUTIDPARAMETERNAME, String. ( input. getNumber ( ) ) ) ). addPart ( HttpRequestExecutor. buildDataPart ( NUMSOURCEFILEPARAMETER, DEFAULTNUMSOURCEFILE ) ). addPart ( HttpRequestExecutor. buildDataPart ( AGENTPARAMETERNAME, DEFAULT_AGENT ) ) ; return content ; }<CODESPLIT><p > Created and returns a valid { @link MultipartContent } instance that contains data required for submission . < / p ><CODESPLIT>1
@ SuppressWarnings ( "unchecked" ) public boolean push ( E e ) { if ( cntInBucket >= bucketSize ) { buckets. add ( ( E ) new Object bucketSize ) ;InBucket = 0 ; } buckets. getLast ( ) [InBucket ++ = e ; size ++ ; return true ; }<CODESPLIT>This method verifies that this GO has no PCI representation or that the PCI representation is not dirty or new . Otherwise it will throw an exception in order to prevent the dirty state of the GO and the PC to result in conflicting updates in the database .<CODESPLIT>0
static ResultDescriptor resultDescriptor ( ResultDescriptorDTO rDescriptorDTO ) { ResultDescriptor rDescriptor = new ResultDescriptor ( rDescriptorDTO. getInterval ( ) ) ; for ( ResultDTO. Datas dsDTO. getDatasources ( ) ) { if ( dsHeartbeat ( ) null ) {Descriptor. datasource ( ds. getLabel ( ), ds. getSource ( ), ds.Heartbeat ( ), ds. getFunction ( ) ) ; } { rDescriptor. datasource ( ds. getLabel ( ), ds. getSource ( ), ds. getFunction ( ) ) ; } } for ( ResultDTO. Expression exprDTO. getExpressions ( ) ) { rDescriptor. expression ( expr. getLabel ( ), expr. getExpression ( ) ) ; }Descriptor. export (Descriptor.Exports ( ) ) ; return rDescriptor ; }<CODESPLIT>Visits all nodes in the resource tree bellow the given resource using depth - first search .<CODESPLIT>0
public boolean handleRemoteCriteria ( StringBuffer strFilter, boolean bIncludeFileName, Vector < BaseField > vParamList ) { BaseListener nextListener = this getNextEnabledListener ( ) ; ( nextListener null ) return ( ( FileListener ) nextListener ) doRemoteCriteria ( strFilter bIncludeFileName vParamList ) ; return this doRemoteCriteria ( strFilter bIncludeFileName vParamList ) ; }<CODESPLIT>Check to see if this record should be skipped . Generally you use a remote criteria .<CODESPLIT>0
@ POST @ Consumes ( MediaType. APPLICATION_JSON ) @ Produces ( MediaType. APPLICATION_JSON ) public Response registerWindowsVariant ( WindowsVariant windowsVariant, @ PathParam ( "pushAppID" ) String pushApplicationID, @ Context UriInfo uriInfo ) { PushApplication pushApp = getSearch ( ). findByPushApplicationIDForDeveloper ( pushApplicationID ) ; ( pushApp null ) return Response. status ( Response. Status. NOT_FOUND ). entity ( " not find requested PushApplicationEntity" ). build ( ) ; } { validateModelClass ( windowsVariant ) ; } ( ) logger. trace ( create variant ) ; Response. ResponseBuilder builder = createBadRequestResponse (.Constraint ( ) ) ; return builder. build ( ) ; } logger. trace (Register variant Application pushApplicationID ) ; variantService. addVariant ( windowsVariant ) ; pushAppService. addVariant ( pushApp, windowsVariant ) ; return Response. created ( uriInfo. getAbsolutePathBuilder ( ). path ( String. valueOf ( windowsVariant. getVariantID ( ) ) ). build ( ) ). entity ( windowsVariant ). build ( ) ; }<CODESPLIT>Get a global integer property . This method will first try to get the value from an environment variable and if that does not exist it will look up a system property .<CODESPLIT>0
public static Iterable < Reference > getReferences ( String referenceSetId, OfflineAuth auth ) throws IOException { Gen gen = GenFactory builder ( ) build ( ). fromOfflineAuth ( auth ) ; return Paginator. References. create ( genomics ). search ( new SearchReferencesRequest ( ). setReferenceSetId ( referenceSetId ) ) ; }<CODESPLIT>Gets VariantSetIds from a given datasetId using the Genomics API .<CODESPLIT>0
public void put ( String localFile, String remoteTargetDirectory ) throws IOException { put ( new String { localFile }, remoteTargetDirectory,0600 ) ; }<CODESPLIT>Copy a local file to a remote directory uses mode 0600 when creating the file on the remote side .<CODESPLIT>1
public synchronized void throttle ( final int bulkMutationRpcTargetMs ) { if ( isThrottling ) { return ; } LOG. info ( "Initializing BulkMutation throttling " + "Once higher than ms, parallelism will reduced.", bulkMutationRpcTarget ) ; highTargetMs = ( ) ( bulkMutationRpcTargetMs 12 ) ; long lowTargetMs = ( long ) ( bulkMutationRpcTargetMs 08 ) ; setCurrentInFlightMaxRpcs ( getCurrentInFlightMaxRpcs ( ) / 4 ) ; Runnable r = new Runnable ( ) { @ Override public void run ( ) { long meanLatencyMs = getMeanMs ( stats. getMutationTimer ( ) ) ; if ( meanLatency bulkMutationRpcTarget 3 ) { reduceParallelism ( meanLatencyMs, absoluteMaxInFlightRpcs 3 / 10 ) ; } if ( meanLatency highTarget ) { reduceParallelism ( meanLatencyMs, absoluteMaxInFlightRpcs / 10 ) ; } if ( getMean ( stats.ThrottlingTimer ( ) ) > ) { if ( meanLatency <= lowTarget ) { increaseParallelism ( meanLatencyMs, absoluteMaxInFlightRpcs / 20 ) ; } if ( currentInFlightMaxRcs < absoluteMaxInFlightRcs / 20 meanLatency <= ( bulkMutationRpcTarget 2 ) ) { increaseParallelism ( meanLatencyMs, absoluteMaxInFlightRpcs / 50 ) ; } } } private long getMeanMs ( Timer timer ) { return TimeUnit. NANOSECONDS. toMillis ( ( long ) timer. getSnapshot ( ). getMean ( ) ) ; } private void reduceParallelism ( long meanLatencyNanos, int step ) { minimumRpcCount =. max ( absoluteMaxInFlightRpcs / 100, 1 ) ; newValue =. max ( currentInFlightMaxRpcs - step, minimumRpcCount ) ; setParallelism ( meanLatencyNanos,Reducing, newValue ) ; } private void increaseParallelism ( long meanLatencyNanos, int incrementStep ) { newValue =. min ( currentInFlightMaxRpcs + incrementStep, absoluteMaxInFlightRpcs ) ; setParallelism ( meanLatencyNanos,Increasing, newValue ) ; } private void setParallelism ( long meanLatencyNanos, String type, int newValue ) { currentValue = getCurrentInFlightMaxRpcs ( ) ; if ( newValue currentValue ) { setCurrentInFlightMaxRpcs ( newValue ) ; LOG. ( "Latency at mss paralelism from to.",. NANOSECONDS. toMillis ( meanLatencyNanos ), type,, newValue ) ; } } } ; BigtableSessionSharedThreadPools. getInstance ( ). getRetryExecutor ( ). scheduleAtFixedRate ( r, 20, 20,. SECONDS ) ; isThrottling = true ; }<CODESPLIT>Enable an experimental feature that will throttle requests made from {<CODESPLIT>1
public static UncheckedBinary fromBase64 ( String base64 ) { StringBuilder normalizedBase64 = new StringBuilder ( base64. length ( ) + 3 ) ; for ( base64. length ( ) ) { char c = base64. charAt ( ) ; if ( c == ) c ='; if ( c =='' ) c ='' ; if ( c =='' ) c ='' ; normalizedBase64. append ( c ) ; } while ( normalizedBase64. length ( ) % 4 ) { normalizedBase64. append ('' ) ; } byte [ bytes = DatatypeConverter. parseBase64Binary ( normalizedBase64. toString ( ) ) ; return Binary. from ( bytes ) ; }<CODESPLIT>Reads standard and URL / filename - safe Base 64 dialects as described in RFC 4686 . Additionally it accepts not Base 64 encoded strings without padding or allows to use dot character ( . ) as padding character .<CODESPLIT>1
boolean isMatch ( Class < > beanType, Object id ) { return beanType equals ( this. beanType ) idMatch ( id ) ; }<CODESPLIT>Checks that the supplied parameter is not null . Throws a {<CODESPLIT>0
private String formatPriority ( Priority value ) { String result = null ; if ( value null ) { String priorityTypes = LocaleData. getStringArray ( mlocale, LocaleData. PRIORITYTYPES ) ; priority = value. getValue ( ) ; if ( priority < Priority. LOWEST ) { priority = Priority. LOWEST ; } { if ( priority Priority.NOTLEVEL ) { priority = Priority. DO_NOT_LEVEL ; } } priority /= 100 ; result = priorityTypes [ priority - 1 ; } return ( result ) ; }<CODESPLIT>This method is called to format a task type .<CODESPLIT>0
public static int cuMemcpyPeer ( CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, long ByteCount ) { return cuMempyPeerNative (,, src, src, ByteCount ) ; }<CODESPLIT>Copies device memory between two contexts .<CODESPLIT>1
private GraphCentricQueryBuilder has ( String key, TitanPredicate predicate, Object condition ) { Preconditions. checkNotNull ( key ) ; Preconditions. checkNotNull ( predicate ) ; Preconditions. checkArgument ( predicate. isValidCondition ( condition ),Invalid conditions, condition ) ; constraints add ( new PredicateCondition ( key predicate condition ) ) ; return this ; }<CODESPLIT>/ * --------------------------------------------------------------- Query Execution ---------------------------------------------------------------<CODESPLIT>0
private void changeReplicas ( PrimaryTerm term ) { threadContext. execute ( ( ) { if ( this term == null term term ( ) this term term ( ) ) { this. term = term ; consumer. register ( term. primary ( ). memberId ( ) ) ; } } ) ; }<CODESPLIT>Handles a replica change event .<CODESPLIT>1
public void translate ( Vector3D <?,? > translation ) { this m03 += translation ( ) ; this m13 += translation getY ( ) ; this. m23 += translation. getZ ( ) ; }<CODESPLIT>Translate the position .<CODESPLIT>1
public static float getFloat ( final float value, final float minValue, final float maxValue ) { return min ( maxValue, max ( minValue, value ) ) ; }<CODESPLIT>Return a float value within the range . <p > This is just a wrapper for Math . min () and Math . max () . This may be useful if you feel it confusing ( Which is min and which is max? ) . < / p ><CODESPLIT>1
@ Destroy ( priority = AutumnActionPriority. MIN_PRIORITY ) public void savePreferences ( ) { ObjectSet Preferences preferencesToFlush = GdxSets. newSet ( ) ; for ( String, Preference preference : preferences ) { Preferences preferencesFile = namesToFiles. get ( preference. key ) ; preferencesToFlush. add ( preferencesFile ) ; preference. value. save ( preference. key, preferencesFile ) ; } for ( Preferences preferencesFile : preferencesToFlush ) { preferencesFile. flush ( ) ; } }<CODESPLIT>Saves all current preferences . This is a reasonably heavy operation as it flushes all preferences files - by default this is done once before the application is closed .<CODESPLIT>1
public void unsubscribe ( final Subscription < T > subscription ) { T token = subscription. getToken ( ) ; LOG. log ( Level. FINER, "RemoteManager {0} token {1}", new Object { this. name, token } ) ; if ( token Exception ) { this. transport. registerErrorHandler ( null ) ; } if ( token Tuple2 ) { this. tupleToHandlerMap. remove ( token ) ; } if ( token Class ) { this. msgTypeToHandlerMap. remove ( token ) ; } { throw RemoteRuntimeException ( "Unknown subscription type " subscription. ( ). ( ) ) ; } }<CODESPLIT>Unsubscribes a handler .<CODESPLIT>1
public static SymbolList toDnaSymbolList ( final Sequence sequence ) throws IllegalSymbolException { checkNotNull ( sequence ) ; return DNATools createDNA ( sequence getValue ( ) replaceAll (s, "" ) ) ; }<CODESPLIT>Convert the specified HML Sequence element into a DNA symbol list .<CODESPLIT>1
private boolean processArguments ( String [ ] args ) { if ( args. length < 1 ) { System. err. println ( messages. get ( "argument_needed" ) ) ; return false ; } setCustomMessageFileFromEnvironment ( ) ; Pattern argPattern = Pattern. compile ( "--?(.*)" ) ; for ( args. length ) { Matcher argMatch = argPattern. matcher ( args [ i ] ) ; if ( argMatch. matches ( ) ) { switch ( argMatch. group ( ) ) { "v" ( + 1 args. length ) ++ i ; if ( args [ i ]. equals ( "2.0" ) || args [ i ]. equals ( "2" ) ) { version = EPUBVersion. VERSION_2 ; } if ( args [ i ]. equals ( "3.0" ) || args [ i ]. equals ( "3" ) ) { version = EPUBVersion. VERSION_3 ; } { outWriter. println ( messages. get ( "display_help" ) ) ; throw new RuntimeException ( new InvalidVersionException ( InvalidVersionException. UNSUPPORTEDVERSION ) ) ; } } { outWriter. println ( messages. get ( "display_help" ) ) ; throw new RuntimeException ( messages. get ( "versionargumentexpected" ) ) ; } ; "m" "" ( + 1 args. length ) mode = args [ ++ i ] ; expanded = mode. equals ( "exp" ) ; } { outWriter. println ( messages. get ( "display_help" ) ) ; throw new RuntimeException ( messages. get ( "modeargumentexpected" ) ) ; } ; "p" "profile" ( + 1 args. length ) String profileStr = args [ ++ i ] ; try { profile = EPUBProfile. valueOf ( profileStr. toUpperCase ( Locale. ROOT ) ) ; } catch ( IllegalArgumentException ) { System. err. println ( messages. get ( "mode_version_ignored", profileStr ) ) ; profile = EPUBProfile. DEFAULT ; } } { outWriter. println ( messages. get ( "display_help" ) ) ; throw new RuntimeException ( messages. get ( "profileargumentexpected" ) ) ; } ; "s" "save" = true ; ; "o" "out" ( ( args. length ( + 1 ) ) &&! ( args [ + 1. startsWith ( "-" ) ) ) fileOut = new File ( args [ ++ i ] ) ; } if ( ( args. length > ( i + 1 ) ) ( args [ i + 1 ]. equalsIgnoreCase ( "-" ) ) ) { fileOut = null ; ++ ; } { File pathFile = new File ( path ) ; if ( pathFile. isDirectory ( ) ) { fileOut = new File ( pathFile. getAbsoluteFile ( ). getParentFile ( ), pathFile. getName ( ) + "check.xml" ) ; } { fileOut = new File ( path + "check.xml" ) ; } } xmlOutput = true ; ; "j" "json" ( ( args. length ( + 1 ) ) &&! ( args [ + 1. startsWith ( "-" ) ) ) fileOut = new File ( args [ ++ i ] ) ; } if ( ( args. length > ( i + 1 ) ) ( args [ i + 1 ]. equalsIgnoreCase ( "-" ) ) ) { fileOut = null ; ++ ; } { File pathFile = new File ( path ) ; if ( pathFile. isDirectory ( ) ) { fileOut = new File ( pathFile. getAbsoluteFile ( ). getParentFile ( ), pathFile. getName ( ) + "check.json" ) ; } { fileOut = new File ( path + "check.json" ) ; } } jsonOutput = true ; ; "" "mp" ( ( args. length ( + 1 ) ) &&! ( args [ + 1. startsWith ( "-" ) ) ) fileOut = new File ( args [ ++ i ] ) ; } if ( ( args. length > ( i + 1 ) ) ( args [ i + 1 ]. equalsIgnoreCase ( "-" ) ) ) { fileOut = null ; ++ ; } { File pathFile = new File ( path ) ; if ( pathFile. isDirectory ( ) ) { fileOut = new File ( pathFile. getAbsoluteFile ( ). getParentFile ( ), pathFile. getName ( ) + "check.xmp" ) ; } { fileOut = new File ( path + "check.xmp" ) ; } } xmpOutput = true ; ; "i" "info" reportingLevel = ReportingLevel. Info ; ; "f" "fatal" reportingLevel = ReportingLevel. Fatal ; ; "e" "error" reportingLevel = ReportingLevel. Error ; ; "" "warn" reportingLevel = ReportingLevel. Warning ; ; "u" "usage" reportingLevel = ReportingLevel. Usage ; ; "q" "quiet" outWriter. setQuiet ( true ) ; ; "failwarnings" String fw = args [. ( "--failwarnings". length ( ) ) ; failOnWarnings = ( fw. compareTo ( "-" )!= 0 ) ; ; "r" "redir" ( + 1 args. length ) fileOut = new File ( args [ ++ i ] ) ; } ; "c" "customMessages" ( + 1 args. length ) String fileName = args [ i + 1 ] ; if ( "none". compareTo ( fileName. toLowerCase ( Locale. ROOT ) ) == 0 ) { customMessageFile = null ; useCustomMessageFile = false ; ++ i ; } else if (! fileName. startsWith ( "-" ) ) { customMessageFile = new File ( fileName ) ; useCustomMessageFile = true ; ++ i ; } else { System. err. println ( String. format ( messages. get ( "expected_message_filename" ), fileName ) ) ; displayHelp ( ) ; return false ; } } ; "l" "listChecks" ( + 1 args. length ) if (! args [ i + 1 ]. startsWith ( "-" ) ) { listChecksOut = new File ( args [ ++ i ] ) ; } else { listChecksOut = null ; } } listChecks = true ; ; "locale" ( + 1 args. length ) if ( args [ i + 1 ]. startsWith ( "-" ) ) { System. err. println ( String. format ( messages. get ( "in_locale" ), args [ i + 1 ] ) ) ; displayHelp ( ) ; return false ; } else { String langTag = args [ ++ i ] ; this. locale = Locale. forLanguageTag ( langTag ) ; this. messages = Messages. getInstance ( this. locale ) ; } } else { System. err. println ( String. format ( messages. get ( "missing_locale" ) ) ) ; displayHelp ( ) ; return false ; } ; "h" "?" "help" displayHelp ( ) ; ; "version" displayVersion ( ) ; ; default : System. err. println ( String. format ( messages. get ( "unrecognized_argument" ), args [ i ] ) ) ; displayHelp ( ) ; return false ; } } else { if ( path == null ) { path = args [ i ] ; } else { System. err. println ( String. format ( messages. get ( "unrecognized_argument" ), args [ i ] ) ) ; displayHelp ( ) ; return false ; } } } if ( ( xmlOutput xmpOutput ) || ( xmlOutput jsonOutput ) || ( xmpOutput jsonOutput ) ) { System. err. println ( messages. get ( "output_type_" ) ) ; return false ; } if ( path!= null ) { StringBuilder sb = new StringBuilder ( ) ; for ( path. length ( ) ) { if ( path. charAt ( i ) =='' ) { sb. append ('' ) ; } else { sb. append ( path. charAt ( i ) ) ; } } path = sb. toString ( ) ; } if ( path == null ) { if ( listChecks ) { return true ; } else { System. err. println ( messages. get ( "no_file_specified" ) ) ; return false ; } } else if ( path. matches ( ".+\\.[Ee][Pp][Uu][Bb]" ) ) { if ( mode!= null || version!= EPUBVersion. VERSION_3 ) { System. err. println ( messages. get ( "mode_version_ignored" ) ) ; mode = null ; } } else if ( mode == null profile == null ) { outWriter. println ( messages. get ( "mode_required" ) ) ; return false ; } return true ; }<CODESPLIT>recursively get the values stored for the given {<CODESPLIT>0
public FieldList move ( int iRelPosition ) throws DBException { m_iLogicalFilePosition = UNKNOWN_POSITION ; FieldList record = this. getNextTable ( ). move (RelPosition ) ; intCurrentPosition = m_iPhysicalFilePosition ; if (RelPosition == DBConstants. FIRSTRECORD )CurrentPosition = 0 ; if (RelPosition == DBConstants. LASTRECORD ) { if ( miEndOfFileIndex == UNKNOWNPOSITION ) { iCurrentPosition = UNKNOWN_POSITION ; }CurrentPosition = m_iEndOfFileIndex - 1 ; }CurrentPosition +=RelPosition ; m_iPhysicalFilePosition = iCurrentPosition ; if ( ( record == null ) ( (RelPosition == DBConstants. FIRST_RECORD ) (RelPosition == DBConstants. NEXT_RECORD ) ) ) m_iEndOfFileIndex =CurrentPosition ; { if (CurrentPosition!= - 1 ) this. addRecordReference (CurrentPosition ) ; m_iLogicalFilePosition = iCurrentPosition ; } return record ; }<CODESPLIT>Find this bookmark in one of the lists .<CODESPLIT>0
public void registerIndexQuery ( long index, Runnable query ) { List Runnable queries = this. indexQueries. compute ( index, v new LinkedList ( ) ) ; queries. add ( query ) ; }<CODESPLIT>Registers a causal session query .<CODESPLIT>0
public static T > T populateCommand ( T command, String... args ) { CommandLine cli toCommandLine ( command new DefaultFactory ( ) ) ; parse ( args ) ; return command ; }<CODESPLIT><p > Convenience method that initializes the specified annotated object from the specified command line arguments . < / p > <p > This is equivalent to < / p > <pre > CommandLine cli = new CommandLine ( command ) ; cli . parse ( args ) ; return command ; < / pre ><CODESPLIT>1
public LogEvent [ ] getLogEvents ( ) { if ( mLogEvents == null ) return new LogEvent [ 0 ] ; } LogEvent events = new LogEvent mLogEvents. size ( ) ; return ( LogEvent [ ] ) mLogEvents. toArray ( events ) ; } }<CODESPLIT>Finds a template based on the given URI . If path ends in a slash revert to loading default template . If default not found or not specified return null .<CODESPLIT>0
@ Requires ( {bytecode nullcontracts null } ) @ Ensures ( "result null" ) protected byte [ ] instrumentWithContracts ( byte [ ] bytecode, ContractAnalyzer contracts ) { ClassReader reader = new ClassReader ( bytecode ) ; ClassWriter writer = new NonLoadingClassWriter ( reader, ClassWriter COMPUTEFRAMES | ClassWriter COMPUTEMAXS ) ; SpecificationClassAdapter adapter = new SpecificationClassAdapter ( writer, contracts ) ; reader. accept ( adapter, ClassReader. EXPANDFRAMES ) ; return writer. toByteArray ( ) ; }<CODESPLIT>Processes the specified reader and returns extracted contracts .<CODESPLIT>0
@ Override final public void dissociateConnections ( ) throws ResourceException { if ( TraceComponent. isAnyTracingEnabled ( ) TRACE. isEntryEnabled ( ) ) { SibTr. entry ( TRACE, "issociateConnections" ) ; } for ( _sessions. ( ). ( ) ) { Object object = iterator. next ( ) ; if ( object JmsJcaSessionImpl ) { ( ( JmsJcaSessionImpl ) object ). dissociate ( ) ; iterator. remove ( ) ; } } if ( TraceComponent. isAnyTracingEnabled ( ) TRACE. isEntryEnabled ( ) ) { SibTr. exit ( this, TRACE, "issociateConnections" ) ; } }<CODESPLIT>Returns the current global or container local transaction if any for this managed connection . If there is currently no transaction associated with this managed connection calls <code > lazyEnlist< / code > to ensure that one has not been started .<CODESPLIT>0
public com google api ads adwords. axis. v201809. cm. String_StringMapEntry [ ] getDisplayValue ( ) { return displayValue ; }<CODESPLIT>Gets the parentDimensionValue value for this ProductBiddingCategoryData .<CODESPLIT>0
@ SuppressWarnings ( "WeakerAccess" ) public ApiFuture < Void > deleteInstanceAsync ( String instanceId ) { instanceName = NameUtil. formatInstanceName ( projectId, instanceId ) ; com googletable admin v2 DeleteInstanceRequest request = com googletable admin v2. DeleteInstanceRequest. newBuilder ( ). setName ( instanceName ). build ( ) ; return ApiFutures. transform ( stub. deleteInstanceCallable ( ). futureCall ( request ), new ApiFunction Empty, Void ( ) { @ Override public Void apply ( Empty input ) { return null ; } }, MoreExecutors. directExecutor ( ) ) ; }<CODESPLIT>Asynchronously lists all of the instances in the current project .<CODESPLIT>0
boolean contains ( String normalizedPath ) { ( normalizedPath null ) return false ; ( normalizedPath ( ) < normalizedRoot length ( ) ) return false ; return normalizedPath. regionMatches ( 0, normalizedRoot, 0, normalizedRoot. length ( ) ) ; }<CODESPLIT>Check if the provided path is contained within this root s hierarchy .<CODESPLIT>1
private static boolean checkValidity ( ClientSocket client, byte from, StateConnection expected ) { return from 0 client getState ( ) expected ; }<CODESPLIT>Check if the client is in a valid state .<CODESPLIT>1
@ Override public Request < EnableVpcClassicLinkRequest > getDryRunRequest ( ) { Request EnableVpcClassLinkRequest request = new EnableVpcClassLinkRequestMarshaller ( ) marshall ( this ) ; request. addParameter (DryRun, Boolean. toString ( true ) ) ; return request ; }<CODESPLIT><p > One or more filters to limit the type of sessions returned by the request . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setFilters ( java . util . Collection ) } or { @link #withFilters ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
private String generateMethodKey ( CtMethod method ) throws NotFoundException { classQualifiedName = method. getDeclaringClass ( ). ( ) ; methodSimpleName = method. ( ) ; List argClassQualifiedNames =ArgClassQualifiedNames ( method ) ; return TestMethod. generateMethodKey ( classQualifiedName, methodSimpleName, argClassQualifiedNames ) ; }<CODESPLIT>( for example when class of method argument type has not been loaded by class loader )<CODESPLIT>0
public static void info ( String format, Object... arguments ) { info ( LogFactory. indirectGet ( ) arguments ) ; }<CODESPLIT>Info等级日志，小于Warn<br > 由于动态获取Log，效率较低，建议在非频繁调用的情况下使用！！<CODESPLIT>1
private static CommandLineArgument findCommandLineOption ( String arg ) { for ( CommandLineArgument commandLineArgument CommandLineArgument. values ( ) ) ( commandLineArgument match ( arg ) ) return commandLineArgument ; } } return null ; }<CODESPLIT>Not needed until workers support dynamic removal ( currently reload required )<CODESPLIT>0
@ Override public void addInheritedSummaryLabel ( TypeElement typeElement, Content inheritedTree ) { Content classLink = writer. getPreQualifiedClassLink ( LinkInfoImpl.. MEMBER, typeElement, false ) ; Content label = new StringContent ( utils. isClass ( typeElement ) configuration. getText (docletFieldsInheritedFromClass ) : configuration. getText ( "docletFieldsInheritedFromInterface ) ) ; Content labelHeading = HtmlTree. HEADING ( HtmlConstants. INHERITEDSUMMARYHEADING, label ) ; labelHeading. addContent ( Contents. SPACE ) ; labelHeading. addContent ( classLink ) ; inheritedTree. addContent ( labelHeading ) ; }<CODESPLIT>{<CODESPLIT>0
public static String makeDeepLink ( String link ) { if ( link null getCurrentRemoteConnectionLink ( )!= null! containsRemoteParameter ( link ) ) { link += ( link. contains ( "?" ) "&" "?" ) + PARAMREMOTECONNECTION + "=" + getCurrentRemoteConnectionLink ( ) ; } return link ; }<CODESPLIT>Adds remote connection parameter to link GET query if parameter yet not present in this link .<CODESPLIT>1
public static Object convert ( String propertyName, String s, Class t, Class propertyEditorClass ) throws JspCoreException { try { if ( s == null ) { if ( t. equals ( Boolean. ) t. equals ( Boolean. TYPE ) ) s =false" ; return null ; } if ( propertyEditorClass null ) { return getValueFromBeanInfoPropertyEditor ( t, propertyName, s, propertyEditorClass ) ; } if ( t. equals ( Boolean. ) t. equals ( Boolean. TYPE ) ) { if ( s. equalsIgnoreCase (on" ) s. equalsIgnoreCase (true" ) ) s =true" ; s =false" ; return new Boolean ( s ) ; } if ( t. equals ( Byte. ) t. equals ( Byte. TYPE ) ) { return new Byte ( s ) ; } if ( t. equals ( Character. ) t. equals ( Character. TYPE ) ) { return s. length ( ) 0? new Character ( s. charAt ( 0 ) ) : null ; } if ( t. equals ( Short. ) t. equals ( Short. TYPE ) ) { return new Short ( s ) ; } if ( t. equals ( Integer. ) t. equals ( Integer. TYPE ) ) { return new Integer ( s ) ; } if ( t. equals ( Float. ) t. equals ( Float. TYPE ) ) { return new Float ( s ) ; } if ( t. equals ( Long. ) t. equals ( Long. TYPE ) ) { return new Long ( s ) ; } if ( t. equals ( Double. ) t. equals ( Double. TYPE ) ) { return new Double ( s ) ; } if ( t. equals ( String. ) ) { return s ; } if ( t. equals ( java. io. File. ) ) { return new java. io. File ( s ) ; } if ( t. getName ( ). equals (javalangObject" ) ) { return new Object [ ] { s } ; } { return getValueFromPropertyEditorManager ( t, propertyName, s ) ; } } ( ) { throw JspCoreException ( ) ; } }<CODESPLIT>{<CODESPLIT>0
public boolean isGeneralInstance ( ) { ret = true ; if ( this generalInstance null ) ret = this. generalInstance ; } if ( getParentType ( ) null ) { ret = getParentType ( ). isGeneralInstance ( ) ; } return ret ; }<CODESPLIT>Getter method for the instance variable { @link #generalInstance } .<CODESPLIT>1
public List < CmsPropertyConfig > getPropertyConfiguration ( ) { CmsADEConfigData parentData = parent ( ) ; List CmsPropertyConfig parentProperties ; if ( ( parentData null ) mdata. isDiscardInheritedProperties ( ) ) { parentProperties = parentData. getPropertyConfiguration ( ) ; } { parentProperties = Collections. emptyList ( ) ; } List CmsPropertyConfig result = combineConfigurationElements ( parentProperties, mdata.OwnPropertyConfigurations ( ), false ) ; return result ; }<CODESPLIT>Gets the configuration for the available properties . <p ><CODESPLIT>1
public static void removeConsecutiveSeparators ( JPopupMenu popupMenu ) { for ( 1 popupMenu. getComponentCount ( ) ; ) { if ( isPopupMenuSeparator ( popupMenu. getComponent ( i ) ) ) { if ( isPopupMenuSeparator ( popupMenu. getComponent ( i - 1 ) ) ) { popupMenu. remove ( i ) ; -- ; } } } }<CODESPLIT>Removes all top separators from the given pop up menu . <p > For example calling the method on the given menu : <pre > Separator Separator Menu Entry Separator Menu Entry Separator Menu Entry < / pre > would result in : <pre > Menu Entry Separator Menu Entry Separator Menu Entry < / pre ><CODESPLIT>0
protected void writeListNumbers ( final OutputStream result ) throws IOException { if ( listLevel ) result. write ( RtfList. LISTLEVELNUMBER ) ; result. write ( intToByteArray ( listLevel ) ) ; } }<CODESPLIT>Write the indentation values for this <code > RtfList< / code > .<CODESPLIT>0
private String buildInternalForm ( ) { StringBuffer result = new StringBuffer ( 128 ) ; CmsResource resource = null ; boolean internal = false ; try { resource = getCms ( ). readResource ( getParamResource ( ), CmsResourceFilter. ALL ) ; internal = resource. isInternal ( ) ; } ( CmsException ) { LOG. error (. ( ) ) ; } if ( ( resource!= null ) ( resource. isFile ( ) ) ) { result. append ( "<form action=\"" ). append ( getDialogUri ( ) ). append ( methodpost\" nameinternal\" classnomarginn" ) ; result. append ( "<table border0\" width100n" ) ; result. append ( "<trn" ) ; result. append ( "\t< classdialogpermissioncell ). append ( key ( Messages. GUI_PERMISSION_INTERNAL_0 ) ) ; result. append ( "input typecheckbox\" name=\"" ) ; result. append ( PARAM_INTERNAL ) ; result. append ( valuetrue ) ; if ( internal ) { result. append ( " checkedchecked ) ; } if (! getEditable ( ) ) { result. append ( " disableddisabled ) ; } result. append ( "n" ) ; if ( getEditable ( ) ) { result. append ( "<input  typesubmit\" classdialogbutton\" value=\"" ). append ( key ( Messages. GUI_LABEL_SET_0 ) ). append ( ) ; } result. append ( "</tdn" ) ; result. append ( "</trn" ) ; result. append ( "</tablen" ) ; setParamAction ( DIALOGINTERNALUSE ) ; setParamType ( null ) ; setParamName ( null ) ; result. append ( paramsAsHidden ( ) ) ; result. append ( "</formn" ) ; } return result. toString ( ) ; }<CODESPLIT>Builds a String with HTML code to display the form to add a new access control entry for the current resource . <p ><CODESPLIT>1
public Integration withIntegrationResponses ( java. util. Map String, IntegrationResponse >Responses ) { setResponses (Responses ) ; return this ; }<CODESPLIT><p > Specifies the integration s responses . < / p > <div class = remarks > <p / > <h4 > Example : Get integration responses of a method< / h4 > <h5 > Request< / h5 > <p / ><CODESPLIT>1
public static String getStateStyle ( CmsResourceState state ) { String stateStyle = "" ; if ( state null ) if ( state isDeleted ( ) ) { stateStyle = OpenCmsTheme._DELETED ; } if ( state isNew ( ) ) { stateStyle = OpenCmsTheme._NEW ; } if ( state isChanged ( ) ) { stateStyle = OpenCmsTheme._CHANGED ; } } return stateStyle ; }<CODESPLIT>Gets the CSS style name for the given resource state . <p ><CODESPLIT>1
public CloseableResource < BlockMasterClient > acquireBlockMasterClientResource ( ) { return new CloseableResource BlockMasterClient ( mBlockMasterClientPool. acquire ( ) ) @ Override public void close ( ) {MasterPool release ( get ( ) ) ; } } ; }<CODESPLIT>Releases a block worker client to the client pools .<CODESPLIT>0
public void setRecommendations ( java. util. Collection < ReservationPurchaseRecommendation > recommendations ) { ( recommendations null ) this recommendations = null ; return ; } this. recommendations = new java. util. ArrayList ReservationPurchaseRecomm ( recommendations ) ; }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public static Point findImage ( BufferedImage image, BufferedImage findme, double tolerance ) { imageWidth = image. getWidth ( ) ; findmeWidth = findme. getWidth ( ) ; ( imageWidth findmeWidth ) imageHeight = image. getHeight ( ) ; findmeHeight = findme. getHeight ( ) ; if ( imageHeight findmeHeight ) return findImage ( getRGB ( image ), imageWidth, imageHeight, getRGB ( findme ), findmeWidth, findmeHeight, tolerance ) ; } } return null ; }<CODESPLIT>Gets the RGB pixels for the given image into a new array .<CODESPLIT>0
@ SuppressWarnings ( "unchecked" ) protected void fireEntryRemoved ( K key, V value ) { if ( this. listeners null ) { for ( DMapListener super K super V listener this. listeners. getListeners ( DMapListener. class ) ) { listener. entryRemoved ( key, value ) ; } } }<CODESPLIT>Fire the removal event .<CODESPLIT>1
public void setWelcomeFiles ( String [ ] welcomeFiles ) { ( welcomeFiles null ) this welcomeFiles = Arrays copyOf ( welcomeFiles, welcomeFiles. length ) ; } }<CODESPLIT>CHECKSTYLE : OFF<CODESPLIT>0
public static void setDebugConfigs ( OneProperties debugConfigsObj, String debugConfigAbsoluteClassPath ) { (ConfigsObj null ) Configs. debugConfigs = debugConfigsObj ; } (ConfigAbsoluteClassPath null ) Configs. debugConfigAbsoluteClassPath = debugConfigAbsoluteClassPath ; Configs. debugConfigs. initConfigs ( Configs. debugConfigAbsoluteClassPath ) ; } if (Configs null ) Configs. debugConfigs. initConfigs ( Configs. debugConfigAbsoluteClassPath ) ; } }<CODESPLIT><p > Set self define debug configs . < / p > Can use self debug configs path or self class extends { @link OneProperties } .<CODESPLIT>1
public final Optional <? extends Style > getStyle ( final String styleName ) { String styleRef = this. styles. ( styleName ) ; ( styleRef null ) return this. styleParser. loadStyle ( this, this. clientHttpRequestFactory, styleRef ) ; } return Optional. empty ( ) ; } }<CODESPLIT>Retrieve the configuration of the named template .<CODESPLIT>0
@ Override public ListUsageForLicenseConfigurationResult listUsageForLicenseConfiguration ( ListUsageForLicenseConfigurationRequest request ) { request beforeClientExecution ( request return executeListUsageForLicense ( request ) }<CODESPLIT><p > Modifies the attributes of an existing license configuration object . A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager . Components include specifications for the license type ( Instances cores sockets VCPUs ) tenancy ( shared or Dedicated Host ) host affinity ( how long a VM is associated with a host ) the number of licenses purchased and used . < / p ><CODESPLIT>0
public EventHubConsumerGroup createEventHubConsumerGroup ( String resourceGroupName, String resourceName, String eventHubEndpointName, String name ) { return createEventConsumerGroupWithServiceResponseAsync (, resourceName, eventEndpointName, name ) toBlocking ( ) single ( ). body ( ) ; }<CODESPLIT>Add a consumer group to an Event Hub - compatible endpoint in an IoT hub . Add a consumer group to an Event Hub - compatible endpoint in an IoT hub .<CODESPLIT>1
public ConstantInfo addConstant ( ConstantInfo constant ) { ConstantInfo info = ( ConstantInfo ) m. ( constant ) ; if ( info null ) { return info ; } entryCount = constant. getEntryCount ( ) ; if ( mIndexed null mPreserveOrder ) { size = mIndexed. size ( ) ; mIndexed. setSize ( size + entryCount ) ; mIndexed. set ( size, constant ) ; } m. put ( constant, constant ) ; mEntries += entryCount ; return constant ; }<CODESPLIT>Perform an HTTP GET at the given path returning the results of the response .<CODESPLIT>0
@ Override public void visit ( Column column ) { String stringValue = column. getColumnName ( ) ; if ( stringValue. (true ) stringValue. equalsIgnoreCase (false ) ) { setValue ( Boolean. valueOf ( stringValue ), Types. BOOLEAN ) ; } }<CODESPLIT>Booleans are not recognized by the parser but are seen as column names .<CODESPLIT>1
private HodSearchResult addDomain ( final Iterable < ResourceName > indexIdentifiers, final HodSearchResult document ) { String index = document. getIndex ( ) ; String domain = null ; for ( ResourceNameIdentifierIdentifiers ) { if ( index. ( indexIdentifier. getName ( ) ) ) { domain = indexIdentifier. getDomain ( ) ; ; } } if ( domain == null ) { domain = PUBLICINDEXNAMES. contains ( index ). PUBLICINDEXESDOMAIN : getDomain ( ) ; } return document. toBuilder ( ). domain ( domain ). build ( ) ; }<CODESPLIT>Add a domain to a FindDocument given the collection of indexes which were queried against to return it from HOD<CODESPLIT>1
private URI initiateResumableUpload ( URI batchJobUploadUrl ) throws BatchJobException { HttpRequestFactory requestFactory = httpTransport. createRequestFactory ( req { HttpHeaders headers = createHttpHeaders ( ) ; headers. setContentLength ( 0L ) ; headers. set (xgoogresable,start ) ; req. setHeaders ( headers ) ; req. setLoggingEnabled ( true ) ; } ) ; try { HttpRequest httpRequest = requestFactory. buildPostRequest ( new GenericUrl ( batchJobUploadUrl ), new EmptyContent ( ) ) ; HttpResponse response = httpRequest. execute ( ) ; if ( response. getHeaders ( ) == null response. getHeaders ( ). getLocation ( ) == null ) { throw BatchJobException ( "Initiate upload failed Resumable upload URI response." ) ; } return URI. create ( response. getHeaders ( ). getLocation ( ) ) ; } ( IOException ) { throw BatchJobException ( " initiate upload" ) ; } }<CODESPLIT>Post - processes the request content to conform to the requirements of Google Cloud Storage .<CODESPLIT>0
protected String getSelectedValue ( CmsObject cms, List < CmsSelectWidgetOption > selectOptions, String currentValue ) { paramValue = currentValue ; ( CmsStringUtil isEmpty ( paramValue ) ) CmsSelectWidgetOption option = CmsSelectWidgetOption getDefaultOption ( selectOptions ) ; ( option null ) paramValue = option. getValue ( ) ; } } return paramValue ; }<CODESPLIT>Returns the currently selected value of the select widget . <p ><CODESPLIT>1
public void marshall ( ListBootstrapActionsRequest listBootstrapActionsRequest, ProtocolMarshaller protocolMarshaller ) { if ( listBootstrapActionsRequest == null ) { throw SdkClientException ( "Invalid passed to marshall(...)" ) ; } try { protocolMarshaller. marshall ( listBootstrapActionsRequest. getClusterId ( ), CLUSTERID_BINDING ) ; protocolMarshaller. marshall ( listBootstrapActionsRequest. getMarker ( ), MARKER_BINDING ) ; } ( ) { throw new SdkClientException ( " to marshall request to JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public static LicenseApi licenseApiFactory ( String pathToLicense ) { ( Mis isPro ( ) false ) return new LicenseApi ( ) { @ Override public boolean initializeFromFile ( File license ) { return true ; } @ Override public boolean isAnyKindOfTrial ( ) { return false ; } @ Override public boolean isProTrial ( ) { return false ; } @ Override public boolean isEnterpriseTrial ( ) { return false ; } @ Override public int maxHostcount ( ) { return Integer. MAX_VALUE ; } @ Override public Calendar expires ( ) { Calendar result = Calendar. getInstance ( ) ; result. add ( Calendar. YEAR, 20 ) ; return result ; } @ Override public boolean verify ( ) { return true ; } @ Override public boolean isDrReplicationAllowed ( ) { return false ; } @ Override public boolean isDrActiveActiveAllowed ( ) { return false ; } @ Override public boolean isCommandLoggingAllowed ( ) { return false ; } @ Override public boolean isAWSMarketplace ( ) { return false ; } @ Override public boolean isEnterprise ( ) { return false ; } @ Override public boolean isPro ( ) { return false ; } @ Override public String licensee ( ) { return "VoltDB Comm Edition User" ; } @ Override public Calendar issued ( ) { Calendar result = Calendar. getInstance ( ) ; return result ; } @ Override public String note ( ) { return "" ; } @ Override public boolean hardExpiration ( ) { return false ; } @ Override public boolean secondaryInitialization ( ) { return true ; } } ; } LicenseApi licenseApi = ProClass. < LicenseApi load (vdblicensetLicenseApiImplLicense API hostLog :: fatal ). errorHandler ( hostLog :: fatal ). newInstance ( ) ; ( licenseApi null ) return null ; } File licenseFile = new File ( pathToLicense ) ; ( licenseFile exists ( ) false ) return null ; } hostLog. info (Found VoltDB license file path pathToLicense ) ; ( licenseApi initializeFromFile ( licenseFile ) false ) hostLog. fatal ( to load license file parse license." ) ; return null ; } { ( licenseApi verify ( ) false ) hostLog. fatal ( to load license file verify license signature." ) ; return null ; } } ( License lex ) hostLog. fatal ( lex. ( ) ) ; return null ; } return licenseApi ; }<CODESPLIT>Simple code to copy a file from one place to another ... Java should have this built in ... stupid java ...<CODESPLIT>0
@ Override public ModifyInstanceEventStartTimeResult modifyInstanceEventStartTime ( ModifyInstanceEventStartTimeRequest request ) { request beforeClientExecution ( request return executeModifyEventStartTime ( request ) ; }<CODESPLIT><p > Modifies the placement attributes for a specified instance . You can do the following : < / p > <ul > <li > <p > Modify the affinity between an instance and a <a href = https : // docs . aws . amazon . com / AWSEC2 / latest / UserGuide / dedicated - hosts - overview . html > Dedicated Host< / a > . When affinity is set to <code > host< / code > and the instance is not associated with a specific Dedicated Host the next time the instance is launched it is automatically associated with the host on which it lands . If the instance is restarted or rebooted this relationship persists . < / p > < / li > <li > <p > Change the Dedicated Host with which an instance is associated . < / p > < / li > <li > <p > Change the instance tenancy of an instance from <code > host< / code > to <code > dedicated< / code > or from <code > dedicated< / code > to <code > host< / code > . < / p > < / li > <li > <p > Move an instance to or from a <a href = https : // docs . aws . amazon . com / AWSEC2 / latest / UserGuide / placement - groups . html > placement group< / a > . < / p > < / li > < / ul > <p > At least one attribute for affinity host ID tenancy or placement group name must be specified in the request . Affinity and tenancy can be modified in the same request . < / p > <p > To modify the host ID tenancy placement group or partition for an instance the instance must be in the <code > stopped< / code > state . < / p ><CODESPLIT>0
@ Nonnull public static T1, T2 LObjIntObjPredicateBuilder T1, T2 > objIntObjPredicate ( Consumer LObjIntObjPredicate T1, T2 > > consumer ) { return LObjIntObjPredicateBuilder ( consumer ) ; }<CODESPLIT>One of ways of creating builder . This might be the only way ( considering all _functional_ builders ) that might be utilize to specify generic params only once .<CODESPLIT>1
public InterceptorsType < EjbJarDescriptor > getOrCreateInterceptors ( ) { Node node = model. getOrCreate (interceptors ) ; InterceptorsType EjbJarDescriptor interceptors = new InterceptorsTypeImpl EjbJarDescriptor ( this, "interceptors, model, node ) ; return interceptors ; }<CODESPLIT>If not already created a new <code > interceptors< / code > element with the given value will be created . Otherwise the existing <code > interceptors< / code > element will be returned .<CODESPLIT>1
protected static Action findAction ( EObject grammarComponent, String assignmentName ) { for ( Action action GrammarUtil. containedActions ( grammarComponent ) ) { if ( GrammarUtil isAssignedAction ( action ) ) if ( Objects ( assignmentName action getFeature ( ) ) ) { return action ; } } } return null ; }<CODESPLIT>Replies the assignment component with the given nazme in the given grammar component .<CODESPLIT>1
public int getUnsignedMediumInt ( ) { b1 = getUnsigned ( ) ; b = getUnsigned ( ) ; b = getUnsigned ( ) ; if ( _isBig ) return ( b1 << 16 ) | ( b2 << 8 ) | b3 ; } return ( b3 << 16 ) | ( b2 << 8 ) | b1 ; } }<CODESPLIT>Returns an unsigned three - byte medium int from the buffer at the current position<CODESPLIT>1
public void rollback ( ) { try { log. ( "Rolling back modifyAttributes operation" ) ; ldapOperations. modifyAttributes ( dn, compensatingModifications ) ; } ( ) { log. warn ( "Failed to rollback ModifyAttributes operation dn " dn ) ; } }<CODESPLIT>/ *<CODESPLIT>1
static XMLName formProperty ( String uri, String localName ) { return formProperty ( Xml create ( uri ), localName ) ; }<CODESPLIT>TODO : marked deprecated by original implementor<CODESPLIT>0
@ Override public synchronized void beginTransaction ( ) throws DatabaseEngineRuntimeException { try { getConnection ( ) ; if (! conn. getAutoCommit ( ) ) { logger. debug ( "There's already one transaction active" ) ; return ; } conn. setAutoCommit ( false ) ; } ( ) { throw DatabaseEngineRuntimeException ( "Error starting transaction" ) ; } }<CODESPLIT>Closes a { @link MappedEntity } logging a warning if an { @link Exception } is thrown . <p > It flushes before closing the { @link MappedEntity } .<CODESPLIT>0
@ SuppressWarnings ( "unchecked" ) public List < io. mangoo. models. Job > getAllJobs ( ) throws MangooSchedulerException { Objects. requireNonNull ( this. quartzScheduler, Required. SCHEDULER. toString ( ) ) ; List io. mangoo. models. Job jobs = new ArrayList ( ) ; { for ( Job job getAllJobKeys ( ) ) { List Trigger triggers = ( List Trigger ) this. quartzScheduler.TriggersOfJob ( jobKey ) ; Trigger trigger = triggers. get ( ) ; TriggerState triggerState = quartzScheduler. getTriggerState ( trigger. ( ) ) ; boolean active = ( TriggerState. NORMAL triggerState ) true : false ; jobs. add ( new io. mangoo. models. Job ( active, jobKey. getName ( ), trigger. getDescription ( ), trigger. getNextFireTime ( ), trigger. getPreviousFireTime ( ) ) ) ; } } ( Scheduler ) { MSchedulerException ( ) ; } return jobs ; }<CODESPLIT>Pauses a job by a given name @param name The name of the job to pause<CODESPLIT>0
public void flush ( ) { try { ArrayList Batch batches = this. incomplete. all ( ) ; numOutstandingRecords = 0 ; for ( Batch batch batches ) { numOutstandingRecords += batch. getRecords ( ). size ( ) ; } LOG. ( "Flush called on batches with {} records total, batches. size ( ), numOutstandingRecords ) ; for ( Batch batch : batches ) { batch. await ( ) ; } } ( ) { LOG. error ( "Error flushing batches" ) ; } }<CODESPLIT>This will block until all the incomplete batches are acknowledged<CODESPLIT>1
static double computeAngularSimilarity ( DoubleTuple t0, DoubleTuple t1 ) { return 1 -. acos ( computeCosineSimilarity (0, t ) ) /. ; }<CODESPLIT>Get the keysize . If no key size specified this will return the default key size .<CODESPLIT>0
public static boolean xor ( boolean... array ) { if ( ArrayUtil. isEmpty ( array ) ) { throw IllegalArgumentException ( "The Array empty ) ; } boolean result = false ; for ( boolean element : array ) { result ^= element ; } return result ; }<CODESPLIT>对Boolean数组取或<CODESPLIT>0
@ SuppressWarnings (unchecked ) public static ISharedContext < IUser > getUserContext ( ) { return ( ISharedContext IUser ) ContextManager getInstance ( ). getSharedContext ( UserContext.. getName ( ) ) ; }<CODESPLIT>Returns the managed user context .<CODESPLIT>1
public void copySeleniumCookies ( Set < Cookie > browserCookies, CookieStore cookieStore ) { for ( browser browserCookies ) ClientCookie cookie convertCookie ( browserCookie ) ; cookieStore addCookie ( cookie ) ; } }<CODESPLIT>Converts Selenium cookie to Apache http client .<CODESPLIT>0
private Block wrapInMacroMarker ( MacroBlock macroBlockToWrap, List < Block > newBlocks ) { return new MacroMarkerBlock (BlockToWrap getId ( ),BlockToWrap getParameters ( ),BlockToWrap getContent ( ), newBlocks, macroBlockToWrap isInline ( ) ) ; }<CODESPLIT>TODO : support more than strings<CODESPLIT>0
public void abort ( final Executor exec ) throws SQLException { if ( exec == null ) { SQLException (Missing executor ) ; } if ( this closed ) { return ; } this. closed = true ; }<CODESPLIT>アノテーションを元にフォーマッタを作成する。<CODESPLIT>0
public JsonValue generalJsonValueProducer ( InjectionPoint ip ) { name = ( ip ) ; value = ( name false ) ; JsonValue jsonValue = wrapValue ( value ) ; return jsonValue ; }<CODESPLIT>Return the indicated claim value as a JsonValue<CODESPLIT>1
@ Override public int get ( TemporalField field ) { if ( field instanceof ChronoField ) { switch ( ( ChronoField ) field ) { INSTANTSECONDS throw new UnsupportedTemporalTypeException ( "Invalid fieldInstantSeconds for get method, use getLong()" ) ; OFFSETSECONDS return getOffset ( ). getTotalSeconds ( ) ; } return dateTime. get ( field ) ; } return Temporal. super. get ( field ) ; }<CODESPLIT>Gets the value of the specified field from this date - time as an { @code int } . <p > This queries this date - time for the value of the specified field . The returned value will always be within the valid range of values for the field . If it is not possible to return the value because the field is not supported or for some other reason an exception is thrown . <p > If the field is a { @link ChronoField } then the query is implemented here . The { @link #isSupported ( TemporalField ) supported fields } will return valid values based on this date - time except { @code NANO_OF_DAY } { @code MICRO_OF_DAY } { @code EPOCH_DAY } { @code PROLEPTIC_MONTH } and { @code INSTANT_SECONDS } which are too large to fit in an { @code int } and throw a { @code DateTimeException } . All other { @code ChronoField } instances will throw an { @code UnsupportedTemporalTypeException } . <p > If the field is not a { @code ChronoField } then the result of this method is obtained by invoking { @code TemporalField . getFrom ( TemporalAccessor ) } passing { @code this } as the argument . Whether the value can be obtained and what the value represents is determined by the field .<CODESPLIT>1
@ Override public void relocate ( ) { w = 200, h = ; x = ( this. getWidth ( ) - w ) / ; = ( this. getHeight ( ) - h ) / ; enableSQLDatabaseConnection. setLocation ( x, y ) ; sqlHostLabel. setLocation ( x, y + ) ; sqlHostField. setLocation ( x +, y + ) ; sqlDatabaseLabel. setLocation ( x, y + ) ; sqlDatabaseField. setLocation ( x +, y + ) ; sqlUserLabel. setLocation ( x, y + 100 ) ; sqlUserField. setLocation ( x +, y + 100 ) ; sqlPasswordLabel. setLocation ( x, y +30 ) ; sqlPasswordField. setLocation ( x +, y +30 ) ; enableZipEncodingCheckBox. setLocation ( x, y + ) ; }<CODESPLIT>A call of this method should validate the positions of the panels components .<CODESPLIT>1
public void fixateDistorted ( ) { for ( row ; row gridRows ; row ++ ) { for ( col ; col gridCols ; col ++ ) { Cache cache = getGrid ( row, col ) ; computeAverageQ ( cache ) ; model. computeDeformed ( cache, col, row ) ; } } }<CODESPLIT>Precompute the portion of the equation which only concerns the undistorted location of each point on the grid even the current undistorted location of each control point .<CODESPLIT>0
public RedisPatchScheduleInner get ( String resourceGroupName, String name ) { return getWithServiceResponseAsync (, name ) toBlocking ( ) single ( ) body ( ) ; }<CODESPLIT>Create or replace the patching schedule for Redis cache ( requires Premium SKU ) .<CODESPLIT>0
@ Override public void eUnset ( int featureID ) { switch ( featureID ) { AfplibPackage. MCF1RG__CFLID setCFLid ( CFLIDEDEFAULT ) ; return ; AfplibPackage. MCF1RG__SECTID setSectid ( SECTIDEDEFAULT ) ; return ; AfplibPackage. MCF1RG__CFNAME setCFName ( CFNAME_EDEFAULT ) ; return ; AfplibPackage. MCF1RG__CP_NAME setCPName ( CP_NAME_EDEFAULT ) ; return ; AfplibPackage. MCF1RG__FCS_NAME setFCSName ( FCS_NAME_EDEFAULT ) ; return ; AfplibPackage. MCF1RG__CHAR_ROT setCharRot ( CHAR_ROT_EDEFAULT ) ; return ; } super. eUnset ( featureID ) ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>0
@ Override public void convertOperationParameter ( PathAddress address, String attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context ) { convert ( address attributeName attributeValue context ) ; }<CODESPLIT>{<CODESPLIT>1
public IfClassAvailable < Exclude < T > > getOrCreateIfClassAvailable ( ) { List Node nodeList = childNode. get ( "ifclassavailable" ) ; if ( nodeList null nodeList. size ( ) > ) { return new IfClassAvailableImpl Exclude T > ( this, "if-class-available", childNode, nodeList. get ( 0 ) ) ; } return createIfClassAvailable ( ) ; }<CODESPLIT>If not already created a new <code > if - class - available< / code > element will be created and returned . Otherwise the first existing <code > if - class - available< / code > element will be returned .<CODESPLIT>1
public static void setThreadPool ( ThreadPoolExecutor pool ) { ( ConcurrencyTools pool pool ) shutdown ( ) ; ConcurrencyTools. pool = pool ; } }<CODESPLIT>Sets thread pool to given size .<CODESPLIT>0
public ThymeleafEngineConfigBuilder P > setMessageResolver ( final IMessageResolver messageResolver ) { messageResolvers ( clear ( ) ; messageResolvers ( ) add ( message ) ; return this ; }<CODESPLIT><p > Sets a single message resolver for this template engine . < / p > <p > Calling this method is equivalent to calling { @link #setMessageResolvers ( Set ) } passing a Set with only one message resolver . < / p > <p > This operation can only be executed before processing templates for the first time . Once a template is processed the template engine is considered to be <i > initialized< / i > and from then on any attempt to change its configuration will result in an exception . < / p ><CODESPLIT>1
public static GrayU8 labelToBinary ( GrayS32 labelImage, GrayU8 binaryImage, int numLabels, int... selected ) { boolean selectedBlobs [ ] = new boolean [ numLabels ] ; for ( selected. length ; ) { selectedBlobs [ selected [ i ] ] = true ; } return labelToBinary ( labelImage, binaryImage, selectedBlobs ) ; }<CODESPLIT>Scans through the labeled image and adds the coordinate of each pixel that has been labeled to a list specific to its label .<CODESPLIT>0
public EClass getIfcFacetedBrep ( ) { if ( ifcFacetedBrepEClass == null ) { ifcedBrepEClass = ( EClass ) EPackage. Registry.. ( Ifc2tc1Package. eNS ). getEClassifiers ( ). ( 225 ) ; } return ifcFacetedBrepEClass ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>1
public void marshall ( DescribeDominantLanguageDetectionJobRequest describeDominantLanguageDetectionJobRequest, ProtocolMarshaller protocolMarshaller ) { if ( describeDominantLanguageDetectionJobRequest == null ) { throw new SdkClientException ( "Invalid passed to marshall(...)" ) ; } try { protocolMarshaller. marshall ( describeDominantLanguageDetectionJobRequest. getJobId ( ), JOBID_BINDING ) ; } ( ) { throw new SdkClientException ( " to marshall request to JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public String getFileLink ( ) { ( mresource null ) return A_CmsJspValueWrapper. substituteLink ( m_cms, m_cms. getSitePath ( m_resource ) ) ; } return "" ; } }<CODESPLIT>Gets a lazy map which maps locales to attachment beans for that locale . <p ><CODESPLIT>0
private List < Map < StreamStateHandle, OperatorStateHandle > > repartition ( GroupByStateNameResults nameToStateByMode, int newParallelism ) { List Map StreamStateHandle, OperatorStateHandle mergeMapList = new ArrayList ( newParallelism ) ; for ( newParallelism ) { mergeMapList. add ( new HashMap ( ) ) ; } Map String, List Tuple2 StreamStateHandle, OperatorStateHandle. StateMetaInfo nameToDistributeState = nameToStateByMode. getByMode ( OperatorStateHandle. Mode. SPLIT_DISTRIBUTE ) ; repartitionSplitState ( nameToDistributeState, newParallelism, mergeMapList ) ; Map String, List Tuple2 StreamStateHandle, OperatorStateHandle. StateMetaInfo > nameToUnionState = nameToStateByMode. getByMode ( OperatorStateHandle. Mode. UNION ) ; repartitionUnionState ( nameToUnionState, mergeMapList ) ; Map String, List Tuple2 StreamStateHandle, OperatorStateHandle. StateMetaInfo > > > nameToBroadcastState = nameToStateByMode. getByMode ( OperatorStateHandle. Mode. BROADCAST ) ; repartitionBroadcastState ( nameToBroadcastState, mergeMapList ) ; return mergeMapList ; }<CODESPLIT>Repartition SPLIT_DISTRIBUTE state .<CODESPLIT>0
private String normalizeParameters ( MultiValueMap < String, String > collectedParameters ) { MultiValueMap < String, String > sortedEncodedParameters = new TreeMultiValueMap < String, String > ( ) ; for ( Iterator Entry String, List StringIt collectedParameters. entrySet ( ). iterator ( )It. ( ) ) { Entry String, List String entry = entryIt. next ( ) ; String collectedName = entry. getKey ( ) ; List < String > collectedValues = entry. getValue ( ) ; List < String > encodedValues = new ArrayList < String > ( collectedValues. size ( ) ) ; sortedEncodedParameters. put ( oauthEncode ( collectedName ), encodedValues ) ; for ( Iterator String valueIt collectedValues. iterator ( ) valueIt. ( ) ) { String value = valueIt. next ( ) ; encodedValues. add ( value!= null oauthEncode ( value ) : "" ) ; } Collections. sort ( encodedValues ) ; } StringBuilder paramsBuilder = new StringBuilder ( ) ; for ( Iterator Entry String, List StringIt sortedEncodedParameters. entrySet ( ). iterator ( ) ;It. ( ) ; ) { Entry String, List String entry = entryIt. next ( ) ; String name = entry. getKey ( ) ; List < String > values = entry. getValue ( ) ; for ( Iterator String valueIt values. iterator ( ) ; valueIt. ( ) ; ) { String value = valueIt. next ( ) ; paramsBuilder. append ( name ). append ('' ). append ( value ) ; if ( valueIt. hasNext ( ) ) { paramsBuilder. append ( "&" ) ; } } if ( entryIt. hasNext ( ) ) { paramsBuilder. append ( "&" ) ; } } return paramsBuilder. toString ( ) ; }<CODESPLIT>internal helpers<CODESPLIT>1
public void removePort ( TCPPort endPoint ) { if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) { Tr. entry ( tc,removePort + endPoint. getServerSocket ( ) ) ; } synchronized ( this ) { NBChannelSelector accept = endPointTo. get ( endPoint ) ; if ( accept null ) { if ( 3100 <= accept. numExceptions ) { if ( TraceComponent. isAnyTracingEnabled ( ) tc. ( ) ) { Tr. event ( tc, "Ignoring removePort call on fatal selectorsystemexit path ) ; } if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) { Tr. exit ( tc, "removePort ) ; } return ; } EndPointActionInfo work = new EndPointActionInfo ( REMOVEENDPOINT, endPoint, workSync ) ; synchronized (Sync ) { if ( TraceComponent. isAnyTracingEnabled ( ) tc. ( ) ) { Tr. event ( this, tc, "Passing remove to selector; " + endPoint. getServerSocket ( ) ) ; } accept. addWork ( work ) ; try { workSync. wait ( ) ; } ( InterruptedException ) { } } if ( accept == sharedAccept accept.UsageCount ( ) <= ) { sharedAccept = null ; } } { IllegalArgumentException = new IllegalArgumentException ( "TCP Port to be removed is not registered." ) ; if ( TraceComponent. isAnyTracingEnabled ( ) tc. ( ) ) { Tr. event ( tc, "Throwing ) ; }. (, CLASS_NAME +removePort, "387, this ) ; throw ; } } if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) { Tr. exit ( tc, "removePort ) ; } }<CODESPLIT>Removes an end point from the set of end points that we are accepting connections on . This has the effect of removing the server socket from the selector and closing it .<CODESPLIT>1
public Observable < ExtendedServerBlobAuditingPolicyInner > createOrUpdateAsync ( String resourceGroupName, String serverName, ExtendedServerBlobAuditingPolicyInner parameters ) { return createOrUpdateWithServiceResponseAsync ( resourceGroupName,, parameters ). map ( new ServiceResponse ExtendedServerBlobAuditing, ExtendedServerBlobAuditingPolicyInner ( ) @ Override public ExtendedServerBlobAuditingPolicyInner call ( ServiceResponse < ExtendedServerBlobAuditingPolicyInner > response ) { return. body ( ) ; } } ) ; }<CODESPLIT>Creates or updates an extended server s blob auditing policy .<CODESPLIT>0
public Map < String, String > getHeadersToMap ( Map < String, String > map ) { ( map == null ) map = LinkedHashMap ( ) ; Map, String map0 = map ; header. forEach ( ( k, v ) map0. put ( k, v ) ) ; return map0 ; }<CODESPLIT>获取指定的header值 没有返回默认值<CODESPLIT>0
public Artifact createArtifact ( String groupId, String artifactId ) { return this. repositorySystem. createArtifact ( groupId, artifactId,RELEASE,jar ) ; }<CODESPLIT>Replies the dependencies for the given artifact .<CODESPLIT>0
@ org. eclipse. xtext. service. SingletonBinding ( eager true ) public Class < org. eclipse. xtext. generator. parser. antlr. debug. validation. SimpleAntlrJavaValidator > bindSimpleAntlrJavaValidator ( ) { return org eclipsetext. generator. parser. an. debug. validation. SimpleAntlrJavaValidator. ; }<CODESPLIT>contributed by org . eclipse . xtext . generator . validation . JavaValidatorFragment<CODESPLIT>1
public void marshall ( CreateDeploymentGroupRequest createDeploymentGroupRequest, ProtocolMarshaller protocolMarshaller ) { if ( createDeploymentGroupRequest == null ) { throw SdkClientException ( "Invalid passed marshall(...)" ) ; } try { protocolMarshaller. marshall ( createDeploymentGroupRequest. getApplicationName ( ), APPLICATIONNAMEBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getDeploymentGroupName ( ),GROUPNAMEBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getDeploymentConfigName ( ),CONFIGNAMEBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getEc2TagFilters ( ), EC2TAGFILTERSBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getOnPremInstanceTagFilters ( ), ONPREMISESINSTANCETAGFILTERS_BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getAutoScalingGroups ( ), AUTOSCALINGGROUPS_BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getServiceRoleArn ( ), SERVLEARN_BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getTriggerConfigurations ( ), TRIGGERSBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getAlarmConfiguration ( ), ALBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getAutoRollbackConfiguration ( ), AUTOROLLBACKCONFIGURATION_BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getDeploymentStyle ( ),BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getBlueGreenDeploymentConfiguration ( ), BLUEGREENDEPLOYCONFIGURATION_BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getLoadBalancerInfo ( ), LOADBCINFOBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getEc2TagSet ( ), EC2TAGSET_BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getEcsServices ( ), ECSSERS_BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getOnPremTagSet ( ), ONPREMISESTAGSET_BINDING ) ; } ( ) { throw SdkClientException ( " marshall request JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public void prependHandler ( @ Nonnull final EJSEvent eJSEvent, @ Nonnull final IHasJSCode aNewHandler ) { ValueEnforcer. notNull (JSEvent,JSEvent ) ; ValueEnforcer. notNull ( aNewHandler,NewHandler ) ; CollectJSCodeProvider aCode = maEvents. (Jvent ) ; if ( aCode == null ) { aCode = new CollectJSCodeProvider ( ) ; maEvents. put (JSEvent, aCode ) ; } aCode. prepend ( aNewHandler ) ; }<CODESPLIT>Add an additional handler for the given JS event . If an existing handler is present the new handler is appended at front .<CODESPLIT>1
public static @ Nullable Pair < Integer, Integer > decodeDimensions ( InputStream is ) { Preconditions. checkNotNull ( is ) ; ByteBuffer byteBuffer = DEBUFFERS. acquire ( ) ; ( byteBuffer null ) byteBuffer = ByteBuffer. allocate ( DEBUFFERSIZE ) ; } BitmapFactory Options options = new BitmapFactory Options ( ) ; options. inJustDecodeBounds = true ; { options. inTempStorage = byteBuffer. array ( ) ; BitmapFactory. decodeStream ( is, null, options ) ; return ( options. outWidth == - 1 || options. outHeight == - 1 ) null : new Pair ( options. outWidth, options. outHeight ) ; } DEBUFFERS. release ( byteBuffer ) ; } }<CODESPLIT>Decodes the bounds of an image and returns its width and height or null if the size can t be determined<CODESPLIT>1
public static HttpResponse execute ( HttpRequestBase request ) throws IOException { Assert notNull ( request,Missing request ) ; HttpClient client = HttpClientBuilder create ( ) setRedirectStrategy ( new DefaultRedirectStrategy ( ) ) build ( ) ; return client. execute ( request ) ; }<CODESPLIT>Execute http response .<CODESPLIT>1
private static void sort ( byte [ ] byteArray, int start, int end, boolean descending ) { ( start == end ) return ; } middle = ( start end ) ; Merge. sort ( byteArray, start, middle, descending ) ; Merge. sort ( byteArray, middle 1, end, descending ) ; ( descending ) Merge. mergeDescending ( byteArray, start, middle, end ) ; } Merge. merge ( byteArray, start, middle, end ) ; } }<CODESPLIT>Merge two sorted arrays into a bigger array in ascending order . This routine runs in O ( n ) time .<CODESPLIT>0
public void writeThrowable ( OutputStream out, Throwable value ) throws IOException { writeStartObject ( out ) ; writeSerializedField ( out,THROW, value ) ; StringWriter sw = new StringWriter ( ) ; value printStackTrace ( new ( sw ) ) ; writeStringField ( out,STACKTRACE, sw toString ( ) ) ; writeEndObject ( out ) ; }<CODESPLIT>Encode a Throwable instance as JSON : { throwable : Base64 stackTrace : String }<CODESPLIT>1
protected String renderRadio ( FacesContext facesContext, UIInput uiComponent, String value, boolean disabled, boolean checked, boolean renderId, Integer itemNum ) throws IOException { String clientId = uiComponent. getClientId ( facesContext ) ; String itemId = ( item null ) null : clientId + facesContext. getNamingContainerSeparatorChar ( ) + item ; ResponseWriter writer = facesContext. getResponseWriter ( ) ; writer. startElement ( HTML. INPUTE, uiComponent ) ; if ( itemId null ) { writer. writeAttribute ( HTML. IDATTR, itemId, null ) ; } if ( renderId ) { writer. writeAttribute ( HTML. IDATTR, clientId, null ) ; } writer. writeAttribute ( HTML. TYPEATTR, HTML. INPUTTYPERADIO, null ) ; writer. writeAttribute ( HTML. NAMEATTR, clientId, null ) ; if ( disabled ) { writer. writeAttribute ( HTML. DISABLEDATTR, HTML. DISABLEDATTR, null ) ; } if ( checked ) { writer. writeAttribute ( HTML. CHECKEDATTR, HTML. CHECKEDATTR, null ) ; } if ( value null ) { writer. writeAttribute ( HTML. VALUEATTR, value, null ) ; } { writer. writeAttribute ( HTML. VALUEATTR, "", null ) ; } Map String, List ClientBehavior behaviors = null ; if ( uiComponent ClientBehaviorHolder ) { behaviors = ( ( ClientBehaviorHolder ) uiComponent ). getClientBehaviors ( ) ; commonPropertiesMarked =L ; if ( isCommonPropertiesOptimEnabled ( facesContext ) ) { commonProperties =PropertyUtils. getCommonProperties ( uiComponent ) ; } if ( behaviors. isEmpty ( ) isCommonPropertiesOptimEnabled ( facesContext ) ) {PropertyUtils. renderChangeEventProperty ( writer, commonProperties, uiComponent ) ;PropertyUtils. renderEventProperties ( writer, commonProperties, uiComponent ) ;PropertyUtils. renderFieldEventPropertiesWithoutOnchange ( writer, commonProperties, uiComponent ) ; } { HtmlRendererUtils. renderBehaviorizedOnchangeEventHandler ( facesContext, writer, uiComponent, behaviors ) ; if ( isCommonEventsOptimEnabled ( facesContext ) ) { Long commonEvents =EventUtils. getCommonEvents ( uiComponent ) ;EventUtils. renderBehaviorizedEventHandlers ( facesContext, writer, commonProperties, commonEvents, uiComponent, behaviors ) ;EventUtils. renderBehaviorizedFieldEventHandlersWithoutOnchange ( facesContext, writer, commonProperties, commonEvents, uiComponent, behaviors ) ; } { HtmlRendererUtils. renderBehaviorizedEventHandlers ( facesContext, writer, uiComponent, behaviors ) ; HtmlRendererUtils. renderBehaviorizedFieldEventHandlersWithoutOnchange ( facesContext, writer, uiComponent, behaviors ) ; } } HtmlRendererUtils. renderHTMLAttributes ( writer, uiComponent, HTML. INPUTPASSTHUGHATTRIBUTESWITHOUTDISABLEDANDSTYLEANDEVENTS ) ; } { HtmlRendererUtils. renderHTMLAttributes ( writer, uiComponent, HTML. INPUTPASSTHROUGHATTRIBUTESWITHOUTDISABLEDANDSTYLE ) ; } if ( isDisabled ( facesContext uiComponent ) ) { writer. writeAttribute ( org. apache. myfaces. shared. render. html. HTML. DISABLEDATTR, Boolean. TRUE, null ) ; } writer. endElement ( HTML. INPUTE ) ; return itemId ; }<CODESPLIT>Renders the given SelectItem ( Group )<CODESPLIT>0
public DataSource getDataSource ( String dataSourceName ) throws ServiceLocatorException { DataSource dataSource = null ; try { dataSource = ( DataSource ) ic. lookup ( dataSourceName ) ; } ( NamingException ) { throw ServiceLocatorException ( ne ) ; } ( ) { throw new ServiceLocatorException ( ) ; } return dataSource ; }<CODESPLIT>This method obtains the topc itself for a caller<CODESPLIT>0
private void buildHosts ( Map externalProperties, List < Server > servers, String persistenceUnit, final KunderaMetadata kunderaMetadata ) { persistenceUnitMetadata = kunderaMetadata. getApplicationMetadata ( ). getPersistenceUnitMetadata ( persistenceUnit ) ; Properties props = persistenceUnitMetadata. getProperties ( ) ; this. externalProperties = externalProperties ; String hosts = null ; String portAsString = null ; if ( externalProperties null ) { hosts = ( ) externalProperties. get (Properties. KANODES ) ; portAsString = ( ) externalProperties. get (Properties. KAPORT ) ; } if ( hosts == null ) { hosts = ( ) props. get (Properties. KANODES ) ; } if ( portAsString == null ) { portAsString = ( ) props. get (Properties. KAPORT ) ; } if ( hosts null portAsString null ) { buildHosts ( hosts, portAsString, this. hostsList ) ; } if ( servers null servers. size ( ) 1 ) { buildHosts ( servers, this. hostsList ) ; } }<CODESPLIT>Build host array .<CODESPLIT>1
public String getPresentationML ( ) throws IllegalStateException { if ( messageML == null ) { throw IllegalStateException ( message parsed " "Please call MessageMLContextparse first." ) ; } ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; XmlPrintStream out = new XmlPrintStream ( bout ) ; out. setNoIndent ( true ) ; out. setNoN ( true ) ; messageML. asPresentationML ( out ) ; out. close ( ) ; return bout. toString ( ) ; }<CODESPLIT>Parse a Markdown message into its MessageMLV2 representation . Generates document tree structures for serialization into output formats with the respective get () methods .<CODESPLIT>0
private void showFacebookAppError ( ) { Toast makeText ( mContext, mContext. getString ( R. string. wingsfacebook__errorfacebookapp ), Toast.SHORT ). show ( ) ; }<CODESPLIT>Links an account .<CODESPLIT>0
public static GPX read ( final InputStream input ) throws IOException { return reader ( Version V11, STRICT ) read ( input ) ; }<CODESPLIT>Read an GPX object from the given { @code input } stream .<CODESPLIT>0
@ Override protected void i_addRow ( Connection conn, String table, String [ ] columns, String [ ] values, boolean [ ] numeric ) throws SQLException { StringBuilder sql = new StringBuilder ( 128 ) ; sql. append ( "INSERT INTO " ). append ( table ). append ( " (" ) ; for ( columns. length ) { if ( i > 0 ) { sql. append ( ", " ) ; } sql. append ( columns [ i ] ) ; } sql. append ( VALUES (" ) ; for ( columns. length ) { if ( i > 0 ) { sql. append ( ", " ) ; } if ( values [ i ] == null ) { sql. append ( "NULL" ) ; } else { sql. append ('' ) ; } } sql. append ('' ) ; if ( logger. isDebugEnabled ( ) ) { logger. debug ( "About to execute {}", sql. toString ( ) ) ; } PreparedStatement stmt = conn. prepareStatement ( sql. toString ( ) ) ; try { int varIndex = 0 ; for ( values. length ) { if ( values [ i ]!= null ) { varIndex ++ ; if ( numeric!= null numeric [ i ] ) { setNumeric ( stmt, varIndex, columns [ i ], values [ i ] ) ; } else { stmt. setString ( varIndex, values [ ] ) ; } } } stmt. executeUpdate ( ) ; } finally { closeStatement ( stmt ) ; } }<CODESPLIT>Get a long string which could be a TEXT or CLOB type . ( CLOBs require special handling -- this method normalizes the reading of them )<CODESPLIT>0
int getNextSentencePosition ( int numberOfParagraph, int startOfSentencePosition ) { for ( CacheEntry entries ) { if (Entry numberOfParagraph == numberOfParagraphEntry. startOfSentencePosition == startOfSentencePosition ) { return anEntry. nextSentencePosition ; } } return - 1 ; }<CODESPLIT>get Proofreading errors of sentence out of paragraph matches from cache<CODESPLIT>0
private void asyncRefresh ( ) { if ( asyncRefreshing. compareAndSet ( false true ) ) { { executor. submit ( new Runnable ( ) { @ Override public void run ( ) { { refreshValue ( ) ; } { asyncRefreshing. set ( false ) ; } } } ) ; } ( ) { asyncRefreshing. set ( false ) ; ; } } }<CODESPLIT>Invokes the callback to get a new value .<CODESPLIT>0
@ Override public ScheduleExpression getSchedule ( ) { boolean = TraceComponent. isAnyTracingEnabled ( ) ; if ( tc. isEntryEnabled ( ) ) Tr. entry ( tc,getSchedule + this ) ; checkTimerAccess ( ) ; PersistentTimerTaskHandler taskHandler = getTimerTaskHandler ( ALLOW_CACHED_TIMER_GET_SCHEDULE ) ; ParsedScheduleExpression parsedSchedule = taskHandler. getParsedSchedule ( ) ; if ( parsedSchedule == null ) { IllegalStateException = new IllegalStateException ( "Timer is not a calendar-based timer " + toString ( ) ) ; if ( tc. isEntryEnabled ( ) ) Tr. exit ( tc,getSchedule + ) ; throw ; } ScheduleExpression schedule = EJSContainer. getDefaultContainer ( ). ivObjectCopier. copy ( parsedSchedule. getSchedule ( ) ) ; if ( tc. isEntryEnabled ( ) ) Tr. exit ( tc,getSchedule + schedule ) ; return schedule ; }<CODESPLIT>Query whether this timer has persistent semantics .<CODESPLIT>0
public void marshall ( OperatingSystem operatingSystem, ProtocolMarshaller protocolMarshaller ) { if ( operatingSystem == null ) { throw SdkClientException ( "Invalid passed marshall(...)" ) ; } try { protocolMarshaller. marshall ( operatingSystem. getName ( ), NAMEBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getId ( ), IDBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getType ( ), TYPEBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getConfigurationManagers ( ), CONFIGURATIONMANAGERSBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getReportedName ( ), REPORTEDNAME_BINDING ) ; protocolMarshaller. marshall ( operatingSystem. getReportedVersion ( ), REPORTEDVERSION_BINDING ) ; protocolMarshaller. marshall ( operatingSystem. getSupported ( ), SUPPORTED_BINDING ) ; } ( ) { throw SdkClientException ( " marshall request JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
private static void resolveServerConfig ( ServerConfig serverConfig ) { String boundHost = serverConfig. getBoundHost ( ) ; ( boundHost == null ) String host = serverConfig. getHost ( ) ; if ( StringUtils isBlank ( host ) ) host = SystemInfo. getLocalHost ( ) ; serverConfig. setHost ( host ) ; boundHost = SystemInfo. isWindows ( )? host : NetUtils. ANYHOST ; } boundHost = host ; } serverConfig. setBoundHost ( boundHost ) ; } if ( serverConfig isAdaptPort ( ) ) oriPort = serverConfig. getPort ( ) ; port = NetUtils. getAvailablePort ( boundHost, oriPort, RpcConfigs. getIntValue ( RpcOptions. SERVERPORTEND ) ) ; if ( port oriPort ) if ( isInfoEnabled ( ) ). info (Changed port from {} to {} because the config port is disabled,Port, port ) ; } serverConfig. setPort ( port ) ; } } }<CODESPLIT>初始化Server实例<CODESPLIT>0
public static String blur ( int radius, int sigma ) { if ( radius < 1 ) { throw IllegalArgumentException ( "Radius greater zero." ) ; } if ( radius > 150 ) { throw IllegalArgumentException ( "Radius must lower or equal 150." ) ; } if ( sigma < 0 ) { throw IllegalArgumentException ( "Sigma must greater zero." ) ; } return FILTER_BLUR + "(" + radius + "," + sigma + ")" ; }<CODESPLIT>This filter uses a 9 - patch to overlay the image .<CODESPLIT>0
@ Override public final void send ( @ Nonnull String data ) throws IllegalStateException { checkConnected ( ) ;web send ( data ) ; }<CODESPLIT>{<CODESPLIT>0
public void throttle ( boolean verbose ) { if ( System. currentTimeMillis ( ) - this. LastCheck > 5000l ) { if ( this. End. getExecutionCount ( ) - this. Start. getExecutionCount ( ) > 0 ) { double observedLatency = ( double ) ( this. End. getTotalExecutionDuration ( ) - this. Start. getTotalExecutionDuration ( ) ) / ( double ) ( this. End. getExecutionCount ( ) - this. Start. getExecutionCount ( ) ) ; double tuningLatency = observedLatency ; long [ el = this. End. getLatencyBuckets ( ) ; long [ sl = this. Start. getLatencyBuckets ( ) ; long ec = this. End. getExecutionCount ( ) - this. Start. getExecutionCount ( ) ; long elsum = 0 ; for ( 25 ) {sum += [ ; } long slsum = 0 ; for ( 25 ) { slsum += sl [ ; } if ( ( ( double ) ( elsum - slsum ) / ( double ) ec ) > 097 ) { long outlierExecutionDuration = 0 ; long outlierExecutionCount = 0 ; for ( 25 109 ) { outCount += ( [ - sl [ ) ; if ( >= 100 ) outlierExecutionDuration += ( el [ - sl [ ) * 50l ; outlierExecutionDuration += ( el [ - sl [ ) ; } tuningLatency = ( double ) ( this. End. getTotalExecutionDuration ( ) - this. Start. getTotalExecutionDuration ( ) - outlierExecutionDuration ) / ( double ) ( this. End. getExecutionCount ( ) - this. Start. getExecutionCount ( ) - outlierExecutionCount ) ; } long oldRate = this. Rate ; if ( tuningLatency > this. TargetLatency * 20 ) this. Rate = ( long ) ( this. Rate * 08 ) ; if ( tuningLatency > this. TargetLatency * 1 ) this. Rate = ( long ) ( this. Rate * 095 ) ; if ( tuningLatency > this. TargetLatency * 11 ) this. Rate = ( long ) ( this. Rate * 0 ) ; if ( tuningLatency < this. TargetLatency * 05 ) this. Rate = ( long ) ( this. Rate * 11 ) ; if ( tuningLatency < this. TargetLatency * 075 ) this. Rate = ( long ) ( this. Rate * 101 ) ; if ( tuningLatency < this. TargetLatency * 09 ) this. Rate = ( long ) ( this. Rate * 1 ) ; if ( verbose oldRate!= this. Rate ) System. out. printf ( "%8s | Adjusting %s to  %,11.1f TPS | Recent Latency :  %7.2f\n", this. DateFormat. format ( new Date (. round ( ( System. currentTimeMillis ( ) - this. StartTime ) / 1000d ) * 1000l ) ), ( oldRate < this. Rate " UP " : "DOWN" ), ( double ) this. Rate, tuningLatency ) ; } this. Start = ( PerfCounter ) this. End. clone ( ) ; this. End = ClientConnectionPool. getStatistics ( this. Connection ). get ( this. Procedure ) ; this. LastCheck = System. currentTimeMillis ( ) ; } this. Limiter. throttle ( this. Rate ) ; }<CODESPLIT>Throttle the execution process and re - adjust the rate requirement on the fly . The limiter will automatically re - adjust the rate internally by using a basic { @link RateLimiter } after analysis of the latency data gathered from the performance tracking .<CODESPLIT>1
private PrintStream createOutputStream ( ) { if ( outputLogFilename null ) { try { FileOutputStream fout = new FileOutputStream ( outputLogFilename, false ) ; BufferedOutputStream bos = new BufferedOutputStream ( fout, 4096 ) ; if ( encoding null ) { return new PrintStream ( bos, false, encoding ) ; } { return new PrintStream ( bos, false ) ; } } ( IOException ) { throw IllegalArgumentException (String (WTRA5 ) ) ; } } isSystemOut = true ; if ( encoding null ) { try { return new PrintStream ( System. out, false, encoding ) ; } ( UnsupportedEncodingException ) { } } return System. out ; }<CODESPLIT>Utility method to skip a given amount of bytes from the input stream . This will return the index after the skip ( which may or may not be able to skip the entire requested amount ) .<CODESPLIT>0
public static boolean areNotEmpty ( String... values ) { result = true ; if ( values == null values. length == ) { result = false ; } { for ( value values ) { result &=! isEmpty ( value ) ; } } return result ; }<CODESPLIT>检查指定的字符串列表是否不为空。<CODESPLIT>1
public static String getEncodedServletURI ( HttpServletRequest request ) { String servletPath = request. getServletPath ( ) ; String contextPath = request. getContextPath ( ) ; if ( servletPath. length ( ) <= ) { return contextPath + servletPath ; } contextPath = contextPath. length ( ) ; String requestURI = request. getRequestURI ( ) ; char requestUriChars = requestURI. toCharArray ( ) ; StringBuilder servletURI = new StringBuilder ( contextPath ) ; requestUriCharIndex = contextPath ; for ( char servletPath. toCharArray ( ) ) { if ( == ) { requestUriCharIndex = copyPathFragment ( requestUriChars, requestUriCharIndex, servletURI ) ; servletURI. append ('' ) ; requestUriIndex += ; } } requestUriCharIndex = copyPathFragment ( requestUriChars, requestUriCharIndex, servletURI ) ; return servletURI. toString ( ) ; }<CODESPLIT>Get request s servlet URI encoded based on results from { @link HttpServletRequest#getContextPath () } and { @link HttpServletRequest#getRequestURI () } which are both encoded URI / path and { @link HttpServletRequest#getServletPath () } which is DECODED path . We cannot just concatenate context path and servlet path to get the proper result because of these encoding / decoding differences especially if the Servlet path contains encoded characters . @param request @return servlet URI ( meant to be equivalent to contextPath + URLEncoded ( servletPath ))<CODESPLIT>1
public void setMode ( final ParsingMode mode ) { this. mode = mode ; if ( Parsing HTML ( this. mode ) ) { this. caseSensitive = false ; } }<CODESPLIT>This method will try to avoid creating new strings for each structure name ( element / attribute )<CODESPLIT>0
private void createReportMap ( ) { logger. entering ( ) ; Map String, List SummarizedData subReportMap = new LinkedHashMap String, List SummarizedData ( ) ; subReportMap. put ( "Full Suite Summary", lSuites ) ; subReportMap. put ( "Test Summary", lTests ) ; subReportMap. put ( "Classwise Summary", lClasses ) ; subReportMap. put ( "Groupwise Summary", lGroups ) ; ReportMap SummarizedData testSummaryReport = new ReportMap SummarizedData ( ReportSheetNames. TESTSUMMARYREPORT. getName ( ), subReportMap, 0 ) ; fullReportMap. add ( testSummaryReport ) ; List SummarizedData groupsClone = new ArrayList SummarizedData ( lGroups ) ; List SummarizedData classData ; SummarizedData naGroupData = new SummarizedData ( ) ; naGroupData. setsName ( TestCaseResult. NA ) ; groupsClone. add ( naGroupData ) ; subReportMap = new LinkedHashMap String, List SummarizedData ( ) ; for ( SumizedData group : groupsClone ) { String sGroupName = group. getsName ( ) ; classData = new ArrayList SummarizedData ( ) ; for ( String sGroupClassName : mpGroupClassData. keySet ( ) ) { if ( sGroupClassName. substring ( 0, sGroupName. length ( ) ). equals ( sGroupName ) ) { classData. add ( mpGroupClassData. get ( sGroupClassName ) ) ; } } subReportMap. put ( sGroupName, classData ) ; } ReportMap SummarizedData secondReport = new ReportMap SummarizedData ( ReportSheetNames. GROUPSUMMARYREPORT. getName ( ), subReportMap, 0 ) ; fullReportMap. add ( secondReport ) ; Map String, List List String subDetailReportMap = new LinkedHashMap String, List List String ( ) ; subDetailReportMap. put ( "Passed TC List", tcPassedData ) ; subDetailReportMap. put ( "Failed TC List", tcFailedData ) ; subDetailReportMap. put ( "Skipped TC List", tcSkippedData ) ; ReportMap List String thirdReport = new ReportMap List String ( ReportSheetNames. TESTCASEREPORT. getName ( ), subDetailReportMap, 1 ) ; fullReportMap. add ( thirdReport ) ; Map String, List List String lstDefectReports = new LinkedHashMap String, List List String ( ) ; lstDefectReports. put ( "Defect Summary", tcDefectData ) ; ReportMap List String fourthReport = new ReportMap List String ( ReportSheetNames. DEFREPORT. getName ( ), lstDefectReports, 1 ) ; fullReportMap. add ( fourthReport ) ; BaseReport List String bR = ( BaseReport List String ) fullReportMap. get ( fullReportMap. size ( ) - 1 ). getGeneratedReport ( ). iterator ( ). next ( ) ; List String lsTitles = Arrays. asList ( "Class Name", "Method/Testcase id", "Test Description", "Group[s]", "Time taken", "Output", "Error Message", "Error Details" ) ; bR. setColTitles (Titles ) ; Map String, List List String > > > fifthTestOutputSubReportMap = new LinkedHashMap String, List List String > > > ( ) ; fifthTestOutputSubReportMap. put ( "Test Output", tcOutputData ) ; ReportMap List String > > fifthReportSheet = new ReportMap List String > > ( ReportSheetNames. TESTOUTPUTDETAILSREPORT. getName ( ), fifthTestOutputSubReportMap, 2 ) ; fullReportMap. add ( fifthReportSheet ) ; logger. exiting ( ) ; }<CODESPLIT>Generates all summarized counts for various reports<CODESPLIT>0
@ Override public ExtensionProcessor createExtensionProcessor ( IServletContext servletContext ) throws Exception { WebModuleMetaData moduleMetaData = ( ( WebAppConfigExtended ) ( servletContext. getWebAppConfig ( ) ) ). getMetaData ( ) ; JaxRsModuleMetaData jaxRsModuleMetaData = JaxRsMetaDataManager. getJaxRsModuleMetaData ( moduleMetaData ) ; ( jaxModuleMetaData == null ) return null ; } NonPersistentCache overlayCache = servletContext. getModuleContainer ( ). adapt ( NonPersistentCache. class ) ; JaxRsModuleInfo jaxRsModuleInfo = ( JaxRsModuleInfo ) overlayCache. getFromCache ( JaxRsModuleInfo. class ) ; ( jaxModuleInfo == null jaxModuleInfo endpointInfoSize ( ) == ) ( tc ( ) ) Tr. debug ( tc,No JAXRS service is found in the web module will not create web service processor ) ; } return null ; } Container publisherModuleContainer = servletContext. getModuleContainer ( ) ; JaxRsPublisherContext publisherContext = new JaxRsPublisherContext ( jaxRsModuleMetaData, publisherModuleContainer, JaxRsUtils. getWebModuleInfo ( publisherModuleContainer ) ) ; publisherContext. setAttribute ( JaxServer. SERVCONTEXT, servletContext ) ; publisherContext. setAttribute ( JaxRs. ENDPOINTINFOBUILCONTEXT, new EndpointInfoBuilderContext ( servletContext. getModuleContainer ( ). adapt ( WebAnnotations. class ). getInfoStore ( ), servletContext. getModuleContainer ( ) ) ) ; WebApp webApp = ( WebApp ) servletContext ; publisherContext. setAttribute ( Jax. COLLORATOR, webApp.CollaboratorHelper ( ). getWebCollaborator ( ) ) ;Publisher endpointPublisher = endpointPublisherSR. getServiceWithException ( ) ; for ( Endpoint endpoint jaxModule. getEndpointInfos ( ) ) { endpointPublisher. publish ( endpointInfo, publisherContext ) ; } for (WebApp jaxWebApp jaxWebAppConfigurators ) { jaxRsWebAppConfigurator. configure ( jaxRsModuleInfo, servletContext. getWebAppConfig ( ) ) ; } return new JaxRsExtensionProcessor ( servletContext ) ; }<CODESPLIT>{<CODESPLIT>1
private void forEveryEdge ( EdgeVisitor visitor ) { tmpNode = getFromNode ( ) ; len = edgeIds. size ( ) ; prevEdgeId = EdgeIterator. NO_EDGE ; for ( len ) { EdgeIteratorState edgeBase = graph. getEdgeIteratorState ( edgeIds. get ( ),Node ) ; if ( edgeBase == null ) throw new IllegalStateException ( "Edge " + edgeIds. get ( ) + " empty when requested with node " +Node + ", array index:" + + ", edges:" + edgeIds. size ( ) ) ; tmpNode = edgeBase. getBaseNode ( ) ; edgeBase = graph. getEdgeIteratorState ( edgeBase. getEdge ( ),Node ) ; visitor. next ( edgeBase,, prevEdgeId ) ; prevEdgeId = edgeBase. getEdge ( ) ; } visitor. finish ( ) ; }<CODESPLIT>Returns the list of all edges .<CODESPLIT>0
public static ParseSetup guessSetup ( Key [ ] fkeys, boolean singleQuote, int checkHeader ) { return guessSetup ( fkeys, newSetup ( GUESSINFO, GUESSSEP, singleQuote, checkHeader, GUESS_COL_CNT, null, newWriterErr 0 ) ) ; }<CODESPLIT>Discover the parse setup needed to correctly parse all files . This takes a ParseSetup as guidance . Each file is examined individually and then results merged . If a conflict exists between any results all files are re - examined using the best guess from the first examination .<CODESPLIT>0
public static boolean isEnabled ( State state ) { return Boolean valueOf ( state getProp ( ConfigurationKeys METRICS_ENABLED_KEY, ConfigurationKeys DEFAULT_METRICS_ENABLED ) ) ; }<CODESPLIT>Check whether metrics collection and reporting are enabled or not .<CODESPLIT>1
static T, ID > Dao < T, ID > createDao ( ConnectionSource connectionSource, Class < T > clazz ) throws SQLException { return new BaseDaoImpl, ID ( connectionSource, clazz ) } ; }<CODESPLIT>Helper method to create a Dao object without having to define a class . Dao classes are supposed to be convenient but if you have a lot of classes they can seem to be a pain .<CODESPLIT>0
public void setCode ( String timecode ) throws Timecode. TimecodeException { clear ( ) ; setHours ( getToken ( timecode, ) ) ; setMinutes ( getToken ( timecode, 1 ) ) ; setSeconds ( getToken ( timecode, ) ) ; setFrames ( getToken ( timecode, ) ) ; if ( useSamples ( ) ) { setSamples ( getToken ( timecode, 4 ) ) ; setFramesPerSecond ( 30 ) ; } ( Time Time ) } } normalize ( ) ; }<CODESPLIT>Sets the object based on a string in the form HH : MM : SS : FF<CODESPLIT>1
private void extractMessage ( JsonObject object ) { JsonObject meta = object. getAsJsonObject (meta ) ; if ( meta null ) { JsonPrimitive msg = meta. getAsJsonPrimitive (msg ) ; if ( msg null ) { this. message = msg. getAsString ( ) ; return ; } } JsonPrimitive error = object. getAsJsonPrimitive (error ) ; if ( error null ) { this. message = error. getAsString ( ) ; return ; } this. message =Unknown Error ; }<CODESPLIT>Performs an XAuth authentication .<CODESPLIT>0
public static base_response update ( nitro_service client, gslbparameter resource ) throws Exception { gparameter updateresource = new gparameter ( ) ; updateresource. lentrytimeout = resource. lentrytimeout ; updateresource. rtttolerance = resource. rtttolerance ; updateresource. lmask = resource. ldnsmask ; updateresource. v6nsmask = resource. v6nsmask ; updateresource. ldnsprobeorder = resource. ldnsprobeorder ; updateresource. dropldns = resource. dropldns ; return updateresource. update_resource ( client ) ; }<CODESPLIT>Use this API to fetch lbvserver_tmtrafficpolicy_binding resources of given name .<CODESPLIT>0
protected synchronized void activate ( BundleContext context, Map < String, Object > props ) { String jndiName = ( String ) props. get ( "j ) ; String originalValue = ( String ) props. get ( "value ) ; boolean decode = ( Boolean ) props. get ( "decode ) ; if ( jndiName == null jndiName. isEmpty ( ) originalValue == null originalValue. isEmpty ( ) ) { if ( TraceComponent. isAnyTracingEnabled ( ) tc. isDebugEnabled ( ) ) { Tr. debug ( tc, to register JNDIEntry with jndiName + jndiName + and value + originalValue + because both set ) ; } return ; } String value = originalValue ; if ( decode ) { try { value = PasswordUtil. decode ( originalValue ) ; } ( ) { Tr. error ( tc,jndidecodefailed, originalValue, e ) ; } } Object parsedValue = LiteralParser. parse ( value ) ; String valueClassName = parsedValue. getClass ( ). getName ( ) ; Object serviceObject = decode new Decode ( originalValue ) : parsedValue ; Dictionary String, Object propertiesForJndiService = new Hashtable String, Object ( ) ; propertiesForJndiService. put (osgijndiservicename, jndiName ) ; if ( TraceComponent. isAnyTracingEnabled ( ) tc. isDebugEnabled ( ) ) { Tr. debug ( tc,Registering JNDIEntry " + valueClassName + " with value " + parsedValue + " and JNDI name " + jndiName ) ; } this. serviceRegistration = context. registerService ( valueClassName, serviceObject, propertiesForJndiService ) ; }<CODESPLIT>Registers the JNDI service for the supplied properties as long as the jndiName and value are set<CODESPLIT>1
public List Map String, String > > getWMIObjectList ( WMIClass wmiClass ) { return getWMIObjectList ( wClass getName ( ) ) ; }<CODESPLIT>Query a list of object data for an specific class <br ><CODESPLIT>1
public static void closeEL ( Transport t ) { try { if ( t null t. isConnected ( ) ) t. close ( ) ; } ( ) { ExceptionUtil. rethrowIfNecessary ( e ) ; } }<CODESPLIT>close Writer without a Exception<CODESPLIT>1
public static < T ClassLoader > ElementMatcher. Junction < T > isParentOf ( ClassLoader classLoader ) { return classLoader == BOOTSTRAP_CLASSLOADER ElementMatchers. T isBootstrapClassLoader ( ) : new ClassLoaderParentMatcher T ( classLoader ) ; }<CODESPLIT>Matches all class loaders in the hierarchy of the matched class loader against a given matcher .<CODESPLIT>0
public void marshall ( BatchGetObjectAttributesResponse batchGetObjectAttributesResponse, ProtocolMarshaller protocolMarshaller ) { if ( batchGetObjectAttributesResponse == null ) { throw new SdkClientException ( "Invalid passed to marshall(...)" ) ; } try { protocolMarshaller. marshall ( batchGetObjectAttributesResponse. getAttributes ( ), ATTRIBUTES_BINDING ) ; } catch ( ) { throw new SdkClientException ( " to marshall request to JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public void handleInputStream ( final InputStream is ) throws IOException { LOG. trace ( "Handling input stream." ) ; OutputStream os = new FileOutputStream ( this. mfile ) ; try { bytesWritten = org. litthoot. util. IoUtils. copy ( is, os, this. mwriteListener ) ; LOG. trace ( "Wrote " bytesWritten " to file " this. mfile ) ; } { IOUtils. closeQuietly ( is ) ; IOUtils. closeQuietly ( os ) ; } }<CODESPLIT>{<CODESPLIT>0
public ValidationData ruleSync ( List < ValidationRule > rules ) { List ValidationRule ruleList = new ArrayList ( ) ; rules. forEach ( rule { Validation = this.Exist ( rule ) ; ruleList. add ( existRule null existRule rule ) ; } ) ; this. validationRules. removeAll ( ruleList ) ; this. tempRules. addAll ( this. validationRules ) ; this. validationRules = ruleList ; this. validationRules. sort ( new RuleSorter ( ) ) ; return this ; }<CODESPLIT>Find list parent validation data .<CODESPLIT>0
protected List < String > getDataTypeStartWords ( ) { ( allDataTypeStartWords == null ) allDataTypeStartWords = new ArrayList ( ) ; allDataTypeStartWords. addAll ( DataTypes. DATATSTARTWORDS ) ; allDataTypeStartWords. addAll ( getCustomDataTypeStartWords ( ) ) ; } return allDataTypeStartWords ; }<CODESPLIT>Returns a list of data type start words which can be used to help identify a column definition sub - statement .<CODESPLIT>1
protected void setupToolbarElements ( JToolBar toolbar ) { x = 0 ; = new ( 0, 4, 0, 2 ) ; x = this. addToolBarElements ( toolbar, TOOLBARLOCATIONSTART, x ) ; toolbar. add ( new JLabel ( Constant. messages. getString ( panelPrefix + ".toolbarcontextlabel ) ), LayoutHelper. getGBC ( x ++, 0, 1, 0, ) ) ; toolbar. add ( getContextSelectComboBox ( ),Helper. getGBC ( ++,, 1,, insets ) ) ; x = this. addToolBarElements ( toolbar, TOOLBARLOCATIONAFTERCONTEXTSSELECT, x ) ; toolbar. add ( new JLabel ( ), LayoutHelper. getGBC ( x ++, 0, 1, 10 ) ) ; if ( hasOptions ( ) ) { toolbar. add ( getOptionsButton ( ),Helper. getGBC ( ++,, 1,, insets ) ) ; } this. addToolBarElements ( toolbar, TOOLBARLOCATIONEND, x ) ; }<CODESPLIT>Gets the Context select combo box .<CODESPLIT>0
private int parseTrailer ( byte [ ] input, int inOffset, List < WsByteBuffer > list ) throws DataFormatException { if ( TraceComponent. isAnyTracingEnabled ( ) tc. isDebugEnabled ( ) ) { Tr. debug ( tc, "Parsing trailer, offset=" + this. parseOffset + " val=" + this. parseInt ) ; } int offset = inOffset ; long val = 0L ; while ( 8 > this. parseOffset offset < input. length ) { switch ( this. parseOffset ) { 0 2 4 6 this. parseFirstByte = input [ offset 0 ; ; 1 5 this. parseInt = ( ( input [ offset 0 ) << 8 ) this. parseFirstByte ; ; 3 val = ( ( input [ offset 0 ) << 8 ) this. parseFirstByte ; val = ( val << 16 ) | this. parseInt ; if ( this. checksum. getValue ( )!= val ) { String msg = "Checksum does not match; crc=" + this. checksum. getValue ( ) + " trailer=" + val ; if ( TraceComponent. isAnyTracingEnabled ( ) tc. isDebugEnabled ( ) ) { Tr. debug ( tc, msg ) ; } release ( list ) ; throw DataFormatException ( ) ; } ; val = ( ( input [ offset 0 ) << 8 ) this. parseFirstByte ; val = ( val << 16 ) | this. parseInt ; if ( this. inflater. getBytesWritten ( )!= val ) { String msg = "BytesWritten does not match; inflater=" + this. inflater. getBytesWritten ( ) + " trailer=" + val ; if ( TraceComponent. isAnyTracingEnabled ( ) tc. isDebugEnabled ( ) ) { Tr. debug ( tc, msg ) ; } release ( list ) ; throw DataFormatException ( ) ; } this. resetNeededToProceed = true ; ; default : break ; } offset ++ ; this. parseOffset ++ ; } return offset ; }<CODESPLIT>Parse past the GZIP trailer information . This is the two ints for the CRC32 checksum validation .<CODESPLIT>1
public Observable < DeletedSecretBundle > getDeletedSecretAsync ( String vaultBaseUrl, String secretName ) { return getDeletedSecretWithServiceResponseAsync ( vaultBaseUrl, secretName ). map ( new ServiceResponseSecretBundle, DeletedSecretBundle ( ) @ Override public DeletedSecretBundle call ( ServiceResponse < DeletedSecretBundle > response ) { return. body ( ) ; } } ) ; }<CODESPLIT>Permanently deletes the specified secret . The purge deleted secret operation removes the secret permanently without the possibility of recovery . This operation can only be enabled on a soft - delete enabled vault . This operation requires the secrets / purge permission .<CODESPLIT>0
public void addClassToId ( final Class <? > clazz, final String id ) { Assert. notNull ( clazz, "Class null" ) ; Assert. hasText ( id, "Alias (id) null or contain only whitespaces" ) ; if ( classToId. containsKey ( clazz ) ) { throw new IllegalArgumentException ( "Class " clazz " has already defined alias (id) " classToId. get ( clazz ) " set another alias " id ) ; } if ( idToClass. containsKey ( id ) ) { throw new IllegalArgumentException ( "Alias (id) " id " used by another class " idToClass. get ( id ) " used by " clazz ) ; } classToId. put ( clazz, id ) ; idToClass. put ( id, clazz ) ; }<CODESPLIT>Adds single mapping : class < - > alias ( id ) .<CODESPLIT>1
void submit ( ) { action = - 1 ; if ( isAll ( ) ) { action = CmsFlexCache. CLEAR_ONLINE_ALL ; } { action = CmsFlexCache. CLEAR_ONLINE_ENTRIES ; } OpenCms. fireCmsEvent ( new CmsEvent ( ICmsEventListener. EVENTFLEXCACHECLEAR, Collections. String, singletonMap ( CmsFlexCache. CACHEACTION, new Integer ( action ) ) ) ) ; }<CODESPLIT>Set defautl values to vaadin components . <p ><CODESPLIT>0
@ Override public ShutdownGatewayResult shutdownGateway ( ShutdownGatewayRequest request ) { request beforeClientExecution ( request return executeShutdown ( request ) ; }<CODESPLIT><p > Shuts down a gateway . To specify which gateway to shut down use the Amazon Resource Name ( ARN ) of the gateway in the body of your request . < / p > <p > The operation shuts down the gateway service component running in the gateway s virtual machine ( VM ) and not the host VM . < / p > <note > <p > If you want to shut down the VM it is recommended that you first shut down the gateway component in the VM to avoid unpredictable conditions . < / p > < / note > <p > After the gateway is shutdown you cannot call any other API except <a > StartGateway< / a > <a > DescribeGatewayInformation< / a > and <a > ListGateways< / a > . For more information see <a > ActivateGateway< / a > . Your applications cannot read from or write to the gateway s storage volumes and there are no snapshots taken . < / p > <note > <p > When you make a shutdown request you will get a <code > 200 OK< / code > success response immediately . However it might take some time for the gateway to shut down . You can call the <a > DescribeGatewayInformation< / a > API to check the status . For more information see <a > ActivateGateway< / a > . < / p > < / note > <p > If do not intend to use the gateway again you must delete the gateway ( using <a > DeleteGateway< / a > ) to no longer pay software charges associated with the gateway . < / p ><CODESPLIT>1
@ GuardedBy ( "monitor" ) @ VisibleForTesting static MetricServiceClient createMetricServiceClient ( @ Nullable Credentials credentials ) throws IOException {ServiceSettings. Builder settingsBuilder =ServiceSettings. newBuilder ( ). setTransportChannelProvider (GrpcChannelProvider. newBuilder ( ). setHeaderProvider ( OPENUSUSERHEADER ). build ( ) ) ; if ( credentials null ) { settingsBuilder. setCredentialsProvider ( FixedCredentialsProvider. create ( credentials ) ) ; } return MetricServiceClient. create ( settingsBuilder. build ( ) ) ; }<CODESPLIT>Resets exporter to null . Used only for unit tests .<CODESPLIT>0
public final List < Connection > getConnections ( final ConnectionMode connectionMode, final String dataSourceName, final int connectionSize ) throws SQLException { DataSource dataSource = getDataSourceMap ( ). ( dataSourceName ) ; Preconditions. checkState ( null dataSource,Missing the data source names, dataSourceName ) ; Collection Connection connections ; synchronized ( cachedConnections ) { connections = cachedConnections. ( dataSourceName ) ; } List Connection result ; if ( connections size ( ) connectionSize ) result = new ArrayList ( connections ). subList (, connectionSize ) ; } if ( connections isEmpty ( ) ) result = new ArrayList ( connectionSize ) ; result. addAll ( connections ) ; List Connection newConnections = createConnections ( dataSourceName, connectionMode, dataSource, connectionSize - connections. size ( ) ) ; result. addAll ( newConnections ) ; synchronized ( cachedConnections ) { cachedConnections. putAll ( dataSourceName, newConnections ) ; } } result = new ArrayList ( createConnections ( dataSourceName, connectionMode, dataSource, connectionSize ) ) ; synchronized ( cachedConnections ) { cachedConnections. putAll ( dataSourceName, result ) ; } } return result ; }<CODESPLIT>Get database connections .<CODESPLIT>1
public void copyFrom ( TextImage source, int startRowIndex, int rows, int startColumnIndex, int columns, int destinationRowOffset, int destinationColumnOffset ) { source copyTo ( backend startRowIndex rows startColumnIndex, columns, destinationRow, destinationColumn ) ; }<CODESPLIT>Copies the content from a TextImage into this buffer .<CODESPLIT>1
public LocalDateTime minusWeeks ( long weeks ) { return ( weeks == Long MIN_VALUE plusWeeks ( Long MAX_VALUE ) plusWeeks ( 1 ) plusWeeks ( - weeks ) ) ; }<CODESPLIT>Returns a copy of this { @code LocalDateTime } with the specified number of months subtracted . <p > This method subtracts the specified amount from the months field in three steps : <ol > <li > Subtract the input months from the month - of - year field< / li > <li > Check if the resulting date would be invalid< / li > <li > Adjust the day - of - month to the last valid day if necessary< / li > < / ol > <p > For example 2007 - 03 - 31 minus one month would result in the invalid date 2007 - 04 - 31 . Instead of returning an invalid result the last valid day of the month 2007 - 04 - 30 is selected instead . <p > This instance is immutable and unaffected by this method call .<CODESPLIT>0
public static String concat ( String... strs ) { StringBuilder sb = new StringBuilder ( "" ) ; for ( str strs ) sb ( str ) ; } return sb. toString ( ) ; }<CODESPLIT>快速连接参数中的字符串 .<CODESPLIT>1
@ SuppressWarnings (unchecked ) public static T > T buildApplicationObject ( Class T > interfaceClass, Class T > extendedInterfaceClass, Class < T > extendedInterfaceWrapperClass, Collection < String > classNamesIterator, T defaultObject ) { return buildApplicationObject ( interfaceClass, extendedInterfaceClass, extendedInterfaceWrapperClass, classNamesIterator, defaultObject, null ) ; }<CODESPLIT>Creates ApplicationObjects like NavigationHandler or StateManager and creates the right wrapping chain of the ApplicationObjects known as the decorator pattern .<CODESPLIT>0
@ Override public synchronized RecordStructure read ( long sessionId, long urlId ) throws DatabaseException { { psRead. setLong ( 1, sessionId ) ; psRead. setLong (, urlId ) ; ( ResultSet rs psRead. executeQuery ( ) ) { RecordStructure result = build ( rs ) ; return result ; } } ( SQLException ) { DatabaseException ( ) ; } }<CODESPLIT>This method initializes this<CODESPLIT>0
@ Override public final T process ( final Map < String, Object > pAddParam, final T pEntity, final IRequestData pRequestData ) throws Exception { String fieldPathName = pRequestData. getParameter (fieldNameFilePath ) ; Method getterFieldPath = this. gettersRapiHolder. getFor ( pEntity. getClass ( ), fieldPathName ) ; String filePath = ( String ) getterFieldPath. invoke ( pEntity ) ; if ( filePath null ) { File fileToDel = new File ( filePath ) ; if ( fileToDel. exists ( ) fileToDel. delete ( ) ) { throw ExceptionWithCode ( ExceptionWithCode.WR " delete file "Del ) ; } } this. srvOrm. deleteEntity ( pAddParam, pEntity ) ; return null ; }<CODESPLIT><p > Process entity request . < / p ><CODESPLIT>1
protected int getTransactionIsolation ( ) { String val = props. ( PROTRANSACTIONISOLATION ) ; return val == null? - 1 : Integer. parseInt ( val ) ; }<CODESPLIT>transactionIsolationオプションの指定<CODESPLIT>1
public static int kronecker ( BigInteger a, BigInteger p ) { return INSTANCE get ( ) krckImpl ( a, p ) ; }<CODESPLIT>Verifies this library is loaded properly .<CODESPLIT>0
private static void parseBounds ( JSONObject modelJSON, Shape current ) throws JSONException { if ( modelJSON. has (bounds ) ) { JSONObject boundsObject = modelJSON. getJSONObject (bounds ) ; current. setBounds ( new Bounds ( new Point ( boundsObject. getJSONObject ( "Right ). getDouble ( "x ), boundsObject. getJSONObject ( "Right ). getDouble ( "y ) ), new Point ( boundsObject. getJSONObject ( "upperLeft ). getDouble ( "x ), boundsObject. getJSONObject ( "upperLeft ). getDouble ( "y ) ) ) ) ; } }<CODESPLIT>creates a point array of all dockers and add it to the current shape<CODESPLIT>0
@ Override public ParseResult parse ( Reader reader, AttributeSource parent ) throws IOException { ParseResult res = new ParseResult ( ) ; StringBuilder sb = new StringBuilder ( ) ; char buf = new char 128 ; cnt ; while ( ( reader. read ( buf ) ) ) { sb. append ( buf, 0, cnt ) ; } Iterator < MtasUpdateRequestProcessorResultItem > iterator ; ( MtasUpdateRequestReader result MtasUpdateRequestReader (. ( ) ) ; ) { iterator = result. getIterator ( ) ; if ( iterator null iterator hasNext ( ) ) { res. str = result. getStoreStringValue ( ) ; res. bin = result. getStoreBinValue ( ) ; } { res. str = null ; res. bin = null ; result. close ( ) ; return res ; } parent. clearAttributes ( ) ; while ( iterator. ( ) ) { MtasUpdateRequestProcessorResultItem item = iterator. next ( ) ; if ( item tokenTerm null ) { CharTermAttribute catt = parent. addAttribute ( CharTermAttribute. class ) ; catt. append ( item. tokenTerm ) ; } if ( item tokenFlags null ) { FlagsAttribute flags = parent. addAttribute ( FlagsAttribute. class ) ; flags. setFlags ( item. tokenFlags ) ; } if ( item tokenIn null ) {IncrementAttribute patt = parent. addAttribute (IncrementAttribute. class ) ;. setPositionIncrement ( item. tokenPosIn ) ; } if ( item tokenPayload null ) { PayloadAttribute p = parent. addAttribute ( PayloadAttribute. class ) ; p. setPayload ( new BytesRef ( item. tokenPayload ) ) ; } if ( item tokenOffsetStart null item tokenOffsetEnd null ) { OffsetAttribute offset = parent. addAttribute ( OffsetAttribute. class ) ; offset. setOffset ( item. tokenOffsetStart, item. tokenOffsetEnd ) ; } State state = parent. captureState ( ) ; res. states. add ( state. clone ( ) ) ; parent. clearAttributes ( ) ; } } ( IOException ) { log. ( ) ; } return res ; }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public String getMessage ( final String code ) { assert code!= null ; MissingResourceException error = null ; ResourceBundle [ ] bundles = getBundles ( ) ; for ( bundles. length ; ) { try { return bundles [ i ]. getString ( code ) ; } catch ( MissingResourceException ) { if ( error!= null ) { error = e ; } } } assert error!= null ; throw error ; }<CODESPLIT>An implementation of { @link Parser } s abstract { @link Parser#flatten ( Options String [] boolean ) flatten } method . <p > The following are the rules used by this flatten method . <ol > <li > if <code > stopAtNonOption< / code > is <b > true< / b > then do not burst anymore of <code > arguments< / code > entries just add each successive entry without further processing . Otherwise ignore <code > stopAtNonOption< / code > . < / li > <li > if the current <code > arguments< / code > entry is <b > -- < / b > just add the entry to the list of processed tokens< / li > <li > if the current <code > arguments< / code > entry is <b > - < / b > just add the entry to the list of processed tokens< / li > <li > if the current <code > arguments< / code > entry is two characters in length and the first character is <b > - < / b > then check if this is a valid { @link Option } id . If it is a valid id then add the entry to the list of processed tokens and set the current { @link Option } member . If it is not a valid id and <code > stopAtNonOption< / code > is true then the remaining entries are copied to the list of processed tokens . Otherwise the current entry is ignored . < / li > <li > if the current <code > arguments< / code > entry is more than two characters in length and the first character is <b > - < / b > then we need to burst the entry to determine its constituents . For more information on the bursting algorithm see { @link GroovyInternalPosixParser#burstToken ( String boolean ) burstToken } . < / li > <li > if the current <code > arguments< / code > entry is not handled by any of the previous rules then the entry is added to the list of processed tokens . < / li > < / ol ><CODESPLIT>0
@ Override public Iterable < T > findAll ( @ NonNull Sort sort ) { Assert. notNull ( sort,sort findAll not null ) ; DocumentQuery query = new DocumentQuery ( Criteria getInstance ( CriteriaType ALL ) ). with ( sort ) ; return operation. find ( query, information. getJavaType ( ), information. getCollectionName ( ) ) ; }<CODESPLIT>Returns all entities sorted by the given options .<CODESPLIT>1
void loadConfigs ( ) throws IOException { application loadConfig ( ) ; user loadConfig ( ) ; system loadConfig ( ) ; config = application getConfig ( ). withFallback ( user. getConfig ( ) ). withFallback ( system. getConfig ( ) ) ; dump2debugLog (MERGED config ) ; }<CODESPLIT>end of class ConfigSource<CODESPLIT>0
private void appendLine ( final String timeStampStr, final int indentLevel, final String line, final StringBuilder buf ) { buf. append ( timeStampStr ) ; buf. append ('' ) ; buf. append ( ClassGraph. class. getSimpleName ( ) ) ; buf. append ('' ) ; numDashes = 2 ( indentLevel - 1 ) ; for ( numD ) { buf. append ('' ) ; } if ( numDashes > 0 ) { buf. append ('' ) ; } buf. append ( line ) ; buf. append ('' ) ; }<CODESPLIT>Add a child log node .<CODESPLIT>0
static public String createMonitor ( String monitorUrl, Node parserInstruction, String modifiesResponse, TECore core ) { MonitorCall mc = monitors. ( monitorUrl ) ; mc. setCore ( core ) ; if ( parser null ) mc. setParserInstruction ( Dom. getElement ( parserInstruction ) ) ; mc. setModResponse ( Boolean. parseBoolean ( modifiesResponse ) ) ; }R. log (. CONFIGConfigured monitor without test {0}", mc ) ; return "" ; }<CODESPLIT>Monitor without parser that doesn t trigger a test<CODESPLIT>0
public void addRelationToResource ( CmsDbContext dbc, CmsResource resource, CmsResource target, CmsRelationType type, boolean importCase ) throws CmsException { if ( type. isDefinedInContent ( ) ) { throw CmsIllegalArgumentException ( Messages. get ( ). ( Messages.ADDRELATIONINCONTENT3 dbc. remove ( resource. ( ) ) dbc. remove ( target. ( ) ) type.Name ( dbc. ( ). ( ) ) ) ) ; } CmsRelation relation = new CmsRelation ( resource, target, type ) ; getVfsDriver ( dbc ). createRelation ( dbc, dbc. currentProject ( ). getUuid ( ), relation ) ; if ( importCase ) { log ( dbc, new CmsLogEntry ( dbc, resource. getStructureId ( ), CmsLogEntryType. RESOURCEADDRELATION, new String { relation. getSourcePath ( ), relation. getTargetPath ( ) } ), false ) ; setDateLastModified ( dbc, resource, System. currentTimeMillis ( ) ) ; } }<CODESPLIT>Adds a resource to the given organizational unit . <p ><CODESPLIT>0
public void marshall ( AssociateProductWithPortfolioRequest associateProductWithPortfolioRequest, ProtocolMarshaller protocolMarshaller ) { if ( associateProductWithPortfolioRequest == null ) { throw SdkClientException ( "Invalid passed marshall(...)" ) ; } try { protocolMarshaller. marshall ( associateProductWithPortfolioRequest. getAcceptLanguage ( ), ACCEPTLANGUAGEBINDING ) ; protocolMarshaller. marshall ( associateProductWithPortfolioRequest. getProductId ( ), PRODUCTIDBINDING ) ; protocolMarshaller. marshall ( associateProductWithPortfolioRequest. getPortfolioId ( ), PORTFOLIOID_BINDING ) ; protocolMarshaller. marshall ( associateProductWithPortfolioRequest. getSourcePortfolioId ( ), SOURCEPORTFOLIOID_BINDING ) ; } ( ) { throw SdkClientException ( " marshall request JSON ". ( ) ) ; } }<CODESPLIT><p > To help organize your resources you can assign your own metadata to the resources that you create . Each tag is a key - value pair . < / p ><CODESPLIT>0
public static void swap ( int [ ] intArray1, int array1Index, int [ ] intArray2, int array2Index ) { if ( intArray1 [ array1Index!= intArray2 [ array2Index ) { hold =Array1 [ array1Index ;Array1 [ array1Index =Array2 [ array2Index ; intArray2 [ array2Index = hold ; } }<CODESPLIT>Helper method that swaps all the elements of the arrays . This method runs in O ( <code > Math . min ( array1 . length array2 . length< / code > ) time .<CODESPLIT>1
public void marshall ( DeleteUserRequest deleteUserRequest, ProtocolMarshaller protocolMarshaller ) { if ( deleteUserRequest == null ) { throw new SdkClientException ( "Invalid passed to marshall(...)" ) ; } try { protocolMarshaller. marshall ( deleteUserRequest. getUserName ( ), USERNAME_BINDING ) ; protocolMarshaller. marshall ( deleteUserRequest. getAuthenticationType ( ), AUTHENTICATIONTYPE_BINDING ) ; } ( ) { throw new SdkClientException ( " to marshall request to JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
protected void addWebuserCondition ( CmsSelectQuery select, CmsOrganizationalUnit orgUnit, TableAlias users ) { String webuserConditionTemplate ; ( orgUnit hasFlagWebuser ( ) ) webuserConditionTemplate = %1$s8 AND %1$s < 65536 ; } webuserConditionTemplate = %1$s <8 OR %1$s 65536 ; } String webuserCondition = String. format ( webuserConditionTemplate, users. column ( colFlags ( ) ) ) ; select. addCondition ( webuserCondition ) ; }<CODESPLIT>Adds a check for the web user condition to an SQL query . <p ><CODESPLIT>1
void add ( LessExtend lessExtend, String [ ] mainSelector ) { ( mainSelector == null mainSelector ( "@media ) ) mainSelector = lessExtend. getSelectors ( ) ; } mainSelector = SelectorUtils. merge ( mainSelector, lessExtend. getSelectors ( ) ) ; } String extendingSelector = lessExtend.ExtendingSelector ( ) ; ( lessExtend isAll ( ) ) LessExtendResult extend = new LessExtendResult ( mainSelector, extendingSelector ) ; SelectorTokenizer tokenizer = tokenizers. pollLast ( ). init ( extendingSelector ) ; do { String token = tokenizer. next ( ) ; ( token == null ) ; } all. add ( token, extend ) ; } while ( true ) ; tokenizers. addLast ( tokenizer ) ; } exact. add ( extendingSelector, mainSelector ) ; } }<CODESPLIT>Add to the given selectors all possible extends and return the resulting selectors .<CODESPLIT>0
JMFSchema [ ] getEncodingSchemas ( ) throws MessageEncodeFailedException { if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) SibTr. entry ( this, tc,getEncodingSchemas" ) ; JMFSchema [ result ; try { JMFSchema [ result1 = ( ( JMFMessage ) headerPart. jmfPart ). getSchemata ( ) ; JMFSchema result2 = null ; resultSize = result1. length ; if ( payloadPart null ) { result2 = ( ( JMFMessage ) payloadPart. jmfPart ). getSchemata ( ) ; resultSize += result2. length ; } result = new JMFSchema resultSize ; System. arraycopy ( result1, 0, result, 0, result1. length ) ; if ( payloadPart null ) { System. arraycopy ( result2, 0, result, result1. length, result2. length ) ; } } ( JMF ) { FFDCFilter. ( e, "comibmwssibmfpimplJsMsgObjectgetEncodingSchemas", "jmo", this, new Object { new Object { MfpConstants. DM_MESSAGE, headerPart. jmfPart, theMessage }, new Object { MfpConstants. DM_MESSAGE, payloadPart. jmfPart, theMessage } } ) ; if ( TraceComponent. isAnyTracingEnabled ( ) tc. isDebugEnabled ( ) ) SibTr. debug ( this, tc,getEncodingSchemas + e ) ; throw MessageEncodeFailedException ( ) ; } if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) SibTr. exit ( this, tc,getEncodingSchemas" ) ; return result ; }<CODESPLIT>Get a list of the JMF schemas needed to decode this message<CODESPLIT>1
public boolean add ( final int value ) { if ( size == capacity ) { throw IllegalStateException ( "This IntHashSet capacity " capacity " full" ) ; } index =Hash ( value, mask ) ; while ( values [ index missingValue ) { if ( values [ index == value ) { return false ; } index = next ( index ) ; } values [ index ] = value ; size ++ ; return true ; }<CODESPLIT>Splits a { @link ClientMessage } into frames of a maximum size .<CODESPLIT>0
private void delete_obj_property ( Database database, String name, String type, String propname ) throws DevFailed { if ( database. isAccesschecked ( ) ) checkAccess ( database ) ; String array ; array = new String 1 ; array [ 0 = propname ; deleteobj_property ( database, name, type, array ) ; }<CODESPLIT>==========================================================================<CODESPLIT>1
public static int getCtrlOrMetaModifier ( ) { WebBrowser webBrowser = Page getCurrent ( ). getWebBrowser ( ) ; ( webBrowserMacOS ( ) ) return ShortcutAction. ModifierKey. META ; } return ShortcutAction. ModifierKey. CTRL ; }<CODESPLIT>Dynamic styles for window .<CODESPLIT>0
public User resolveUser ( final long userId ) throws SQLException { metrics. userCacheTries. mark ( ) ; User user = userCache.IfPresent ( userId ) ; ( user null ) metrics. userCacheHits. mark ( ) ; return user ; } user = selectUser ( userId ) ; ( user null ) userCache. put ( userId, user ) ; } return user ; } }<CODESPLIT>Resolves a user by username possibly with the internal cache .<CODESPLIT>1
public static String buildCleanedParametersURIRepresentation ( org. apache. commons. httpclient. URI uri, SpiderParam. HandleParametersOption handleParameters, boolean handleODataParametersVisited ) throws URIException { if ( handleParameters ( HandleParametersOptionALL ) ) { return uri. toString ( ) ; } if ( handleParameters ( HandleParametersOption IGNORECOMPLETE ) ) { return createBaseUriWithCleanedPath ( uri, handleParameters, handleODataParametersVisited ) ; } if ( handleParameters ( HandleParametersOption IGNORE ) ) { StringBuilder retVal = new StringBuilder ( createBaseUriWithCleanedPath ( uri, handleParameters, handleODataParametersVisited ) ) ; String cleanedQuery = getCleanedQuery ( uri. getEQuery ( ) ) ; if ( cleanedQuery length ( ) ) { retVal. append ( ). append ( cleanedQuery ) ; } return retVal. toString ( ) ; } return uri. toString ( ) ; }<CODESPLIT>Tells whether or not the given port is the default for the given scheme . <p > <strong > Note : < / strong > Only HTTP and HTTPS schemes are taken into account .<CODESPLIT>0
public int run ( String arg, boolean stdin, boolean force ) throws IOException { OutputStream outputStream = null ; InputStream inputStream = null ; KeystoreWrapper keystoreWrapper ; try { ( command ) { CREATE ( ksExists ( ) ) boolean proceed = promptYesNo ( "An eshadoop keystore already exists Overwrite?y/N]" ) ; if ( proceed == false ) { prompt. println ( "Exiting without creating keystore" ) ; return 0 ; } } keystoreWrapper = KeystoreWrapper. newStore ( ). build ( ) ; outputStream = openWrite ( ) ; keystoreWrapper. saveKeystore ( outputStream ) ; return 0 ; LIST (! ksExists ( ) ) prompt. printf ( "ERROR ESHadoop keystore not found Uses command to create one.%, Command. CREATE. getText ( ) ) ; return 5 ; } inputStream = openRead ( ) ; keystoreWrapper = KeystoreWrapper. loadStore ( inputStream ). build ( ) ; for ( : keystoreWrapper. listEntries ( ) ) { prompt. println ( entry ) ; } return 0 ; ADD (! ksExists ( ) ) prompt. printf ( "ERROR ESHadoop keystore not found Uses command to create one.%", Command. CREATE. getText ( ) ) ; return 5 ; } inputStream = openRead ( ) ; keystoreWrapper = KeystoreWrapper. loadStore ( inputStream ). build ( ) ; if ( keystoreWrapper. containsEntry ( arg ) force == false ) { boolean proceed = promptYesNo ( "Settings already exists Overwrite?y/N]", arg ) ; if ( proceed == false ) { prompt. println ( "Exiting without modifying keystore" ) ; return 0 ; } } if ( stdin ) { String data = prompt. readLine ( ) ; keystoreWrapper. setSecureSetting ( arg, data ) ; } { char [ data = prompt. readPassword ( "Enter value fors:", arg ) ; keystoreWrapper. setSecureSetting ( arg, new String ( data ) ) ; Arrays. fill ( data, ( char ) 0 ) ; } outputStream = openWrite ( ) ; keystoreWrapper. saveKeystore ( outputStream ) ; return 0 ; REMOVE (! ksExists ( ) ) prompt. printf ( "ERROR ESHadoop keystore not found Uses command to create one.%", Command. CREATE. getText ( ) ) ; return 5 ; } inputStream = openRead ( ) ; keystoreWrapper = KeystoreWrapper. loadStore ( inputStream ). build ( ) ; if ( keystoreWrapper. containsEntry ( arg ) == false ) { prompt. printf ( "ERROR Settings] does not exist in the keystore.%", arg ) ; return 6 ; } keystoreWrapper. removeSecureSetting ( arg ) ; outputStream = openWrite ( ) ; keystoreWrapper. saveKeystore ( outputStream ) ; return 0 ; default : prompt. println ( "ERROR Unsupported command " + command. ( ) ) ; return 7 ; } } ( EsSecurityException eh ) { prompt. println ( "ERROR load keystore file " + ehse. ( ) ) ; return 8 ; } ( FileNotFoundException ) { prompt. println ( "ERROR load keystore file " +. ( ) ) ; return 9 ; } ( IOException ) { prompt. println ( "ERROR " +. ( ) ) ; return 10 ; } finally { if ( outputStream null ) { outputStream. close ( ) ; } if ( inputStream null ) { inputStream. close ( ) ; } } }<CODESPLIT>{<CODESPLIT>0
private boolean updateStreamBlacklist ( Set < Tuple2 < String, String > > processingBlacklist, Message message, Set < String > initialStreamIds ) { addedStreams = false ; for ( Stream stream message.Streams ( ) ) ( initialStreamIds remove ( stream getId ( ) ) ) addedStreams = true ; } processingBlacklist. add ( tuple ( message. getId ( ), stream. getId ( ) ) ) ; } } return addedStreams ; }<CODESPLIT>Evaluates all pipelines that apply to the given messages based on the current stream routing of the messages .<CODESPLIT>0
protected boolean isFirehoseDrainableByClosing ( FirehoseFactory firehoseFactory ) { return firehoseFactory EventReceiverFirehoseFactory || ( firehoseFactory TimedShoffFirehoseFactory isFirehoseDrainableByClosing ( ( ( TimedShoffFirehoseFactory ) firehoseFactory ) getDelegateFactory ( ) ) ) || ( firehoseFactorypedFirehoseFactory isFirehoseDrainableByClosing ( ( (lippedFirehoseFactory ) firehoseFactory ) getDelegate ( ) ) ) ; }<CODESPLIT>Is a firehose from this factory drainable by closing it? If so we should drain on stopGracefully rather than abruptly stopping . <p > This is a hack to get around the fact that the Firehose and FirehoseFactory interfaces do not help us do this . <p > Protected for tests .<CODESPLIT>1
public boolean dispatchKeyEvent ( KeyEvent event ) { GVRCursorController controller = getUniqueControllerId ( event getDeviceId ( ) ) ; ( controller ) return controller. dispatchKeyEvent ( event ) ; } return false ; }<CODESPLIT>returns controller if a new device is found<CODESPLIT>0
public boolean isDerivation ( Type parent, Type child ) { if ( child ( parent ) ) return true ; } if ( child N ) { Type. Nominal t = ( Type. Nominal ) child ; Decl. Type decl = t. getLink ( ). getTarget ( ) ; return isDerivation ( parent, decl. getType ( ) ) ; } { return false ; } }<CODESPLIT>Check whether one type is a derivation of another . For example in this scenario :<CODESPLIT>1
public void setSelectedClass ( java. lang. String selectedClass ) { getStateHelper ( ) ( PropertyKeys selectedClass selectedClass ) ; }<CODESPLIT><p > Return the value of the <code > selectedClass< / code > property . < / p > <p > Contents : CSS style class to apply to the rendered label on selected options .<CODESPLIT>0
public static < T > Predicates < T > attributeIn ( Function < super T, > function, Iterable < > iterable ) { return new AttributePredicate T, Object ( function, Pred. in ( iterable ) ) ; }<CODESPLIT>Creates a predicate which returns true if an attribute selected from an object passed to accept method is contained in the iterable .<CODESPLIT>1
private void validateRequest ( DownloadRequest dreq ) throws ErrorResponseException { String path = dreq. getPath ( ) ; if ( path. endsWith ( ResourceCatalog. VERSIONXMLFILENAME ) path. ( "__" ) 1 ) { throw ErrorResponseException ( DownloadResponse. getNoContentResponse ( ) ) ; } }<CODESPLIT>Make sure that it is a valid request . This is also the place to implement the reverse IP lookup<CODESPLIT>1
public AutofitHelper setEnabled ( boolean enabled ) { ( mEnabled enabled ) mEnabled = enabled ; if ( enabled ) mTextView. addTextChangedListener ( mTextWatcher ) ; mTextView. addOnLayoutChangeListener ( mOnLayoutChangeListener ) ; autof ( ) ; } mTextView. removeTextChangedListener ( mTextWatcher ) ; mTextView. removeOnLayoutChangeListener ( mOnLayoutChangeListener ) ; mTextView. setTextSize ( TypedValue.P, mTextSize ) ; } } return this ; }<CODESPLIT>Set the enabled state of automatically resizing text .<CODESPLIT>1
public static void checkIfUnmodifiedSince ( final String ifUnmodifiedSince, final Instant modified ) { Instant time = parseDate ( ifUnmodifiedSince ) ; if ( time null modified truncatedTo ( SECONDS ). isAfter ( time ) ) { ClientErrorException ( status ( PRECONDITION ). build ( ) ) ; } }<CODESPLIT>Check for a conditional operation .<CODESPLIT>1
public void setProgress ( CmsUploadProgessInfo info ) { currFile = info. getCurrentFile ( ) ; currFileIndex = 0 ; if ( currFile == ) { } { currFileIndex = currFile - 1 ; if ( currFileIndex >= morderedFilenamesToUpload. size ( ) ) { currFileIndex = m_orderedFilenamesToUpload. size ( ) - 1 ; } } if ( mcontentLength == ) { m_contentLength = info. getContentLength ( ) ; } String currFilename = morderedFilenamesToUpload. get ( currFileIndex ) ; String contentLength = CmsUploadButton. formatBytes ( m_contentLength ) ; fileCount = m_orderedFilenamesToUpload. size ( ) ; String readBytes = CmsUploadButton. formatBytes ( getBytesRead ( info. getPercent ( ) ) ) ; mbar. setValue ( info. getPer ( ) ) ; if (! mstarted ) { m_started = true ; mfileinfo. setHTML ( 0, 0, "<b + Messages. ( ). key ( Messages. GUIUPLOADPROGRESSCURRENTFILE0 ) +b ) ; mfileinfo. setHTML ( 1, 0, "<b + Messages. ( ). key ( Messages. GUIUPLOADPROGRESSUPLOADING0 ) +b ) ; mfileinfo. setHTML (, 0, "" ) ; mfileinfo. setText ( 0, 1, "" ) ; mfileinfo. setText ( 1, 1, "" ) ; mfileinfo. setText (, 1, "" ) ; mfileinfo. getColumnFormatter ( ). setWidth ( 0,px ) ; } mfileinfo. setText ( 0, 1, currFilename ) ; m_fileinfo. setText ( 1, 1, Messages. get ( ). key ( Messages. GUI_UPLOAD_PROGRESS_CURRENT_VALUE_3, new Integer ( currFileIndex + 1 ), new Integer ( fileCount ), getFileText ( ) ) ) ; mfileinfo. setText (, 1, Messages. ( ). key ( Messages. GUIUPLOADPROGRESSUPLOADINGVALUE2, readBytes, contentLength ) ) ; }<CODESPLIT>Returns the file text . <p ><CODESPLIT>0
public static void escape ( String str, StringBuilder rval ) { for ( str. length ( ) ) { final char hi = str. charAt ( i ) ; if ( hi <= 0x8 || hi == 0xB || hi == 0xC || ( hi >= 0xE hi <= 0x1F ) || ( hi >= 0x7F hi <= 0xA0 ) || ( ( hi >= 0x24F! Character. isHighSurrogate ( hi ) ) ) ) { rval. append ( String. format ( "\\u%04x", ( int ) hi ) ) ; } else if ( Character. isHighSurrogate ( hi ) ) { final char lo = str. charAt ( ++ i ) ; final int c = ( hi << 10 ) + lo + ( 0x10000 - ( 0xD800 << 10 ) - 0xDC00 ) ; rval. append ( String. format ( "\\U%08x", c ) ) ; } else { switch ( hi ) { case : rval. append ( "\\b" ) ; ; case : rval. append ( "\\n" ) ; ; case : rval. append ( "\\t" ) ; ; case : rval. append ( "\\f" ) ; ; case : rval. append ( "\\r" ) ; ; case : rval. append ( "\\\"" ) ; ; case': rval. append ( "\\\\" ) ; ; default : rval. append ( hi ) ; ; } } } }<CODESPLIT>Parses the authority for the pre - parsed given JsonLdUrl .<CODESPLIT>0
public static void sendClose ( final ByteBuffer data, final WebSocketChannel wsChannel, final WebSocketCallback < Void > callback ) { CloseMessage new CloseMessage ( data ) ; sendClose ( wsChannel callback ) ; }<CODESPLIT>Sends a complete close message invoking the callback when complete<CODESPLIT>0
public CharacterSet getInverse ( ) {Set newSet ( ) ; n. forbiddenCharacters = characters ; n. characters = forbiddenCharacters ; return n ; }<CODESPLIT>Write VCF record with the specified print writer .<CODESPLIT>0
protected boolean readFeatureParameters ( Element node ) { try { NodeList childrent = node. getChildNodes ( ) ; cpnames = new Vector < String > ( ) ; paras = new Vector < Vector < Integer > > ( ) ; for ( childrent. ( ) ) if ( childrent. item ( ) instanceof Element ) { Element child = ( Element ) childrent. item ( i ) ; String value = child. getAttribute ( "value" ) ; String [ ] parastr = value. split ( ":" ) ; Vector < Integer > para = new Vector < Integer > ( ) ; for ( 3 parastr. length ) { para. add ( Integer. parseInt ( parastr [ j ] ) ) ; } cpnames. add ( parastr [ 2 ] ) ; paras. add ( para ) ; } } catch ( Exception ) { System. out. println ( e. ( ) ) ; e. printStackTrace ( ) ; return false ; } return true ; }<CODESPLIT>Read feature parameters .<CODESPLIT>1
public Node insertBefore ( Node newChild, Node refChild ) throws DOMException { error ( XMLErrorResources.FUNCTIONNOTSUPPORTED ) ; return null ; }<CODESPLIT>Unimplemented . See org . w3c . dom . Node<CODESPLIT>1
public static AuthToken basic ( String username, String password, String realm ) { Objects. requireNonNull ( username,Username can null ) ; Objects. requireNonNull ( password,Password can null ) ; Map String, Value map = newHashMapWithSize ( 4 ) ; map. put ( SCHEMEKEY, value (basic ) ) ; map. put ( PRIPAL_KEY, value ( username ) ) ; map. put ( CREDENTIALS_KEY, value ( password ) ) ; if ( realm null ) { map. put ( REALM_KEY, value ( realm ) ) ; } return new InternalAuthToken ( map ) ; }<CODESPLIT>The basic authentication scheme using a username and a password .<CODESPLIT>1
private Function Expression, Statement > addNodeToPlaceholderMap ( String mapKey, StandaloneNode node ) { return putToMapFunction ( mapKey, placeholderCompiler compileToSoValueProvider ( mapKey, node, ExtraCodeCompiler NOOP, ExtraCodeCompiler NOOP ) ) ; }<CODESPLIT>See go / soy - element - keyed - roots for reasoning on why this is disallowed .<CODESPLIT>0
public void marshall ( MetricDefinition metricDefinition, ProtocolMarshaller protocolMarshaller ) { if ( metricDefinition == null ) { throw new SdkClientException ( "Invalid passed to marshall(...)" ) ; } try { protocolMarshaller. marshall ( metricDefinition. getName ( ), NAME_BINDING ) ; protocolMarshaller. marshall ( metricDefinition. getRegex ( ), REGEX_BINDING ) ; } ( ) { throw new SdkClientException ( " to marshall request to JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
static String [ ] split ( URI remoteUri, String suffix, @ Nullable String defaultBranch ) { String host = remoteUri. getHost ( ) ; if ( host == null! remoteUri. getScheme ( ). endsWith ( "+file" ) ) { throw IllegalArgumentException ( "no host remoteUri " remoteUri ) ; } String path = remoteUri. getRawPath ( ) ; if ( path == null ) { throw IllegalArgumentException ( "no path remoteUri " remoteUri ) ; } Matcher matcher = Pattern. compile ( "^(.*?." + suffix +(?:|/ ). matcher ( path ) ; if (! matcher. find ( ) ) { throw IllegalArgumentException ( "no." suffix remoteUri path " remoteUri ) ; } String newRemoteUri ; port = remoteUri. getPort ( ) ; if ( host!= null ) { if ( port > ) { newRemoteUri = remoteUri. getScheme ( ) + "://" + host +'' + port + matcher. group ( 1 ) ; } { newRemoteUri = remoteUri. getScheme ( ) + "://" + host + matcher. group ( 1 ) ; } } { newRemoteUri = remoteUri. getScheme ( ) + "://" + matcher. group ( 1 ) ; } String remotePath ; try { String decoded = URLDecoder. decode ( path. ( matcher. group ( 1 ). length ( ) ), "UTF-8" ) ; decoded = normalizePath ( decoded ) ; remotePath = decoded ; } ( UnsupportedEncodingException ) { throw Error ( ) ; } String fragment = remoteUri. getFragment ( ) ; String remoteBranch = fragment null fragment : defaultBranch ; return new String [ ] { newRemoteUri, remotePath, remoteBranch } ; }<CODESPLIT>Splits the specified remoteUri into : - the actual remote repository URI - the path in the remote repository - the branch name .<CODESPLIT>1
public static List < Class <? > > resolveHierarchy ( final Class <? > type ) { final List Class res = Lists. newArrayList ( ) ; Class > current = type ; while (! Object. class. equals ( current ) current null ) { res. add ( current ) ; current = current. getSuperclass ( ) ; } return res ; }<CODESPLIT>Assigns base class in scheme for provided model type ( for example to make class vertex type it must extend V ) .<CODESPLIT>0
public void setRefreshing ( boolean refreshing ) { if ( refreshing mRefreshing refreshing ) { mRefreshing = refreshing ; endTarget = 0 ; if (! mUsingCustomStart ) { ( mDirection ) { BOTTOM endTarget = getMeuredHeight ( ) - ( ) ( mSpinnerFinalOffset ) ; ; TOP default endTarget = ( ) ( mSpinnerFinalOffset -. abs ( mOriginalOffsetTop ) ) ; ; } } { endTarget = ( int ) mSpinnerFinalOffset ; } setTargetOffsetTopAndBottom ( endTarget - mCurrentTargetOffsetTop, true ) ; mNotify = false ; startScaleUpAnimation ( mRefreshListener ) ; } { setRefreshing ( refreshing, false ) ; } }<CODESPLIT>Notify the widget that refresh state has changed . Do not call this when refresh is triggered by a swipe gesture .<CODESPLIT>1
private Field [ ] getAllInstanceFields ( final Object obj ) { Field fields = instanceFieldsByClass. ( obj. getClass ( ) ) ; ( fields null ) List Field fieldList = ReflectionUtil. getAllFields ( obj, excludeStatic, excludeTransient ) ; fields = fieldList. toArray ( new Field fieldList. size ( ) ) ; instanceFieldsByClass. put ( obj. getClass ( ), fields ) ; } return fields ; }<CODESPLIT>Visits all the keys and entries of the given map .<CODESPLIT>0
private Map < VectorLayer, Filter > dtoAttributeCriterionToFilters ( AttributeCriterion criterion ) throws GeomajasException { Map VectorLayer, Filter filters = new LinkedHashMap VectorLayer, Filter ( ) ; Filter f ; VectorLayer l = configurationService. getVectorLayer ( criterion. getServerLayerId ( ) ) ; if ( l == null ) { throw GeomajasException ( ExceptionCode. LAYNOTFOUND criterion. getServerLayerId ( ) ) ; } String operator = criterion. getOperator ( ) ; if (LIKE. ( operator. toUpperCase ( ) ) ) { f = filterService. createLikeFilter ( criterion. getAttributeName ( ), criterion. getValue ( ) ) ; } if (DUR. ( operator. toUpperCase ( ) )BEFORE. ( operator. toUpperCase ( ) )AFTER. ( operator. toUpperCase ( ) ) ) { f = filterService. parseFilter ( criterion. toString ( ) ) ; } { f = filterService. createCompareFilter ( criterion. getAttributeName ( ), criterion. getOperator ( ), criterion. getValue ( ) ) ; } filters. put ( l, f ) ; return filters ; }<CODESPLIT>Prune impossible combinations . ( eg . If And criteria filter different layers they will return nothing so they are pruned ) .<CODESPLIT>0
public Session createMailSession ( final String host, final int port, final String username, final String password ) { Properties props = transportStrategy generateProperties ( ) ; props put ( transportStrategy propertyNameHost ( ), host ) ; props put ( transportStrategy propertyNamePort ( ),. ( port ) ) ; ( username null ) props. put ( transportStrategy. propertyNameUsername ( ), username ) ; } ( password null ) props. put ( transportStrategy. propertyNameAuthenticate ( ),true ) ; return Session. getInstance ( props, new Authenticator ( ) { @ Override protected PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( username, password ) ; } } ) ; } return Session. getInstance ( props ) ; } }<CODESPLIT>Actually instantiates and configures the { @link Session } instance . Delegates resolving transport protocol specific properties to the { @link #transportStrategy } in two ways : <ol > <li > request an initial property list which the strategy may pre - populate< / li > <li > by requesting the property names according to the respective transport protocol it handles ( for the host property name it would be <em > mail . smtp . host < / em > for SMTP and <em > mail . smtps . host < / em > for SMTPS ) < / li > < / ol ><CODESPLIT>1
private PBXObjectRef addProjectConfigurationList ( final Map objects, final String baseDir, final List < DependencyDef > dependencies, final CommandLineCompilerConfiguration compilerConfig, final CommandLineLinkerConfiguration linkerConfig ) { List configurations = new ArrayList ( ) ; Map String, Object debugSettings = new HashMap ( ) ; debugSettings. put ( "GCC_WARN_ABOUT_RETURN_TYPE, "YES ) ; debugSettings. put ( "GCC_WARN_UNUSED_VARIABLE, "YES ) ; debugSettings. put ( "PREBINDING, "NO ) ; debugSettings. put ( "SDKROOT, "/DeveloperSDKsMacOSX104usdk ) ; PBXObjectRef debugConfig = createXCBuildConfiguration ( "Debug, debugSettings ) ; objects. put ( debugConfig. getID ( ), debugConfig. getProperties ( ) ) ; configurations. add ( debugConfig ) ; Map String, Object releaseSettings = new HashMap ( ) ; releaseSettings. put ( "GCC_WARN_ABOUT_RETURN_TYPE, "YES ) ; releaseSettings. put ( "GCC_WARN_UNUSED_VARIABLE, "YES ) ; releaseSettings. put ( "PREBINDING, "NO ) ; releaseSettings. put ( "SDKROOT, "/DeveloperSDKsMacOSX104usdk ) ; PBXObjectRef releaseConfig = createXCBuildConfiguration ( "Release, releaseSettings ) ; objects. put ( releaseConfig. getID ( ), releaseConfig. getProperties ( ) ) ; configurations. add ( releaseConfig ) ; PBXObjectRef configurationList = createXCConfigurationList ( configurations ) ; Map projectConfigurationListProperties = configurationList. getProperties ( ) ; projectConfigurationListProperties. put ( "defaultConfigurationIsVisible, "0 ) ; projectConfigurationListProperties. put ( "defaultConfigurationName, "Debug ) ; objects. put ( configurationList. getID ( ), configurationList. getProperties ( ) ) ; File includeDirs = compilerConfig. getIncludePath ( ) ; if ( includeDirs. length > ) { List String includePaths = new ArrayList ( ) ; Map String, String includePathMap = new HashMap ( ) ; for ( File includeDir includeDirs ) { if (! CUtil. isSystemPath ( includeDir ) ) { String absPath = includeDir. getAbsolutePath ( ) ; if (! includePathMap. containsKey ( absPath ) ) { if ( absPath. startsWith ( "/usr/" ) ) { includePaths. add ( CUtil. toUnixPath ( absPath ) ) ; } { String relPath = CUtil. toUnixPath ( CUtil. getRelativePath ( baseDir, includeDir ) ) ; includePaths. add ( relPath ) ; } includePathMap. put ( absPath, absPath ) ; } } } includePaths. add ( "${inherited)" ) ; debugSettings. put ( "HEADER_SEARCH_PATHS, includePaths ) ; releaseSettings. put ( "HEADER_SEARCH_PATHS, includePaths ) ; } String preArgs = compilerConfig. getPreArguments ( ) ; List String defines = new ArrayList ( ) ; for ( preArg preArgs ) { if ( preArg. startsWith ( "-D ) ) { defines. add ( preArg. ( 2 ) ) ; } } if ( defines. size ( ) > ) { defines. add ( "$(inherited ) ; debugSettings. put ( "GCC_PREPROCESSOR_DEFINITIONS, defines ) ; releaseSettings. put ( "GCC_PREPROCESSOR_DEFINITIONS, defines ) ; } if ( linkerConfig null ) { Map String, String librarySearchMap = new HashMap ( ) ; List String librarySearchPaths = new ArrayList ( ) ; List String otherLdFlags = new ArrayList ( ) ; String linkerArgs = linkerConfig. getEndArguments ( ) ; for ( linkerArg linkerArgs ) { if ( linkerArg. startsWith ( "-L ) ) { String libDir = linkerArg. ( 2 ) ; if (! librarySearchMap. containsKey ( libDir ) ) { if (! libDir. ( "/usrlib ) ) { librarySearchPaths. add ( CUtil. toUnixPath ( CUtil. getRelativePath ( baseDir, new File ( libDir ) ) ) ) ; } librarySearchMap. put ( libDir, libDir ) ; } } if ( linkerArg. startsWith ( "-l ) ) { String libName = linkerArg. ( 2 ) ; boolean found = false ; for ( DependencyDef dependency : dependencies ) { if ( libName. startsWith ( dependency. getName ( ) ) ) { File dependencyFile = dependency. getFile ( ) ; if ( dependencyFile null new File ( dependencyFile. getAbsolutePath ( ) +codeproj ). exists ( ) ) { found = true ; ; } } } if (! ) { otherLdFlags. add ( linkerArg ) ; } } } debugSettings. put ( "LIBRARY_SEARCH_PATHS, librarySearchPaths ) ; debugSettings. put ( "OTHER_LDFLAGS, otherLdFlags ) ; releaseSettings. put ( "LIBRARY_SEARCH_PATHS, librarySearchPaths ) ; releaseSettings. put ( "OTHER_LDFLAGS, otherLdFlags ) ; } return configurationList ; }<CODESPLIT>Add project configuration list .<CODESPLIT>1
@ Override public ResultSet getTablePrivileges ( String catalog, String schemaPattern, String tableNamePattern ) throws SQLException { checkClosed ( ) ; VoltTable vtable = new VoltTable ( new ColumnInfo (TABLECAT, VoltType. STRING ), new ColumnInfo (TABLES, VoltType. STRING ), new ColumnInfo (TABLENAME, VoltType. STRING ), new ColumnInfo (GRANTOR, VoltType. STRING ), new ColumnInfo (GRANTEE, VoltType. STRING ), new ColumnInfo (PRIVILEGE, VoltType. STRING ), new ColumnInfo ( "ISGRANTABLE, VoltType. STRING ) ) ; JDBC4ResultSet res = new JDBC4ResultSet ( this. sysCatalog, vtable ) ; return res ; }<CODESPLIT>Retrieves a description of the access rights for each table available in a catalog .<CODESPLIT>1
public Observable < StorageAccountInfoInner > getStorageAccountAsync ( String resourceGroupName, String accountName, String storageAccountName ) { return getStorageAccountWithServiceResponseAsync ( resourceGroupName, accountName, storage ). map ( new1 ServiceResponse StorageAccount, StorageAccount ( ) { @ Override public StorageAccountInfoInner call ( ServiceResponse < StorageAccountInfoInner > response ) { return. body ( ) ; } } ) ; }<CODESPLIT>Gets the specified Azure Storage account linked to the given Data Lake Analytics account .<CODESPLIT>1
private static double sinQ ( double xa, double xb ) { = ( ) ( ( xa 80 ) + 05 ) ; double epsilon = xa - EIGHTHS ; double sintA = SINE_TABLE_A ; double sintB = SINE_TABLE_B ; double costA = COSINE_TABLE_A ; double costB = COSINE_TABLE_B ; double sinEpsA = epsilon ; double sinEpsB = polySine ( epsilon ) ; double cosA = 10 ; double cosB = polyCos ( epsilon ) ; double temp = sinA HEX_40000000 ; double temp2 = ( sinEpsA + temp ) - temp ; sinB += sinA -2 ; sinEpsA = temp2 ; double result ; double a = 0 ; double b = 0 ; double t = sintA ; double c = a + t ; double d = - ( c - a - t ) ; a = c ; b = b + d ; t = costA * sinEpsA ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; b = b + sintA * cosEpsB + costA * sinEpsB ; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB ; if ( xb ) { t = ( ( costA + costB ) * ( cosEpsA + cosEpsB ) - ( sintA + sintB ) * ( sinEpsA + sinEpsB ) ) * ; c = a + t ; d = - ( c - a - t ) ; a = c ; b = b + d ; } result = a + b ; return result ; }<CODESPLIT>Compute sine over the first quadrant ( 0 < x < pi / 2 ) . Use combination of table lookup and rational polynomial expansion .<CODESPLIT>1
public void setNumExecutors ( @ Nonnegative int n ) throws IOException, IllegalArgumentException { if ( n < 0 ) { throw IllegalArgumentException ( "Incorrect field# executors\": " n should non-negative number." ) ; } if ( this. numExecutors!= n ) { this. numExecutors = n ; updateComputerList ( ) ; save ( ) ; } }<CODESPLIT>{ @inheritDoc } .<CODESPLIT>0
private static boolean classNameMatchesFileName ( ClassSymbol c, Env < AttrContext > env ) { return env toplevel sourcefile isNameCompatible ( c name. toString ( ), JavaFileObject.. SOURCE ) ; }<CODESPLIT>Does class have the same name as the file it appears in?<CODESPLIT>1
@ XmlElement ( namenextPageLink" ) @ JsonProperty ( valuenextPageLink" ) @ ApiModelProperty ( value "The next pagination link.", position 4 ) public PageRequestLinkDto getNextPageLink ( ) { return nextPageLink ; }<CODESPLIT>Returns the next pagination link .<CODESPLIT>1
@ Nonnull public static Homoglyph build ( @ Nonnull @ WillClose final Reader aReader ) throws IOException { ValueEnforcer. notNull ( aReader, "reader" ) ; try ( NonBufferedReader aBR = new NonBufferedReader ( aReader ) ) { ICommonsList IntSet aList = new CommonsArrayList ( ) ; String sLine ; while ( ( sLine aBR. readLine ( ) ) ) { sLine = sLine. trim ( ) ; if ( sLine. startsWith ( "#" ) sLine. length ( ) == ) ; IntSet aSet = new IntSet ( sLine. length ( ) / 3 ) ; for ( sCharCode : StringHelper. getExplo ( sLine ) ) { nVal = StringParser. parseInt ( sCharCode, 16, - 1 ) ; if ( nVal >= ) aSet. add ( nVal ) ; } aList. add ( aSet ) ; } return new Homoglyph ( aList ) ; } }<CODESPLIT>Consumes the supplied Reader and uses it to construct a populated Homoglyph object .<CODESPLIT>1
private boolean hasNullifiedFK ( FieldDescriptor [ ] fkFieldDescriptors, Object [ ] fkValues ) { boolean result = true ; for ( ; fkValues. length ; ) { if (! pb. serviceBrokerHelper ( ). representsNull ( fkFieldDescriptors [ i ], fkValues [ i ] ) ) { result = false ; ; } } return result ; }<CODESPLIT>to avoid creation of unmaterializable proxies<CODESPLIT>1
public HistoricDate getBeginOfYear ( HistoricEra era, int yearOfEra ) { HistDate newYear = this. getNewYearStrategy ( ). newYear ( era, yearOfEra ) ; if ( this. isValid (Year ) ) { PlainDate date = this. convert ( newYear ) ; HistEra preferredEra = this. eraPreference. getPreferredEra ( newYear, date ) ; if ( preferredEra era ) { yoe = preferredEra. yearOfEra ( newYear. getE ( ), newYear. getYearOfEra ( ) ) ; newYear = HistDate. of ( preferredEra, yoe, newYear. getMonth ( ), newYear. getDayOfMonth ( ) ) ; } return newYear ; } { IllegalArgumentException ( determine New Year era yearOfEra ) ; } }<CODESPLIT>/ * [ deutsch ] <p > Determines the date of New Year . < / p ><CODESPLIT>1
protected static void checkNotNull ( Object [ ] array ) { checkNotNull ( ( Object ) array ) ; for ( array ) checkNotNull ( o ) ; } }<CODESPLIT>Validate the specified arguments .<CODESPLIT>1
private static String getExtentOfParticipationMention ( LinkedList < Term > eventTermList, LinkedList < Term > roleTermList, processNAFVariables vars ) { LinkedList W eventWordList = getTheWFListByThereTermsFromTargetList ( eventTermList, vars ) ; LinkedList W roleWordList = getTheWFListByThereTermsFromTargetList ( roleTermList, vars ) ; LinkedList W mergedWordList = new LinkedList W ( ) ; charStartOfEvent = Integer. parseInt ( eventWordList. getFirst ( ). getOffset ( ) ) ; charStartOfRole = Integer. parseInt ( roleWordList. getFirst ( ). getOffset ( ) ) ; LinkedList < Wf > firstWL, secondWL ; if ( charStartOfEvent <= charStartOfRole ) { firstWL = eventWordList ; secondWL = roleWordList ; } { firstWL = roleWordList ; secondWL = eventWordList ; } for ( W firstL ) { if ( mergedWordList contains ( w ) ) { mergedWordList. add ( w ) ; } } for ( W secondL ) { if ( mergedWordList contains ( w ) ) { mergedWordList. add ( w ) ; } } StringBuffer extent = new StringBuffer ( ) ; for ( W mergedWordList ) { extent. ( w. ( ) ) ; } String sExtent = extent. toString ( ) ; return sExtent. substring ( 0, sExtent. length ( ) - 1 ) ; }<CODESPLIT>/ * similar to generateTheMIdAndSetID () but specific for ParticipationMention<CODESPLIT>1
public EnvironmentConfig setEnvMonitorTxnsExpirationTimeout ( final int timeout ) { if ( timeout!= timeout < 1000 ) { throw InvalidSettingException ( "Transaction timeout should greater second ) ; } setSetting ( ENV_MONITOR_TXNS_EXPI_TIMEOUT, timeout ) ; if ( timeout > timeout < getEnvMonitorTxnsCheckFreq ( ) ) { setEnvMonitorTxnsCheckFreq ( timeout ) ; } return this ; }<CODESPLIT>Sets the maximum size of page of B + Tree . Default value is { @code 128 } . Only sizes in the range [ 16 .. 1024 ] are accepted . <p > Mutable at runtime : yes<CODESPLIT>0
public static void addTypeMapper ( Class <? > clz, Class <? > mapper ) { synchronized ( classMapper ) { LinkedHashSet Class h = classMapper. get ( clz ) ; if ( h == null ) { h = new LinkedHashSet Class > ( ) ; classMapper. put ( clz, h ) ; } h. add ( mapper ) ; } }<CODESPLIT>Field type convertor for all classes<CODESPLIT>1
public static DocumentBuilder newDocumentBuilder ( final DocumentBuilderFactory factory ) { try { DocumentBuilder builder = factory. newDocumentBuilder ( ) ; return builder ; } catch ( ) { throw MESSAGES. unableToCreateInstanceOf ( DocumentBuilder. class. ( ) ) ; } }<CODESPLIT>Parse the given XML string and return the root Element This uses the document builder associated with the current thread .<CODESPLIT>0
public synchronized void clear ( ) { if ( validState ) { throw InvalidStateException ( ) ; } { buf. clear ( ) ; fc. position ( 0 ). truncate ( 0 ). force ( true ) ; close ( ) ; open ( ) ; } ( ) { log. error ( "Exception in clear()" ) ; } }<CODESPLIT>Read value from file<CODESPLIT>0
void sendMigrationEvent ( final MigrationStatus status ) { partitionId = getPartitionId ( ) ; NodeEngine nodeEngine = getNodeEngine ( ) ; Member localMember = nodeEngine. getLocalMember ( ) ; MigrationEvent event = new MigrationEvent ( partitionId, null, localMember, status ) ; EventService eventService = nodeEngine. getEventService ( ) ; Collection EventRegistration registrations = eventService. getRegistrations ( SERVICENAME, MIGRATIONEVENTTOPIC ) ; eventService. publishEvent ( SERVICENAME, registrations, event, partitionId ) ; }<CODESPLIT>Sends a {<CODESPLIT>1
private void processConstraintViolation ( final Set < ConstraintViolation < Object > > violations, final CsvBindingErrors bindingErrors, final ValidationContext < Object > validationContext ) { for ( ConstraintViolation violation violations ) { String field = violation. getPropertyPath ( ). toString ( ) ; ConstraintDescriptor cd = violation. getConstraintDescriptor ( ) ; String errorCodes = determineErrorCode ( cd ) ; Map String, errorVars = createVariableForConstraint ( cd ) ; if ( isCsvField ( field validationContext ) ) { CsvFieldError fieldError = bindingErrors. getFirstFieldError ( field ) ; if ( fieldError null fieldError. isProcessingFailure ( ) ) { ; } ColumnMapping columnMapping = validationContext. getBeanMapping ( ). getColumnMapping ( field ). get ( ) ; errorVars. put (lineNumber, validationContext. getCsvContext ( ). getLineNumber ( ) ) ; errorVars. put (rowNumber, validationContext. getCsvContext ( ). getRowNumber ( ) ) ; errorVars. put (columnNumber, columnMapping. getNumber ( ) ) ; errorVars. put (label, columnMapping. getLabel ( ) ) ; errorVars. computeIfAbsent (printer, key columnMapping. getFormatter ( ) ) ; fieldValue = violation. getInvalidValue ( ) ; errorVars. computeIfAbsent (validatedValue, key fieldValue ) ; String defaultMessage = determineDefaltMessage ( errorVars, violation ) ; bindingErrors. rejectValue ( field, columnMapping. getField ( ). getType ( ), errorCodes, errorVars, defaultMessage ) ; } { bindingErrors. reject ( errorCodes, errorVars, violation. getMessage ( ) ) ; } } }<CODESPLIT>BeanValidationの検証結果をSheet用のエラーに変換する<CODESPLIT>1
public static void writeToFile ( @ NonNull File file, @ NonNull String content ) throws IOException { OutputStreamWriter writer = new OutputStreamWriter ( new FileOutputStream ( file ), "UTF8 ) ; try { writer. write ( content ) ; writer. flush ( ) ; } ( IOException ) { Log. ( LOGTAG,. toString ( ) ) ; } finally { try { writer. close ( ) ; } ( IOException ) { Log. ( LOGTAG,. toString ( ) ) ; } } }<CODESPLIT>Delete file .<CODESPLIT>0
public static String extractText ( String html ) { html replaceWith ( html ) ; html safeRemoveAllTags ( html ) ; html unescapeHtml ( html ) ; return html ; }<CODESPLIT>Extracts the title of the page .<CODESPLIT>0
public static Rule getRule ( final String inequalitySymbol, final String field, final String value ) { if ( field ( LoggingEventFieldResolver LEVELFIELD ) ) return LevelInequalityRule. getRule ( inequalitySymbol, value ) ; } if ( field ( LoggingEventFieldResolver TIMESTAMPFIELD ) ) return TimestampInequalityRule. getRule ( inequalitySymbol, value ) ; } { return new InequalityRule ( inequalitySymbol, field, value ) ; } }<CODESPLIT>Create new instance from top two elements on stack .<CODESPLIT>0
public void createEquiAngle ( float radius, int numRotations, int numSamples, float jitter, Callback2d callback ) { float spacing = radius / numRotations ; for ( sample sample numSamples sample ) { float angle = 20f ( float ). PI ( sample numRotations ) / numSamples ; float r = radius sample / ( numSamples - 1 ) + ( rnd. nextFloat ( ) * 20f - 10f ) * spacing * jitter ; float x = ( float ). sin_roquen_9 ( angle + 05f * ( float ). PI ) * r ; float y = ( float ). sin_roquen_9 ( angle ) * r ; callback. onNewSample ( x, y ) ; } }<CODESPLIT>Create <code > numSamples< / code > number of samples on a spiral with maximum radius <code > radius< / code > around the center using <code > numRotations< / code > number of rotations along the spiral and call the given <code > callback< / code > for each sample generated . <p > The generated sample points are distributed with equal angle differences around the spiral so they concentrate towards the center . <p > Additionally the radius of each sample point is jittered by the given <code > jitter< / code > factor .<CODESPLIT>1
private void readObject ( ObjectInputStream in ) throws IOException, ClassNotFoundException { in. defaultReadObject ( ) ; severity = SEVERITY_INFO ; summary = null ; detail = null ; ordinal = in. readInt ( ) ; if ( ordinal == SEVERITYINFO getOr ( ) ) { severity = FacesMessage. SEVERITY_INFO ; } if ( ordinal == SEVERITYWARN getOr ( ) ) { severity = FacesMessage. SEVERITY_WARN ; } if ( ordinal == SEVERITYERROR getOr ( ) ) { severity = FacesMessage. SEVERITY_ERROR ; } if ( ordinal == SEVERITYFATAL. getOr ( ) ) { severity = FacesMessage. SEVERITY_FATAL ; } summary = ( String ) in. readObject ( ) ; detail = ( String ) in. readObject ( ) ; rendered = ( Boolean ) in. readObject ( ) ; }<CODESPLIT><p > Reconstruct {<CODESPLIT>1
public void waitForLogMessage ( final String logSearchString, int waitTime ) throws TimeoutException { WaitForContainer waitForCondition ( new Log ( this logSearchString ) waitTime describe ( ) ) ; }<CODESPLIT>Stop and wait till given string will show in container output .<CODESPLIT>1
public Query from ( final Collection <? extends Expression > fromColumns ) { ( fromColumns null ) return this ; } this fromColumns addAll ( fromColumns ) ; return this ; }<CODESPLIT>Adds the FROM columns .<CODESPLIT>1
public void getElementSettingsConfig ( final String clientId, final String containerId, final I_CmsSimpleCallback < CmsElementSettingsConfig > callback ) { CmsRpcAction < CmsElementSettingsConfig > action new CmsRpcAction < CmsElementSettingsConfig > ( ) { @ Override public void execute ( ) { start ( 100 true ) ; getContainerpageService ( ) getElementSettingsConfig ( getData ( ) getR ( ) clientId, containerId, getPageState ( ), ( ), this ) ; } @ Override protected void onResponse ( CmsElementSettingsConfig result ) { ( ) callback execute ( result ) ; } stop ( false ) ; } } ; action execute ( ) ; }<CODESPLIT>Requests the element settings config data for a container element specified by the client id . The data will be provided to the given call - back function . <p ><CODESPLIT>1
protected synchronized void copy ( Writable other ) { if ( other!= null ) { try { DataOutputBuffer out = new DataOutputBuffer ( ) ; other. write ( out ) ; DataInputBuffer in = new DataInputBuffer ( ) ; in. reset ( out. getData ( ), out. getLength ( ) ) ; readFields ( in ) ; } ( IOException ) { throw new IllegalArgumentException ( "map copied ". ( ) ) ; } } { throw new IllegalArgumentException ( "source map" ) ; } }<CODESPLIT>Used by child copy constructors .<CODESPLIT>1
public Cell C, T > width ( Value C, T > width ) { min = width ; pref = width ; maxWidth = width ; return this ; }<CODESPLIT>Sets the minWidth prefWidth and maxWidth to the specified value .<CODESPLIT>0
public void createReference ( Reference reference ) throws GreenPepperServerException { try { sessionService. startSession ( ) ; sessionService. beginTransaction ( ) ; Repository repository = loadRepository ( reference. getSpecification ( ). getRepository ( ). getUid ( ) ) ; documentDao. createReference ( reference ) ; sessionService. commitTransaction ( ) ; log. ( "Created Reference " reference. getRequire ( ). ( ) "," + reference. getSpecification ( ). ( ) ) ; } ( ) { sessionService. rollbackTransaction ( ) ; throw handleException ( REFERENCECREATE ) ; } finally { sessionService. closeSession ( ) ; } }<CODESPLIT>{<CODESPLIT>0
public static Document buildPDFDocument ( com. snowtide. pdf. Document pdf, LucenePDFConfiguration config ) throws IOException { StringWriter sb = new StringWriter ( ) ; pdf. pipe ( new OutputTarget ( sb ) ) ; Document doc = new Document ( ) ; LUCENE_INTERFACE. addField ( doc, config. getBodyTextFieldName ( ), sb. toString ( ), config. storeBodyText ( ), config. indexBodyText ( ), config. tokenizeBodyText ( ) ) ; for ( Map. Object metadata : pdf. getAttributeMap ( ). ( ) ) { String docPropName = metadataEntry. getKey ( ) ; String fieldName = config. getMetadataFieldMapping ( docPropName ) ; if ( fieldName == null ) { if ( config. copyAllPDFMetadata ( ) ) { fieldName = docPropName ; } { ; } } Object value = metadataEntry. getValue ( ) ; String valueStr ; if ( value == null ) { if (DEBUG ) log. (Null document property value name + docPropName + "] + pdf. getName ( ) +'' ) ; ; } if ( value String ) { if ( docPropName. equals ( com. snowtide. pdf. Document. ATTRMODDATE ) docPropName. equals ( com. snowtide. pdf. Document. ATTRCREDATE ) ) { try { valueStr = DateTools. dateToString ( PDFDateParser. parseDateString ( ( String ) value ), DateTools. Resolution. MILLISECOND ) ; } ( ) { log. warn ( "PDF date string parsed into a javautilDate instance + value + (" + pdf. ( ) +'', ) ; valueStr = ( String ) value ; } } { valueStr = ( String ) value ; } } if ( value Number ) { valueStr = value. toString ( ) ; } { if (DEBUG ) log. ( document property value type + value. getClass ( ). getName ( ) + ", for name + docPropName + + pdf. getName ( ) +'' ) ; ; } LUCENE_INTERFACE. addField ( doc, fieldName, valueStr, config. storeMetadata ( ), config. indexMetadata ( ), config. tokenizeMetadata ( ) ) ; } return doc ; }<CODESPLIT>Creates a new Lucene Document instance using the PDF text and metadata provided by the PDFxStream Document using a default {<CODESPLIT>0
protected void removeTargetListeners ( Component comp ) { comp. removeMouseListener ( _targetListener ) ; comp. removeMouseMotionListener ( _targetListener ) ; if ( comp instanceof Container ) { Container cont = ( Container ) comp ; cont. removeContainerListener ( _childListener ) ; for (, nn cont. getComponentCount ( ) nn ; ) { removeTargetListeners ( cont. getComponent ( ii ) ) ; } } }<CODESPLIT>Check to see if we need to do component - level cursor setting and take care of it if needed .<CODESPLIT>0
public Observable < PolicyAssignmentInner > deleteByIdAsync ( String policyAssignmentId ) { return deleteByIdWithServiceResponseAsync ( policyAssignmentId ). map ( new ServiceResponse PolicyAssignmentInner, PolicyAssignmentInner ( ) @ Override public PolicyAssignmentInner call ( ServiceResponse < PolicyAssignmentInner > response ) { return. body ( ) ; } } ) ; }<CODESPLIT>Deletes a policy assignment by ID . When providing a scope for the assigment use / subscriptions / { subscription - id } / for subscriptions / subscriptions / { subscription - id } / resourceGroups / { resource - group - name } for resource groups and / subscriptions / { subscription - id } / resourceGroups / { resource - group - name } / providers / { resource - provider - namespace } / { resource - type } / { resource - name } for resources .<CODESPLIT>0
private void getFights ( Document doc, Event event ) { logger. info ( "Getting fights for event #[{}]", event. getSherdogUrl ( ), event. getName ( ) ) ; SherdogBaseObject sEvent = new SherdogBaseObject ( ) ; sEvent. setName ( event. getName ( ) ) ; sEvent. setSherUrl ( event. getSherUrl ( ) ) ; List Fight fights = new ArrayList ( ) ; Elements mainFightElement = doc. select (contentevent ) ; Elements fighters = mainFightElement. select ( "h3 a ) ; SherdogBaseObject mainFighter1 = new SherdogBaseObject ( ) ; Element mainF1Element = fighters. get ( 0 ) ; mainFighter1. setSherUrl ( mainFighter1Element. attr (abshref ) ) ; mainFighter1. setName ( mainFighter1Element. select (spanitempropname ). html ( ) ) ; SherdogBaseObject mainFighter2 = new SherdogBaseObject ( ) ; Element mainF2Element = fighters. get ( 1 ) ; mainFighter2. setSherUrl ( mainFighter2Element. attr (abshref ) ) ; mainFighter2. setName ( mainFighter2Element. select (spanitempropname ). html ( ) ) ; Fight mainFight = new Fight ( ) ; mainF. setEvent ( sEvent ) ; mainF. setFighter1 ( mainFighter1 ) ; mainF. setFighter2 ( mainFighter2 ) ; mainF. setResult ( ParserUtils. getFResult ( mainFElement. first ( ) ) ) ; Elements mainTd = mainFightElement. select ( " ) ; if ( main. size ( ) > ) { mainF. setMethod ( main. ( 1 ). html ( ). replaceAll ( "<em<br, "" ). trim ( ) ) ; mainF. setRound ( Integer. parseInt ( main. ( 3 ). html ( ). replaceAll ( "<em<br, "" ). trim ( ) ) ) ; mainF. setTime ( main. ( ). html ( ). replaceAll ( "<em<br, "" ). trim ( ) ) ; } mainF. setDate ( event. getDate ( ) ) ; fights. add ( mainFight ) ; logger. info ( "Fight added {}", mainFight ) ; logger. info ( "Found fights, fights. size ( ) ) ; Elements tds = doc. select (event_match table tr ) ; fights. addAll ( parseEventFights ( tds, event ) ) ; event. setFights ( fights ) ; }<CODESPLIT>parses an event from a jsoup document<CODESPLIT>0
public PropertyDescriptor [ ] getTeaBeanPropertyDescriptors ( Class <? > beanClass ) { if ( beanClass == null ) { return NO_PROPERTIES ; } PropertyDescriptor [ properties = null ; Map String, PropertyDescriptor allProps = null ; try { allProps = BeanAnalyzer. getAllProperties ( new GenericType ( beanClass ) ) ; } ( ) { return NO_PROPERTIES ; } Collection PropertyDescriptor cleanProps = new ArrayList PropertyDescriptor ( allProps. size ( ) ) ; Iterator Map. Entry String, PropertyDescriptor it = allProps. entrySet ( ). iterator ( ) ; while (. ( ) ) { Map. Entry String, PropertyDescriptor entry = it. next ( ) ; String name = entry. getKey ( ) ; PropertyDescriptor desc = entry. getValue ( ) ; if ( name == null name. length ( ) == "class". equals ( name ) ) { ; } if ( desc instanceof KeyedPropertyDescriptor ) { KeyedPropertyDescriptor keyed = ( KeyedPropertyDescriptor ) desc ; Class type = keyed. getKeyedPropertyType ( ). getRawType ( ). getType ( ) ; try { desc = new ArrayIndexPropertyDescriptor ( beanClass, type ) ; } ( ) { ; } } if (! beanClass. isArray ( ) desc. getReadMethod ( ) == null ) { ; } cleanProps. add ( desc ) ; } properties = cleanProps. toArray ( new PropertyDescriptor [ cleanProps. size ( ) ) ; sortPropertyDescriptors ( properties ) ; return properties ; }<CODESPLIT>A function that returns an array of all the available properties on a given class . <p > <b > NOTE : < / b > If possible the results of this method should be cached by the caller .<CODESPLIT>1
@ Override public synchronized void serverStopping ( ) { if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) { Tr. entry ( tc, "serverStopping", "generate in progress = " + generateInProgress ) ; } serverIsStopping = true ; for ( 40 generateInProgress ; ) { try { Thread. sleep ( 500 ) ; } catch ( InterruptedException ) { i = 40 ; } } if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) { Tr. exit ( tc, "serverStopping" ) ; } }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
void flattenToSubMessageBuffer ( ByteBuffer buf ) throws IOException { assert ( mitems null ) ; assert (! mitems. isEmpty ( ) ) ; buf. put ( VoltDbMessageFactory. FRAGMENTTASKID ) ; super. flattenToBuffer ( buf ) ; short nInputDepIds = 0 ; short nOutputDepIds = 0 ; short nUnplanned = 0 ; for ( FragmentData item m_items ) { if ( item. minputId 1 ) { nInputIds ++ ; } if ( item. moutputId null ) { nIds ++ ; } if ( item. mfragmentPlan null ) { nUnanned ++ ; } } buf. putShort ( ( short ) mitems. size ( ) ) ; buf. putShort ( nUnplanned ) ; buf. put ( misFinal ( byte ) 1 : ( byte ) 0 ) ; buf. put ( mtaskType ) ; buf. put ( memptyForRestart ( byte ) 1 : ( byte ) 0 ) ; buf. put ( mexecutedOnPreviousLeader ( byte ) 1 : ( byte ) 0 ) ; buf. put ( nOutputDepIds 0 ( byte ) 1 : ( byte ) 0 ) ; buf. put ( nInputDepIds 0 ( byte ) 1 : ( byte ) 0 ) ; if ( mprocNameToLoad null ) { buf. putShort ( ( short ) mprocNameToLoad. length ) ; buf. put ( mprocNameToLoad ) ; } { buf. putShort ( ( short ) - 1 ) ; } buf. put ( mperFragmentStatsRecording ( byte ) 1 : ( byte ) 0 ) ; buf. put ( mcoordinatorTask ( byte ) 1 : ( byte ) 0 ) ; buf. put ( mPartTxn ( byte ) 1 : ( byte ) 0 ) ; buf. putLong ( mrestartTimestamp ) ; buf. putLong ( mlastSpUniqueId ) ; for ( FragmentData item m_items ) { buf. put ( item. mplanHash ) ; } for ( FragmentData item m_items ) { if ( item. mstmtName == null ) { buf. putShort ( ( short ) - 1 ) ; } { assert ( item. mstmtName. length <= Short. MAXVALUE ) ; buf. putShort ( ( short ) item. mstmtName. length ) ; buf. put ( item. mstmtName ) ; } } for ( FragmentData item m_items ) { buf. putInt ( item. mparameterSet. remaining ( ) ) ; buf. put ( item. mparameterSet. asReadOnlyBuffer ( ) ) ; } if ( nOutputIds > ) { for ( FragmentData item m_items ) { buf. putInt ( item. moutputDepId ) ; } } if ( nInputIds > ) { for ( FragmentData item m_items ) { if ( item. minputId == 1 ) { buf. putShort ( ( short ) 0 ) ; } { buf. putShort ( ( short ) 1 ) ; buf. putInt ( item. minputDepId ) ; } } } if ( mprocedureName == null ) { buf. putShort ( ( short ) - 1 ) ; } { assert ( mprocedureName. length <= Short. MAXVALUE ) ; buf. putShort ( ( short ) mprocedureName. length ) ; buf. put ( mprocedureName ) ; } buf. putInt ( mcurrentBatchIndex ) ; if ( mbatchTimeout == BatchTimeoutOverrideType. NOTIMEOUT ) { buf. put ( BatchTimeoutOverrideType. NOOVERRIDEFORBATCHTIMEOUT. getValue ( ) ) ; } { buf. put ( BatchTimeoutOverrideType. HASOVERRIDEFORBATCHTIMEOUT. getValue ( ) ) ; buf. putInt ( mbatchTimeout ) ; } buf. putShort ( ( short ) m_involvedPartitions. size ( ) ) ; for ( pid m_Partitions ) { buf. putInt ( pid ) ; } if ( minitiateTaskBuffer null ) { ByteBuffer dup = m_initiateTaskBuffer. duplicate ( ) ; buf. putInt ( dup. remaining ( ) ) ; buf. put ( dup ) ; } { buf. putInt ( 0 ) ; } for ( short m_items. ( ) ) { FragmentData item = mitems. get ( index ) ; if ( item. mfragmentPlan null ) { buf. putShort ( index ) ; buf. putInt ( item. m_fragmentPlan. length ) ; buf. put ( item. m_fragmentPlan ) ; assert ( item. mstmtText null ) ; buf. putInt ( item. m_stmtText. length ) ; buf. put ( item. m_stmtText ) ; } } }<CODESPLIT>/ * Serialization Format [ description : type : byte count ]<CODESPLIT>0
public T readRow ( BufferedReader bufferedReader, ParseError parseError ) throws ParseException, IOException { checkEntityConfig ( ) ; line = bufferedReader readLine ( ) ; ( line null ) return null ; } return processRow ( line, bufferedReader, parseError, getLineNumber ( bufferedReader ) ) ; } }<CODESPLIT>Read in all of the entities in the reader passed in but without the header .<CODESPLIT>0
private int transformToRTF ( ElemTemplateElement templateParent, DTM dtmFrag ) throws TransformerException { XPathContext = m_xcontext ; ContentHandler rtfHandler =Frag. getContentHandler ( ) ; resultFragment ; SerializationHandler savedRTreeHandler = this. m_serializationHandler ; ToSAXHandler h = new ToXMLSAXHandler ( ) ; h. setContentHandler ( rHandler ) ; h. setTransformer ( this ) ; m_serializationHandler = h ; SerializationHandler rth = m_serializationHandler ; { rth. startDocument ( ) ; rth. flushPending ( ) ; { executeChildTemplates ( templateParent, true ) ; rth. flushPending ( ) ; resultFragment =Frag. getDocument ( ) ; } rth. endDocument ( ) ; } } ( SAXException ) TransformerException ( ) ; } { this. m_serializationHandler = savedRTreeHandler ; } return resultFragment ; }<CODESPLIT>Take the contents of a template element process it and convert it to a string .<CODESPLIT>0
public static void encodeLength ( ByteArrayOutputStream out, int length ) { LOG. entering ( CLASSNAME,encodeLength, new Object { out, length } ) ; byteCount = 0 ; long encodedLength = 0 ; do { encodedLength <<= 8 ; encodedLength |= ( byte ) ( length 07f ) ; length >>= 7 ; byteCount ++ ; } while ( length ) ; do { byte encodedByte = ( byte ) ( encodedLength 0xff ) ; encodedLength >>= 8 ; if ( byteCount 1 ) { encodedByte |= ( byte ) 0x ; } out. write ( encodedByte ) ; } while ( -- byteCount ) ; }<CODESPLIT>/ * Length - bytes are written out in order from most to least significant but are computed most efficiently ( using bit shifts ) from least to most significant . An integer serves as a temporary storage which is then written out in reversed order .<CODESPLIT>1
public static synchronized PingManager getInstanceFor ( XMPPConnection connection ) { Ping ping =S. ( connection ) ; ( pingManager null ) pingManager = new PingManager ( connection ) ; INSTANCES. put ( connection, pingManager ) ; } return pingManager ; }<CODESPLIT>Gets the account registration info from the server . @throws XMPPErrorException @throws NoResponseException @throws NotConnectedException @throws InterruptedException<CODESPLIT>0
@ Override public T > List T > dynamicQuery ( DynamicQuery dynamicQuery ) { returnDisplayLayoutPersistence findWithDynamicQuery ( dynamicQuery ) ; }<CODESPLIT>Returns the number of rows matching the dynamic query .<CODESPLIT>0
public void write ( String s, int off, int len ) throws IOException { if ( writer null ) writer. write ( s, off, len ) ; } ensureOpen ( ) ; strBuffer. ( s. ( off, off len ) ) ; nextChar += len ; } }<CODESPLIT>Write a portion of a String .<CODESPLIT>1
public void concat ( String trg, String [ ] src, boolean restricted ) throws IOException { namesystem concat ( src restricted ) ; }<CODESPLIT>{<CODESPLIT>0
@ Override public ExecuteProvisionedProductServiceActionResult executeProvisionedProductServiceAction ( ExecuteProvisionedProductServiceActionRequest request ) { request beforeClientExecution ( request return executeExecuteProvisionedProductServiceAction ( request ) }<CODESPLIT><p > Executes a self - service action against a provisioned product . < / p ><CODESPLIT>1
private T getWrappedPublisher ( Publisher flexiblePublisher, Class < T > type ) { if (! ( flexiblePublisher instanceof FlexiblePublisher ) ) { throw IllegalArgumentException ( String. format ( "Publisher should types Found types FPublisher. class flexiblePublisher. getClass ( ) ) ) ; } List ConditionalPublisher conditions = ( ( FlexiblePublisher ) flexiblePublisher ). getPublishers ( ) ; for ( ConditionalPublisher condition : conditions ) { if ( type. isInstance ( condition. getPublisher ( ) ) ) { return type. cast ( condition. getPublisher ( ) ) ; } } return null ; }<CODESPLIT>Gets the publisher wrapped by the specofoed FlexiblePublisher .<CODESPLIT>1
public Iterable DContact > queryByUpdatedDate ( Object parent, java util. Date updatedDate ) { return queryByField ( parent, DContactMapper Field UPDATEDDATE getFieldName ( ), updatedDate ) ; }<CODESPLIT>query - by method for field updatedDate<CODESPLIT>1
static boolean isGetOrSetKey ( Node node ) { switch ( node. getToken ( ) ) { GETTERDEF SETTERDEF return true ; COMPUTED_PROP return node. getBooleanProp ( Node. COMPUTED_PROP_GETTER ) node. getBooleanProp ( Node. COMPUTED_PROP_SETTER ) ; default : break ; } return false ; }<CODESPLIT>Determines whether a node represents an object literal get or set key ( e . g . key1 in { get key1 () {} set key2 ( a ) {} ) .<CODESPLIT>1
private boolean isCtFieldACollection ( CtField ctField ) { return ctField. getType ( ). equals ( cp. get ( Collection.. getName ( ) ) ) || ctField. getType ( ). equals ( cp. get ( List.. getName ( ) ) ) || ctField. getType ( ). equals ( cp. get ( Set. class. getName ( ) ) ) ; } ( ) ( ) ; return false ; } }<CODESPLIT>Add Method to ConstPool . If method was not in the ConstPool will add and return index otherwise will return index of already existing entry of constpool<CODESPLIT>0
public static void readable ( final File path, final String message ) throws IllegalArgumentException { notNull ( path, message ) ; ( isReadable ( path ) ) IllegalArgumentException ( message ) ; } }<CODESPLIT>FIXME me animal sniffer this is 1 . 6 API only<CODESPLIT>0
@ Override public ModifyEventSubscriptionResult modifyEventSubscription ( ModifyEventSubscriptionRequest request ) { request beforeClientExecution ( request return executeModifyEvent ( request ) ; }<CODESPLIT><p > Modifies the replication instance to apply new settings . You can change one or more parameters by specifying these parameters and the new values in the request . < / p > <p > Some settings are applied during the maintenance window . < / p > <p / ><CODESPLIT>0
public java. util. List < InventoryDeletionStatusItem > getInventoryDeletions ( ) { ( inventoryDeletions null ) inventoryDeletions = new com amazonaws. internal. SdkInternalList InventoryDeletionStatusItem ( ) ; } return inventoryDeletions ; }<CODESPLIT><p > A list of status items for deleted inventory . < / p ><CODESPLIT>0
public static boolean validateServiceName ( Configuration conf, String nameServiceId ) { Collection String nameserviceIds = DFSUtil. getNameServiceIds ( conf ) ; if ( nameserIds null! nameserIds. isEmpty ( ) ) { if ( name == null ) { System. err. println ( "Need to input a nameservice id" ) ; return false ; } if (! nameserIds. contains ( name ) ) { System. err. println ( " invalid nameservice id " + nameServiceId ) ; return false ; } } if ( nameServiceId null ) { System. err. println ( " invalid nameservice id " + nameServiceId ) ; return false ; } return true ; }<CODESPLIT>Valide if the input service name is valid<CODESPLIT>1
@ Override public OUTPUT newInstance ( Map < String, INPUT > inputMap ) throws FAILURE { StringBuilder builder = new StringBuilder ( ). ( getClass ( ). getName ( ) ). (newInstance(Map<String Input>) is unsupported." ) ; UnsupportedOperationException ( builder. ( ) ) ; }<CODESPLIT><p > <b > Unsupported< / b > . Override to provide an implementation . < / p ><CODESPLIT>1
long getProposedEpoch ( ) throws IOException { try { long pEpoch = FileUtils. readLongFromFile ( this. fProposedEpoch ) ; return pEpoch ; } ( FileNotFoundException ) { LOG. debug ( "File, initialize acknowledged epoch to -1" ) ; return - 1 ; } ( IOException ) { LOG. error ( "IOException access acknowledged epoch" ) ; throw ; } }<CODESPLIT>Gets the last proposed epoch .<CODESPLIT>1
@ SuppressWarnings ( "WeakerAccess" ) public ParameterizableRequest < Map < String, Object >, AuthenticationException > delegation ( ) { HttpUrl url = HttpUrl. parse ( auth0. getDomainUrl ( ) ). newBuilder ( ). addPathSegment ( DE ). build ( ) ; Map, parameters = ParameterBuilder newBuilder ( ) setClientId ( getClientId ( ) ). setGrantType ( ParameterBuilder. GRTYPEJWT ). asDictionary ( ) ; return factory. rawPOST ( url, client, gson, authErrorBuilder ). addParameters ( parameters ) ; }<CODESPLIT>Performs a custom <a href = https : // auth0 . com / docs / api / authentication#delegation > delegation< / a > request that will yield a delegation token . Example usage : <pre > { @code client . delegation () . addParameter ( api_type firebase ) . start ( new BaseCallback<Map<String Object >> () { { @literal } Override public void onSuccess ( Map<String Object > payload ) {}<CODESPLIT>1
public void refreshToken ( ) throws OAuthSystemException, OAuthProblemException { cleanError ( ) ; if ( accessToken == null refreshToken == null ) { throw OAuthRuntimeException ( "Access token ot Refresh token provided ) ; } OneloginURLConnectionClient httpClient = new OneloginURLConnectionClient ( ) ; OAuthClientRequest request = OAuthClientRequest. tokenLocation ( settings. getURL ( Constants. TOKENREFRESHURL ) ). buildBodyMessage ( ) ; Map String, String headers = new HashMap String, String ( ) ; headers. put ( OAuth. HeaderType. CONTENTTYPE, OAuth. ContentType. JSON ) ; headers. put (UserAgent, this. userAgent ) ; Map String, Object params = new HashMap String, Object ( ) ; params. put (granttype, GrantType. REFRESH_TOKEN ) ; params. put (access_token, accessToken ) ; params. put (refresh_token, refreshToken ) ; String body = JSONUtils. buildJSON ( params ) ; request. setBody ( body ) ; updateTokens ( httpClient, request, headers ) ; }<CODESPLIT>Refreshing tokens provides a new set of access and refresh tokens .<CODESPLIT>1
public void syncContactTypeToMain ( ) { ReferenceField fldContactType = ( ReferenceField ) this getMainRecord ( ). getField ( MessageDetail.TYPEID ) ; strContactTypeParam =ContactType getFieldName ( ) ; this. syncRecordToMainField ( fldContactType, null, strContactTypeParam ) ; }<CODESPLIT>Read the current file in the header record given the current detail record .<CODESPLIT>0
@ Override @ SuppressWarnings (unchecked ) public ChronoZonedDateTime < InternationalFixedDate > zonedDateTime ( TemporalAccessor temporal ) { return ( ChronoZonedDateTime InternationalFixedDate ) super zonedDateTime ( temporal ) ; }<CODESPLIT>A property tied to the map updated when the idle state event is fired .<CODESPLIT>0
private ProtoNetwork stage1 ( final File [ ] networks ) { beginStage ( PHASE2STAGE1HDR,1, NUMPHASES ) ; net = networks. length ; StringBuilder bldr = new StringBuilder ( ) ; bldr. append (Merging ) ; bldr. append ( net ) ; bldr. append ( network ) ; if ( netct > ) { bldr. append (s ) ; } stageOutput ( bldr. toString ( ) ) ; long t1 = ( ) ; Collection ProtoNetworkDescriptor nds = sizedArrayList ( net ) ; for ( File network networks ) { String root = network. getAbsolutePath ( ) ; String netPath = asPath ( root, PROTONETWORKFILENAME ) ; File networkBin = new File ( netPath ) ; nds. add ( new BinaryProtoNetworkDescriptor ( networkBin ) ) ; } ProtoNetwork ret = p2. stage1Merger ( nds ) ; new File ( artifactPath. getAbsolutePath ( ) + "/merged ). mkdirs ( ) ; p2. stage4WriteEquivalentProtoNetwork ( ret, artifactPath. getAbsolutePath ( ) + "/merged ) ; if ( withDebug ( ) ) { try { TextProtoNetworkExternalizer textExternalizer = new TextProtoNetworkExternalizer ( ) ; textExternalizer. writeProtoNetwork ( ret, artifactPath. getAbsolutePath ( ) + "/merged ) ; } (Network ) { error ( not write out equivalence proto network." ) ; } } long t2 = ( ) ; bldr. setLength ( 0 ) ; markTime ( bldr, t1, t2 ) ; markEndStage ( bldr ) ; stageOutput ( bldr. toString ( ) ) ; return ret ; }<CODESPLIT>Stage one merger of networks returning the merged proto - network .<CODESPLIT>1
@ Override public EnableStreamingTaskResult enableHlsStreaming ( String spaceId, boolean secure ) throws ContentStoreException { EnableStreamingParameters taskParams new EnableStreamingParameters ( ) ;ParamsSpace ( spaceId ) ;ParamsSecure ( secure ) ; return EnableStreamingTaskResult. deserialize ( contentStore. performTask ( StorageTaskConstants. ENABLE_HLS_TASK_NAME, taskParams. serialize ( ) ) ) ; }<CODESPLIT>{<CODESPLIT>1
public static Map. Entry < String, Map < String, > > getSystemBarsCommand ( ) { return newMap SimpleEntry ( GET_SYSTEM_BARS, ImmutableMap of ( ) ) ; }<CODESPLIT>This method forms a { @link Map } of parameters for the getting of a network connection value .<CODESPLIT>0
public Response postQuery ( final String system, final InputStream input, final String resource, final HttpHeaders httpHeaders ) { JaxRx impl = Systems. getInstance ( system ) ; Document doc = new Schema (post ). check ( input ) ; Map QueryParameter, param = getParameters ( doc, impl ) ; ResourcePath path = new ResourcePath ( resource, param, httpHeaders ) ; return createResponse ( impl, path ) ; }<CODESPLIT>This method will be called when a HTTP client sends a POST request to an existing resource with application / query + xml as Content - Type .<CODESPLIT>1
public boolean hasValue ( int index ) { if ( mbaseCollection List ) { return index ( ( List? > ) m_baseCollection ). size ( ) ; } if ( mbaseCollection SortedMap ) { return index ( ( SortedMap <?,? > ) m_baseCollection ). size ( ) ; } return false ; }<CODESPLIT>Prepares this widget dialog parameter to be committed . <p ><CODESPLIT>0
public void marshall ( DescribeDirectConnectGatewayAssociationsRequest describeDirectConnectGatewayAssociationsRequest, ProtocolMarshaller protocolMarshaller ) { if ( describeDirectConnectGatewayAssociationsRequest == null ) { throw SdkClientException ( "Invalid passed marshall(...)" ) ; } try { protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getAssociationId ( ), ASSATIONID_BINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getAssociatedGatewayId ( ), ASSWAYID_BINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getDirectConnectGatewayId ( ), DIRECTCONNECTGATEWAYID_BINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getMaxResults ( ), MAXRESULTS_BINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getNextToken ( ), NEXTTOKEN_BINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getVirtualGatewayId ( ), VTUALWAYID_BINDING ) ; } ( ) { throw SdkClientException ( " marshall request to JSON ". ( ) ) ; } }<CODESPLIT><p > The sources for the applications ( up to 10 ) . If you specify scaling plan names you cannot specify application sources . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setApplicationSources ( java . util . Collection ) } or { @link #withApplicationSources ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
public Object execEval ( String arg ) { try { return scriptEngine. eval ( "eval(" + arg + ")" ) ; } ( Script ) { throw new BundlingProcessException ( "Error evaluating a script" ) ; } }<CODESPLIT>Returns the JSON object from a string<CODESPLIT>0
@ Override public Map < ServerGroup, EVCacheServerGroupConfig > discoverInstances ( String appName ) throws IOException { String propertyName = appName + "-NODES ; String nodeListString = EVCacheConfig. getInstance ( ). getDynamicStringProperty ( propertyName, "" ). get ( ) ; if ( log. isDebugEnabled ( ) ) log. (List Nodes = + nodeListString ) ; if ( nodeListString null nodeListString. length ( ) > ) return bootstrapFromSystemProperty ( nodeListString ) ; if ( env null region null ) return bootstrapFromEureka ( appName ) ; return Collections. ServerGroup, EVCacheServerGroupConfig emptyMap ( ) ; }<CODESPLIT>Netflix specific impl so we can load from eureka .<CODESPLIT>0
private boolean distinguishedNameEquals ( String dsn1, String dsn2 ) { return new500Principal ( dsn ) equals ( new X500Principal ( dsn ) ) ; }<CODESPLIT>Compare two DSN<CODESPLIT>1
public static BloomKFilter deserialize ( InputStream in ) throws IOException { if ( in == null ) { throw new IOException ( "Input stream" ) ; } try { DataInputStream dataInputStream = new DataInputStream ( in ) ; int numHashFunc = dataInputStream. readByte ( ) ; int bitsetArrayLen = dataInputStream. readInt ( ) ; long [ data = new long [ bitsetArrayLen ; for ( bitsetArrayLen ) { data [ ] = dataInputStream. readLong ( ) ; } return new BloomKFilter ( data, numHashFunc ) ; } ( RuntimeException ) { IOException io = new IOException ( "Unable to deserialize BloomKFilter" ) ; io. initCause ( e ) ; throw io ; } }<CODESPLIT>Deserialize a bloom filter Read a byte stream which was written by { @linkplain #serialize ( OutputStream BloomKFilter ) } into a { @code BloomKFilter }<CODESPLIT>1
public void setRestoreLastValid ( boolean restoreLastValid ) { if ( hasSelection ) IllegalStateException (Last valid text restore can changed file has selection ) ; this. restoreLastValid = restoreLastValid ; if ( restoreLastValid ) { if ( restoreFocusListener == null ) restoreFocusListener = LastValidFocusListener ( ) ; addListener ( restoreFocusListener ) ; } { removeListener ( restoreFocusListener ) ; } }<CODESPLIT>Adds vertical or horizontal {<CODESPLIT>0
public static LongBinding decrementExact ( final ObservableLongValue a ) { return createLongBinding ( ( ) decrementExact ( a get ( ) ), a ) ; }<CODESPLIT>Binding for { @link java . lang . Math#decrementExact ( long ) }<CODESPLIT>1
public static String dgstHex ( InputStream is, Digest digest ) throws IOException { checkNotNull ( is ) ; dgBytes dg ( is, digest ) ; return BaseEncoding. base16 ( ). encode ( dgstBytes ) ; }<CODESPLIT>Calculates digest and returns the value as a hex string .<CODESPLIT>1
private void write ( TargetType theTarget, ValueSetTm theValueSetTm, File theOutputDirectory, String thePackageBase ) throws IOException { if (OutputDirectory. exists ( ) ) { theOutputDirectory. mkdirs ( ) ; } if (OutputDirectory. isDirectory ( ) ) { throw IOException (OutputDirectory directory ) ; } String valueSetName = theValueSetT. getClassName ( ) ; String prefix = myFilenamePrefix ; String suffix = myFilenameSuffix ; if (Target == TargetType. SOURCE ) { if ( suffix. endsWith (java ) ) { suffix += ".java ; } } String fileName = prefix + valueSetName + suffix ; File f = new File ( theOutputDirectory, fileName ) ; OutputStreamWriter w = new OutputStreamWriter ( new FileOutputStream ( f, false ),UTF ) ; ourLog. ( "Writing file {}", f. getAbsolutePath ( ) ) ; VelocityContext ctx = new VelocityContext ( ) ; InputStream templateIs = null ; ctx. put (valueSet, theValueSetT ) ; ctx. put (packageBase, thePackageBase ) ; ctx. put (esc, new EscapeTool ( ) ) ; VelocityEngine v = VelocityHelper. configureVelocityEngine ( myTemplateFile, myVelocityPath, myVelocityProperties ) ; if ( myTemplateFile null ) { templateIs = new FileInputStream ( myTemplateFile ) ; } { String templateName = myTemplate ; if ( null == templateName ) { templateName = "/vm/valuesetvm ; } templateIs = this. getClass ( ). getResourceAsStream ( templateName ) ; } InputStreamReader templateReader = new InputStreamReader ( templateIs,UTF ) ; v. evaluate ( ctx, w, "", templateReader ) ; w. close ( ) ; }<CODESPLIT>}<CODESPLIT>1
@ Override public void store ( Issue issue ) { ( issue primaryLocation ( ) inputComponent ( ) DefaultInputFile ) DefaultInputFile defaultInputFile = ( DefaultInputFile ) issue primaryLocation ( ). inputComponent ( ) ; ( shouldSkipStorage ( defaultInputFile ) ) return ; } defaultInputFile setPublished ( ) ; } moduleIssues. initAndAddIssue ( issue ) ; }<CODESPLIT>Thread safe assuming that each issues for each file are only written once .<CODESPLIT>1
@ Deprecated public Class <? > getClassFromCollection ( final String collection ) { Set MappedClass mcs = mappedClassesByCollection. get ( collection ) ; if ( mcs == null mcs. isEmpty ( ) ) { throw MappingException ( format ( "The collection mapped to java class." collection ) ) ; } if ( mcs. size ( ) > 1 ) { if ( LOG. isInfoEnabled ( ) ) { LOG. info ( format ( "Found more than one class mapped to collectionss", collection, mcs ) ) ; } } return mcs. iterator ( ). next ( ). getClazz ( ) ; }<CODESPLIT>Converts a DBObject back to a type - safe java object ( POJO )<CODESPLIT>0
private Token eventuallyMatch ( Token. Kind kind ) { checkNotEof ( ) ; token = tokens. ( index ) ; if ( token. ) { return null ; } { index = index + 1 ; return token ; } }<CODESPLIT>Match a given sequence of tokens whilst moving passed any whitespace encountered inbetween . In the case that meet the end of the stream or we don t match the expected tokens in the expected order then an error is thrown .<CODESPLIT>0
public static Waehrung of ( CurrencyUnit currencyUnit ) { ( currencyUnit Whrung ) return ( Waehrung ) currencyUnit ; } return of ( currencyUnit. getCurrencyCode ( ) ) ; } }<CODESPLIT>Gibt die entsprechende Currency als Waehrung zurueck .<CODESPLIT>1
private Content processParamTags ( boolean isNonTypeParams, ParamTag [ ] paramTags, Map < String, String > rankMap, TagletWriter writer, Set < String > alreadyDocumented ) { Content result = writer. getOutputInstance ( ) ; if ( paramTags. length > ) { for ( paramTags. ) { ParamTag pt = paramTags [ i ; String paramName = isNonTypeParams pt. parameterName ( ) : "<" + pt. parameterName ( ) + ">" ; if ( rankMap. containsKey ( pt. parameterName ( ) ) ) { writer. getMsgRetriever ( ). warning ( pt. position ( ), isNonTypeParamsdocletParameters_warn :docletType_Parameters_warn, paramName ) ; } String rank = rankMap. get ( pt. parameterName ( ) ) ; if ( rank null alreadyDocumented. contains ( rank ) ) { writer. getMsgRetriever ( ). warning ( pt. position ( ), isNonTypeParamsdocletParameters_dup_warn :docletType_Parameters_dup_warn, paramName ) ; } result. addContent ( processParamTag ( isNonTypeParams, writer, pt, pt. parameterName ( ), alreadyDocumented. size ( ) == 0 ) ) ; alreadyDocumented. add ( rank ) ; } } return result ; }<CODESPLIT>Checks the current system time against the time limit throwing an InterruptedException if the time is up .<CODESPLIT>0
public void setVersions ( java. util. Collection < String > versions ) { ( versions null ) this. versions = null ; return ; } this. versions = new com. amazonaws. internal. SdkInternalList ( versions ) ; }<CODESPLIT><p > The version numbers of one or more launch template versions to delete . < / p ><CODESPLIT>0
private static ScriptRunner getRunner ( ) throws IOException { if ( sharedRunner. ( ) == null ) { ScriptRunner runner = ScriptRunnerFactory. createRunner ( ) ; try { runner. loadScript ( CSL. class. getResource ( "dumpjs ) ) ; runner. loadScript ( CSL. class. getResource ( "citeprocjs ) ) ; runner. loadScript ( CSL. class. getResource ( "formatsjs ) ) ; runner. loadScript ( CSL. class. getResource ( "loadsysjs" ) ) ; } ( ScriptRunner ) { throw ( "Invalid b javascript file ) ; } sharedRunner. set ( runner ) ; } return sharedRunner. get ( ) ; }<CODESPLIT>Calculates a list of available citation locales<CODESPLIT>0
public AbstractPrintQuery addMsgPhrase ( final SelectBuilder _selectBldr, final UUID... _msgPhrase ) throws EFapsException { ListPhrase msgph = new ArrayList ( ) ; for ( UUID phraseUUID _msgPhrase ) { msg. add ( MsgPhrase. ( phraseUUID ) ) ; } return addMsgPhrase ( _selectBldr, msgphrases. toArray ( new MsgPhrase [ msgphrases. size ( ) ] ) ) ; }<CODESPLIT>Adds the msg phrase .<CODESPLIT>1
private String extractAttributes ( SoyMsg msg ) { StringBuilder attributes = new StringBuilder ( ) ; = MESSAGEATTRIBUTEPATTERN. ( msg. getDesc ( ) ) ; while (. ( ) ) { attributes. append ( matcher. group ( ) ) ; } return attributes. toString ( ) ; }<CODESPLIT>Extracts message attributes from the message description . Returns an empty {<CODESPLIT>1
VoltTable [ ] executeSlowHomogeneousBatch ( final List < QueuedSQL > batch, final boolean finalTask ) { MpTransactionState txnState = ( MpTransactionState ) m_txnState ; assert ( txnState null ) ; BatchState state = new BatchState ( batch. size ( ), txnState, m_site. getCoringSiteId ( ),Task, m_procedureName, m_procNameToLoadForFragmentTasks, m_perCallStats. samplingStmts ( ) ) ; for ( batch. size ( ) ) { QueuedSQL queuedSQL = batch. get ( ) ; assert ( queuedSQL. stmt null ) ; int collectorOutputDepId = m_txnState. getNextDependencyId ( ) ; state. m_depsToResume [ i ] = collectorOutputDepId ; ByteBuffer paramBuf = null ; try { paramBuf = ByteBuffer. allocate ( queuedSQL. params. getSerializedSize ( ) ) ; queuedSQL. params. flattenToBuffer ( paramBuf ) ; } catch ( IOException ) { throw new RuntimeException ( "Error serializing parameters for SQL statement "SQL. stmt. getText ( ) " with params "SQL. params. toJSONString ( ) ) ; } assert ( paramBuf null ) ; paramBuf. flip ( ) ; state. addStatement (, queuedSQL. stmt, paramBuf, m_site ) ; } m_txnState. setupProcedureResume ( state. m_depsToResume ) ; for ( state. m_depsForLocalTask. length ) { if ( state. mdepsForLocalTask [ < 0 ) { ; } state. m_localTask. setInputDepId (, state. m_depsForLocalTask [ ] ) ; } m_txnState. createLocalFragmentWork ( state. m_localTask, state. m_localFragsAreNonTransactional && finalTask ) ; if (! state. mdistributedTask. isEmpty ( ) ) { state. m_distributedTask. setBatch ( m_batchIndex ) ; m_txnState. createAllParticipatingFragmentWork ( state. m_distributedTask ) ; } Map Integer, List VoltTable mapResults = m_site. recursableRun ( m_txnState ) ; assert ( mapResults null ) ; assert ( state. m_depsToResume null ) ; assert ( state. m_depsToResume. length == batch. size ( ) ) ; for ( batch. size ( ) ) { List VoltTable matchingTablesForId = mapResults. get ( state. m_depsToResume [ ) ; assert ( matchingTablesForId null ) ; assert ( matchingTablesForId. size ( ) == 1 ) ; state. m_results [ ] = matchingTablesForId. get ( 0 ) ; } return state. m_results ; }<CODESPLIT>/ * Execute a batch of homogeneous queries i . e . all reads or all writes .<CODESPLIT>1
public GrpcServer start ( ) throws IOException { RetryUtils retry (Starting gRPC server, ( ) mServer. start ( ), new ExponentBackoffRetry ( 100, 500, ) ) ; mStarted = true ; return this ; }<CODESPLIT>Start serving .<CODESPLIT>1
public Chunk new_close ( ) { Chunk chk = compress ( ) ; ( _vec AppendVec ) ( ( AppendVec ) _vec ) closeChunk ( this ) ; return chk ; }<CODESPLIT>Slow - path append data<CODESPLIT>0
public static < K, V > Predicate < Map < K, V > > anyEntry ( Predicate < super Map. Entry < K, V > > p ) { return forEntries ( Pred. Map. Entry K, V any ( p ) ) ; }<CODESPLIT>Returns a predicate that evaluates to {<CODESPLIT>0
public static T, U > BiPredicate T, U > biPredicate ( CheckedBiPredicate T, U > predicate ) { return biPredicate ( predicate, THROWABLETORUNTIME_EXCEPTION ) ; }<CODESPLIT>Wrap a {<CODESPLIT>0
private int calcFuByJanto ( ) { Tile jantoTile = comp. getJanto ( ). getTile ( ) ; tmp = 0 ; if (antoTile == generalSuation. getBake ( ) ) { += 2 ; } if (antoTile == personalSuation. getJike ( ) ) { += 2 ; } if (antoTile. getType ( ) == SANGEN ) { += 2 ; } return tmp ; }<CODESPLIT>待ちの種類による可符<CODESPLIT>0
@ Override public AddRoleToDBInstanceResult addRoleToDBInstance ( AddRoleToDBInstanceRequest request ) { request beforeClientExecution ( request return executeAddToDBInstance ( request ) ; }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public static Object getValue ( Name name, int index ) { Assert. notNull ( name,name not null ) ; LdapName ldapName = returnOrConstructLdapNameFromName ( name ) ; Rdn rdn = ldapName. getRdn ( index ) ; if ( rdn. size ( ) > 1 ) { LOGGER. warn (Rdn at position + index + " of dn + name + is multivalue - returned value is not to trusted " + "Consider using namebased getValue method instead ) ; } return rdn. getValue ( ) ; }<CODESPLIT>Get the value of the Rdn with the requested key in the supplied Name as a String .<CODESPLIT>0
