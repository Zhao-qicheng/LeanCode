public InputStream getResourceAsStream ( String resourceName ) { InputStream is = null ; realPath = getRealResourcePath ( resourceName ) ; ( isFileSystemPath ( resourceName realPath ) ) { is = new FileInputStream ( realPath ) ; } ( FileNotFoundException ) LOGGER. debug ( resource realPath has not found ) ; } } ( is null ) is = super. getResourceAsStream ( realPath ) ; } return is ; }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>0
public static void register ( Binder binder, Class < > clazz, Class < extends Annotation > annotation ) { register ( binder ( clazz annotation ) ) ; }<CODESPLIT>Registers a class / annotation combination to instantiate eagerly . Classes mentioned here will be pulled out of the injector with an injector . getInstance () call when the lifecycle is created .<CODESPLIT>1
public static br_restoreconfig [ ] restoreconfig ( nitro_service client, br_restoreconfig [ ] resources ) throws Exception { ( resources null ) Exception (Null resource array ) ; ( resources ) return ( ( brrestoreconfig ) resources performoperation ( clientrestoreconfig ) ) ; return ( ( br_restoreconfig [ ] ) perform_operation_bulk_request ( client, resources, "restoreconfig" ) ) ; }<CODESPLIT><pre > Use this operation to restore config from file on Repeater Instances . < / pre ><CODESPLIT>0
public Page findPageParameter ( Object paramObj ) { Page page = null ; ( paramObj Page ) page = ( Page ) paramObj ; } ( paramObj Map ) Map m = ( Map ) paramObj ; for ( m. values ( ) ) ( o Page ) page = ( Page ) o ; ; } } } ( page null ) PAGETHREADLOCAL set ( page ) ; } return page ; }<CODESPLIT>从传递的参数中找Page对象，并返回<CODESPLIT>1
public static InputStream getResourceAsStream ( Class <? > clazz, String fn ) throws IOException { InputStream stream = clazz. getResourceAsStream ( fn ) ; if ( stream == null ) { throw IOException (resource relative clazz." ) ; } return unpackStream ( stream, fn ) ; }<CODESPLIT>Get an input stream to read the raw contents of the given resource remember to close it : )<CODESPLIT>1
public static < T, R > Supplier < R > compose ( Function < T, R > f, Supplier < T > g ) { dbc precondition ( compose supplier with a function ) ; dbc precondition ( g compose function with a null supplier ) ; return ( ) f. apply ( g. get ( ) ) ; }<CODESPLIT>Composes a function with a ternary function .<CODESPLIT>0
public void getChars ( int srcBegin, int srcEnd, char dst [ ], int dstBegin ) { destIndex = dstBegin ; for ( srcBegin srcEnd ) { dst destIndex ++ = m_str. charAt ( ) ; } }<CODESPLIT>Copies characters from this string into the destination character array .<CODESPLIT>1
public String getRedirectURL ( context, String viewId, Map String, List String parameters, boolean includeViewParams ) { return getActionURL ( context, ) }<CODESPLIT><p class = changed_added_2_0 > Return a JSF action URL derived from the <code > viewId< / code > argument that is suitable to be used by the { @link NavigationHandler } to issue a redirect request to the URL using a NonFaces request . Compliant implementations must implement this method as specified in section JSF . 7 . 6 . 2 . The default implementation simply calls through to { @link #getActionURL } passing the arguments <code > context< / code > and <code > viewId< / code > . < / p ><CODESPLIT>1
@ Override public EClass getServerInfo ( ) { ( serverInfoEClass ) serverInfoEClass = ( EClass ) EPackage Registry. ( Store. eNS ). getEClassifiers ( ). ( 45 ) ; } return serverInfoEClass ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>0
public void addMaybeStartHandler ( Handler handler, Stage stage ) throws Exception { synchronized ( handlers ) { ( started ( ) ) (Stage null stage compareTo (Stage ) ) handler. start ( ) ; } } handlers. ( stage ). add ( handler ) ; } }<CODESPLIT>This will materialize the entire sequence in memory . Use at your own risk .<CODESPLIT>0
@ SuppressWarnings ( {unusedWeakerAccess } ) public static CleverTapAPI instanceWithConfig ( Context context, @ NonNull CleverTapInstanceConfig config ) { ( config null ). v (CleTapInstanceConfig null ) ; return null ; } ( instances null ) instances = new ( ) ; } CleTapAPI instance = instances. ( config.AccountId ( ) ) ; ( instance null ) instance = new CleTapAPI ( context config ) ; instances. put ( config.AccountId ( ), instance ) ; } return instance ; }<CODESPLIT>Lifecycle<CODESPLIT>0
public ElemTemplate getCurrentTemplate ( ) { ElemTemplateElement elem = getCurrentElement ( ) ; while ( ( ) (. ( ) Constants.TEMPLATE ) ) { elem = elem. getParentElem ( ) ; } return ( ElemTemplate ) elem ; }<CODESPLIT>This method retrieves the xsl : template that is in effect which may be a matched template or a named template .<CODESPLIT>1
public static boolean normalize ( IAtomContainer ac, Document doc ) throws InvalidSmilesException, CDKException { NodeList nl = doc. getElementsByTagName (replaceset ) ; SmilesParser sp = new SmilesParser ( ac. getBuilder ( ) ) ; change = false ; for ( nl. ( ) ) { child = ( ) nl. item ( ) ; NodeList replaces = child. getElementsByTagName (replace ) ; NodeList replacement = child. getElementsByTagName (replacement ) ; String replacementstring = replacement. item ( ). getFirstChild ( ). getNodeValue ( ) ; if ( replacementstring ( ) replacementstring length ( ) < ) replacementstring = replacement. item ( ). getFirstChild ( ). getNextSibling ( ). getNodeValue ( ) ; } IAtomContainer replacementStructure = sp. parseSmiles ( replacementstring ) ; for ( replaces. ( ) ) { replace = ( ) replaces. item ( k ) ; String replacestring = replace. getFirstChild ( ). getNodeValue ( ) ; if ( replacestring ( ) replacestring length ( ) < ) replacestring = replace. getFirstChild ( ). getNextSibling ( ). getNodeValue ( ) ; } IAtomContainer replaceStructure = sp. parseSmiles ( replacestring ) ; List RMap l = null ; UniversalorphT universalorphT = new UniversalorphTester ( ) ; while ( ( universalIsMap ( ac replaceStructure ) ) ) { List RMap l = universalorphTester. makeAtomsMapOfBondsMap ( l, ac, replaceStructure ) ; RMap bond = l. iterator ( ) ; while ( ( ) ) { RMap rmap = bond. next ( ) ; acbond = ac. getBond ( rmap. getId1 ( ) ) ; replacebond = replacementStructure. getBond ( rmap. getId2 ( ) ) ; ac. setOrder ( replace. getOrder ( ) ) ; change = true ; } RMap atom = l2. iterator ( ) ; while ( ( ) ) { RMap rmap = atom. next ( ) ; acatom = ac. getAtom ( rmap. getId1 ( ) ) ; replaceatom = replacementStructure. getAtom ( rmap. getId2 ( ) ) ; acatom. setCharge ( replaceatom. getFormalCharge ( ) ) ; change = true ; } } } } return ( change ) ; }<CODESPLIT>The method takes an XML files like the following : <br > &lt ; replace - set&gt ; <br > &lt ; replace&gt ; O = N = O&lt ; / replace&gt ; <br > &lt ; replacement&gt ; [ O - ] [ N + ] = O&lt ; / replacement&gt ; <br > &lt ; / replace - set&gt ; <br > All parts in ac which are the same as replace will be changed according to replacement . Currently the following changes are done : BondOrder FormalCharge . For detection of fragments like replace we rely on UniversalIsomorphismTester . doc may contain several replace - sets and a replace - set may contain several replace fragments which will all be normalized according to replacement .<CODESPLIT>1
protected void writeTraceeContextToMessage ( Message message ) throws JMSException { ( backend isEmpty ( ) backend getConfiguration ( ) shouldProcessContext ( AsyncDispatch ) ) Map, filteredContext = backend. getConfiguration ( ). filterDeniedParams ( backend. copyToMap ( ), AsyncDispatch ) ; contextAsString = httpHeaderSerialization. render ( filteredContext ) ; message setStringProperty ( TracePICHEADER contextAsString ) ; } }<CODESPLIT>Writes the current TraceeContext to the given javaee message . This method is idempotent .<CODESPLIT>1
public void product ( IntLongVector other ) { for ( ; size ; ) { elements [ + start ] *= other. get ( i ) ; } }<CODESPLIT>/ * This method is used to get PHSFellowshipSupplemental12 XMLObject and set the data to it from DevelopmentProposal data .<CODESPLIT>0
public static SignatureValidationFilter buildSignatureValidationFilter ( final Resource signatureResourceLocation ) throws Exception { ( ResourceResourceExist ( signatureResourceLocation ) ). (Resource cannot be located signatureResourceLocation ) ; return null ; } val keyList = new ArrayList ( ) ; keyList add ( new RSAKeyValue ( ) ) ; keyList add ( newSAKeyValue ( ) ) ; keyList add ( new DEREncodedKeyValue ( ) ) ; keyList add ( new InlineX509 ( ) ) ;. debug (Attempting to resolve credentials from signatureResourceLocation ) ; val credential buildCredentialForMetadataSignatureValidation ( signatureResourceLocation ) ;. info (Successfully resolved credentials from signatureResourceLocation ) ;. debug (Configuring credential resolver for key signature trust engine @, credential getCredentialType ( ) ( ) ) ; val resolver = new StaticCredentialResolver ( credential ) ; val keyResolver = new BasicProviderCredentialResolver ( keyProviderList ) ; val trustEngine = new ExplicitSignatureTrustEngine ( resolver keyResolver ) ; (Adding signature validation filter based on the configured trust engine ) ; val signatureValidationFilter = new SignatureValidationFilter ( trustEngine ) ; signatureValidationFilter setDefaultCriteria ( new SignatureValidationCriteriaSetFactoryBean ( ) getObject ( ) ) ;. debug (Added metadata SignatureValidationFilter with signature from signatureResourceLocation ) ; return signatureValidationFilter ; }<CODESPLIT>Build signature validation filter if needed .<CODESPLIT>1
public static URL makeURL ( String specification ) throws MalformedURLException { logger. trace (retrieving URL specification specification ) ; ( specification (classpath ) ) logger. trace (URL typeclasspath'" ) ; return new URL ( null, specification, new ClassPathURLStreamHandler ( ) ) ; } logger. trace (URL normal type ) ; return new URL ( specification ) ; }<CODESPLIT>Returns an URL object for the given URL specification .<CODESPLIT>1
public final void debug ( Object message, Throwable t ) { if ( isLevelEnabled (LEVELDEBUG ) ) log (LEVELDEBUG message t ) ; } }<CODESPLIT><p > Log a message with debug log level . < / p ><CODESPLIT>1
protected final String toLocaleStr ( Locale locale ) { ( locale == Locale ROOT ) return "" ; } language = locale. getLanguage ( ) ; String country = locale. getCountry ( ) ; String variant = locale.Variant ( ) ; ( language == "" country == "" variant == "" ) return "" ; } StringBuilder sb = new StringBuilder ( ) ; ( variant "" ) sb. ( language ). ( ). ( country ). ( ). ( variant ) ; } ( country "" ) sb. ( language ). ( ). ( country ) ; } sb. ( language ) ; } return sb. toString ( ) ; }<CODESPLIT>Convert locale to string with language_country [ _variant ]<CODESPLIT>1
public ListFacetAttributesResult withAttributes ( FacetAttribute... attributes ) { ( this attributes null ) setAttributes ( new java util ArrayList FacetAttribute ( attributes length ) ) ; } for (Attribute ele attributes ) this attributes add ( ele ) ; } return this ; }<CODESPLIT><p > Associates an Identity and Access Management ( IAM ) role from an Neptune DB cluster . < / p ><CODESPLIT>0
public AutofitHelper addOnTextSizeChangeListener ( OnTextSizeChangeListener listener ) { (Listeners )Listeners = new ArrayListTextChangeListener ( ) ; } mListeners add ( listener ) ; return this ; }<CODESPLIT>Adds an {<CODESPLIT>1
public void mergeVertices ( Set < VertexType > vertexSet, GraphType g, VertexCombinator < VertexType > combinator, GraphToolkit < GraphType, EdgeType, VertexType > toolkit ) { ( vertexSet ( ) <= ) return ; } TreeSet EdgeType edgeSet = new TreeSet ( ) ; for (Type g. ( ). ( ) ) { EdgeType =. next ( ) ; ( vertexSet contains ( getSource ( ) ) vertexSet contains ( getTarget ( ) ) ) edgeSet. add ( ) ; } } VertexType compositeVertex = combinator. combineVertices ( vertexSet ) ; for (TypeSet ) { VertexType source = vertexSet. contains (. getSource ( ) ) compositeVertex :. getSource ( ) ; VertexType target = vertexSet. contains (. getTarget ( ) ) compositeVertex :. getTarget ( ) ; ( source compositeVertex target == compositeVertex getSource ( ) getTarget ( ) ) ; } ( g lookupEdge ( source target ) null ) ; } EdgeType compositeEdge = g. createEdge ( source, target ) ; tool. copyEdge (, compositeEdge ) ; } for ( VertexTypeSet vertexSet ) { g. removeVertex ( aVertexSet ) ; } }<CODESPLIT>Resolve an annotation into AnnotationValues representing any type qualifier ( s ) the annotation resolves to . Detects annotations which are directly marked as TypeQualifier annotations and also resolves the use of TypeQualifierNickname annotations .<CODESPLIT>0
@ Override public void visit ( Node node ) throws ELException { if ( nodeFunction ) AstFunction funcNode = ( AstFunction ) node ; Method m = null ; if ( this fnMapper null ) m = fnMapper. resolveFunction ( funcNode. getPrefix ( ), funcNode. getLocalName ( ) ) ; } if ( m == null this varMapper null func getPrefix ( ) length ( ) == ) this. varMapper. resolveVariable ( funcNode. getLocalName ( ) ) ; return ; } if ( this fnMapper == null ) { ELException ( MessageFactory. get (fnMapper ) ) ; } if ( m == null ) { ELException ( MessageFactory. get (fnMappermethod funcNode. ( ) ) ) ; } methodParameterCount = m. getParameterTypes ( ). length ; inputParameterCount = node. jjtGetChild ( ). jjtGetChildren ( ) ; if ( m isVarArgs ( ) inputParameterCount < methodParameterCount m isVarArgs ( ) inputParameterCount methodParameterCount ) { ELException ( MessageFactory. get (fnMapperparamcount funcNode. ( ) methodCount node. jjGetChild ( ). jjGetNumChildren ( ) ) ) ; } } if ( nodeIdentifier this varMapper null ) { String variable = ( ( AstIdentifier ) node ). getImage ( ) ; this. varMapper. resolveVariable ( variable ) ; } }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public Observable Job > getJobDetailsAsync ( String teamName, String jobId ) { return getJobDetailsWithServiceResponseAsync ( teamName, jobId ) map ( new ServiceResponse, ( ) @ Override public Job call ( ServiceResponse Job > response ) { return body ( ) ; } } ) ; }<CODESPLIT>Get the Job Details for a Job Id .<CODESPLIT>0
private void checkIndices ( int row, int col ) { if ( row < row >= rows ) new ArrayIndexOutOfBoundsException (row + row ) ; if ( col < col >= cols ) throw new ArrayIndexOutOfBoundsException (column + col ) ; }<CODESPLIT>Check that the indices of a requested cell are within bounds .<CODESPLIT>1
private void createParentChildRelationships ( Database db, HashMap < String, Account > descriptionMap, HashMap < String, ArrayList < String > > seqMap ) throws Exception { ArrayList String parentIdStack = new ArrayList String ( ) ; if ( seqMap. ( Account. ROOTACCOUNTURI ) ) Exception (File does contain root account Account. ROOTACCOUNTURI ) ; parentIdStack. add ( Account. ROOTACCOUNTURI ) ; while ( parentIdStack. size ( ) ) { String parentId = parentIdStack. ( 0 ) ; Account parent = descriptionMap. get ( parentId ) ; parentIdStack. remove ( 0 ) ; if ( parentId. compareTo ( Account. ROOTACCOUNTURI ) ) { if ( parentAccount null ) { if ( db. findAccountById ( parentId ) == null ) { Account parentParentAccount = db. findParent ( parentAccount ) ; if ( parentParentAccount == null ) { logger. warning (SeqNode a parent will dropped ) ; parentAccount = null ; } } } { logger. warning (SeqNode a matching RDFDescription node will dropped ) ; } } { parentAccount = db. getRootAccount ( ) ; } if ( parentAccount null ) { for ( child seqMap. get ( ) ) { Account child = descriptionMap. get ( childId ) ; if ( childAccount null ) { if ( parentAccount. hasChild ( childAccount ) ) { parentAccount. getChildren ( ). add ( childAccount ) ; if ( seqMap. ( childAccount. getId ( ) ) ) { parentIdStack. add ( childId ) ; childAccount. setIsFolder ( true ) ; } } { logger. warning ( "Duplicate child child of parent parentAccount. ( ) ) ; } } { logger. warning ( " find RDFDescription child will dropped ) ; } } } } }<CODESPLIT><p > Specifies the type of the array components so that the adequate array functions can be offered . < / p ><CODESPLIT>0
private DecimalFormat getNumberFormatter ( TransformerImpl transformer, int contextNode ) throws TransformerException { Locale locale = ( Locale ) getLocale ( transformer, contextNode ). clone ( ) ; DecimalFormat formatter = null ; digitGroupValue = ( null mgroupingSeparatorav ) mgroupingSeparatorav. evaluate ( transformer. getXPathContext ( ), contextNode, this ) null ; ( ( digitGroupValue null ) ( mgroupingSeparatoravt isSimple ( ) ) ( digitGroupValue length ( ) ) ) transformer. getMsgMgr ( ). warn ( this, XSLTErrorResources. WGILLEGALATTRIBUTEVALUE, new { Constants.NAME_NAME, m_Separator_avt. getName ( ) } ) ; } nDigitsGroupValue = ( null mgroupingSizeav ) mgroupingSizeav. evaluate ( transformer. getXPathContext ( ), contextNode, this ) null ; ( ( null digitGroupValue ) ( null nDigitsPerGroupValue ) ( digitGroupValue length ( ) ) ) { formatter = ( DecimalFormat ) NumberFormat. getNumberInstance ( locale ) ; formatter setGroupingSize ( ( nDigitsGroupValue ) ( ) ) ; DecimalFormat symbols = formatter.DecimalFormat ( ) ; symbols setGroupingSeparator ( digitGroupValue. ( 0 ) ) ; formatter. setFormatSymbols ( symbols ) ; formatter. setGroupingUsed ( ) ; } ( NumberFormatException ) formatter. setGroupingUsed ( false ) ; } } return formatter ; }<CODESPLIT>Get the number formatter to be used the format the numbers<CODESPLIT>1
public static List <NotificationTemplate > toModels (NotificationTemplateSoap [ ] soapModels ) { ( soapModels null ) return null ; } List models = new ArrayList ( soapModels. length ) ; for (Soap soapModel soapModels ) { models. add ( toModel ( soapModel ) ) ; } return models ; }<CODESPLIT>Converts the soap model instances into normal model instances .<CODESPLIT>1
public static Double toNullableDouble ( Object value ) { ( value ) return null ; ( value Date ) return ( double ) ( ( Date ) value ) ( ) ; ( value ) return ( double ) ( ( ) value )InMillis ( ) ; ( value Duration ) return ( double ) ( ( Duration ) value ) ( ) ; ( value Boolean ) return ( boolean ) value ; ( value Integer ) return ( double ) ( ( int ) value ) ; ( value Short ) return ( double ) ( ( short ) value ) ; ( value Long ) return ( double ) ( ( long ) value ) ; ( value Float ) return ( double ) ( ( float ) value ) ; ( value Double ) return ( double ) value ; ( value String ) try return Double. parseDouble ( ( String ) value ) ; } ( ) return null ; } return null ; }<CODESPLIT>Converts value into doubles or returns default value when conversion is not possible .<CODESPLIT>0
@ Override public HttpCommandProcessor getCommandProcessor ( Protocol protocol ) { String commandProcessorName = commandProcessorNames. ( protocol ) ; if ( commandProcessorName == null ) { PanicInCo ( HTTP Command Processor configured protocol protocol ) ; } HttpCommandProcessor commandProcessor = ( HttpCommandProcessor ) applicationContext. getBean ( commandProcessorName ) ; if ( commandProcessor == null ) { PanicInCo ( HTTP Command Processor configured name commandProcessorName ) ; } return commandProcessor ; }<CODESPLIT>Returns the command processor assocated with the supplied protocol<CODESPLIT>1
public String getGeneratorParameters ( ) { String result = this. getCommonConstructorParameters ( ) ; result += "," ; result +=this." this getName ( )From()" ; result += "," ; result +=this." this getName ( )To()" ; result += "," ; result += this getOwner ( ) getFClassName ( ) "." this getName ( )Infinity ; result += "," ; result += this futureiringExist ( ) ; result += "," ; result += thisToIsInclusive ( ) ; result += "," ; result += this getOwner ( ) getFinderClassName ( ) "." this getName ( )Default ; result += "," ; result += thisProcessing ( ) ; result += "," ; result += thisfinityNull ( ) ; return result ; }<CODESPLIT>/ * String attributeName String dataClassName String busClassName boolean isNullable boolean hasBusDate RelatedFinder relatedFinder Map<String Object > properties boolean transactional boolean isOptimistic<CODESPLIT>1
@ Override public boolean setActive ( ) { activated = isActive ( ) ; ( activated ) WebLocator locator = new WebLocator ( getPathBuilder ( ) getContainer ( ) ) setElPath ( getTitlePath ( false ) ) ; WebLocator title = locator setInfoMessage (Builder ( ) getText ( ) Tab ) ; activated = titleElement click ( ) ; } ( activated ) info (setActive : toString ( ) ) ; } return activated ; }<CODESPLIT>example new DataField () . setDate ( 19 05 2013 )<CODESPLIT>0
@ Override public StringConverter < > findConverter ( Class < > cls ) { ( cls Byte ) return ByteArrayStringConverter. INSTANCE ; } return null ; }<CODESPLIT>Creates a new conversion manager including the extended standard set of converters . <p > The returned converter is a new instance that includes additional converters : <ul > <li > JDK converters <li > { @link NumericArrayStringConverterFactory } <li > { @link NumericObjectArrayStringConverterFactory } <li > { @link CharObjectArrayStringConverterFactory } <li > { @link ByteObjectArrayStringConverterFactory } <li > { @link BooleanArrayStringConverterFactory } <li > { @link BooleanObjectArrayStringConverterFactory } < / ul > <p > The convert instance is mutable in a thread - safe manner . Converters may be altered at any time including the JDK converters . It is strongly recommended to only alter the converters before performing actual conversions .<CODESPLIT>0
@ Override public DisassociateS3Resources disassociateS3Resources ( DisassociateS3ResourcesRequest request ) { request beforeClientExecution request return executeDisassociateResources ( request }<CODESPLIT><p > Removes specified S3 resources from being monitored by Amazon Macie . If memberAccountId isn t specified the action removes specified S3 resources from Macie for the current master account . If memberAccountId is specified the action removes specified S3 resources from Macie for the specified member account . < / p ><CODESPLIT>1
public static double cdf ( double val, double k, double lambda, double theta ) { return ( val theta ) ( 10 - FastMath exp ( - FastMath pow ( ( val - theta ) / lambda, ) ) ) val val0 Double NaN ; }<CODESPLIT>CDF of Weibull distribution<CODESPLIT>1
public static void equalizeLocalCol ( GrayU16 input, int radius, int startX, GrayU16 output, IWorkArrays workArrays ) { width = 2 * radius + 1 ; area = width * width ; maxValue = workArrays. length ( ) - 1 ; [ histogram = workArrays. pop ( ) ; [ transform = workArrays. pop ( ) ; hist0 = startX ; hist1 = startX + width ; if ( hist1 > input. width ) { hist1 = input. width ; hist0 = hist1 - width ; } localHistogram ( input, hist0, 0, hist1, width, histogram ) ; sum = 0 ; for ( histogram. length ) { transform [ = sum += histogram [ ; } indexIn = input. startIndex + radius * input. stride + startX ; indexOut = output. startIndex + radius * output. stride + startX ; for ( radius ) { inputValue = input. data [ indexIn ++ & 0 ; output. data [ indexOut ++ = ( short ) ( ( transform [ inputValue * maxValue ) / area ) ; } for ( radius 1 input. height - radius ) { indexIn = input. startIndex + ( y - radius - 1 ) * input. stride ; for ( hist0 hist1 ) { histogram [ input. data [ indexIn + xxFFFF -- ; } indexIn += width * input. stride ; for ( hist0 hist1 ) { histogram [ input. data [ indexIn + xxFFFF ++ ; } sum = 0 ; for ( histogram. length ) { transform [ = sum += histogram [ ; } indexIn = input. startIndex + y * input. stride + startX ; indexOut = output. startIndex + y * output. stride + startX ; for ( radius ) { inputValue = input. data [ indexIn ++ & 0 ; output. data [ indexOut ++ = ( short ) ( ( transform [ inputValue * maxValue ) / area ) ; } } workArrays. recycle ( histogram ) ; workArrays. recycle ( transform ) ; }<CODESPLIT>Local equalization along a row . Image must be at least the histogram s width ( 2 * r + 1 ) in width and height .<CODESPLIT>0
public static int validArrayIndex ( final int index, final int arrayLength, final String message ) { ( index arrayLength ) IndexOutOfBoundsException ( message ) ; } return index ; }<CODESPLIT>Throws an { @link IndexOutOfBoundsException } if { @code sliceFrom } or { @code sliceLength } is negative or the sum of both is greater than { @code arrayLength } . Note that this means that a slice of length zero starting at array length is a valid slice .<CODESPLIT>0
public static QConnectorSync create ( String host, int port ) { return create (, true, true ) }<CODESPLIT>ファイルが1904年始まりの設定かどうか。<CODESPLIT>0
private < T extends INode > T addNode ( String src, T child, long childDiskspace, boolean inheritPermission ) throws QuotaExceededException { components = INode getPathComponents ( src ) ; byte path = components components. length - 1 ; child setLocal ( path ) ; cacheName ( child ) ; inodes = new components length ; writeLock ( ) ; rootDir.ExistingPath ( components in ) ; return addChild ( inodes, inodes. length - 1, child, childDiskspace, inheritPermission ) ; } writeUnlock ( ) ; } }<CODESPLIT>Add a node child to the namespace . The full path name of the node is src . childDiskspace should be - 1 if unknown . QuotaExceededException is thrown if it violates quota limit<CODESPLIT>1
public Vector4f add ( float x, float y, float z, float w ) { return add (,,OrNew ( ) ) }<CODESPLIT>Increment the components of this vector by the given values .<CODESPLIT>1
public final DetectLanguageResponse detectLanguage ( String parent, String model, String mimeType ) { ( parent ( ) ) LOCATIONTEMPLATE validate ( parent,detectLanguage ) ; } DetectLanguageRequest request = DetectLanguageRequest newBuilder ( ) setParent ( parent ) setModel ( model ) ( mimeType ) build ( ) ; return detectLanguage ( request ) ; }<CODESPLIT>Formats a string containing the fully - qualified path to represent a location resource .<CODESPLIT>0
protected void commonSetup ( ZMatrixRMaj A ) { setExpectedMaxSize ( A A ) ; QR ( A ) ; }<CODESPLIT><p > Computes the householder vector u for the first column of submatrix j . Note this is a specialized householder for this problem . There is some protection against overflow and underflow . < / p > <p > Q = I - &gamma ; uu<sup > H< / sup > < / p > <p > This function finds the values of u and &gamma ; . < / p ><CODESPLIT>0
@ Override public EsaResourceWritable parseFileToResource ( File assetFile, File metadataFile, String contentUrl ) throws RepositoryException { ArtifactMetadata artifactMetadata = explodeArtifact ( assetFile, metadataFile ) ; ProvisioningFeatureDefinition feature ; { feature = EsaSubsystemFeatureDefinitionImpl. constructInstance ( assetFile ) ; } ( IOException ) RepositoryArchiveIOException (. ( ) assetFile ) ; } EsaResourceWritable resource = WritableResourceFactory. createEsa ( null ) ; symbolicName = feature. getSName ( ) ; version = feature. getVersion ( ). toString ( ) ; subsystemName = feature. getHeader (SubsystemName, Locale. ) ; String shortName = feature. getIbmShortName ( ) ; String metadataName = artifactMetadata null artifactMetadata. getName ( ) null ; String name ; ( metadataName null metadataName isEmpty ( ) ) name = metadataName ; } ( subsystemName null subsystemName isEmpty ( ) ) name = subsystemName ; } ( shortName null shortName isEmpty ( ) ) name = shortName ; } name = symbolicName ; } resource. setName ( name ) ; String shortDescription = null ; String overriddenDisplayPolicy = null ; ( artifactMetadata null ) shortDescription = artifactMetadata. getShortDescription ( ) ; resource. setDescription ( artifactMetadata.Description ( ) ) ; resource. setVURL ( artifactMetadata. getProperty (VURL ) ) ; overriddenDisplayPolicy = artifactMetadata. getProperty (DISPLAYPOLICY ) ; } ( shortDescription == null ) shortDescription = feature. getHeader (SubsystemDescription, Locale. ) ; } resource. setShortDescription ( shortDescription ) ; resource. setVersion ( version ) ; processIcons ( assetFile, feature, resource ) ; String provider = feature. getHeader (SubsystemVendor ) ; ( provider null provider isEmpty ( ) ) resource. setProviderName ( provider ) ; (IB ( provider ) ) resource. setProviderUrl (httpibm ) ; } } InvalidParameterException (SubsystemVendor set manifest headers ) ; } resource. setProvideFeature ( symbolicName ) ; ( artifactMetadata null artifactMetadata getProperty (IBAppliesTo ) null ) resource. setApplies ( artifactMetadata. getProperty (IBApplies ) ) ; } resource. setApplies ( feature. getHeader (IBApplies ) ) ; } Visibility visibility ; DisplayPolicy displayPolicy ; DisplayPolicy webDisplayPolicy ; ( com ibm ws kernel feature Visibility PUBLIC ( featureVisibility ( ) ) ) visibility = Visibility. PUBLIC ; displayPolicy = DisplayPolicy. VISIBLE ; webDisplayPolicy = DisplayPolicy. VISIBLE ; } ( com ibm ws kernel feature Visibility PROTECTED ( featureVisibility ( ) ) ) visibility = Visibility. PROTECTED ; displayPolicy = DisplayPolicy. HIDDEN ; webDisplayPolicy = DisplayPolicy. HIDDEN ; } ( com ibm ws kernel feature Visibility INSTALL ( featureVisibility ( ) ) ) visibility = Visibility. INSTALL ; displayPolicy = DisplayPolicy. VISIBLE ; webDisplayPolicy = DisplayPolicy. HIDDEN ; } visibility = Visibility. PRIVATE ; displayPolicy = DisplayPolicy. HIDDEN ; webDisplayPolicy = DisplayPolicy. HIDDEN ; } resource. setVisibility ( visibility ) ; ( feature isAutoFeature ( ) ) resource. setProvision ( feature. getHeader (IBProvision ) ) ; String IBMInstallPolicy = feature. getHeader (IBMInstallPolicy ) ; InstallPolicy installPolicy ; ( IBInstallPolicy null (whensatisfied ( IBInstallPolicy ) ) ) installPolicy = InstallPolicy. WHEN_SATISFIED ; } installPolicy = InstallPolicy. MANUAL ; displayPolicy = DisplayPolicy. VISIBLE ; webDisplayPolicy = DisplayPolicy. VISIBLE ; } resource. setInstallPolicy ( installPolicy ) ; } ( isBeta ( resourceAppliesTo ( ) ) ) resource. setWebDisplayPolicy (Policy. HIDDEN ) ; } resource. setWebDisplayPolicy ( webDisplayPolicy ) ; } ( overriddenDisplayPolicy null ) displayPolicy = DisplayPolicy. valueOf ( overriddenDisplayPolicy ) ; } resource. setDisplayPolicy ( displayPolicy ) ; String requiredes = feature. getHeader (IBMRequire ) ; ( requiredFix null requiredFix isEmpty ( ) ) String fixes = requiredes. split ( "," ) ; for ( fixes ) { fix = fix. trim ( ) ; ( fix isEmpty ( ) ) resource. addRequireFix ( fix ) ; } } } resource. setShortName ( shortName ) ; Collection FeatureResource requiredFeatures = feature.Conents ( SubsystemContentType. FEATURETYPE ) ; for ( FeatureResource featureResource requiredFeatures ) { List String tolates = featureResource. getTates ( ) ; String requiredFeatureSyName = featureResource. getSName ( ) ; resource. addRequireFeatureWithTolates ( requiredFeatureName, tolates ) ; } String supersededBy = feature. getSupersededBy ( ) ; ( superseBy null superseBy trim ( ) isEmpty ( ) ) String supersededByArray = supersededBy. split ( "," ) ; for ( superByArray ) { ( f ( "[" ) ) f = f. ( 1, f. length ( ) - 1 ) ; resource. addSuperdedByOptional ( f ) ; } resource. addSuperdedBy ( f ) ; } } } ( artifactMetadata null ) attachLicenseData ( artifactMetadata, resource ) ; } setJavaRequirements ( assetFile, resource ) ; String attachmentName = symbolicNameesa ; addContent ( resource, assetFile, attachmentName, artifactMetadata, contentUrl ) ; { processLAandLI ( assetFile, resource, feature ) ; } ( IOException ) RepositoryArchiveIOException (. ( ) assetFile ) ; } resource. setLicenseId ( feature. getHeader (SubsystemLicense ) ) ; resource. setSingleton ( Boolean. toString ( feature. isSingleton ( ) ) ) ; resource. setIBInstall ( feature. getHeader (IBInstall ) ) ; return resource ; }<CODESPLIT>Look in the esa for bundles with particular java version requirements . Create an aggregate requirement of the esa as a whole and write the data into the supplied resource<CODESPLIT>0
public static < T > T invokeMethod ( final Object obj, Method method, Object... args ) { return ( T ) method. invoke ( obj, args ) ; } ( ). unwrapAnd ( ) ; } }<CODESPLIT>调用构造函数 .<CODESPLIT>0
public SSLEngine addCommonConfigs ( SSLEngine engine ) { ( sslConfig getCSuites ( ) null sslConfig getCSuites ( ) length ) engine. setEnabledCipherSuites ( sslConfig.Suites ( ) ) ; } if ( sslConfigEnableProtocols ( ) null sslConfigEnableProtocols ( ) length ) engine. setEnabledProtocols ( sslConfig.EnableProtocols ( ) ) ; } engine. setEnableSessionCreation ( sslConfig.EnableSessionCreation ( ) ) ; return engine ; }<CODESPLIT>Add common configs for both client and server ssl engines .<CODESPLIT>1
public static InternalKnowledgeBaseKnowledgeBase ( String kbaseId,ieBaseConfiguration conf ) { returnBaseImpl (, ( RuleBase ) conf ) ; }<CODESPLIT>TODO : FIXME : make it consistent with above<CODESPLIT>0
private < ItemT > void addInternal ( @ Nonnull Iterable < ItemT > items ) { if ( items iterator ( ) hasNext ( ) ) return ; } nextBuildNumber = getNextBuildNumber ( items. iterator ( ). next ( ) ) ; if ( newerThan == null olderThan == null )T = items. iterator ( ) ; while (. ( ) ) { add (. next ( ) ) ; if ( isFull ( ) ) ; } } hasDownPage =. hasNext ( ) ; } if ( newerThan null ) toFillCount = getFCount ( ) ; if ( toFillCount ) LinkedList ItemT itemsToAdd = new LinkedList ( ) ;T = items. iterator ( ) ; while (. ( ) ) {T item =. next ( ) ; if ( HistoryPageEntry getEntryId ( item ) newerThan ) itemsToAdd. addLast ( item ) ; if ( itemsToAdd size ( ) toFillCount ) itemsToAdd. removeFirst ( ) ; hasUpPage = true ; } } ; } } if ( itemsToAdd size ( ) == ) hasDownPage = true ; } if ( itemsToAdd size ( ) < toFillCount )T skipped = items. iterator ( ) ; Iterators. skip ( skipped, itemsToAdd. size ( ) ) ; for ( itemsToAdd. ( ) to skipped. ( ) ) {T item = skipped. next ( ) ; itemsToAdd. addLast ( item ) ; } } hasDownPage =. hasNext ( ) ; for ( item itemsToAdd ) { add ( item ) ; } } } } if ( olderThan null )T = items. iterator ( ) ; while (. ( ) ) { item =. next ( ) ; if ( HistoryPageEntry getEntryId ( item ) olderThan ) hasUpPage = true ; } add ( item ) ; if ( isFull ( ) ) hasDownPage =. hasNext ( ) ; ; } } } } }<CODESPLIT>Add run items and queued items to the History page .<CODESPLIT>0
private Set < Artifact > getProjectDependencyManagement ( ) { Set result = new LinkedHashSet ( ) ; DependencyManagement dependencyManagement = getProject ( ).Management ( ) ; ( dependencyManagement ) for ( dependency dependencyManagement. getDependencies ( ) ) result add ( toArtifact ( dependency ) ) ; } } return result ; }<CODESPLIT>Returns all dependency artifacts in all modules excluding all reactor artifacts ( including attached ) .<CODESPLIT>0
public void add ( Rec fieldList ) throws DBException { Record record = ( Record ) fieldList ; if ( ( ( this. getRecord ( ). getOpenMode ( ) DBConstants. OPENREFRESHANDLOCKSTR ) DBConstants. OPENREFRESHANDLOCKCHANGESTR ) ( record. isRefreshedRecord ( ) ) ) this. restoreMainRecord ( record true ) ; super. add ( record ) ; }<CODESPLIT>Add this record ( Always called from the record class ) .<CODESPLIT>1
protected void setException ( Throwable t ) { ( U compareAndSwapInt ( this NEW COMP ) ) outcome = t ; U putOrderedInt ( this, STATE, EXCEPTION ) ; finishCompletion ( ) ; } }<CODESPLIT>Sets the result of this future to the given value unless this future has already been set or has been cancelled .<CODESPLIT>0
@ Pure public static URL getResource ( ClassLoader classLoader, String path ) { returnResource ( classLoader path ) }<CODESPLIT>Replies the input stream of a resource .<CODESPLIT>0
@ SuppressWarnings (unchecked" ) static < K, V > Map < K, V > dynamicallyCastMap ( Map <, > map, Class < K > keyType, Class < V > valueType ) { ( map ) return null ; } assert checkCollectionMembers ( map ( ), keyType ) : map contains keys a type other keyType ( ) ; assert checkCollectionMembers ( map values ( ), valueType ) : map contains values with a type other valueType ( ) ; return ( Map K, V ) map ; }<CODESPLIT>=====<CODESPLIT>0
@ Override public java util List com liferay product modelOptionValueRel > getCPDefinitionOptionValueRelsByUuidAndCompanyId ( String uuid, long companyId ) { return _DefinitionOptionValueRelLocalService getCPDefinitionOptionValueRelsByUuidAndCompanyId ( uuid, companyId ) ; }<CODESPLIT>Returns a range of cp definition option value rels matching the UUID and company .<CODESPLIT>0
public void setComplianceStatus ( java. util. Collection < StringFilter > complianceStatus ) { ( compliance ) this complianceStatus = null ; return ; } this complianceStatus = new java util ArrayListFilter ( complianceStatus ) ; }<CODESPLIT><p > The details of a resource that does not have a specific sub - field for the resource type defined . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setResourceDetailsOther ( java . util . Collection ) } or { @link #withResourceDetailsOther ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
public static void callMethod ( final Object obj, final String methodName, final boolean includePrivateMehtods, final Object... args ) throws InvocationTargetException { ClassArgsClass = initParamsClasses ( args ) ; { Class current = obj. getClass ( ) ; Method method = null ; while ( Object. ) { try { method = current. getDeclaredMethod ( methodName, intArgsClass ) ; ; } ( NoSuchMethodException ) { current = current. getSuperclass ( ) ; } } if ( method == null ) { throw NoSuchMethodException (Meht current ) ; } method. setAccessible ( true ) ; method. invoke ( obj, args ) ; } ( InvocationTargetException ) { throw (. ( ) ) ; } ( ) { throw ( ) ; } }<CODESPLIT>Checks if is class avilable in class path .<CODESPLIT>0
@ Override public boolean canParse ( File file ) { filename file ( ) ; return endsWithIgnoreCase ( filename,es ) ; }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public final ListProductSetsPagedResponse listProductSets ( LocationName parent ) {ProductSetsRequest requestProductSetsRequest newBuilder ( ) setParent ( parent parent toString ( ) ) build ( ) ; return listProductSets ( request ) ; }<CODESPLIT>Lists ProductSets in an unspecified order .<CODESPLIT>1
public Matrix solve ( Matrix B ) { if ( B. getRowDimension ( )!= n ) { throw new IllegalArgumentException ( "Matrix row dimensions must agree." ) ; } if (! isspd ) { throw new RuntimeException ( "Matrix not symmetric positive definite." ) ; } double [ ] [ ] X = B. getArrayCopy ( ) ; int nx = B. getColumnDimension ( ) ; for ( n ) { for ( nx ) { for ( ) { X [ k ] [ j ] -= X [ i ] [ j ] * L [ k ] [ i ] ; } X [ k ] [ j ] /= L [ k ] [ k ] ; } } for ( n - 1 ; ; -- ) { for ( ; nx ; ) { for ( + 1 ; n ; ) { X [ k ] [ j ] -= X [ i ] [ j ] * L [ i ] [ k ] ; } X [ k ] [ j ] /= L [ k ] [ k ] ; } } return new Matrix ( X, n, nx ) ; }<CODESPLIT>Solve A * X = B<CODESPLIT>1
public java. util. List < RecordPatch > getRecordPatches ( ) { ( recordPatches ) recordPatches new com amazonaws internal SdkInternalList RecordPatch ( ) ; } return recordPatches ; }<CODESPLIT>A list of patch operations .<CODESPLIT>1
private void processFields ( ) { List Field fields = Introspection getPersistFields ( embeddableClass ) ; for ( Field field fields ) ( field isAnnotationPresent ( Embedded ) ) processEmbeddedField ( field ) ; } processSimpleField ( field ) ; } } }<CODESPLIT>Processes the given simple ( or primitive ) field and updates the metadata .<CODESPLIT>0
public Observable OperationStatus > updateExplicitListItemAsync ( UUID appId, String versionId, UUID entityId, long itemId, UpdateExplicitListItemOptionalParameter updateExplicitListItemOptionalParameter ) { return updateExplicitListItemWithServiceResponseAsync (,,, itemId, updateExplicitListItemOptionalParameter ) map ( ServiceResponse, ( ) Override public OperationStatus call ( ServiceResponse OperationStatus > response ) { return body ( ) ; } } ) ; }<CODESPLIT>Updates an explicit list item for a Pattern . Any entity .<CODESPLIT>1
public void register ( DiagnosticsPlugin plugin ) { checkNotNull ( plugin,plugin null ) ; if ( enabled ) { return ; } periodMillis = plugin. getPerMillis ( ) ; if ( periodMillis < ) { IllegalArgumentException ( plugin return periodMillis smaller1 ) ; } logger. finest ( plugin. getClass ( ). toString ( ) ( period DISABLEDdisabledenabled ) ) ; if ( periodMillis == DISABLED ) { return ; } pluginsMap. put ( plugin. getClass ( ), plugin ) ; plugin. onStart ( ) ; if ( periodMillis > ) { scheduler. scheduleAtFixedRate ( new WritePluginTask ( plugin ),, periodMillis, ) ; } { addStaticPlugin ( plugin ) ; } }<CODESPLIT>Registers a { @link DiagnosticsPlugin } . <p > This method is thread - safe . <p > There is no checking for duplicate registration . <p > If the { @link Diagnostics } is disabled the call is ignored .<CODESPLIT>1
public CacheManagerTask cleanAreaAsync ( Context ctx, BoundingBox bb, int zoomMin, int zoomMax ) { Cache task new Cache ( this getCAction ( ) bb zoomMin zoomMax ) ; task addCallback ( getCleDialog ( ctx, task ) ) ; return execute ( task ) ; }<CODESPLIT>Remove all cached tiles in the specified area .<CODESPLIT>1
public static List < ExternalGraphic > externalGraphicsFromGraphic ( Graphic graphic ) { List External gList = new ArrayList External ( ) ; for ( graphic. graphSymbols ( ) ) ( ( gs null ) ( gs External ) ) ExternalGraphic externalGraphic = ( ExternalGraphic ) gs ; gList. add ( externalGraphic ) ; } } return gList ; }<CODESPLIT>Creates a default { @link Style } for a featurecollection .<CODESPLIT>0
public ArrayClassInfo getArrayClassInfo ( String typeClassName, Type arrayType ) {ClassInfo getDelClassInfo ( array ( ) ) ; return new ArrayClassInfo ( typeClassName, elementClassInfo ) ; }<CODESPLIT>For array types the previous implementation used the element name .<CODESPLIT>0
public void free ( ) {Panel panel ( CalendarPanel ) JBasePanel getSubScreen ( this, CalendarPanel ) ; ( panel ) panel free ( ) ; super free ( ) ; }<CODESPLIT>Free the sub = components .<CODESPLIT>1
public final void ruleXMemberFeatureCall ( ) throws RecognitionException { stack = keepStackSize ( ) ; { { { ( backtracking ) before ( grammarAccess. getXMemberFeatureCallAccess ( ). getGroup ( ) ) ; } { (2 ) ; rule__XMemberFeatureCall__Group__0 ( ) ;fsp -- ; ( ) return ; } ( backtracking ) after ( grammarAccess. getXMemberFeatureCallAccess ( ). getGroup ( ) ) ; } } } } ( RecognitionException ) reportError ( re ) ; recover ( input, re ) ; } restoreStackSize ( stackSize ) ; } return ; }<CODESPLIT>InternalXbase . g : 633 : 1 : entryRuleXMemberFeatureCall : ruleXMemberFeatureCall EOF ;<CODESPLIT>0
protected String signAndBase64Encode ( byte [ ] data, String key, SigningAlgorithm algorithm ) throws SdkClientException { { byte signature = sign ( data, key. getBytes ( UTF8 ), algorithm ) ; return Base64. encodeAsString ( signature ) ; } ( ) { throw SdkClientException ( calculate request signature. ( ) ) ; } }<CODESPLIT>Computes an RFC 2104 - compliant HMAC signature for an array of bytes and returns the result as a Base64 encoded string .<CODESPLIT>1
private void ProcessNextStep ( ) { ( iSelectionStep ) { SELECTSOURCECATALOG SELECTDESTCATALOG ( CatalogToSelect ( ) ) fMain. show ( ) ; return ; } ; SELECTDESTSCHEMA SELECTSOURCESCHEMA ( SchemaToSelect ( ) ) fMain. show ( ) ; return ; } ; SELECTSOURCETABLES (TransferMode == TRFMTRANSFER ) bStart. setLabel (Start Transfer ) ; } if (TransferMode == TRFMDUMP ) { bStart. setLabel (Start Dump ) ; } if (TransferMode == TRFMRESTORE ) { bStart. setLabel (Start Restore ) ; } bStart. invalidate ( ) ; bStart. setEnabled ( false ) ; lTable. setMultipleMode ( false ) ; RefreshMainDisplay ( ) ; ; default : break ; } }<CODESPLIT>Method declaration<CODESPLIT>0
JsonRepresentation asEventRepr ( EventMetadata metadata, final JsonRepresentation payloadRepr ) { JsonRepresentation eventRe = JsonRepresentation newMap ( ) ; JsonRepresentation metadataRe = JsonRepresentation newMap ( ) ; eventRe mapPut (metadata, metadataRe ) ; metadataRe mapPut (, metadata getId ( ) ) ; metadataRe mapPut (transactionId, metadata getTransactionId ( ) ) ; metadataRe mapPut (sequence, metadata getSequence ( ) ) ; metadataRe. mapPut (eventType, metadata. getEventType ( ) ) ; metadataRe. mapPut (user, metadata. getUser ( ) ) ; metadataRe. mapPut (timestamp, metadata. getTimestamp ( ) ) ; eventRe. mapPut (payload, payloadRe ) ; return eventRepr ; }<CODESPLIT>Set up the screen fields ( default = set them all up for the current record ) .<CODESPLIT>0
public float dot ( IntFloatVector y ) { if ( y IntFloatSortedVector ) { IntFloatSortedVector other = ( ( IntFloatSortedVector ) y ) ; float dot = 0 ; oc = 0 ; for ( c c used c ) { while ( < other. used ) { if ( other. indices oc < indices c ) { ++ ; } if ( indices c == other. indices oc ) { dot += values [ c * other. values [ ; ; } { ; } } } return dot ; } { float dot = 0 ; for ( c c used c ) { dot += this. values [ c * y. get ( indices [ c ) ; } return dot ; } }<CODESPLIT>Computes the dot product of this vector with the other vector .<CODESPLIT>1
protected final PrcRefreshCatalog lazyGetPrcRefreshCatalog ( final Map < String, Object > pAddParam ) throws Exception { beanName = PrcRefreshCatalog class ( ) ; PrcRefreshCatalog proc = ( PrcRefreshCatalog ) this processorsMap ( beanName ) ; ( ) = new PrcRefreshCatalog ( ) ; procListeners ( ). add ( this.PublicTradeProcessors. lazyGetPrcWebstorePage ( pAddParam ) ) ; this processorsMap put ( beanName, proc ) ; this logger info ( null, FBTradeProcessors, beanName has created." ) ; } return proc ; }<CODESPLIT><p > Lazy get PrcRefreshCatalog . < / p ><CODESPLIT>1
private static String buildMessage ( final String id ) { ( ) return NULLMESSAGE ; } return format ( INVALID_FMT, id ) ; }<CODESPLIT>Build the exception s message using the <tt > id< / tt > value .<CODESPLIT>1
public double [ ] getMoneynessAsOffsets ( ) { DoubleStreamness getGridNodesMoneyness ( ) ( ) stream ( ) mapToDouble ( Integer ) ; ( quoting Qu PAY ) moneyness moneyness. map ( new DoubleUnaryOperator ( ) { @ Override public double applyAsDouble ( double x ) { return x * 001 ; } } ) ; } ( quoting QuPRI ) moneyness moneyness. map ( new DoubleUnaryOperator ( ) { @ Override public double applyAsDouble ( double x ) { return - x * 00001 ; } } ) ; } moneyness moneyness. map ( new DoubleUnaryOperator ( ) { @ Override public double applyAsDouble ( double x ) { return x * 0.0001 ; } } ) ; } return moneyness. toArray ( ) ; }<CODESPLIT>Return all valid maturities for a given moneyness . Uses the fixing times of the fix schedule to determine fractions .<CODESPLIT>0
public Frustum setToProjection ( double left, double right, double bottom, double top, double near, double far, IVector3 nearFarNormal, boolean ortho, boolean mirrored ) { double n = nearFarNormal. x ( ), ny = nearFarNormal. y ( ), nz = nearFarNormal. z ( ) ; if ( ) { double nrz = - 1f / nz ; double xl = nx * left * nrz, = nx * right * nrz ; double yb = ny * bottom * nrz, yt = ny * top * nrz ; _vertices 0. set ( left, bottom, xl + yb - near ) ; _vertices mirrored 3 : 1. set ( right, bottom, xr + yb - near ) ; _vertices. set ( right, top, xr + y - near ) ; _vertices mirrored 1 : 3. set ( left, top, xl + y - near ) ; _vertices. set ( left, bottom, xl + yb - far ) ; _vertices mirrored : 5. set ( right, bottom, xr + yb - far ) ; _vertices. set ( right, top, xr + y - far ) ; _vertices mirrored 5 :. set ( left, top, xl + y - far ) ; } { double = 1f / near ; doublen = left *, rrn = right * ; double brn = bottom *, trn = top * ; double nz = near * nz ; double z0 = nz / ( n lr + ny br - nz ) ; _vertices 0. set ( - z0 lr, - z0 br, z0 ) ; double z1 = nz / ( n rr + ny br - nz ) ; _vertices mirrored 3 : 1. set ( - z1 rr, - z1 br, z1 ) ; double z2 = nz / ( n rr + ny tr - nz ) ; _vertices. set ( - z2 rr, - z2 tr, z2 ) ; double z3 = nz / ( n lr + ny tr - nz ) ; _vertices mirrored 1 : 3. set ( - z3 lr, - z3 tr, z3 ) ; double fz = far * nz ; double z4 = fz / ( n lr + ny br - nz ) ; _vertices. set ( - z4 lr, - z4 br, z4 ) ; double z5 = fz / ( n rr + ny br - nz ) ; _vertices mirrored : 5. set ( - z5 rr, - z5 br, z5 ) ; double z6 = fz / ( n rr + ny tr - nz ) ; _vertices. set ( - z6 rr, - z6 tr, z6 ) ; double z7 = fz / ( n lr + ny tr - nz ) ; _vertices mirrored 5 :. set ( - z7 lrn, - z7 trn, z7 ) ; } updateDerivedState ( ) ; return this ; }<CODESPLIT>Sets this frustum to an orthographic one pointing in the Z - direction with the specified parameters determining its size ( see the OpenGL documentation for <code > glOrtho< / code > ) .<CODESPLIT>0
private String parameterToString ( Object param ) { ( param null ) return "" ; } ( param Date ) return formatDate ( ( Date ) param ) ; } ( param Collection ) StringBuilder b = new StringBuilder ( ) ; for ( ( Collection ) param ) ( b length ( ) ) b. ( "," ) ; } b. ( String. valueOf ( o ) ) ; } return b. toString ( ) ; } return String. valueOf ( param ) ; } }<CODESPLIT>Reads a buffer .<CODESPLIT>0
public static T > T validateNotNull ( T value, String errorMsgTemplate, Object... params ) throws ValidateException { ( ( ) ) Validate ( errorMsg params ) ; } return value ; }<CODESPLIT>检查指定值是否为<code > null< / code ><CODESPLIT>0
public final void setCommitTrigger ( CommitTrigger commitTrigger ) { ( this commitTrigger commitTrigger ) return ; } ( this commitTrigger ) this commitTrigger removeCommitTriggerListener ( commitTriggerHandler ) ; this commitTrigger = null ; } ( commitTrigger ) ( this commitTriggerHandler ) this commitTriggerHandler = new CommitTriggerHandler ( ) ; } this. commitTrigger = commitTrigger ; this commitTrigger addCommitTriggerListener ( commitTriggerHandler ) ; } }<CODESPLIT>Sets the <code > CommitTrigger< / code > that triggers the commit and flush events .<CODESPLIT>1
public static String getRelativeSubPath ( String base, String path ) { result = null ; base = CmsStringUtil joinPaths ( base, "/" ) ; path = CmsStringUtil joinPaths ( path, "/" ) ; ( path ( base ) ) result = path ( base length ( ) ) ; } ( result null ) ( result ( "/" ) ) result = result. (, result. length ( ) ) ; } ( result ( "/" ) ) result = "/" + result ; } } return result ; }<CODESPLIT>Returns <code > true< / code > if the provided Objects are either both <code > null< / code > or equal according to { @link Object#equals ( Object ) } . <p ><CODESPLIT>0
private void readMoreBytesFromStream ( ) throws IOException { ( innerStreamHasMoreData ) return ; } bufferSpaceAvailable = buffer. length bytesInBuffer ; ( bufferSpaceAvailable ) return ; } = stream. read ( buffer, bytesInBuffer, bufferSpaceAvailable ) ; ( ) innerStreamHasMoreData = false ; } bytesInBuffer += bytesRead ; } }<CODESPLIT>Fill the buffer with more data from the InputStream if there is any .<CODESPLIT>1
@ Override public GetPlanResult getPlan ( GetPlanRequest request ) { request beforeClientExecution request return executeGet ( request ) }<CODESPLIT><p > Retrieves a specified security configuration . < / p ><CODESPLIT>0
public void println ( final String str ) throws IOException { this writer print ( str ) ; this. writer. print ( ) ; this writer flush ( ) ; }<CODESPLIT>{<CODESPLIT>0
@ Generated ( value = {comthreeringspresentsGenDObjectTask } ) public void setPeerService ( PeerMarshaller value ) { PeerMarshaller ovalue = this. peerService ; requestAttributeChange ( valuevalue ) ; this. peerService = value ; }<CODESPLIT>Requests that the <code > bootStamp< / code > field be set to the specified value . The local value will be updated immediately and an event will be propagated through the system to notify all listeners that the attribute did change . Proxied copies of this object ( on clients ) will apply the value change when they received the attribute changed notification .<CODESPLIT>0
public String replaceDocRootDir ( String htmlstr ) { index = htmlstr. indexOf (@" ) ; ( index < ) return htmlstr ; } docrootMatcher = docrootPattern. ( htmlstr ) ; ( docrootMatcher find ( ) ) return htmlstr ; } StringBuilder buf = new StringBuilder ( ) ; prevEnd = ; do { match = docrootMatcher. start ( ) ; buf. ( htmlstr. ( prevEnd, match ) ) ; prevEnd = docrootMatcher. end ( ) ; ( configuration docrootparent length ( ) htmlstr ( "/ prevEnd ) ) buf. ( configuration. docrootparent ) ;End += ; } buf. ( pathToRoot. isEmpty ( ) "." : pathToRoot. getPath ( ) ) ; } ( prevEnd < htmlstr length ( ) htmlstr ( prevEnd ) ) buf. ( ) ; } } while ( doc ( ) ) ; buf. ( htmlstr. ( prevEnd ) ) ; return buf. toString ( ) ; }<CODESPLIT>Programmatic interface .<CODESPLIT>0
public static List < String > getPropertyNames ( Object obj ) { List propertyNames = new ArrayList String ( ) ; ( obj == null ) return propertyNames ; } List cycleDetect = new ArrayList ( ) ; performGetPropertyNames ( obj, null, propertyNames, cycleDetect ) ; return propertyNames ; } }<CODESPLIT>Recursively gets names of all properties implemented in specified object and its subobjects .<CODESPLIT>1
public boolean checkLocks ( boolean exclusive, int depth ) { ( checkParents ( checkChildren ( ) ) return true ; } return false ; }<CODESPLIT>checks if a lock of the given exclusivity can be placed only considering children up to depth<CODESPLIT>1
private static void createFactoryInstance ( ) { try { Class cls = Class. forName ( MP_SELECTOR_EVALUATOR_FACTORY_CLASS ) ; instance = ( MPSelectorEvaluatorFactory ) cls. newInstance ( ) ; } ( ) {. ( e, "sibprocessorMPSelectorEvaluatorFactorycreateFactoryInstance, "100 ) ; throw ( ) ; } }<CODESPLIT>Create the singleton Factory instance .<CODESPLIT>1
public NotificationChain basicSetUniformDistribution ( UniformDistributionType newUniformDistribution, NotificationChain msgs ) { return ( (Map Internal ) getMixed ( ) ) basicAdd ( BpsimPackageROOTUNIFORMDISTRIBUTION,Uniform, msgs ) ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>1
private EntityManager getEntityManager ( ) { EntityManager em ; ( Tx isActive ( transaction ) ) em ( EntityManager ) transactionSynchronizationRegistry getResource ( unitName ) ; ( em ) em createEntityManager ( ) ; transactionSynchronizationRegistry registerInterSynchronization ( new TxSynchronization ( em ) ) ; transactionSynchronizationRegistry putResource ( unitName, em ) ; } validateCompatibleSyncTypes ( em ) ; } } em nonTxEmHolder getEntityManager ( ) ; ( em ) em createEntityManager ( ) ; nonEmHolder setEntityManager ( em ) ; } } return em ; }<CODESPLIT>Subscribes to an event dispatcher and starts a watch for a given key .<CODESPLIT>0
public FSArray getItemList ( ) { if ( ListType featOkTst ( ( ListType ) jcasType ) casFeatitemList == null ) jcasType jcas. throwFeatMissing (itemListdeList ) ; return ( FSArray ) ( jcasType. ll_cas. ll_getFSForRef ( jcasType. ll_cas. ll_get ( addr, ( ( List_Type ) jcasType ). casFeatCode_itemList ) ) ) ; }<CODESPLIT>setter for itemList - sets contains items of the level 1 . The items of the level 1 could contain further items of next level and so on in order to represent an iterative structure of list items .<CODESPLIT>0
public PushRules createPushRules ( Object projectIdOrPath, PushRules pushRule ) throws GitLabApiException { GitLabApiForm formData = new GitLabApiForm ( ). (dendeletetag, pushRule. getDDeleteTag ( ) ). (membercheck, pushRule. getMemberCheck ( ) ). (secrets, pushRule. getPreSecrets ( ) ). withParam (commitmessageregex, pushRule.CommitMessageRegex ( ) ). withParam (branchnameregex, pushRule. getBranchNameRegex ( ) ). withParam (authoremailregex, pushRule.AuthorEmailRegex ( ) ). withParam (filenameregex, pushRule. getFileNameRegex ( ) ). withParam (maxfilesize, pushRule. getMaxFileSize ( ) ) ; Response response = post ( Response.. CREATED, formData,projects, getProjectIdOrPath ( projectIdOrPath ),push ) ; return ( response. readEntity ( PushRules. class ) ) ; }<CODESPLIT>Adds a push rule to a specified project .<CODESPLIT>1
public static IsoRecurrence < DateInterval > of ( int count, PlainDate start, Duration < IsoDateUnit > duration ) { check ( count ) ; ( ) ( start interval ) ; } return new RecurrentDateIntervals ( count, TYPE_START_DURATION, start, duration ) ; }<CODESPLIT>/ * [ deutsch ] <p > Erzeugt eine Sequenz von wiederkehrenden Datumsintervallen mit der angegebenen Dauer . < / p ><CODESPLIT>1
private static String upperCaseHex ( String s ) { char chars [ ] = s. toCharArray ( ) ; int length = s. length ( ) ; for ( length ) { switch ( chars [ i ] ) { case : chars [ ='' ; ; case'' : chars [ ='' ; ; case'' : chars [ ='' ; ; case'' : chars [ ='' ; ; case'' : chars [ ='' ; ; case'' : chars [ ='' ; ; } } return new String ( chars ) ; }<CODESPLIT>/ * Efficiently converts a string containing a hexadecimal number from lower case to upper case<CODESPLIT>1
static ImmutableList < NameValuePair > buildParameters ( String analyticsId, String clientId, String virtualPageName, String virtualPageTitle, String eventType, String eventName, boolean isUserSignedIn, boolean isUserInternal, Optional < Boolean > isUserTrialEligible, Optional < String > projectNumberHash, Optional < String > billingIdHash, Optional < String > clientHostname, Random random ) { checkNotNull ( analyticsId ) ; checkNotNull ( clientId ) ; checkNotNull ( virtualPageTitle ) ; checkNotNull ( virtualPageName ) ; checkNotNull ( eventType ) ; checkNotNull ( eventName ) ; checkNotNull ( projectNumberHash ) ; checkNotNull ( billingIdHash ) ; checkNotNull ( clientHostname ) ; checkNotNull ( random ) ; ImmutableList Builder NameValuePair listBuilder = new ImmutableList Builder ( ) ; listBuilder add ( new BasicValuePair ( PARAMPROTOCOL ) ) ; listBuilder add ( new BasicValuePair ( PARAMPROPERTYID analyticsId ) ) ; listBuilder add ( new BasicValuePair ( PARAMTYPE VALUETYPEPAGEVIEW ) ) ; listBuilder add ( new BasicNameValuePair ( PARAMISNONINTERACTIVE VALUEFALSE ) ) ; listBuilder add ( new BasicNameValuePair ( PARAMCACHEBUSTER Long toString ( random nextLong ( ) ) ) ) ; listBuilder add ( new BasicNameValuePair ( PARAMEVENTTYPE eventType ) ) ; listBuilder add ( new BasicNameValuePair ( PARAMEVENT eventName ) ) ; (Hostname ( )Hostname ( ) isEmpty ( ) ) listBuilder add ( new BasicNameValuePair ( PARAMHOST clientHostname ( ) ) ) ; } listBuilder add ( new BasicNameValuePair ( PARAMCLIENTID clientId ) ) ; ( projectNumberHash ( ) projectNumberHash ( ) isEmpty ( ) ) listBuilder add ( new BasicNameValuePair ( PARAMPROJECTNUMHASH projectNumberHash ( ) ) ) ; } ( billingIdHash ( ) billingIdHash ( ) isEmpty ( ) ) listBuilder add ( new BasicNameValuePair ( PARAMBILLIDHASH billingIdHash ( ) ) ) ; } listBuilder add ( new BasicNameValuePair ( PARAMUSERSIGNEDIN toValue ( isUserSignedIn ) ) ) ; listBuilder add ( new BasicNameValuePair ( PARAMUSER toValue ( isUserInternal ) ) ) ; ( isUserTriEligible ( ) ) listBuilder add ( new BasicNameValuePair ( PARAMUSERTRIALELIGIBLE toValue ( isUserTriEligible ( ) ) ) ) ; } listBuilder add ( new BasicNameValuePair ( PARAMISVIRTUAL VALUETRUE ) ) ; listBuilder add ( new BasicNameValuePair ( PARAMPAGE virtualPageName ) ) ; ( virtualTitle isEmpty ( ) ) listBuilder add ( new BasicNameValuePair ( PARAMPAGETITLE virtualPageTitle ) ) ; } return listBuilder. build ( ) ; }<CODESPLIT>Adds more data providers to the validator .<CODESPLIT>0
@ Override public void insert ( CharSequence text ) throws IOException { ln = text. length ( ) ; if ( ln == ) { return ; } if ( ln >= size ( end - cursor ) ) { throw IOException ( text " fit buffer ) ; } if ( cursor end ) { makeRoom ( ln ) ; } for ( ln ) { set ( ( cursor + ), text. charAt ( ) ) ; } end += ln ; }<CODESPLIT>Inserts text at cursor position<CODESPLIT>1
public void onNewTab ( final AjaxRequestTarget target, final T tab, final int index ) { ( ( index ) ( indexabs ( ) ( ) ) ) IndexOutOfBoundsException ( ) ; }abs ( ) add ( index ) ; setSelectedTab ( index ) ; target add ( this ) ; }<CODESPLIT>On new tab .<CODESPLIT>1
public static void outputImage ( int w, int h, OutputStream os, String code ) throws IOException { verifySize = code. length ( ) ; BufferedImage image = new BufferedImage ( w, h, BufferedImage. TYPEINTRGB ) ; Random rand = new Random ( ) ; Graphics2D g2 = image. createGraphics ( ) ; g2. setHint (.,. ) ; Color colors = new Color 5 ; Color colorSpaces = new Color { Color. WHITE, Color. CYAN, Color. GRAY, Color. LIGHT_GRAY, Color. MAGENTA, Color. ORANGE, Color. PINK, Color. YELLOW } ; fractions = new colors. length ; for ( colors. ) { colors [ i = color [ rand. nextInt ( color. length ) ; fractions = rand. nextFloat ( ) ; } Arrays. sort ( fractions ) ; g2. setColor (. GRAY ) ; g2. fillRect ( 0, 0, w, h ) ; Color c = getRandColor ( 200, 250 ) ; g2. setColor ( c ) ; g2. fillRect ( 0,, w, h - 4 ) ; Random random = new Random ( ) ; g2. setColor ( getRColor (, 200 ) ) ; for ( 20 ) { x = random. nextInt ( w - 1 ) ; y = random. nextInt ( h - 1 ) ; xl = random. nextInt ( ) + 1 ; y = random. nextInt ( 12 ) + 1 ; g2. drawLine ( x, y, x xl 40, y yl 20 ) ; } yawpRate =05 ; area = ( ) ( yawpRate w h ) ; for ( area ) { x = random. nextInt ( w ) ; y = random. nextInt ( h ) ; rgb = getRandomIntColor ( ) ; image. setRGB ( x, y, ) ; } shear ( g2, w, h, c ) ; g2. setColor ( getRColor ( 100, ) ) ; fontSize = h - ; font = new (Algerian,. IIC, fontSize ) ; g2. setFont ( font ) ; chars = code. toCharArray ( ) ; for ( verify ) { AffTransform affine = new AffTransform ( ) ; affine. setToRotation (. / rand. nextDouble ( ) ( rand. nextBoolean ( ) - ), ( w / verifySize ) + /, h / ) ; g2. setTransform ( affine ) ; g2. drawChars ( chars,, 1, ( ( w - 10 ) / verifySize ) 5, h / fontSize / - 10 ) ; } g2. dispose ( ) ; ImageIO. write ( image,jpg, os ) ; }<CODESPLIT>生成指定验证码图像文件<CODESPLIT>0
public Object findClosestObject ( int x, int y, int [ ] distance ) { ( _size == ) return null ; } sr = binarySearch ( x ), sl = sr - 1 ;ist = Integer. MAXVALUE, min = - 1 ; for ( boolean expanded true expanded ) { expanded = false ; ( sr < _size ) Record rec = _records [ sr ; if ( x x < mindist ) dist = distance ( rec. x, rec., x, ) ; if ( < mindist ) min = sr ; mindist = dist ; } += ; expanded = true ; } } if ( sl ) Record rec = _records [ sl ; if ( x x < mindist ) dist = distance ( rec. x, rec., x, ) ; if ( < mindist ) min = sl ; mindist = dist ; } sl -= 1 ; expanded = true ; } } } if ( min == ) (Proximity algorithm ) ; } if ( distance null distance length ) distance [ 0 = mindist ; } return _records [ minidx ]. object ; }<CODESPLIT>Removes from the tracker the object that is equal to ( <code > o1 . equals ( object ) < / code > ) the specified object .<CODESPLIT>0
public void setGoldenGrammarErrors ( FSArray v ) { if ( GoldenSentenceType featOkTst ( ( GoldenSentenceType ) jcasType ) casFeatgoldenGrammarErrors == null ) jcasType jcas throwFeatMissing (goldenGrammarErrorsogrouimaGoldenSentence ) ; jcasType. llcas. llset ( addr, ( ( GoldSentenceType ) jcasType ). casFeatCodegoldGrammarErrors, jcasType. llcas. llgetFSRef ( v ) ) ; }<CODESPLIT>setter for goldenGrammarErrors - sets<CODESPLIT>1
Map < CmsPrincipalBean, String > getResponsibles ( CmsObject cms, CmsResource res ) { Map CmsPrincipalBean, String result = new HashMap CmsPrincipalBean, String ( ) ; List CmsResource parentResources = new ArrayList CmsResource ( ) ; { parentResources = cms. readPath ( res, CmsResourceFilter.EXPI ) ; } ( ). error (. ( ) ) ; } for ( CmsResource resource parentResources ) { String storedSiteRoot = cms. ( ). getSiteRoot ( ) ; String sitePath = cms. ( ). removeSiteRoot ( resource. getRootPath ( ) ) ; { cms. ( ). set ( "/" ) ; List CmsAccessControlEntry entries = cms.AccessControlEntries ( resource. getRootPath ( ), false ) ; for ( CmsAccessControl ace entries ) { if ( ace isRes ( ) ) ICmsPrincipal principal = cms. lookupPrincipal ( ace. getPrincipal ( ) ) ; if ( principal null ) CmsPrincipalBean prinBean = new CmsPrincipalBean ( principal. getName ( ), principal. getDescription ( ), principal. isGroup ( ) ) ; if ( resource ( ) ( res ( ) ) ) if ( resource ( ) ( storedSiteRoot ) ) result. put ( prinBean, sitePath ) ; } result. put ( prinBean, resource. getRootPath ( ) ) ; } } result. put ( prinBean, null ) ; } } } } } ( ). info ( with reading responsible users resource. ( ). ( ) ) ; } { cms. ( ). set ( ) ; } } return result ; }<CODESPLIT>Returns the responsibles . <p ><CODESPLIT>1
public static Router post ( String uriTemplate, ContextHandler handler ) { return ( ) post ( uriTemplate handler ) }<CODESPLIT>Performs mapping for all routers .<CODESPLIT>0
public static void descendingOrder ( DMatrixRMaj U, boolean tranU, DMatrixRMaj W, DMatrixRMaj V, boolean tranV ) {Singular =. min ( W. numRows, W. ) ; checkSMatrixSize ( U, tranU, W, V, tranV ) ; for (Singular ) { double bigValue = - 1 ; bigIndex = - 1 ; for (Singular ) { = W. (, ) ; if ( v bigValue ) { bigValue = v ; bigIndex = j ; } } if ( bigIndex == ) ; if ( bigIndex == ) { ; } = W. (, ) ; W. set (,, bigValue ) ; W. set ( bigIndex, bigIndex, tmp ) ; if ( V null ) { swapRowOrCol ( V, tranV,, bigIndex ) ; } if ( U null ) { swapRowOrCol ( U, tranU,, bigIndex ) ; } } }<CODESPLIT>Computes the SVD and sorts singular values in descending order . While easier to use this can reduce performance when performed on small matrices numerous times .<CODESPLIT>0
public ApiSuccessResponse stopMonitoring ( StopMonitoringData stopMonitoringData ) throws ApiException { ApiResponse ApiSuccessResponse stopMonitoringWithHttpInfo ( stopMonitoring ; return getData ( ) ; }<CODESPLIT>Start recording a call Start recording the specified call . Recording stops when the call is completed or you send [ / voice / calls / { id } / stop - recording ] ( / reference / workspace / Voice / index . html#stopRecording ) on either the call or the DN .<CODESPLIT>0
public String getAttributeString ( String attName ) { o = attributes ( att ) ; ( o null ) return null ; } return ( String ) o ; } }<CODESPLIT>Get the value for a given attribute .<CODESPLIT>1
public static ListOptionValue findByGroupId ( long groupId, int start, int end ) { return ( ) findBy ( groupId,, ) ; }<CODESPLIT>Returns a range of all the cp option values where groupId = &#63 ; .<CODESPLIT>1
private static void handleSingletonClass ( String key, String value ) throws Exception { object = handleValue ( value ) ; ( key contains ( "," ) ) interfaces = key split ( "," ) ; for ( interfaces ) serviceMap put ( anInterface, object ) ; } } serviceMap put ( key, object ) ; } }<CODESPLIT>Send email with a string content and attachment<CODESPLIT>0
public static String [ ] split ( final String string, final char separator, final boolean ignoreQuotes ) { Str str = new Str ( string Str char ( separator ) Str ( ) ) ; return strtok. getTokenArray ( ) ; }<CODESPLIT>Normalize and collapse whitespaces from string buffer .<CODESPLIT>0
public ComparisonExpression getLtFilterFromPrefixLike ( ) { ExpressionType rangeComparator = ExpressionType_LESSTHAN ; com extractIncrementLike ( ) ; return rangeFilterFromPrefixLike (left, rangeComparator, comand ) ; }<CODESPLIT>/ Construct the upper bound comparison filter implied by a prefix LIKE comparison .<CODESPLIT>1
public void showForgotPasswordView ( String authToken ) { { CmsTokenValidator validator = new CmsTokenValidator ( ) ; String validationResult = validator. validateToken ( ACmsUI. getCmsObject ( ), authToken, OpenCms. getLoginManager ( ). getTokenLifetime ( ) ) ; if ( validationResult == null ) user = validator. getUser ( ) ; if ( user isManaged ( ) ) CmsSetPasswordDialog dlg = new CmsSetPasswordDialog ( madminCms, user, getLocale ( ) ) ; ACmsUI. ( ). setContentToDialog ( Messages. ( ). ( ACmsUI. ( ). ( ) ). key ( Messages.PWCHANGEHEADER ) + user. ( ), dlg ) ; } Notification. show ( CmsVaadinUtils. getMessageText ( Messages.USERNOTSELFMANAGED1, user. getName ( ) ), Type. ERRORMESSAGE ) ; } } ACmsUI. ( ). setError ( Messages. ( ). ( ACmsUI. ( ). ( ) ). key ( Messages.PWCHANGEINVALIDTOKEN ) ) ;. info (Invalid authorization token authToken / validationResult ) ; } } ( ) {. error (. ( ) ) ; } }<CODESPLIT>Initializes the login view . <p ><CODESPLIT>0
@ WithBridgeMethods ( value SQLServerQuery. class, castRequired true ) public C tableHints ( SQLServerTableHints... tableHints ) { ( tableHints ) hints SQLServerGrammar tableHints ( tableHints ) ; addJoinFlag ( hintsFlag END ) ; } return ( C ) this ; }<CODESPLIT>Set the table hints<CODESPLIT>1
private void populate ( Field field, Object target, String stringValue ) { field. setAccessible ( true ) ; { Class fieldType = field. getType ( ) ; value = TypeConverter. convert ( stringValue ). to ( fieldType ) ; field. set ( target, value ) ; } ( IllegalAccessException ) ( populate field field ) ; } }<CODESPLIT>Populates the specified field on the target with the value from the given option .<CODESPLIT>1
public Object getParameter ( String name ) { try { qname =. getQNameFromString ( name ) ; if ( null == muserParams ) return null ; n = muserParams. size ( ) ; for ( - ) { Arg arg = ( Arg ) m_userParams. elementAt ( ) ; if ( arg.QName ( ). ( qname ) ) { return arg. getVal ( ). object ( ) ; } } return null ; } ( java NoSuchElementException ) { return null ; } }<CODESPLIT>Reset parameters that the user specified for the transformation . Called during transformer . reset () after we have cleared the variable stack . We need to make sure that user params are reset so that the transformer object can be reused .<CODESPLIT>0
private MultipartContent createContent ( final ProblemInput input, final File output, final File source ) throws IOException { HttpMediaType type = new HttpMediaType ( MEDIATYPE ) ; type setParameter ( BOUND createBoundary ( ) ) ; sourceFilePath = new StringBuilder ( PATHPREFIX ) ( source ( ) ) toString ( ) ; MultipartContent content = new MultipartContent ( ) setMediaType ( type ) addPart ( HttpRequestExecutor buildDataPart ( CSRFPARAMETER, values getToken ( ) ) ) addPart ( HttpRequestExecutor buildFilePart ( AWERPARAMETER, output ) ) addPart ( HttpRequestExecutor buildFilePart ( SOURCEFILEPARAMETER, source ) ) addPart ( HttpRequestExecutor buildDataPart ( SOURCEFILEPARAMETER, sourceFilePath ) ). addPart ( HttpRequestExecutor. buildDataPart ( COMMANDPARAMETER, SUBCOMMAND ) ). addPart ( HttpRequestExecutor. buildDataPart ( PROBPARAMETER, input. getPro ( ). getId ( ) ) ). addPart ( HttpRequestExecutor. buildDataPart ( INPUTIDPARAMETER,. ( input. getNumber ( ) ) ) ). addPart ( HttpRequestExecutor. buildDataPart ( NUMSOURCEFILEPARAMETER, DEFAULTNUMSOURCEFILE ) ). addPart ( HttpRequestExecutor. buildDataPart ( AGPARAMETER, DEFAULTAGENT ) ) ; return content ; }<CODESPLIT><p > Created and returns a valid { @link MultipartContent } instance that contains data required for submission . < / p ><CODESPLIT>1
@ SuppressWarnings ( "unchecked" ) public boolean push ( E e ) { (InBucket bucketSize ) buckets. add ( ( ) new bucketSize ) ;InBucket = 0 ; } buckets. getLast ( ) [InBucket = e ; size ++ ; return true ; }<CODESPLIT>This method verifies that this GO has no PCI representation or that the PCI representation is not dirty or new . Otherwise it will throw an exception in order to prevent the dirty state of the GO and the PC to result in conflicting updates in the database .<CODESPLIT>0
static ResultDescriptor resultDescriptor ( ResultDescriptorDTO rDescriptorDTO ) { ResultDescriptor rDescriptor = new ResultDescriptor ( rDescriptorDTO getInterval ( ) ) ; for ( ResultDTO.DTO. getDatasources ( ) ) (Heartbeat ( ) null )Descriptor. datasource ( ds. ( ), ds. getSource ( ), ds.Heartbeat ( ), ds. getFunction ( ) ) ; } rDescriptor datasource ( ds getLabel ( ), ds getSource ( ), ds getFunction ( ) ) ; } } for ( ResultDTO. Expression exprDTO.Expressions ( ) ) rDescriptor expression ( expr getLabel ( ), expr. getExpression ( ) ) ; }Descriptor. export (Descriptor.Exports ( ) ) ; return rDescriptor ; }<CODESPLIT>Visits all nodes in the resource tree bellow the given resource using depth - first search .<CODESPLIT>0
public boolean handleRemoteCriteria ( StringBuffer strFilter, boolean bIncludeFileName, Vector < BaseField > vParamList ) { BaseListenerListener this getNextEnabledListener ( ) ; (Listener ) return ( ( FileListener )Listener ) doRemoteCriteria ( strFilterIncludeFileName vList ) ; return this doRemoteCriteria ( strFilterIncludeFileName vList ) ; }<CODESPLIT>Check to see if this record should be skipped . Generally you use a remote criteria .<CODESPLIT>0
@ POST @ Consumes ( MediaType._JSON ) @ Produces ( MediaType._JSON ) public Response registerWindowsVariant ( WindowsVariant windowsVariant, @ PathParam (pushAppID" ) String pushApplicationID, @ Context UriInfo uriInfo ) { PushApplication pushApp getSearch ( ) findByPushApplicationForDeveloper ( pushApplication ) ; ( push ) return. status (.. NOT_FOUND ). entity ( " not find requested PushApplicationEntity" ). build ( ) ; } validateModelClass ( windowsVariant ) ; } ( ) ( create variant ) ;Builder builder = createBadRequestResponse (Constraint ( ) ) ; return builder. build ( ) ; }. (Register variant Application pushApplicationID ) ;Service addVariant ( windowsVariant ) ; pushAppService addVariant ( pushApp, windowsVariant ) ; return. created ( uriInfo. getAbsolutePathBuilder ( ). path ( String. valueOf ( windowsVariant. getVariantID ( ) ) ). build ( ) ). entity ( windowsVariant ). build ( ) ; }<CODESPLIT>Get a global integer property . This method will first try to get the value from an environment variable and if that does not exist it will look up a system property .<CODESPLIT>0
public static Iterable < Reference > getReferences ( String referenceSetId, OfflineAuth auth ) throws IOException { gen builder ( ) build ( ) fromOffline ( ) ; return Paginator. References. create ( genics ). search ( new SearchReferencesRequest ( ). setReferenceSetId ( referenceSetId ) ) ; }<CODESPLIT>Gets VariantSetIds from a given datasetId using the Genomics API .<CODESPLIT>0
public void put ( String localFile, String remoteTargetDirectory ) throws IOException { put ( new { localFile } remoteTargetDirectory00 ) ; }<CODESPLIT>Copy a local file to a remote directory uses mode 0600 when creating the file on the remote side .<CODESPLIT>1
public synchronized void throttle ( final int bulkMutationRpcTargetMs ) { ( isThrott ) return ; }. info (Initializing BulkMutation throttlingOnce higher ms parallelism reduced." bulkMutationRpcTarget ) ; highTarget = ( ) ( bulkMutationRpcTarget 1 ) ; lowTarget = ( ) ( bulkMutationRpcTargetMs ) ; setCurrentInFlightMaxRcs ( getCurrentInFlightMaxRcs ( ) / 4 ) ; Runnable r = new Runnable ( ) { @ Override public void run ( ) { meanLatencyMs = getMeanMs ( stats. getMutationTimer ( ) ) ; ( meanLatency bulkMutationRpcTarget 3 ) reduceParallelism ( meanLatencyMs, absoluteMaxInFlightRcs / 10 ) ; } ( meanLatency highTarget ) reduceParallelism ( meanLatencyMs, absoluteMaxInFlightRcs / 10 ) ; } ( getMe ( statsThrottTimer ( ) ) ) ( meanLatency <= lowTarget ) increaseParallelism ( meanLatencyMs, absoluteMaxInFlightRcs / 20 ) ; } ( currentInFlightMaxRcs < absoluteMaxInFlightRcs / 20 meanLatency <= ( bulkMutationRpcTarget 2 ) ) increaseParallelism ( meanLatencyMs, absoluteMaxInFlightRcs / 50 ) ; } } } private long getMeanMs ( Timer timer ) { return TimeUnit. NANOSECONDS. toMillis ( ( long ) timer. getSnapshot ( ). getMean ( ) ) ; } private void reduceParallelism ( long meanLatencyNanos, int step ) { minimumRpcCount =. max ( absoluteMaxInRpcs / 100, 1 ) ; newValue =. max ( currentInMaxRpcs - step, minimumRpcCount ) ; setParallelism ( meanLatencyNanos,Redu, newValue ) ; } private void increaseParallelism ( long meanLatencyNanos, int incrementStep ) { newValue =. min ( currentInMaxRpcs incrementStep, absoluteMaxInRpcs ) ; setParallelism ( meanLatencyNanos,Increasing, newValue ) ; } private void setParallelism ( long meanLatencyNanos, String type, int newValue ) { currentValue = getCurrentInMaxRpcs ( ) ; ( newValue currentValue ) setCurrentInFlightMaxRcs ( newValue ) ;. (Latency ms paral from to.".OSECONDS. ( meanLatencyNanos ) type newValue ) ; } } } ; BigtableSessionSharedThreadPools. getInstance ( ). getRetryExecutor ( ). scheduleAtFixedRate ( r, 20, 20,. SECONDS ) ; isThrottling = true ; }<CODESPLIT>Enable an experimental feature that will throttle requests made from {<CODESPLIT>1
public static UncheckedBinary fromBase64 ( String base64 ) { StringBuilder normalizedBase64 = new StringBuilder ( base64. length ( ) + ) ; for ( base64. ( ) ) { c = base64. charAt ( ) ; if ( == ) = ; if ( c == ) c = ; if ( c == ) c = ; normalizedBase64. append ( c ) ; } while ( normalizedBase64. ( ) % 4 ) { normalizedBase64. append ('' ) ; } byte bytes = DatatypeConverter. parseBase64Binary ( normalizedBase64. toString ( ) ) ; return Binary. from ( bytes ) ; }<CODESPLIT>Reads standard and URL / filename - safe Base 64 dialects as described in RFC 4686 . Additionally it accepts not Base 64 encoded strings without padding or allows to use dot character ( . ) as padding character .<CODESPLIT>1
boolean isMatch ( Class beanType, Object id ) { return beanType equals ( this beanType ) idMatch ( id ) ; }<CODESPLIT>Checks that the supplied parameter is not null . Throws a {<CODESPLIT>0
private String formatPriority ( Priority value ) { result = null ; ( value null ) priorityTypes =Data. getStringArray ( mlocale, LocaleData. PRIORITYTYPES ) ; priority = value. getValue ( ) ; ( priority < Priority LOWEST ) priority = Priority. LOWEST ; } ( priority PriorityNOTLEVEL ) priority = Priority. DO_NOT_LEVEL ; } } priority /= 100 ; result = priorityTypes [ priority - 1 ; } return ( result ) ; }<CODESPLIT>This method is called to format a task type .<CODESPLIT>0
public static int cuMempyPeer ( CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, long ByteCount ) { return cuMemNative (,,,, ByteCount ) }<CODESPLIT>Copies device memory between two contexts .<CODESPLIT>1
private GraphCentricQueryBuilder has ( String key, TitanPredicate predicate, Object condition ) { checkNotNull ( key ) ; checkNotNull ( predicate ) ; checkArgument ( predicate isValidCondition ( condition ),Invalid condition, condition ) ; constraints add ( new PredicateCondition ( key predicate condition ) ) ; return this ; }<CODESPLIT>/ * --------------------------------------------------------------- Query Execution ---------------------------------------------------------------<CODESPLIT>0
private void changeReplicas ( PrimaryTerm term ) { threadContext. execute ( ( ) { ( this term term term ( ) this term term ( ) ) this. term = term ; consumer register ( term primary ( ) memberId ( ) ) ; } } ) ; }<CODESPLIT>Handles a replica change event .<CODESPLIT>1
public void translate ( Vector3D <?,? > translation ) { this03 += translation ( ) ; this13 += translation ( ) ; this m23 += translation getZ ( ) ; }<CODESPLIT>Translate the position .<CODESPLIT>1
public static float getFloat ( float value, float minValue, float maxValue ) { return min ( maxValue, max ( minValue, ) ) ; }<CODESPLIT>Return a float value within the range . <p > This is just a wrapper for Math . min () and Math . max () . This may be useful if you feel it confusing ( Which is min and which is max? ) . < / p ><CODESPLIT>1
@ Destroy ( priority AutumnActionPriority. MIN_PRIORITY ) public void savePreferences ( ) {Set Preferences preferencesToFlush = GdxSets newSet ( ) ; for ( Preference preference preferences ) Preferences preferencesFile = namesToFiles ( preference. key ) ; preferencesToFlush. add ( preferencesFile ) ; preference. value. save ( preference. key, preferencesFile ) ; } for ( Preferences preferences preferencesToFlush ) preferencesFile. flush ( ) ; } }<CODESPLIT>Saves all current preferences . This is a reasonably heavy operation as it flushes all preferences files - by default this is done once before the application is closed .<CODESPLIT>1
public void unsubscribe ( final Subscription < T > subscription ) { token = subscription. getToken ( ) ;. log (. FINERRemoteManager {0} token {1}", new { this. name, token } ) ; if ( token Exception ) this. transport. registerErrorHandler ( null ) ; } if ( token Tuple2 ) this. tupleToHandlerMap. remove ( token ) ; } if ( token Class ) this. msgTypeToHandlerMap. remove ( token ) ; } Remote (Unknown subscription type subscription. ( ). ( ) ) ; } }<CODESPLIT>Unsubscribes a handler .<CODESPLIT>1
public static SymbolList toDnaSymbolList ( final Sequence sequence ) throws IllegalSymbolException { checkNotNull ( sequence ; returnTools createDN ( sequence getValue ( ) replaceAll (, "" ) ) ; }<CODESPLIT>Convert the specified HML Sequence element into a DNA symbol list .<CODESPLIT>1
private boolean processArguments ( String [ ] args ) { if ( args. length < 1 ) { System. err. println ( messages. get ( "argument" ) ) ; return false ; } setCustomMessageFileFromEnvironment ( ) ; Pattern argPattern = Pattern. compile ( "--?(.* ) ; for ( args. length ) { argMatch = argPattern. matcher ( args [ ) ; if ( argMatch. matches ( ) ) { ( argMatch. group ( ) ) { "v ( args. length ) ++ i ; if ( args [. equals (2" ) args [. equals (2" ) ) { version = EPUBVersion. VERSION_2 ; } if ( args [. equals (3" ) args [. equals (3" ) ) { version = EPUBVersion. VERSION_3 ; } { outWriter. println ( messages. get ( "displayhelp" ) ) ; throw RuntimeException ( InvalidVersionException ( InvalidVersionException. UNSUPPORTEDVERSION ) ) ; } } { outWriter. println ( messages. get ( "displayhelp" ) ) ; throw RuntimeException ( messages. get ( "versionargumentexpected ) ) ; } ; " " ( args. length ) mode = args [ ++ i ; expanded = mode. equals ( "exp" ) ; } { outWriter. println ( messages. get ( "displayhelp" ) ) ; throw RuntimeException ( messages. get ( "modeargumentexpected ) ) ; } ; "p "profile ( args. length ) String profileStr = args ++ ; try { profile = EPUBProfile. valueOf ( profileStr. toUpperCase ( Locale. ROOT ) ) ; } ( IllegalArgumentException ) { System. err. println ( messages. get ( "modeversionignored", profileStr ) ) ; profile = EPUBProfile. DEFAULT ; } } { outWriter. println ( messages. get ( "displayhelp" ) ) ; throw RuntimeException ( messages. get ( "profileargumentexpected ) ) ; } ; " "save = true ; ; "o "out ( ( args. length ( ) ) &&! ( args. startsWith ( "-" ) ) ) fileOut = new File ( args ++ ) ; } if ( ( args. length > ( + 1 ) ) ( args [ + 1. equalsIgnoreCase ( "-" ) ) ) { fileOut = null ; ++ ; } { File pathFile = new File ( path ) ; if ( pathFile. isDirectory ( ) ) { fileOut = new File ( pathFile. getAbsoluteFile ( ). getParentFile ( ), pathFile. getName ( ) + "checkxml" ) ; } { fileOut = new File ( path + "checkxml" ) ; } } xmlOutput = true ; ; "j "json ( ( args. length ( ) ) &&! ( args. startsWith ( "-" ) ) ) fileOut = new File ( args ++ ) ; } if ( ( args. length > ( + 1 ) ) ( args [ + 1. equalsIgnoreCase ( "-" ) ) ) { fileOut = null ; ++ ; } { File pathFile = new File ( path ) ; if ( pathFile. isDirectory ( ) ) { fileOut = new File ( pathFile. getAbsoluteFile ( ). getParentFile ( ), pathFile. getName ( ) + "checkjson" ) ; } { fileOut = new File ( path + "checkjson" ) ; } } jsonOutput = true ; ; " "mp ( ( args. length ( ) ) &&! ( args. startsWith ( "-" ) ) ) fileOut = new File ( args ++ ) ; } if ( ( args. length > ( + 1 ) ) ( args [ + 1. equalsIgnoreCase ( "-" ) ) ) { fileOut = null ; ++ ; } { File pathFile = new File ( path ) ; if ( pathFile. isDirectory ( ) ) { fileOut = new File ( pathFile. getAbsoluteFile ( ). getParentFile ( ), pathFile. getName ( ) + "checkxmp" ) ; } { fileOut = new File ( path + "checkxmp" ) ; } } xmpOutput = true ; ; "i "info reportingLevel = ReportingLevel. Info ; ; "f "fatal reportingLevel = ReportingLevel. Fatal ; ; "e "error reportingLevel = ReportingLevel. Error ; ; " "warn reportingLevel = ReportingLevel. Warning ; ; "u "usage reportingLevel = ReportingLevel. Usage ; ; " "quiet outWriter. setQuiet ( true ) ; ; "failwarnings String fw = args. (failwarnings. length ( ) ) ; failOnWarnings = ( fw. compareTo ( "-" )!= 0 ) ; ; "r "redir ( args. length ) fileOut = new File ( args ++ ) ; } ; " "customMessages ( args. length ) String fileName = args + 1 ; if ( "none". compareTo ( fileName. toLowerCase ( Locale. ROOT ) ) == ) { customMessageFile = null ; useCustomMessageFile = false ; ++ i ; } if (! fileName. startsWith ( "-" ) ) { customMessageFile = new File ( fileName ) ; useCustomMessageFile = true ; ++ i ; } { System. err. println ( String. format ( messages. get ( "messagefilename" ), fileName ) ) ; displayHelp ( ) ; return false ; } } ; "l "listChecks ( args. length ) if (! args [ + 1. startsWith ( "-" ) ) { listChecksOut = new File ( args ++ ) ; } { listChecksOut = null ; } } listChecks = true ; ; " ( args. length ) if ( args [ + 1. startsWith ( "-" ) ) { System. err. println ( String. format ( messages. get ( "inlocale" ), args [ + 1 ) ) ; displayHelp ( ) ; return false ; } { String langTag = args ++ ; this. locale = Locale. forLanguageTag ( langTag ) ; this. messages = Messages. getInstance ( this. locale ) ; } } { System. err. println ( String. format ( messages. get ( "locale" ) ) ) ; displayHelp ( ) ; return false ; } ; "h "?" "help displayHelp ( ) ; ; "version displayVersion ( ) ; ; default : System. err. println ( String. format ( messages. get ( "unrecognizedargument" ), args [ ) ) ; displayHelp ( ) ; return false ; } } { if ( path == null ) { path = args [ i ; } { System. err. println ( String. format ( messages. get ( "unrecognizedargument" ), args [ ) ) ; displayHelp ( ) ; return false ; } } } if ( ( xmlOutput xmpOutput ) ( xmlOutput jsonOutput ) ( xmpOutput jsonOutput ) ) { System. err. println ( messages. get ( "outputtype" ) ) ; return false ; } if ( path null ) { StringBuilder sb = new StringBuilder ( ) ; for ( path. length ( ) ) { if ( path. charAt ( ) =='' ) { sb. append ('' ) ; } { sb. append ( path. charAt ( ) ) ; } } path = sb. toString ( ) ; } if ( path == null ) { if ( listChecks ) { return true ; } { System. err. println ( messages. get ( "nofilespecified" ) ) ; return false ; } } if ( path. matches ( ".\\.[EePpUuBb]" ) ) { if ( mode null version EPUBVersion. VERSION3 ) { System. err. println ( messages. get ( "modeversionignored" ) ) ; mode = null ; } } if ( mode == null profile == null ) { outWriter. println ( messages. get ( "moderequired" ) ) ; return false ; } return true ; }<CODESPLIT>recursively get the values stored for the given {<CODESPLIT>0
public FieldList move ( int iRelPosition ) throws DBException { m_iLogicalFilePosition = UNKNOWN_POSITION ; FieldList record = this. getNextTable ( ). move (RelPosition ) ;CurrentPosition = mPhysicalFilePosition ; if (RelPosition == DBConstants FIRSTRECORD )CurrentPosition = ; if (RelPosition == DBConstants LASTRECORD ) { if ( mEndOfFileIndex == UNKNOWNPOSITION ) {CurrentPosition = UNKNOWN_POSITION ; }CurrentPosition = mEndOfFileIndex ; }CurrentPosition +=RelPosition ; m_iPhysicalFilePosition = iCurrentPosition ; if ( ( record == null ) ( (RelPosition == DBConstants FIRSTRECORD ) (RelPosition == DBConstants NEXTRECORD ) ) ) mEndOfFileIndex =CurrentPosition ; { if (CurrentPosition ) this addRecordReference (CurrentPosition ) ; m_iLogicalFilePosition = iCurrentPosition ; } return record ; }<CODESPLIT>Find this bookmark in one of the lists .<CODESPLIT>0
public void registerIndexQuery ( long index, Runnable query ) { Runnable queries = this indexQueries compute ( index v new LinkedList ( ) ) ; queries add ( query ) ; }<CODESPLIT>Registers a causal session query .<CODESPLIT>0
public static T > T populateCommand ( T command, String... args ) { CommandLine toCommandLine ( command DefaultFactory ( ; parse ( args ) ; return command ; }<CODESPLIT><p > Convenience method that initializes the specified annotated object from the specified command line arguments . < / p > <p > This is equivalent to < / p > <pre > CommandLine cli = new CommandLine ( command ) ; cli . parse ( args ) ; return command ; < / pre ><CODESPLIT>1
public LogEvent [ ] getLogEvents ( ) { (LogEvents ) return new LogEvent [ 0 ] ; } LogEvent events = new LogEventLogEvents ( ) ; return ( LogEvent [ ] ) mLogEvents. toArray ( events ) ; } }<CODESPLIT>Finds a template based on the given URI . If path ends in a slash revert to loading default template . If default not found or not specified return null .<CODESPLIT>0
@ Requires ( {bytecode nullcontract null ) @ Ensures (result null" ) protected byte [ ] instrumentWithContracts ( byte [ ] bytecode, ContractAnalyzer contracts ) {Reader reader = newReader ( bytecode ) ; writer = new NonLoadingClassWriter ( reader COMPUTEFRAMES | COMPUTEMAXS ) ; SpecificationClassAdapter adapter = new SpecificationClassAdapter ( writer contracts ) ; reader accept ( adapter, ClassReader EXPANDFRAMES ) ; return writer. toByteArray ( ) ; }<CODESPLIT>Processes the specified reader and returns extracted contracts .<CODESPLIT>0
@ Override final public void dissociateConnections ( ) throws ResourceException { ( TraceComponent isAnyTracingEnabled ( ) TRACE isEntryEnabled ( ) ) SibTr. entry ( TRACE,issociateConnections ) ; } for ( _sessions. ( ). ( ) ) { object = iterator. next ( ) ; ( object JmsJcaSessionImpl ) ( ( JmsJcaSessionImpl ) object ). dissociate ( ) ; iterator. remove ( ) ; } } ( TraceComponent isAnyTracingEnabled ( ) TRACE isEntryEnabled ( ) ) SibTr. exit ( this, TRACE,issociateConnections ) ; } }<CODESPLIT>Returns the current global or container local transaction if any for this managed connection . If there is currently no transaction associated with this managed connection calls <code > lazyEnlist< / code > to ensure that one has not been started .<CODESPLIT>0
public com google api ads adwords axis v201809 cm. String_StringMapEntry [ ] getDisplayValue ( ) { return displayValue ; }<CODESPLIT>Gets the parentDimensionValue value for this ProductBiddingCategoryData .<CODESPLIT>0
@ SuppressWarnings (WeakerAccess" ) public ApiFuture < Void > deleteInstanceAsync ( String instanceId ) { instanceName = NameInstanceName ( projectId instanceId ) ; com googletable admin v DeleteInstanceRequest request = com googletable admin v DeleteInstanceRequest newBuilder ( ) setName ( instanceName ) build ( ) ; return ApiFutures. transform ( stub. deleteInstanceCallable ( ). futureCall ( request ), new ApiFunction Empty, Void ( ) @ Override public Void apply ( Empty input ) { return null ; } },Executors directExecutor ( ) ) ; }<CODESPLIT>Asynchronously lists all of the instances in the current project .<CODESPLIT>0
boolean contains ( String normalizedPath ) { ( ) return false ; ( normalized ( ) normalizedRoot ( ) ) return false ; return normalizedPath. regionMatches ( 0, normalizedRoot, 0, normalizedRoot. length ( ) ) ; }<CODESPLIT>Check if the provided path is contained within this root s hierarchy .<CODESPLIT>1
private static boolean checkValidity ( ClientSocket client, byte from, StateConnection expected ) { return from getState ( ) ; }<CODESPLIT>Check if the client is in a valid state .<CODESPLIT>1
@ Override public Request < EnableVpcClassicLinkRequest > getDryRunRequest ( ) { Request EnableVpcLinkRequest request new EnableVpcLinkRequestMarshaller ( ) marshall ( this ) ; request addParameter (DryRun Boolean toString ( true ) ) ; return request ; }<CODESPLIT><p > One or more filters to limit the type of sessions returned by the request . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setFilters ( java . util . Collection ) } or { @link #withFilters ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
private String generateMethodKey ( CtMethod method ) throws NotFoundException { classQualifiedName = method getDeclaringClass ( ) ( ) ; methodSimple = method ( ) ;ClassQualifiedNames =ClassQualifiedNames ( method ) ; return TestMethod. generateMethodKey (QualifiedName, methodSimpleName, argClassQualifiedNames ) ; }<CODESPLIT>( for example when class of method argument type has not been loaded by class loader )<CODESPLIT>0
public static void info ( String format, Object... arguments ) { ( LogFactory indirectGet ( ) arguments ) }<CODESPLIT>Info等级日志，小于Warn<br > 由于动态获取Log，效率较低，建议在非频繁调用的情况下使用！！<CODESPLIT>1
private static CommandLineArgument findCommandLineOption ( String arg ) { for ( CommandLine commandLine CommandLine values ( ) ) ( commandLine match ( arg ) ) return commandLineArgument ; } } return null ; }<CODESPLIT>Not needed until workers support dynamic removal ( currently reload required )<CODESPLIT>0
@ Override public void addInheritedSummaryLabel ( TypeElement typeElement, Content inheritedTree ) { ContentLink = writer getPreQualifiedClassLink ( LinkInfoImpl. MEMBER, typeElement, false ) ; Content label = newContent ( utils ( typeElement ) configuration getText (docletFieldsInheritedFromClass ) configuration getText (docletFieldsInheritedFromInterface ) ) ; Content labelHeading = HtmlTree. HEAD ( HtmlConstants. INHERITSUMMARYHEAD, label ) ; labelHeading. addContent ( Contents. SPACE ) ; labelHeading. addContent (Link ) ; inheritedTree. addContent ( labelHeading ) ; }<CODESPLIT>{<CODESPLIT>0
public static String makeDeepLink ( String link ) { if ( link null getCurrentRemoteConnectionLink ( ) null containsRemoteParameter ( link ) ) { link += ( link ( "?" ) "&" "?" ) PARAMREMOTECONNECTION "=" getCurrentRemoteConnectionLink ( ) ; } return link ; }<CODESPLIT>Adds remote connection parameter to link GET query if parameter yet not present in this link .<CODESPLIT>1
public static Object convert ( String propertyName, String s, Class t, Class propertyEditorClass ) throws JspCoreException { { if ( s == null ) { if ( t ( Boolean ) t ( Boolean TYPE ) ) s =false ; return null ; } if ( propertyEditorClass null ) { return getValueFromBeanInfoPropertyEditor ( t, propertyName, s, propertyEditorClass ) ; } if ( t ( Boolean ) t ( Boolean TYPE ) ) { if ( s (on ) s (true ) ) s =true ; s =false ; return new Boolean ( s ) ; } if ( t ( Byte ) t ( Byte TYPE ) ) { return new Byte ( s ) ; } if ( t ( Character ) t ( Character TYPE ) ) { return s. length ( ) 0? new Character ( s. charAt ( 0 ) ) : null ; } if ( t. ( Short. ) t. ( Short. TYPE ) ) { return new Short ( s ) ; } if ( t. ( Integer. ) t. ( Integer. TYPE ) ) { return new Integer ( s ) ; } if ( t. ( Float. ) t. ( Float. TYPE ) ) { return new Float ( s ) ; } if ( t. ( Long. ) t. ( Long. TYPE ) ) { return new Long ( s ) ; } if ( t. ( Double. ) t. ( Double. TYPE ) ) { return new Double ( s ) ; } if ( t. ( String. ) ) { return s ; } if ( t. ( java. io. File. ) ) { return new java. io. File ( s ) ; } if ( t. getName ( ). (javalangObject ) ) { return new Object [ ] { s } ; } { return getValueFromPropertyEditorManager ( t, propertyName, s ) ; } } ( ) { JspCoreException ( ) ; } }<CODESPLIT>{<CODESPLIT>0
public boolean isGeneralInstance ( ) { ret = ; ( this generalInstance null ) ret = this. generalInstance ; } ( getParent ( ) null ) ret = getParentType ( ) isGeneralInstance ( ) ; } return ret ; }<CODESPLIT>Getter method for the instance variable { @link #generalInstance } .<CODESPLIT>1
public List < CmsPropertyConfig > getPropertyConfiguration ( ) { CmsAConfigData parentData = parent ( ) ; List CmsPropertyConfig parentProperties ; ( ( parentData null ) mdataDiscardInheritedProperties ( ) ) parentProperties = parentData getPropertyConfiguration ( ) ; } parentProperties = Collections emptyList ( ) ; } List CmsPropertyConfig result = combineConfigurationElements ( parentProperties mdataOwnPropertyConfigurations ( ) false ) ; return result ; }<CODESPLIT>Gets the configuration for the available properties . <p ><CODESPLIT>1
public static void removeConsecutiveSeparators ( JPopupMenu popupMenu ) { for ( popupMenu. getComponent ( ) ) { if ( isPopupMenuSeparator ( popupMenu getComponent ( ) ) ) { if ( isPopupMenuSeparator ( popupMenu. getComponent ( ) ) ) { popupMenu. remove ( ) ; -- ; } } } }<CODESPLIT>Removes all top separators from the given pop up menu . <p > For example calling the method on the given menu : <pre > Separator Separator Menu Entry Separator Menu Entry Separator Menu Entry < / pre > would result in : <pre > Menu Entry Separator Menu Entry Separator Menu Entry < / pre ><CODESPLIT>0
protected void writeListNumbers ( final OutputStream result ) throws IOException { ( listLevel ) result write ( RtfList LISTLEVELNUMBER ) ; result write (ToByteArray ( listLevel ) ) ; } }<CODESPLIT>Write the indentation values for this <code > RtfList< / code > .<CODESPLIT>0
private String buildInternalForm ( ) { StringBuffer result = new StringBuffer ( 128 ) ; CmsResource resource = null ; boolean internal = false ; { resource = getCms ( ). readResource ( getParamResource ( ), CmsResourceFilter. ALL ) ; internal = resource. isInternal ( ) ; } ( CmsException ) { LOG. error (. ( ) ) ; } if ( ( resource null ) ( resource. isFile ( ) ) ) { result. append ( "<form action ). append ( getDialogUri ( ) ). append ( methodpost\" nameinternal\" class ) ; result. append ( "<table border0\" width100 ) ; result. append ( "<tr ) ; result. append (< classdialogpermissioncell ). append ( key ( Messages.PERMISSIONINTERNAL0 ) ) ; result. append (input typecheckbox\" name ) ; result. append ( PARAMINTERNAL ) ; result. append ( valuetrue ) ; if ( internal ) { result. append ( checkedchecked ) ; } if (Editable ( ) ) { result. append ( disableddisabled ) ; } result. append ( ) ; if (Editable ( ) ) { result. append ( "<input  typesubmit\" classdialogbutton\" value ). append ( key ( Messages.LABELSET0 ) ). append ( ) ; } result. append ( "</ ) ; result. append ( "</tr ) ; result. append ( "</table ) ; setParamAction ( DIALOGINTERNALUSE ) ; setParamType ( null ) ; setParamName ( null ) ; result. append ( paramsAsHidden ( ) ) ; result. append ( "</form ) ; } return result. toString ( ) ; }<CODESPLIT>Builds a String with HTML code to display the form to add a new access control entry for the current resource . <p ><CODESPLIT>1
public withIntegrationResponses ( java util Map String, IntegrationResponse >Responses ) { setResponses (Responses ) ; return this ; }<CODESPLIT><p > Specifies the integration s responses . < / p > <div class = remarks > <p / > <h4 > Example : Get integration responses of a method< / h4 > <h5 > Request< / h5 > <p / ><CODESPLIT>1
public static String getStateStyle ( CmsResourceState state ) { stateStyle = "" ; ( state null ) ( state isDeleted ( ) ) stateStyle = OpenCmsTheme._DELETED ; } ( state isNew ( ) ) stateStyle = OpenCmsTheme._NEW ; } ( stateChanged ( ) ) stateStyle = OpenCmsTheme._CHANGED ; } } return stateStyle ; }<CODESPLIT>Gets the CSS style name for the given resource state . <p ><CODESPLIT>1
public CloseableResource BlockMasterClient > acquireBlockMasterClientResource ( ) { return new CloseableResource BlockMasterClient (BlockMasterClientPool acquire ( ) ) Override public void close ( ) {Master release ( ( ) ) ; } } ; }<CODESPLIT>Releases a block worker client to the client pools .<CODESPLIT>0
public void setRecommendations ( java. util. Collection < ReservationPurchaseRecommendation > recommendations ) { ( recommendations ) this recommend = null ; return ; } this recommend = new java util ArrayList ReservationPurchaseRecomm ( recommendations ) ; }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public static Point findImage ( BufferedImage image, BufferedImage findme, double tolerance ) { image = image ( ) ; findme = findme ( ) ; ( imageWidth findmeWidth ) image = image ( ) ; findmeHeight = findme ( ) ; ( imageHeight findmeHeight ) return findImage ( getRGB ( image ), imageWidth, imageHeight, getRGB ( findme ), findmeWidth, findmeHeight, tolerance ) ; } } return null ; }<CODESPLIT>Gets the RGB pixels for the given image into a new array .<CODESPLIT>0
@ SuppressWarnings ( "unchecked" ) protected void fireEntryRemoved ( K key, V value ) { ( this listeners null ) for (MapListener super K super V listener this. listeners.Listeners (MapListener. class ) ) listener. entryRemoved ( key, value ) ; } } }<CODESPLIT>Fire the removal event .<CODESPLIT>1
public void setWelcomeFiles ( String [ ] welcomeFiles ) { ( welcomeFiles ) this welcomeFiles Arrays ( welcomeFiles, welcomeFiles length ) ; } }<CODESPLIT>CHECKSTYLE : OFF<CODESPLIT>0
public static void setDebugConfigs ( OneProperties debugConfigsObj, String debugConfigAbsoluteClassPath ) { (Configs null ) Configs. debugConfigs = debugConfigsObj ; } (ConfigAbsoluteClassPath null ) Configs. debugConfigAbsoluteClassPath = debugConfigAbsoluteClassPath ; ConfigsConfigs initConfigs ( ConfigsConfigAbsoluteClassPath ) ; } (Configs null ) ConfigsConfigs initConfigs ( Configs.ConfigAbsoluteClassPath ) ; } }<CODESPLIT><p > Set self define debug configs . < / p > Can use self debug configs path or self class extends { @link OneProperties } .<CODESPLIT>1
public final Optional < extends Style > getStyle ( final String styleName ) { style = this styles ( styleName ) ; ( style ) return this. styleParser. loadStyle ( this, this. clientHttpRequestFactory, styleRef ) ; } return Optional. empty ( ) ; } }<CODESPLIT>Retrieve the configuration of the named template .<CODESPLIT>0
@ Override public ListUsageForLicenseConfiguration listUsageForLicenseConfiguration ( ListUsageForLicenseConfigurationRequest request ) { request beforeClientExecution request executeListUsageForLicense ( request }<CODESPLIT><p > Modifies the attributes of an existing license configuration object . A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager . Components include specifications for the license type ( Instances cores sockets VCPUs ) tenancy ( shared or Dedicated Host ) host affinity ( how long a VM is associated with a host ) the number of licenses purchased and used . < / p ><CODESPLIT>0
public EventConsumerGroup createEventConsumerGroup ( String resourceGroupName, String resourceName, String eventEndpointName, String name ) { return createEventConsumerGroupWithServiceResponseAsync (,, eventEndpoint, name ) toBlocking ( ) single ( ) body ( ) ; }<CODESPLIT>Add a consumer group to an Event Hub - compatible endpoint in an IoT hub . Add a consumer group to an Event Hub - compatible endpoint in an IoT hub .<CODESPLIT>1
public ConstantInfo addConstant ( ConstantInfo constant ) { ConstantInfo info = ( ConstantInfo ) m. ( constant ) ; ( info null ) return info ; }Count = constant getEntryCount ( ) ; ( mIndexed null mPreserveOrder ) = mIndexed. ( ) ; mIndexed setSize ( size + entryCount ) ; mIndexed set ( size constant ) ; } m. put ( constant, constant ) ;Entries += entryCount ; return constant ; }<CODESPLIT>Perform an HTTP GET at the given path returning the results of the response .<CODESPLIT>0
@ Override public void visit ( Column column ) { stringValue = column. getColumnName ( ) ; ( stringValue (true ) stringValue (false ) ) setValue ( Boolean. valueOf ( stringValue ), Types. BOOLEAN ) ; } }<CODESPLIT>Booleans are not recognized by the parser but are seen as column names .<CODESPLIT>1
private HodSearchResult addDomain ( final Iterable < ResourceName > indexIdentifiers, final HodSearchResult document ) { index = document. getIndex ( ) ; domain = null ; for (IdentifierIdentifiers ) ( index ( indexIdentifier ( ) ) ) domain = indexIdentifier. getDomain ( ) ; ; } } ( domain null ) domain =INDEXNAMES. contains ( index ). PUBLICINDEXESDOMAIN : getDomain ( ) ; } return document. toBuilder ( ). domain ( domain ). build ( ) ; }<CODESPLIT>Add a domain to a FindDocument given the collection of indexes which were queried against to return it from HOD<CODESPLIT>1
private URI initiateResumableUpload ( URI batchJobUploadUrl ) throws BatchJobException { HttpRequestFactory requestFactory = httpTransport. createRequestFactory ( req { HttpHeaders headers = createHttpHeaders ( ) ; headers setContentLength ( 0L ) ; headers set (ogresable,start ) ; req setHeaders ( headers ) ; req setLoggingEnabled ( ) ; } ) ; { HttpRequest httpRequest = requestFactory. buildPostRequest ( new GenericUrl ( batchJobUploadUrl ), new EmptyContent ( ) ) ; HttpResponse response = httpRequest. execute ( ) ; ( response getHeaders ( ) null response getHeaders ( ) getLocation ( ) == null ) BatchJobException (Initiate upload Resumable upload URI response ) ; } return URI. create ( response. getHeaders ( ). getLocation ( ) ) ; } ( IOException ) BatchJobException ( initiate upload ) ; } }<CODESPLIT>Post - processes the request content to conform to the requirements of Google Cloud Storage .<CODESPLIT>0
protected String getSelectedValue ( CmsObject cms, List < CmsSelectWidgetOption > selectOptions, String currentValue ) { paramValue = currentValue ; ( CmsStringUtil ( paramValue ) )SelectWidgetOption option CmsSelectWidgetOption getDefaultOption ( selectOptions ) ; ( ) paramValue option ( ) ; } } return paramValue ; }<CODESPLIT>Returns the currently selected value of the select widget . <p ><CODESPLIT>1
public void marshall ( ListBootstrapActionsRequest listBootstrapActionsRequest, ProtocolMarshaller protocolMarshaller ) { if ( listBootstrapActionsRequest == null ) { throw SdkClientException (Invalid marshall(...)" ) ; } { protocolMarshaller. marshall ( listBootstrapActionsRequest. getClusterId ( ), CLUSTERIDBINDING ) ; protocolMarshaller. marshall ( listBootstrapActionsRequest. getMarker ( ), MARKERBINDING ) ; } ( ) { throw SdkClientException ( marshall request. ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public static LicenseApi licenseApiFactory ( String pathToLicense ) { ( MisPro ( ) false ) return new LicenseApi ( ) @ Override public boolean initializeFromFile ( File license ) { return true ; } @ Override public boolean isAnyKindOfTrial ( ) { return false ; } @ Override public boolean isProTrial ( ) { return false ; } @ Override public boolean isEnterpriseTrial ( ) { return false ; } @ Override public int maxHostcount ( ) { return Integer. MAX_VALUE ; } @ Override public Calendar expires ( ) { result getInstance ( ) ; result add ( YEAR, 20 ) ; return result ; } @ Override public boolean verify ( ) { return true ; } @ Override public boolean isDrReplicationAllowed ( ) { return false ; } @ Override public boolean isDrActiveActiveAllowed ( ) { return false ; } @ Override public boolean isCommandLoggingAllowed ( ) { return false ; } @ Override public boolean isAWSMarketplace ( ) { return false ; } @ Override public boolean isEnterprise ( ) { return false ; } @ Override public boolean isPro ( ) { return false ; } @ Override public String licensee ( ) { return "VoltDB Comm Edition User" ; } @ Override public Calendar issued ( ) { result getInstance ( ) ; return result ; } @ Override public String note ( ) { return "" ; } @ Override public boolean hardExpiration ( ) { return false ; } @ Override public boolean secondaryInitialization ( ) { return true ; } } ; }Api licenseApi ProClassApi load (dbsetApiImpl APILog fatal ) (Log fatal ) newInstance ( ) ; ( licenseApi ) return null ; } licenseFile = new ( pathToLicense ) ; ( license ( ) false ) return null ; }Log ( VoltDB license file path ) ; ( licenseApi initializeFromFile ( license ) false )Log fatal ( load license file parse license ) ; return null ; } ( licenseApi verify ( ) false )Log fatal ( load license file verify license signature ) ; return null ; } } ( License lex )Log fatal ( lex ( ) ) ; return null ; } return licenseApi ; }<CODESPLIT>Simple code to copy a file from one place to another ... Java should have this built in ... stupid java ...<CODESPLIT>0
@ Override public ModifyInstanceEventStartTimeResult modifyInstanceEventStartTime ( ModifyInstanceEventStartTimeRequest request ) { request beforeClientExecution request return executeModifyStartTime ( request }<CODESPLIT><p > Modifies the placement attributes for a specified instance . You can do the following : < / p > <ul > <li > <p > Modify the affinity between an instance and a <a href = https : // docs . aws . amazon . com / AWSEC2 / latest / UserGuide / dedicated - hosts - overview . html > Dedicated Host< / a > . When affinity is set to <code > host< / code > and the instance is not associated with a specific Dedicated Host the next time the instance is launched it is automatically associated with the host on which it lands . If the instance is restarted or rebooted this relationship persists . < / p > < / li > <li > <p > Change the Dedicated Host with which an instance is associated . < / p > < / li > <li > <p > Change the instance tenancy of an instance from <code > host< / code > to <code > dedicated< / code > or from <code > dedicated< / code > to <code > host< / code > . < / p > < / li > <li > <p > Move an instance to or from a <a href = https : // docs . aws . amazon . com / AWSEC2 / latest / UserGuide / placement - groups . html > placement group< / a > . < / p > < / li > < / ul > <p > At least one attribute for affinity host ID tenancy or placement group name must be specified in the request . Affinity and tenancy can be modified in the same request . < / p > <p > To modify the host ID tenancy placement group or partition for an instance the instance must be in the <code > stopped< / code > state . < / p ><CODESPLIT>0
@ Nonnull public static T1, T2bjIntObjPredicateBuilder T1, T2 objIntObjPredicate ( ConsumerbjIntObjPredicate T1, T2 consumer ) { return LObjIntObjPredicate ( consumer ) ; }<CODESPLIT>One of ways of creating builder . This might be the only way ( considering all _functional_ builders ) that might be utilize to specify generic params only once .<CODESPLIT>1
public InterceptorsType < EjbJarDescriptor > getOrCreateInterceptors ( ) { Node node = model. getOrCreate (interceptors ) ; InterorsTypeJarDescriptor interceptors = new InterorsTypeImplJarDescriptor ( this,interceptors, model, node ) ; return interceptors ; }<CODESPLIT>If not already created a new <code > interceptors< / code > element with the given value will be created . Otherwise the existing <code > interceptors< / code > element will be returned .<CODESPLIT>1
protected static Action findAction ( EObject grammarComponent, String assignmentName ) { for ( Action action GrammarUtil. containedActions ( grammar ) ) ( GrammarAssignedAction ( action ) ) ( Objects ( assignmentName action getFeature ( ) ) ) return action ; } } } return null ; }<CODESPLIT>Replies the assignment component with the given nazme in the given grammar component .<CODESPLIT>1
public int getUnsignedMediumInt ( ) { = getUnsigned ( ) ; = getUnsigned ( ) ; = getUnsigned ( ) ; ( _is ) return ( b << 16 ) | ( b2 << 8 ) | b3 ; } return ( b3 << 16 ) | ( b2 << 8 ) | b ; } }<CODESPLIT>Returns an unsigned three - byte medium int from the buffer at the current position<CODESPLIT>1
public void rollback ( ) { { log. (Rolling back modifyAttributes operation ) ; ldapOperations. modifyAttributes ( dn, compensatingModifications ) ; } ( ) { log. warn ( to rollback ModifyAttributes operation dn dn ) ; } }<CODESPLIT>/ *<CODESPLIT>1
static XMLName formProperty ( String uri, String localName ) { return form ( create ( uri ), localName ) }<CODESPLIT>TODO : marked deprecated by original implementor<CODESPLIT>0
@ Override public synchronized void beginTransaction ( ) throws DatabaseEngineRuntimeException { { getConnection ( ) ; if ( conn. getAutoCommit ( ) ) { logger. ( "There's already one transaction active ) ; return ; } conn. setAutoCommit ( false ) ; } ( ) { DatabaseEngineRuntimeException ( starting transaction ) ; } }<CODESPLIT>Closes a { @link MappedEntity } logging a warning if an { @link Exception } is thrown . <p > It flushes before closing the { @link MappedEntity } .<CODESPLIT>0
@ SuppressWarnings ( "unchecked" ) public List < io.oo. models. Job > getAllJobs ( ) throws MangooSchedulerException { Objects. requireNonNull ( this. quScheduler, Required. SCHEDUL. toString ( ) ) ; List io models Job jobs = new ArrayList ( ) ; { for ( Job job getAllKeys ( ) ) List Trigger triggers = ( List Trigger ) this quartzSchedulerTriggersJob ( jobKey ) ; Trigger trigger = triggers. ( ) ; TriggerState triggerState = quScheduler.TriggerState ( trigger. ( ) ) ; active = ( TriggerState. triggerState ) true false ; jobs. add ( new io.. models. Job ( active, jobKey. ( ), trigger. getDescription ( ), trigger. getNextFireTime ( ), trigger. getPreviousFireTime ( ) ) ) ; } } ( Scheduler ) MSchedulerException ( ) ; } return jobs ; }<CODESPLIT>Pauses a job by a given name @param name The name of the job to pause<CODESPLIT>0
public void flush ( ) { { ArrayList Batch batches = this. incomplete. all ( ) ;OutstandingRecords = ; for ( Batch batch batches ) { numOutstandingRecords += batchRecords ( ) size ( ) ; }. (Flush called on batches with {} records total, batches. size ( ), numOutstandingRecords ) ; for ( Batch batch batches ) { batch. await ( ) ; } } ( ) {. error (Error flushing batches ) ; } }<CODESPLIT>This will block until all the incomplete batches are acknowledged<CODESPLIT>1
static double computeAngularSimilarity ( DoubleTuple t0, DoubleTuple t1 ) { return 1 - acos ( computeCosSimilar (0, ) ) / ; }<CODESPLIT>Get the keysize . If no key size specified this will return the default key size .<CODESPLIT>0
public static boolean xor ( boolean... array ) { if ( ArrayUtil isEmpty ( array ) ) { IllegalArgumentException ( Array empty ) ; } result = false ; for ( boolean element array ) { result ^= element ; } return result ; }<CODESPLIT>对Boolean数组取或<CODESPLIT>0
@ SuppressWarnings (unchecked ) public static ISharedContext IUser > getUserContext ( ) { return (SharedContext IUser ) ContextManager getInstance ( ) getSharedContext ( UserContext getName ( ) ) ; }<CODESPLIT>Returns the managed user context .<CODESPLIT>1
public void copySeleniumCookies ( Set Cookie > browserCookies, CookieStore cookieStore ) { ( browser browser )Cookie cookie convertCookie ( browserCookie ) ; cookie addCookie ( cookie ) ; } }<CODESPLIT>Converts Selenium cookie to Apache http client .<CODESPLIT>0
private Block wrapInMacroMarker ( MacroBlock macroBlockToWrap, List Block newBlocks ) { returnMarkerBlock (BlockTo getId ( ),BlockToWrap getParameters ( ),BlockToWrap getContent ( ),Blocks,BlockToWrap isInline ( ) ) ; }<CODESPLIT>TODO : support more than strings<CODESPLIT>0
public void abort ( final Executor exec ) throws SQLException { ( exec null ) SQLException (Missing executor ) ; } ( this closed ) return ; } this. closed = true ; }<CODESPLIT>アノテーションを元にフォーマッタを作成する。<CODESPLIT>0
public JsonValue generalJsonValueProducer ( InjectionPoint ip ) { name ( ) ; value ( name ) ; JsonValue jsonValue wrapValue ( value ) ; return jsonValue ; }<CODESPLIT>Return the indicated claim value as a JsonValue<CODESPLIT>1
@ Override public int get ( TemporalField field ) { if ( field ChronoField ) { ( ( ChronoField ) field ) { INSECONDS throw new UnsupportedTemporalTypeException ( " fieldInstantSeconds get method use getLong ) ; OFFSETSECONDS return ( ). getTotalSeconds ( ) ; } return dateTime. get ( field ) ; } return Temporal. super. get ( field ) ; }<CODESPLIT>Gets the value of the specified field from this date - time as an { @code int } . <p > This queries this date - time for the value of the specified field . The returned value will always be within the valid range of values for the field . If it is not possible to return the value because the field is not supported or for some other reason an exception is thrown . <p > If the field is a { @link ChronoField } then the query is implemented here . The { @link #isSupported ( TemporalField ) supported fields } will return valid values based on this date - time except { @code NANO_OF_DAY } { @code MICRO_OF_DAY } { @code EPOCH_DAY } { @code PROLEPTIC_MONTH } and { @code INSTANT_SECONDS } which are too large to fit in an { @code int } and throw a { @code DateTimeException } . All other { @code ChronoField } instances will throw an { @code UnsupportedTemporalTypeException } . <p > If the field is not a { @code ChronoField } then the result of this method is obtained by invoking { @code TemporalField . getFrom ( TemporalAccessor ) } passing { @code this } as the argument . Whether the value can be obtained and what the value represents is determined by the field .<CODESPLIT>1
@ Override public void relocate ( ) { w = 200, h = ; x = ( this. ( ) - w ) / ; = ( this. getHeight ( ) - h ) / ; enableSQLDatabaseConnection setLocation ( x, ) ; sqlHostLabel setLocation ( x, + ) ; sqlHostField setLocation ( x +, + ) ; sqlDatabaseLabel setLocation ( x, + ) ; sqlDatabaseField setLocation ( x +, + ) ; sqlUserLabel setLocation ( x, + 100 ) ; sqlUserField setLocation ( x +, + 100 ) ; sqlPasswordLabel setLocation ( x, +30 ) ; sqlPasswordField setLocation ( x +, y +30 ) ; enableZipEncodingCheckBox setLocation ( x, y + ) ; }<CODESPLIT>A call of this method should validate the positions of the panels components .<CODESPLIT>1
public void fixateDistorted ( ) { for ( row row gridRows row ) { for ( col gridCols col ) { Cache cache = getGrid ( row, col ) ; computeAverageQ ( cache ) ; model. computeDeformed ( cache, col, row ) ; } } }<CODESPLIT>Precompute the portion of the equation which only concerns the undistorted location of each point on the grid even the current undistorted location of each control point .<CODESPLIT>0
public RedisPatchSchedule get ( String, String name ) { return getWithServiceResponseAsync (, ) toBlocking ( ) single ( ) body ( ) ; }<CODESPLIT>Create or replace the patching schedule for Redis cache ( requires Premium SKU ) .<CODESPLIT>0
@ Override public void eUnset ( int featureID ) { ( featureID ) { AfplibPackage. MCFRG__CFLID setCFLid (LIDEDEFAULT ) ; return ; AfplibPackage. MCFRG__SEID setSectid ( SEIDEDEFAULT ) ; return ; AfplibPackage. MCFRG__CFNAME setCFName (NAMEEDEFAULT ) ; return ; AfplibPackage. MCF1RG__CPNAME setCPName ( CPNAMEEDEFAULT ) ; return ; AfplibPackage. MCF1RG__FCSNAME setFCSName ( FCSNAMEEDEFAULT ) ; return ; AfplibPackage. MCF1RG__CHARROT setCharRot ( CHARROTEDEFAULT ) ; return ; } super. eUnset ( featureID ) ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>0
@ Override public void convertOperationParameter ( PathAddress address, String attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context ) { convert ( attributeValue ; }<CODESPLIT>{<CODESPLIT>1
public IfClassAvailable < Exclude < T > > getOrCreateIfClassAvailable ( ) { List Node nodeList = childNode. (ifclassavailable ) ; ( nodeList null nodeList ( ) ) return new IfClassAvailableImpl Exclude T ( this, "if-class-available", childNode, nodeList. get ( 0 ) ) ; } return createIfClassAvailable ( ) ; }<CODESPLIT>If not already created a new <code > if - class - available< / code > element will be created and returned . Otherwise the first existing <code > if - class - available< / code > element will be returned .<CODESPLIT>1
public static void setThreadPool ( ThreadPoolExecutor pool ) { ( pool ) shutdown ( ) ; ConcurrencyTools. pool = pool ; } }<CODESPLIT>Sets thread pool to given size .<CODESPLIT>0
public ThymafEngineConfigBuilder P setMessageResolver ( final IMessageResolver messageResolver ) { messageResolvers ( clear ( ; messageResolvers ( add ( message ; return this ; }<CODESPLIT><p > Sets a single message resolver for this template engine . < / p > <p > Calling this method is equivalent to calling { @link #setMessageResolvers ( Set ) } passing a Set with only one message resolver . < / p > <p > This operation can only be executed before processing templates for the first time . Once a template is processed the template engine is considered to be <i > initialized< / i > and from then on any attempt to change its configuration will result in an exception . < / p ><CODESPLIT>1
public static GrayU8 labelToBinary ( GrayS32 labelImage, GrayU8 binaryImage, int numLabels, int... selected ) { boolean selectedBlobs = new boolean numLabels ; for ( selected. length ) { selectedBlobs selected [ = true ; } return labelToBinary ( labelImage, binaryImage, selectedBlobs ) ; }<CODESPLIT>Scans through the labeled image and adds the coordinate of each pixel that has been labeled to a list specific to its label .<CODESPLIT>0
public EClass getIfcFacetedBrep ( ) { ( ifcFacetBEClass null ) ifcrepEClass = ( EClass ) EPackage. Registry.. ( Ifc2tc1Package. eNS ). getEClassifiers ( ). ( 225 ) ; } return ifcFacetedBrepEClass ; }<CODESPLIT><! -- begin - user - doc -- > <! -- end - user - doc -- ><CODESPLIT>1
public void marshall ( DescribeDominantLanguageDetectionJobRequest describeDominantLanguageDetectionJobRequest, ProtocolMarshaller protocolMarshaller ) { if ( describeDominantLanguageDetectionJobRequest == null ) { throw SdkClientException (Invalid marshall(...)" ) ; } try { protocolMarshaller. marshall ( describeDomLanguageDetectionJobRequest. getJobId ( ), JOBIDBINDING ) ; } ( ) { throw SdkClientException ( marshall request JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public String getFileLink ( ) { (resource ) return A_CmsJspValueWrapper substituteLink (_cms, m_cms getSitePath ( m_resource ) ) ; } return "" ; } }<CODESPLIT>Gets a lazy map which maps locales to attachment beans for that locale . <p ><CODESPLIT>0
private List < Map < StreamStateHandle, OperatorStateHandle > > repartition ( GroupByStateNameResults nameToStateByMode, int newParallelism ) { List Map StreamStateHandle,StateHandle mergeMapList = new ArrayList ( newParallelism ) ; for (Parallelism ) mergeMapList. add ( new HashMap ( ) ) ; } Map, List Tuple StreamStateHandle,StateHandle. StateMetaInfo nameToDistributeState = nameToStateByMode. getByMode (StateHandle.. SPLITDIBUTE ) ; repState ( nameToDistributeState, newParallelism, mergeMapList ) ; Map, List Tuple StreamStateHandle,StateHandle. StateMetaInfo nameToUnionState = nameToStateByMode. getByMode (StateHandle.. UNION ) ; repartUnionState ( nameToUnionState, mergeMapList ) ; Map, List Tuple StreamStateHandle,StateHandle. StateMetaInfo nameToBroadcastState = nameToStateByMode. getByMode (StateHandle.. BROADCAST ) ; repartBroadcastState ( nameToBroadcastState, mergeMapList ) ; return mergeMapList ; }<CODESPLIT>Repartition SPLIT_DISTRIBUTE state .<CODESPLIT>0
private String normalizeParameters ( MultiValueMap < String, String > collectedParameters ) { MultiValueMap String, String sortedEncodedParameters = new TreeMultiValueMap String, String ( ) ; for ( Iterator List collectedParameters. ( ). ( ). ( ) ) { Entry String, List String entry = entryIt. next ( ) ; String collectedName = entry. getKey ( ) ; List String collectedValues = entry. getValue ( ) ; List String encodedValues = new ArrayList String ( collectedValues. size ( ) ) ; sortedEncodedParameters. put ( oauthEncode ( collectedName ), encodedValues ) ; for ( Iterator value collectedValues. ( ) value. ( ) ) { String value = valueIt. next ( ) ; encodedValues. add ( value null oauthEncode ( value ) : "" ) ; } Collections. sort ( encodedValues ) ; } StringBuilder paramsBuilder = new StringBuilder ( ) ; for ( Iterator List sortedEncodedParameters. ( ). ( ). ( ) ) { Entry String, List String entry = entryIt. next ( ) ; String name = entry. getKey ( ) ; List String values = entry. getValue ( ) ; for ( Iterator value values. ( ) value. ( ) ) { String value = valueIt. next ( ) ; paramsBuilder. append ( name ). append ('' ). append ( value ) ; if ( valueIt. hasNext ( ) ) { paramsBuilder. append ( "&" ) ; } } if ( entryIt. hasNext ( ) ) { paramsBuilder. append ( "&" ) ; } } return paramsBuilder. toString ( ) ; }<CODESPLIT>internal helpers<CODESPLIT>1
public void removePort ( TCPPort endPoint ) { if ( TraceComponent isAnyTracingEnabled ( ) tc isEntryEnabled ( ) ) Tr. entry ( tc,removePort endPoint. getServerSocket ( ) ) ; } synchronized ( this ) { NBChannelSelector accept = endPointTo. ( endPoint ) ; if ( accept null ) if ( 3100 <= acceptExceptions ) if ( TraceComponent isAnyTracingEnabled ( ) tc ( ) ) { Tr. event ( tc,Ignoring removePort call on fatal selectorsystemexit path ) ; } if ( TraceComponent isAnyTracingEnabled ( ) tc isEntryEnabled ( ) ) { Tr. exit ( tc,removePort ) ; } return ; } EndPointActionInfo work = new EndPointActionInfo ( REMOVEENDPOINT, endPoint, workSync ) ; synchronized (Sync ) { if ( TraceComponent isAnyTracingEnabled ( ) tc ( ) ) { Tr. event ( this, tc,Passing remove to selector; endPoint. getServerSocket ( ) ) ; } accept. addWork ( work ) ; { workSync. wait ( ) ; } ( ) { } } if ( accept == sharedAccept acceptUsageCount ( ) <= ) { sharedAccept = null ; } } { = new (TCP Port to be removed is not registered." ) ; if ( TraceComponent isAnyTracingEnabled ( ) tc ( ) ) { Tr. event ( tc,Throwing ) ; }. (, CLASSremovePort,7, this ) ; ; } } if ( TraceComponent isAnyTracingEnabled ( ) tc isEntryEnabled ( ) ) { Tr. exit ( tc,removePort ) ; } }<CODESPLIT>Removes an end point from the set of end points that we are accepting connections on . This has the effect of removing the server socket from the selector and closing it .<CODESPLIT>1
public Observable ExtendedServerBlobAuditingPolicyInner > createOrUpdateAsync ( String resourceGroupName, String serverName, ExtendedServerBlobAuditingPolicyInner parameters ) { return createOrUpdateWithServiceResponseAsync (,, parameters ) map ( ServiceResponse ExtendedServerBlobAudit, ExtendedServerBlobAudit ( ) Override public ExtendedServerBlobAuditingPolicyInner call ( ServiceResponse ExtendedServerBlobAuditingPolicyInner > response ) { return body ( ) ; } } ) ; }<CODESPLIT>Creates or updates an extended server s blob auditing policy .<CODESPLIT>0
public Map < String, String > getHeadersToMap ( Map < String, String > map ) { ( map null ) map LinkedHashMap ( ) ; Map map0 = map ; header forEach ( (, v ) map0. put (, v ) ) ; return map0 ; }<CODESPLIT>获取指定的header值 没有返回默认值<CODESPLIT>0
public Artifact createArtifact ( String groupId, String artifactId ) { return this repositorySystem create ( groupId, artifactId,RELEASE,jar ) ; }<CODESPLIT>Replies the dependencies for the given artifact .<CODESPLIT>0
@ org. eclipse. xtext. service. SingletonBinding ( eager true ) public Class < org. eclipse. xtext. generator. parser. antlr. debug. validation. SimpleAntlrJavaValidator > bindSimpleAntlrJavaValidator ( ) { return org ectext generator parser an debug validation SimpleAntlrJavaValidator ; }<CODESPLIT>contributed by org . eclipse . xtext . generator . validation . JavaValidatorFragment<CODESPLIT>1
public void marshall ( CreateDeploymentGroupRequest createDeploymentGroupRequest, ProtocolMarshaller protocolMarshaller ) { ( createDeploymentGroupRequest null ) SdkClientException ( marshall(...)" ) ; } { protocolMarshaller. marshall ( createDeploymentGroupRequest. getApplicationName ( ), APPLICATIONBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest.DeploymentGroupName ( ),GROUPBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest.DeploymentConfigName ( ),CONFIGBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getE2TagFilters ( ), EC2TAGFILTERSBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getOnPremInstanceTagFilters ( ), ONPREMISINSTANCETAGFILTERSBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getAutoScalingGroups ( ), AUTOSCGROUPSBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getServiceRoleArn ( ), SERVLEARNBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest.TriggerConfigurations ( ),SBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest.AlarmConfiguration ( ),BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getAutoRollbackConfiguration ( ), AORBACKCONFIGURATIONBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest.DeploymentStyle ( ),BINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getBlueGreenDeploymentConfiguration ( ), BLUEGREENDEPLOYCONFIGURATIONBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest.LoadBalancerInfo ( ), LOADINFOBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getE2TagSet ( ), EC2TAGSETBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getEcsServices ( ), ECSSSBINDING ) ; protocolMarshaller. marshall ( createDeploymentGroupRequest. getOnPremTagSet ( ), ONPREMISTSETBINDING ) ; } ( ) SdkClientException ( marshall request. ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
public void prependHandler ( @ Nonnull final EJSEvent eJSEvent, @ Nonnull final IHasJSCode aNewHandler ) { ValueEnforcer. notNull (J,J ) ; ValueEnforcer. notNull ( aNewHandler,NewHandler ) ; CollectJSCodeProviderCode = mEvents. (J ) ; ( a null ) aCode = new CollectJSCodeProvider ( ) ; maEvents. put (J, aCode ) ; } aCode. prepend ( aNewHandler ) ; }<CODESPLIT>Add an additional handler for the given JS event . If an existing handler is present the new handler is appended at front .<CODESPLIT>1
public static @ Nullable Pair < Integer, Integer > decodeDimensions ( InputStream is ) { checkNotNull ( is ) ; ByteBuffer byteBuffer DEBUFFERS acquire ( ) ; ( byteBuffer ) byteBuffer ByteBuffer allocate ( DEBUFFER ) ; } BitmapFactory Options options = new BitmapFactory Options ( ) ; options inDecodeBounds = ; options inTempStorage = byteBuffer array ( ) ; BitmapFactory decodeStream ( is, null, options ) ; return ( options. outWidth == - 1 || options. outHeight == - 1 ) null : new Pair ( options. outWidth, options. outHeight ) ; } DEBUFFERS release ( byteBuffer ) ; } }<CODESPLIT>Decodes the bounds of an image and returns its width and height or null if the size can t be determined<CODESPLIT>1
public static HttpResponse execute ( HttpRequestBase request ) throws IOException { notNull ( requestMissing request ) ; HttpClient client HttpClient create ( ) setRedirect ( new DefaultRedirect ( ) ) build ( ) ; return client. execute ( request ) ; }<CODESPLIT>Execute http response .<CODESPLIT>1
private static void sort ( byte [ ] byteArray, int start, int end, boolean descending ) { ( start ) return ; } middle = ( start end ) ; Merge sort ( byteArray, start,, descending ) ; Merge sort ( byteArray,, end, descending ) ; ( descending ) Merge mergeDescending ( byteArray, start,, end ) ; } Merge merge ( byteArray, start,, end ) ; } }<CODESPLIT>Merge two sorted arrays into a bigger array in ascending order . This routine runs in O ( n ) time .<CODESPLIT>0
public void writeThrowable ( OutputStream out, Throwable value ) throws IOException { writeStartObject ( out ) ; writeSerializedField ( outROW value ) ; StringWriter new StringWriter ( ) ; value printStackTrace ( new ( ) ) ; writeStringField ( outSTACKTRACE sw toString ( ) ) ; writeEndObject ( out ) ; }<CODESPLIT>Encode a Throwable instance as JSON : { throwable : Base64 stackTrace : String }<CODESPLIT>1
protected String renderRadio ( FacesContext facesContext, UIInput uiComponent, String value, boolean disabled, boolean checked, boolean renderId, Integer itemNum ) throws IOException { clientId = uiComponent getClientId ( facesContext ) ; itemId = ( item null ) null clientId facesContext getNamingContainerSeparatorChar ( ) item ; ResponseWriter writer = facesContext getResponseWriter ( ) ; writer startElement ( HTML INPUTE, uiComponent ) ; ( itemId null ) writer writeAttribute ( HTML ID, itemId, null ) ; } ( renderId ) writer writeAttribute ( HTML. ID, clientId, null ) ; } writer. writeAttribute ( HTML. TYPE, HTML. INPUTTYPERADIO, null ) ; writer. writeAttribute ( HTML. NAME, clientId, null ) ; ( disabled ) writer. writeAttribute ( HTML. DISABLED, HTML. DISABLED, null ) ; } ( checked ) writer. writeAttribute ( HTML. CHECK, HTML. CHECK, null ) ; } ( value null ) writer. writeAttribute ( HTML. VALUE, value, null ) ; } writer. writeAttribute ( HTML. VALUE, "", null ) ; } Map List ClientBehavior behaviors = null ; ( uiComponent ClientBehaviorHolder ) behaviors = ( ( ClientBehaviorHolder ) uiComponent ). getClientBehaviors ( ) ; commonPropertiesMarked =L ; (CommonPropertiesOptimEnabled ( facesContext ) ) commonProperties =Property. getCommonProperties ( uiComponent ) ; } ( behaviors isEmpty ( )CommonPropertiesOptimEnabled ( facesContext ) )Property. renderChangeEventProperty ( writer, commonProperties, uiComponent ) ;Property. renderEventProperties ( writer, commonProperties, uiComponent ) ;Property. renderFieldEventPropertiesWithoutOnchange ( writer, commonProperties, uiComponent ) ; } HtmlRenderer. renderBehaviorizedOnchangeEventHandler ( facesContext, writer, uiComponent, behaviors ) ; (CommonEventsOptimEnabled ( facesContext ) ) Long commonEvents =Event. getCommonEvents ( uiComponent ) ;Event. renderBehaviorizedEventHandlers ( facesContext, writer, commonProperties, commonEvents, uiComponent, behaviors ) ;Event. renderBehaviorizedFieldEventHandlersWithoutOnchange ( facesContext, writer, commonProperties, commonEvents, uiComponent, behaviors ) ; } HtmlRenderer. renderBehaviorizedEventHandlers ( facesContext, writer, uiComponent, behaviors ) ; HtmlRenderer. renderBehaviorizedFieldEventHandlersWithoutOnchange ( facesContext, writer, uiComponent, behaviors ) ; } } HtmlRenderer. renderHTMLAttributes ( writer, uiComponent, HTML. INPUTPSTHUGHATTRIBUTESWITHOUTDISABLEDANDSTYLEANDEVENTS ) ; } HtmlRenderer. renderHTMLAttributes ( writer, uiComponent, HTML. INPUTPSTHUGHATTRIBUTESWITHOUTDISABLEDANDSTYLE ) ; } ( isDisabled ( facesContext uiComponent ) ) writer. writeAttribute (.. myfaces. shared. render. html. HTML. DISABLED, Boolean. TRUE, null ) ; } writer. endElement ( HTML. INPUTE ) ; return itemId ; }<CODESPLIT>Renders the given SelectItem ( Group )<CODESPLIT>0
public DataSource getDataSource ( String dataSourceName ) throws ServiceLocatorException { DataSource dataSource = null ; { dataSource = ( DataSource ) ic. lookup ( dataSourceName ) ; } ( NamingException ) ServiceLocatorException ( ) ; } ( ) ServiceLocatorException ( ) ; } return dataSource ; }<CODESPLIT>This method obtains the topc itself for a caller<CODESPLIT>0
private void buildHosts ( Map externalProperties, List < Server > servers, String persistenceUnit, final KunderaMetadata kunderaMetadata ) { persistenceUnitMetadata = kunderaMetadata. getApplicationMetadata ( ). getPersistenceUnitMetadata ( persistenceUnit ) ; Properties props = persistenceUnitMetadata. getProperties ( ) ; this. externalProperties = externalProperties ; hosts = null ; String portAsString = null ; ( externalProperties null ) hosts = ( ) externalProperties. (Properties. KNODES ) ; portAsString = ( ) externalProperties. (Properties. K ) ; } ( hosts == null ) hosts = ( ) props. (Properties. KNODES ) ; } ( portAsString == null ) portAsString = ( ) props. (Properties. K ) ; } ( hosts null portAsString null ) buildHosts ( hosts, portAsString, this. hostsList ) ; } ( servers null servers ( ) ) buildHosts ( servers, this. hostsList ) ; } }<CODESPLIT>Build host array .<CODESPLIT>1
public String getPresentationML ( ) throws IllegalStateException { ( messageML == null ) IllegalStateException ( message parsed call MessageMLContextparse first ) ; } ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; XmlPrintStream out = new XmlPrintStream ( bout ) ; out setNoIndent ( ) ; out setNoN ( ) ; messageML. asPresentationML ( out ) ; out. close ( ) ; return bout. toString ( ) ; }<CODESPLIT>Parse a Markdown message into its MessageMLV2 representation . Generates document tree structures for serialization into output formats with the respective get () methods .<CODESPLIT>0
private void showFacebookAppError ( ) { Toast makeText ( mContext, mContext getString ( R string wingsfacebook__errorfacebookapp ), ToastSHORT ) show ( ) ; }<CODESPLIT>Links an account .<CODESPLIT>0
public static GPX read ( final InputStream input ) throws IOException { return reader ( Version11, ST ) read ( input ) ; }<CODESPLIT>Read an GPX object from the given { @code input } stream .<CODESPLIT>0
@ Override protected void i_addRow ( Connection conn, String table, String [ ] columns, String [ ] values, boolean [ ] numeric ) throws SQLException { StringBuilder sql = new StringBuilder ( 128 ) ; sql. append ( "INSERT INTO " ). append ( table ). append ( " (" ) ; for ( columns. ) { if ( > ) { sql. append ( ", " ) ; } sql. append ( columns ) ; } sql. append ( VALUES (" ) ; for ( columns. ) { if ( > ) { sql. append ( ", " ) ; } if ( values == null ) { sql. append ( "NULL ) ; } { sql. append ('' ) ; } } sql. append ('' ) ; if ( logger. isDebugEnabled ( ) ) { logger. ( "About to execute {}", sql. toString ( ) ) ; } PreparedStatement stmt = conn. prepareStatement ( sql. toString ( ) ) ; try { varIndex = 0 ; for ( values. ) { if ( values null ) { varIndex ++ ; if ( numeric null numeric ) { setNumeric ( stmt, varIndex, columns, values ) ; } { stmt. setString ( varIndex, values ) ; } } } stmt. executeUpdate ( ) ; } finally { closeStatement ( stmt ) ; } }<CODESPLIT>Get a long string which could be a TEXT or CLOB type . ( CLOBs require special handling -- this method normalizes the reading of them )<CODESPLIT>0
int getNextSentencePosition ( int numberOfParagraph, int startOfSentencePosition ) { for ( CacheEntry entries ) (Entry numberOfParagraph numberOfParagraphEntry startOfSentencePosition startOfSentencePosition ) return anEntry. nextSentencePosition ; } } return - 1 ; }<CODESPLIT>get Proofreading errors of sentence out of paragraph matches from cache<CODESPLIT>0
private void asyncRefresh ( ) { ( asyncRefresh compareAndSet ( false true ) ) { executor. submit ( new Runnable ( ) { @ Override public void run ( ) { { refreshValue ( ) ; } asyncRefresh set ( false ) ; } } } ) ; } ( ) asyncRefresh. set ( false ) ; ; } } }<CODESPLIT>Invokes the callback to get a new value .<CODESPLIT>0
@ Override public ScheduleExpression getSchedule ( ) { = TraceComponent. isAnyTracingEnabled ( ) ; if ( tc isEntryEnabled ( ) ) Tr entry ( tcgetSchedule this ) ; checkTimerAccess ( ) ; PersistentTimerTaskHandler taskHandler = getTTaskHandler ( ALLOWCACHEDTIMERGETSCHEDULE ) ; ParsedScheduleExpression parsedSchedule = taskHandler. getParsedSchedule ( ) ; if ( parsedSchedule == null ) { IllegalStateException = new IllegalStateException (Timer is not a calendarbased timer + toString ( ) ) ; if ( tc isEntryEnabled ( ) ) Tr. ( tcgetSchedule ) ; ; } ScheduleExpression schedule = EJSContainer. getDefaultContainer ( ). ivObjectCopier. copy ( parsedSchedule. getSchedule ( ) ) ; if ( tc. isEntryEnabled ( ) ) Tr. ( tcgetSchedule schedule ) ; return schedule ; }<CODESPLIT>Query whether this timer has persistent semantics .<CODESPLIT>0
public void marshall ( OperatingSystem operatingSystem, ProtocolMarshaller protocolMarshaller ) { if ( operatingSystem == null ) SdkClientException ( marshall(...)" ) ; } { protocolMarshaller. marshall ( operatingSystem. getName ( ), NAMEBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getId ( ), IDBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getType ( ), TYPEBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getConfigurationManagers ( ), CONFIGURATIONMANBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getReportedName ( ), REBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getReportedVersion ( ), REVERSIONBINDING ) ; protocolMarshaller. marshall ( operatingSystem. getSupported ( ), SUPPORTEDBINDING ) ; } ( ) SdkClientException ( marshall request. ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
private static void resolveServerConfig ( ServerConfig serverConfig ) { boundHost = serverConfig getBoundHost ( ) ; ( boundHost null ) host = serverConfig getHost ( ) ; ( StringUtils isBlank ( host ) ) host = SystemInfo. getLocalHost ( ) ; serverConfig setHost ( host ) ; boundHost = SystemInfo. isWindows ( )? host : NetUtils. ANYHOST ; } boundHost = host ; } serverConfig setBoundHost ( boundHost ) ; } ( serverConfigAdaptPort ( ) )Port = serverConfig getPort ( ) ; port = NetUtils getAvailablePort ( boundHost,Port, RpcConfigs getIntValue ( RpcOptions SERVERPORTEND ) ) ; ( port oriPort ) ( isInfoEnabled ( ) ). info (Changed port from {} to {} because the config port is disabledPort port ) ; } serverConfig setPort ( port ) ; } } }<CODESPLIT>初始化Server实例<CODESPLIT>0
public static String blur ( int radius, int sigma ) { if ( radius < ) { throw IllegalArgumentException (Radius zero." ) ; } if ( radius > 150 ) { throw IllegalArgumentException (Radius lower or equal." ) ; } if ( sigma < ) { throw IllegalArgumentException (Sigma zero." ) ; } return FILTER_BLUR + "(" + radius + "," + sigma + ")" ; }<CODESPLIT>This filter uses a 9 - patch to overlay the image .<CODESPLIT>0
@ Override public final void send ( Nonnull String data ) throws IllegalStateException { checkConnected ( ;web send ( ) ; }<CODESPLIT>{<CODESPLIT>0
public void throttle ( boolean verbose ) { if ( System. ( ) this. LastCheck > 5000l ) { if ( this. End. getExecutionCount ( ) this. Start. getExecutionCount ( ) > ) { double observedLatency = ( double ) ( this. End. getTotalExecutionDuration ( ) - this. Start. getTotalExecutionDuration ( ) ) / ( double ) ( this. End. getExecutionCount ( ) - this. Start. getExecutionCount ( ) ) ; double tuningLatency = observedLatency ; el = this. End. getLatencyBuckets ( ) ; sl = this. Start. getLatencyBuckets ( ) ; ec = this. End. getExecutionCount ( ) - this. Start. getExecutionCount ( ) ; elsum = 0 ; for ( ) {sum += ; } slsum = 0 ; for ( ) { slsum += sl ; } if ( ( ( double ) ( elsum slsum ) / ( double ) ec ) > ) { outlierExecutionDuration = 0 ; outlierExecutionCount = 0 ; for ( ) { outCount += ( sl ) ; if ( 100 ) outlierExecutionDuration += ( el sl ) 50l ; outlierExecutionDuration += ( el sl ) ; } tuningLatency = ( double ) ( this. End. getTotalExecutionDuration ( ) - this. Start. getTotalExecutionDuration ( ) - outlierExecutionDuration ) / ( double ) ( this. End. getExecutionCount ( ) - this. Start. getExecutionCount ( ) - outlierExecutionCount ) ; } oldRate = this. Rate ; if ( tuningLatency > this. TargetLatency 2 ) this. Rate = ( long ) ( this. Rate8 ) ; if ( tuningLatency > this. TargetLatency ) this. Rate = ( long ) ( this. Rate ) ; if ( tuningLatency > this. TargetLatency1 ) this. Rate = ( long ) ( this. Rate ) ; if ( tuningLatency < this. TargetLatency5 ) this. Rate = ( long ) ( this. Rate1 ) ; if ( tuningLatency < this. TargetLatency ) this. Rate = ( long ) ( this. Rate01 ) ; if ( tuningLatency < this. TargetLatency ) this. Rate = ( long ) ( this. Rate ) ; if ( verbose oldRate this. Rate ) System. out. printf ( "%8s | Adjusting %s to  %111 TPS | Recent Latency  %72n, this. DateFormat. format ( new Date (. round ( ( System. ( ) this. StartTime ) / 1000 ) 1000l ) ), ( oldRate < this. Rate UPDOWN ), ( double ) this. Rate, tuningLatency ) ; } this. Start = ( PerfCounter ) this. End. clone ( ) ; this. End = ClientConnectionPool. getStatistics ( this. Connection ). get ( this. Procedure ) ; this. LastCheck = System. currentTimeMillis ( ) ; } this. Limiter. throttle ( this. Rate ) ; }<CODESPLIT>Throttle the execution process and re - adjust the rate requirement on the fly . The limiter will automatically re - adjust the rate internally by using a basic { @link RateLimiter } after analysis of the latency data gathered from the performance tracking .<CODESPLIT>1
private PrintStream createOutputStream ( ) { ( outputLogFilename null ) { FileOutputStream fout = new FileOutputStream ( outputLogFilename, false ) ; BufferedOutputStream bos = new BufferedOutputStream ( fout, 4096 ) ; ( encoding null ) return new PrintStream ( bos, false, encoding ) ; } return new PrintStream ( bos, false ) ; } } ( ) IllegalArgumentException (String (WTRA ) ) ; } } isSystemOut = true ; ( encoding null ) { return new PrintStream ( System. out, false, encoding ) ; } ( UnsupportedEncodingException ) } } return System. out ; }<CODESPLIT>Utility method to skip a given amount of bytes from the input stream . This will return the index after the skip ( which may or may not be able to skip the entire requested amount ) .<CODESPLIT>0
public static boolean areNotEmpty ( String... values ) { result = true ; ( values null values length ) result = false ; } for ( value values ) { result &=! isEmpty ( value ) ; } } return result ; }<CODESPLIT>检查指定的字符串列表是否不为空。<CODESPLIT>1
public static String getEncodedServletURI ( HttpServletRequest request ) { servletPath = request getServletPath ( ) ; contextPath = request. getContextPath ( ) ; ( servletPath ( ) ) return contextPath + servletPath ; } contextPath = contextPath. length ( ) ; requestURI = request. getRequestURI ( ) ; char requestUriChars = requestURI. toCharArray ( ) ; StringBuilder servletURI = new StringBuilder ( contextPath ) ; requestUriCharIndex = contextPath ; for ( servlet. toCharArray ( ) ) ( ) requestUriCharIndex = copyPathFragment ( requestUriChars, requestUriCharIndex, servletURI ) ; servletURI. ( ) ; requestUri += ; } } requestUriCharIndex = copyPathFragment ( requestUriChars, requestUriCharIndex, servletURI ) ; return servletURI. toString ( ) ; }<CODESPLIT>Get request s servlet URI encoded based on results from { @link HttpServletRequest#getContextPath () } and { @link HttpServletRequest#getRequestURI () } which are both encoded URI / path and { @link HttpServletRequest#getServletPath () } which is DECODED path . We cannot just concatenate context path and servlet path to get the proper result because of these encoding / decoding differences especially if the Servlet path contains encoded characters . @param request @return servlet URI ( meant to be equivalent to contextPath + URLEncoded ( servletPath ))<CODESPLIT>1
public void setMode ( final ParsingMode mode ) { this. mode = mode ; ( Parsing HTML ( this ) ) this. caseSensitive = false ; } }<CODESPLIT>This method will try to avoid creating new strings for each structure name ( element / attribute )<CODESPLIT>0
private void createReportMap ( ) { logger. entering ( ) ; Map String, List SumizedData subReportMap = new LinkedHashMap String, List SumizedData ( ) ; subReportMap. put (Full Suite Summary, lSuites ) ; subReportMap. put (Test Summary, lTests ) ; subReportMap. put (Class Summary, lClasses ) ; subReportMap. put (Group Summary, lGroups ) ; ReportMap SumizedData testSummaryReport = new ReportMap SumizedData ( ReportSheetNames. TESTSUMMARYREPORT. getName ( ), subReportMap, ) ; fullReportMap. add ( testSummaryReport ) ; List SumizedData groupsClone = new ArrayList SumizedData ( lGroups ) ; List SumizedData classData ; SumizedDataGroupData = new SumizedData ( ) ;GroupData.Name ( TestCaseResult. ) ; groupsClone. add ( naGroupData ) ; subReportMap = new LinkedHashMap String, List SumizedData ( ) ; for ( SumData group groupsClone ) { String sGroupName = group. getsName ( ) ; classData = new ArrayList SumizedData ( ) ; for ( sGroupClassNameGroupClassData. ( ) ) { if ( sGroupClassName. ( sGroupName. length ( ) ). ( sGroupName ) ) {Data. add ( mpGroupClassData. get ( sGroupClassName ) ) ; } } subReportMap. put ( sGroupName, classData ) ; } ReportMap SumizedData secondReport = new ReportMap SumizedData ( ReportSheetNames. GROUPSUMMARYREPORT. getName ( ), subReportMap, 0 ) ; fullReportMap. add ( secondReport ) ; Map String, List List String subDetailReportMap = new LinkedHashMap String, List List String ( ) ; subDetailReportMap. put (Passed TC List, tcPassedData ) ; subDetailReportMap. put (Failed TC List, tcFailedData ) ; subDetailReportMap. put (Skipped TC List, tcSkippedData ) ; ReportMap List String thirdReport = new ReportMap List String ( ReportSheetNames. TESTCASEREPORT. getName ( ), subDetailReportMap, 1 ) ; fullReportMap. add ( thirdReport ) ; Map String, List List String lstDefReports = new LinkedHashMap String, List List String ( ) ; lstDefectReports. put (Defect Summary, tcDefectData ) ; ReportMap List StringthReport = new ReportMap List String ( ReportSheetNames. DEFREPORT. getName ( ), lstDefReports, 1 ) ; fullReportMap. add ( fourthReport ) ; BaseReport bR = ( BaseReport ) fullReportMap. get ( fullReportMap. ( ) ). getGeneratedReport ( ). ( ). next ( ) ; List String lsTitles = Arrays. (Class Name,MethodTestcase id,Test Description,Groups]",Time taken,Output,Error Message,Error Details ) ; bR. setTitles (Titles ) ; Map String, List List String fifthTestOutputSubReportMap = new LinkedHashMap String, List List String ( ) ; fifthTestOutputSubReportMap. put (Test Output, tcOutputData ) ; ReportMap List String fifthReportSheet = new ReportMap List String ( ReportSheetNames. TESTOUTPUTETAILSREPORT. getName ( ), fifthTestOutputSubReportMap, ) ; fullReportMap. add ( fifthReportSheet ) ; logger. exiting ( ) ; }<CODESPLIT>Generates all summarized counts for various reports<CODESPLIT>0
@ Override public ExtensionProcessor createExtensionProcessor ( IServletContext servletContext ) throws Exception { WebModuleMetaData moduleMetaData = ( ( WebAppConfigExtended ) ( servletContext getWebAppConfig ( ) ) ) getMetaData ( ) ; JaxRsModuleMetaData jaxRsModuleMetaData = JaxRsMetaDataManager getJRsModuleMetaData ( moduleMetaData ) ; ( jaxModuleMetaData null ) return null ; } NonPersistentCache overlayCache = servletContext getModuleContainer ( ) adapt ( NonPersistentCache ) ; JaxRsModuleInfo jaxRsModuleInfo = ( JaxRsModuleInfo ) overlayCache getFromCache ( JaxRsModuleInfo ) ; ( jaxModuleInfo null jaxModuleInfo endpointInfoSize ( ) ) ( tc ( ) ) Tr ( tc,No JAXRS service is found in the web module will not create web service processor ) ; } return null ; } Container publisherModuleContainer = servletContext getModuleContainer ( ) ; JaxRsPublisherContext publisherContext = new JaxRsPublisherContext ( jaxRsModuleMetaData publisherModuleContainer JaxRs getWebModuleInfo ( publisherModuleContainer ) ) ; publisherContext setAttribute ( JaxServer SERCONTEXT servletContext ) ; publisherContext setAttribute ( JaxRs ENDPOINTINFOBUCONTEXT new EndpointInfoBuilderContext ( servletContext getModuleContainer ( ) adapt ( WebAnnotations class ) getInfoStore ( ) servletContext getModuleContainer ( ) ) ) ; WebApp webApp = ( WebApp ) servletContext ; publisherContext setAttribute ( Jax COLLATOR webAppCollaboratorHelper ( ) getWebCollaborator ( ) ) ;Publisher endpointPublisher = endpointPublisherSR. getServiceWithException ( ) ; for ( Endpoint endpoint jaxModule.Infos ( ) ) endpointPublisher. publish ( endpointInfo, publisherContext ) ; } for (Web jaxWeb jaxWebAppConfigurators ) jaxRsWebAppConfigurator. configure ( jaxRsModuleInfo, servletContext. getWebAppConfig ( ) ) ; } return new JaxRsExtensionProcessor ( servletContext ) ; }<CODESPLIT>{<CODESPLIT>1
private void forEveryEdge ( EdgeVisitor visitor ) {Node = getFromNode ( ) ; len = edgeIds. size ( ) ; prevEdgeId = EdgeIterator. NOEDGE ; for ( ) {IteratorState edgeBase = graph. getEdgeIteratorState ( edgeIds. get ( ),Node ) ; if ( edgeBase == null ) IllegalStateException (Edge edgeIds. ( ) empty when requested with nodeNode ", array index ", edges edgeIds. size ( ) ) ; tmpNode = edgeBase. getBaseNode ( ) ; edgeBase = graph. getEdgeIteratorState ( edgeBase. getEdge ( ),Node ) ; visitor. next ( edgeBase,, prevEdgeId ) ; prevEdgeId = edgeBase. getEdge ( ) ; } visitor. finish ( ) ; }<CODESPLIT>Returns the list of all edges .<CODESPLIT>0
public static ParseSetup guessSetup ( Key [ ] fkeys, boolean singleQuote, int checkHeader ) { return guessSetup ( fkeys,Setup ( GUESSINFO, GUESSSEP, singleQuote, checkHeader, GUESSCOL, null,WriterErr ) ) ; }<CODESPLIT>Discover the parse setup needed to correctly parse all files . This takes a ParseSetup as guidance . Each file is examined individually and then results merged . If a conflict exists between any results all files are re - examined using the best guess from the first examination .<CODESPLIT>0
public static boolean isEnabled ( State state ) { return Boolean valueOf ( state getProp ( METRICSENABLEDKEY, DEFAULT_METRICS_ENABLED ) ) ; }<CODESPLIT>Check whether metrics collection and reporting are enabled or not .<CODESPLIT>1
static T, ID Dao T, ID createDao ( ConnectionSource connectionSource, Class T > clazz ) throws SQLException { return BaseDaoImpl, ID ( connectionSource, clazz ) } ; }<CODESPLIT>Helper method to create a Dao object without having to define a class . Dao classes are supposed to be convenient but if you have a lot of classes they can seem to be a pain .<CODESPLIT>0
public void setCode ( String timecode ) throws Timecode. TimecodeException { clear ( ) ; setHours ( getToken ( timecode ) ) ; setMinutes ( getToken ( timecode ) ) ; setSeconds ( getToken ( timecode ) ) ; setFrames ( getToken ( timecode ) ) ; ( useSamples ( ) ) setSamples ( getToken ( timecode ) ) ; setFramesSecond ( 30 ) ; } ( ) } } normalize ( ) ; }<CODESPLIT>Sets the object based on a string in the form HH : MM : SS : FF<CODESPLIT>1
private void extractMessage ( JsonObject object ) { JsonObject meta = object getAsJsonObject (meta ) ; ( meta null ) JsonPrimitive msg = meta getAsJsonPrimitive ( ) ; ( msg null ) this message = msg getAsString ( ) ; return ; } } JsonPrimitive error = object. getAsJsonPrimitive (error ) ; ( error null ) this. message = error. getAsString ( ) ; return ; } this. message =Unknown Error ; }<CODESPLIT>Performs an XAuth authentication .<CODESPLIT>0
public static base_response update ( nitro_service client, gslbparameter resource ) throws Exception { gparameter updateresource new gparameter ( ) ;. lentrytimeout = resource. lentrytimeout ;. rtttolerance = resource. rtttolerance ;. l = resource. lmask ;. v6nsmask = resource. v6nsmask ;. lprobeorder = resource. lprobeorder ;. dropl = resource. dropl ; return updateresource. update_resource ( client ) ; }<CODESPLIT>Use this API to fetch lbvserver_tmtrafficpolicy_binding resources of given name .<CODESPLIT>0
protected synchronized void activate ( BundleContext context, Map < String, Object > props ) { String jndiName = ( String ) props. (j ) ; String originalValue = ( String ) props. (value ) ; decode = ( Boolean ) props. (decode ) ; if ( jndiName == null jndiName isEmpty ( ) originalValue == null originalValue isEmpty ( ) ) { if ( TraceComponent isAnyTracingEnabled ( ) tc ( ) ) { Tr. debug ( tc, to register JNDIEntry with jndiName jndiName and value originalValue both set ) ; } return ; } String value = originalValue ; if ( decode ) { { value = PasswordUtil. decode ( originalValue ) ; } ( ) { Tr. error ( tc,jndidecodefailed, originalValue, ) ; } } parsedValue = LiteralParser. parse ( value ) ; String valueClassName = parsedValue. getClass ( ). getName ( ) ; serviceObject = decode new Decode ( originalValue ) : parsedValue ; Dictionary String, propertiesForJndiService = new Hashtable String, ( ) ; propertiesForJndiService. put (osgijndiservicename, jndiName ) ; if ( TraceComponent isAnyTracingEnabled ( ) tc ( ) ) { Tr. debug ( tc,Registering JNDIEntry valueClassName with value parsedValue and JNDI name jndiName ) ; } this. serviceRegistration = context. registerService ( valueClassName, serviceObject, propertiesForJndiService ) ; }<CODESPLIT>Registers the JNDI service for the supplied properties as long as the jndiName and value are set<CODESPLIT>1
public List Map String, String getWMIObjectList ( WMIClass wClass ) { return getWMIObjectList ( wClass ( ) ) ; }<CODESPLIT>Query a list of object data for an specific class <br ><CODESPLIT>1
public static void closeEL ( Transport t ) { { if ( t null t isConnected ( ) ) t close ( ) ; } ( ) ExceptionUtil. rethrowIfNecessary ( ) ; } }<CODESPLIT>close Writer without a Exception<CODESPLIT>1
public static T ClassLoader > ElementMatcher. Junction < T > isParentOf ( ClassLoader classLoader ) { return classLoader == BOSTRAP_CLASSLOADER ElementMatchers isBootstrapClassLoader ( ) new ClassLoaderParentMatcher ( classLoader ) ; }<CODESPLIT>Matches all class loaders in the hierarchy of the matched class loader against a given matcher .<CODESPLIT>0
public void marshall ( BatchGetObjectAttributesResponse batchGetObjectAttributesResponse, ProtocolMarshaller protocolMarshaller ) { if ( batchGetObjectAttributesResponse == null ) { throw SdkClientException (Invalid marshall(...)" ) ; } try { protocolMarshaller. marshall ( batchGetObjectAttributesResponse. getAttributes ( ), ATTRIBUTESBINDING ) ; } ( ) { throw SdkClientException ( marshall request JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public void handleInputStream ( final InputStream is ) throws IOException {. trace (Handling input stream." ) ; OutputStream os = new FileOutputStream ( this. mfile ) ; { bytesWritten =. lithoot. util. IoUtils. copy ( is, os, this. mwriteListener ) ;. trace (Wrote bytesWritten to file this. mfile ) ; } IOUtils. closeQuietly ( is ) ; IOUtils. closeQuietly ( os ) ; } }<CODESPLIT>{<CODESPLIT>0
public ValidationData ruleSync ( List < ValidationRule > rules ) { ValidationRule ruleList = new ArrayList ( ) ; rules. forEach ( rule { Validation = this ( rule ) ; ruleList add ( existRule null existRule rule ) ; } ) ; this validationRules removeAll ( ruleList ) ; thisRules addAll ( this validationRules ) ; this. validationRules = ruleList ; this validationRules sort ( new RuleSorter ( ) ) ; return this ; }<CODESPLIT>Find list parent validation data .<CODESPLIT>0
protected List < String > getDataTypeStartWords ( ) { ( allStartWords null ) allStartWords = new ArrayList ( ) ; allDataTypeStartWords addAll (Types DATSTARTWORDS ) ; allDataTypeStartWords addAll ( getCustomDataTypeStartWords ( ) ) ; } return allDataTypeStartWords ; }<CODESPLIT>Returns a list of data type start words which can be used to help identify a column definition sub - statement .<CODESPLIT>1
protected void setupToolbarElements ( JToolBar toolbar ) { x = ; = new (,,, ) ; x = this. addToolBarElements ( toolbar, TOBARLOCATIONSTART, x ) ; toolbar. add ( new ( Constant. messages. getString ( panelPrefixtoolbarcontextlabel ) ), LayoutHelper.GBC ( x ++,, 1,, ) ) ; toolbar. add ( getContextSelectComboBox ( ),Helper. ( ++,,,, insets ) ) ; x = this. addToolBarElements ( toolbar, TOBARLOCATIONAFTERCONTEXTSSELECT, x ) ; toolbar. add ( new ( ), LayoutHelper.GBC ( x ++,, 1, 10 ) ) ; if ( hasOptions ( ) ) { toolbar. add ( getOptionsButton ( ),Helper. ( ++,,,, insets ) ) ; } this. addToolBarElements ( toolbar, TOOLBARLOCATIONEND, x ) ; }<CODESPLIT>Gets the Context select combo box .<CODESPLIT>0
private int parseTrailer ( byte [ ] input, int inOffset, List < WsByteBuffer > list ) throws DataFormatException { if ( TraceComponent. isAnyTracingEnabled ( ) tc. ( ) ) { Tr. debug ( tc,Parsing trailer offset + this. parseOffset + val + this. parseInt ) ; } offset = inOffset ; long val = 0L ; while ( 8 this. parseOffset offset input. length ) { ( this.Offset ) { this. parseFirstByte = input offset ; ; this. parseInt = ( ( input offset ) ) this. parseFirstByte ; ; val = ( ( input offset ) ) this. parseFirstByte ; val = ( val << 16 ) | this. parseInt ; if ( this. checksum. getValue ( ) val ) { String msg =Checksum does not match; crc + this. checksum. getValue ( ) + trailer + val ; if ( TraceComponent. isAnyTracingEnabled ( ) tc. ( ) ) { Tr. debug ( tc, msg ) ; } release ( list ) ; throw DataFormatException ( ) ; } ; val = ( ( input offset ) ) this. parseFirstByte ; val = ( val << 16 ) | this. parseInt ; if ( this. inflater. getBytesWritten ( ) val ) { String msg =BytesWritten does not match; inflater + this. inflater. getBytesWritten ( ) + " trailer + val ; if ( TraceComponent. isAnyTracingEnabled ( ) tc. ( ) ) { Tr. debug ( tc, msg ) ; } release ( list ) ; throw DataFormatException ( ) ; } this. resetNeededToProceed = true ; ; default : break ; } offset ++ ; this. parseOffset ++ ; } return offset ; }<CODESPLIT>Parse past the GZIP trailer information . This is the two ints for the CRC32 checksum validation .<CODESPLIT>1
public ObservableSecretBundle > getDeletedSecretAsync ( String vaultBaseUrl, String secretName ) { return getDeletedSecretWithServiceResponseAsync ( vaultBaseUrl, secret ) map ( new ServiceResponseSecretBundle,SecretBundle ( ) Override public DeletedSecretBundle call ( ServiceResponse DeletedSecretBundle > response ) { return body ( ) ; } } ) ; }<CODESPLIT>Permanently deletes the specified secret . The purge deleted secret operation removes the secret permanently without the possibility of recovery . This operation can only be enabled on a soft - delete enabled vault . This operation requires the secrets / purge permission .<CODESPLIT>0
public void addClassToId ( final Class <? > clazz, final String id ) { Assert. notNull ( clazz,Class null ) ; Assert. hasText ( id,Alias (id null or contain only ) ; if (ToId. ( clazz ) ) { throw IllegalArgumentException (Class clazz already defined alias (id) classToId. get ( clazz ) set another alias id ) ; } if ( idToClass. ( id ) ) { throw IllegalArgumentException ( "Alias (id) " id " used by another class " idToClass. get ( id ) " used by " clazz ) ; } classToId. put ( clazz, id ) ; idToClass. put ( id, clazz ) ; }<CODESPLIT>Adds single mapping : class < - > alias ( id ) .<CODESPLIT>1
void submit ( ) { action = ; (All ( ) ) action = CmsFlexCache. CLEAR_ONLINE_ALL ; } action = CmsFlexCache. CLEAR_ONLINE_ENTRIES ; } OpenCms. fireEvent ( new CmsEvent (EventListener. EVENTFLEXCACHECLEAR, Collections., singletonMap ( CmsFlexCache. CACHEACTION, new ( action ) ) ) ) ; }<CODESPLIT>Set defautl values to vaadin components . <p ><CODESPLIT>0
@ Override public ShutdownResult shutdown ( ShutdownRequest request ) { request beforeClientExecution ( request return executeShutdown ( request ) ; }<CODESPLIT><p > Shuts down a gateway . To specify which gateway to shut down use the Amazon Resource Name ( ARN ) of the gateway in the body of your request . < / p > <p > The operation shuts down the gateway service component running in the gateway s virtual machine ( VM ) and not the host VM . < / p > <note > <p > If you want to shut down the VM it is recommended that you first shut down the gateway component in the VM to avoid unpredictable conditions . < / p > < / note > <p > After the gateway is shutdown you cannot call any other API except <a > StartGateway< / a > <a > DescribeGatewayInformation< / a > and <a > ListGateways< / a > . For more information see <a > ActivateGateway< / a > . Your applications cannot read from or write to the gateway s storage volumes and there are no snapshots taken . < / p > <note > <p > When you make a shutdown request you will get a <code > 200 OK< / code > success response immediately . However it might take some time for the gateway to shut down . You can call the <a > DescribeGatewayInformation< / a > API to check the status . For more information see <a > ActivateGateway< / a > . < / p > < / note > <p > If do not intend to use the gateway again you must delete the gateway ( using <a > DeleteGateway< / a > ) to no longer pay software charges associated with the gateway . < / p ><CODESPLIT>1
@ GuardedBy ( "monitor" ) @ VisibleForTesting static MetricServiceClient createMetricServiceClient ( @ Nullable Credentials credentials ) throws IOException {ServiceSettings settingsBuilder =ServiceSettings newBuilder ( ) setTransportChannelProvider (GrpcChannelProvider newBuilder ( ) setHeaderProvider ( OPENUSERHEADER ) build ( ) ) ; ( credentials null ) settingsBuilder setCredentialsProvider ( FixedCredentialsProvider create ( credentials ) ) ; } return MetricServiceClient. create ( settingsBuilder. build ( ) ) ; }<CODESPLIT>Resets exporter to null . Used only for unit tests .<CODESPLIT>0
public final List < Connection > getConnections ( final ConnectionMode connectionMode, final String dataSourceName, final int connectionSize ) throws SQLException { DataSource dataSource = getDataSourceMap ( ). ( dataSourceName ) ; Preconditions. checkState ( null dataSource,Missing the data source names, dataSourceName ) ; Collection Connection connections ; synchronized (Connections ) { connections = cachedConnections. ( dataSourceName ) ; } List Connection result ; ( connections ( ) connectionSize ) result = new ArrayList ( connections ) subList ( connection ) ; } ( connections isEmpty ( ) ) result = new ArrayList ( connection ) ; result. addAll ( connections ) ; List Connection newConnections = createConnections ( dataSourceName connection dataSource connection connections ( ) ) ; result addAll ( newConnections ) ; synchronized (Connections ) { cachedConnections putAll ( dataSourceName newConnections ) ; } } result = new ArrayList ( createConnections ( dataSourceName connection dataSource connection ) ) ; synchronized (Connections ) { cachedConnections. putAll ( dataSourceName, result ) ; } } return result ; }<CODESPLIT>Get database connections .<CODESPLIT>1
public void copyFrom ( TextImage source, int startRowIndex, int rows, int startColumnIndex, int columns, int destinationRowOffset, int destinationColumnOffset ) { source copyTo ( backend start startColumnIndex columns destinationRow destination ) ; }<CODESPLIT>Copies the content from a TextImage into this buffer .<CODESPLIT>1
public LocalDateTime minusWeeks ( long weeks ) { return ( weeks Long MIN plusWeeks ( Long MAX ) plusWeeks ( 1 ) plusWeeks ( - weeks ) ) ; }<CODESPLIT>Returns a copy of this { @code LocalDateTime } with the specified number of months subtracted . <p > This method subtracts the specified amount from the months field in three steps : <ol > <li > Subtract the input months from the month - of - year field< / li > <li > Check if the resulting date would be invalid< / li > <li > Adjust the day - of - month to the last valid day if necessary< / li > < / ol > <p > For example 2007 - 03 - 31 minus one month would result in the invalid date 2007 - 04 - 31 . Instead of returning an invalid result the last valid day of the month 2007 - 04 - 30 is selected instead . <p > This instance is immutable and unaffected by this method call .<CODESPLIT>0
public static String concat ( String... strs ) { sb = new ( ) ; for ( str strs ) ( str ) ; } return sb. toString ( ) ; }<CODESPLIT>快速连接参数中的字符串 .<CODESPLIT>1
@ (unchecked ) public static T T buildApplicationObject ( Class T interfaceClass, Class T extendedInterfaceClass, Class T extendedInterfaceWrapperClass, Collection String classNamesIterator, T defaultObject ) { return buildApplicationObject ( interfaceClass, extendedInterfaceClass, extendedInterfaceWrapperClass, classNamesIterator, defaultObject, null ) ; }<CODESPLIT>Creates ApplicationObjects like NavigationHandler or StateManager and creates the right wrapping chain of the ApplicationObjects known as the decorator pattern .<CODESPLIT>0
@ Override public synchronized RecordStructure read ( long sessionId, long urlId ) throws DatabaseException { psRead setLong ( sessionId ) ; psRead setLong ( urlId ) ; ( ResultSet rs psRead executeQuery ( ) ) { RecordStructure result = build ( rs ) ; return result ; } } ( SQLException ) DatabaseException ( ) ; } }<CODESPLIT>This method initializes this<CODESPLIT>0
@ Override public final T process ( final Map < String, Object > pAddParam, final T pEntity, final IRequestData pRequestData ) throws Exception { fieldPathName = pRequestData. getParameter (fieldNameFilePath ) ; Method getterFieldPath = this. gettersRapiHolder. getFor ( pEntity. getClass ( ), fieldPathName ) ; filePath = ( String ) getterFieldPath. invoke ( pEntity ) ; ( filePath null ) File fileToDel = new File ( filePath ) ; ( fileTo exists ( ) fileTo delete ( ) ) (.WR delete file ) ; } } this. srvOrm. deleteEntity ( pAddParam, pEntity ) ; return null ; }<CODESPLIT><p > Process entity request . < / p ><CODESPLIT>1
protected int getTransactionIsolation ( ) { val = props. ( PROTRANSACTIONIS ) ; return val == null - 1 : Integer. parseInt ( val ) ; }<CODESPLIT>transactionIsolationオプションの指定<CODESPLIT>1
public static int kronecker ( BigInteger a, BigInteger p ) { return INSTANCE get ( ) krImpl (, ) ; }<CODESPLIT>Verifies this library is loaded properly .<CODESPLIT>0
private static void parseBounds ( JSONObject modelJSON, Shape current ) throws JSONException { if ( modelJSON. has (bounds ) ) { JSONObject boundsObject = modelJSON. getJSONObject (bounds ) ; current. setBounds ( new Bounds ( new ( boundsObject. getJSONObject (Right ). getDouble ( ), boundsObject. getJSONObject (Right ). getDouble ( ) ), new ( boundsObject. getJSONObject (upperLeft ). getDouble ( ), boundsObject. getJSONObject (upperLeft ). getDouble ( ) ) ) ) ; } }<CODESPLIT>creates a point array of all dockers and add it to the current shape<CODESPLIT>0
@ Override public ParseResult parse ( Reader reader, AttributeSource parent ) throws IOException { ParseResult res = new ParseResult ( ) ; StringBuilder sb = new StringBuilder ( ) ; char buf = new char 128 ; ; while ( ( reader ( buf ) ) ) sb ( buf,, cnt ) ; } Iterator < MtasUpdateRequestProcessorResultItem > iterator ; ( MtasUpdateRequest result MtasUpdateRequest ( ( ) ) ; ) { iterator = result getIterator ( ) ; ( iterator null iterator hasNext ( ) ) res str = result. getStoreStringValue ( ) ; res. bin = result. getStoreBinValue ( ) ; } res str = null ; res bin = null ; result. close ( ) ; return res ; } parent. clearAttributes ( ) ; while ( iterator ( ) ) MtasUpdateRequestProcessorResultItem item = iterator. next ( ) ; ( item tokenTerm null ) CharTermAttribute catt = parent. addAttribute ( CharTermAttribute. ) ; catt. ( item. tokenTerm ) ; } ( item tokenFlags null ) FlagsAttribute flags = parent. addAttribute ( FlagsAttribute. ) ; flags setFlags ( item tokenFlags ) ; } ( item tokenIn null )IncrementAttribute patt = parent. addAttribute (IncrementAttribute. ) ; setPositionIncrement ( item tokenPosIn ) ; } ( item tokenPayload null ) PayloadAttribute p = parent. addAttribute ( PayloadAttribute. ) ; setPayload ( new BytesRef ( item tokenPayload ) ) ; } ( item tokenOffsetStart null item tokenOffsetEnd null ) OffsetAttribute offset = parent. addAttribute ( OffsetAttribute. ) ; offset setOffset ( item tokenOffsetStart item tokenOffsetEnd ) ; } State state = parent. captureState ( ) ; res. states. add ( state. clone ( ) ) ; parent. clearAttributes ( ) ; } } ( ) log. ( ) ; } return res ; }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
public String getMessage ( final String code ) { assert code null ; MissingResourceException error = null ; ResourceBundle bundles = getBundles ( ) ; for ( bundles. ) { try { return bundles [ i ]. getString ( code ) ; } (ResourceException ) { if ( error null ) { error = e ; } } } assert error null ; throw error ; }<CODESPLIT>An implementation of { @link Parser } s abstract { @link Parser#flatten ( Options String [] boolean ) flatten } method . <p > The following are the rules used by this flatten method . <ol > <li > if <code > stopAtNonOption< / code > is <b > true< / b > then do not burst anymore of <code > arguments< / code > entries just add each successive entry without further processing . Otherwise ignore <code > stopAtNonOption< / code > . < / li > <li > if the current <code > arguments< / code > entry is <b > -- < / b > just add the entry to the list of processed tokens< / li > <li > if the current <code > arguments< / code > entry is <b > - < / b > just add the entry to the list of processed tokens< / li > <li > if the current <code > arguments< / code > entry is two characters in length and the first character is <b > - < / b > then check if this is a valid { @link Option } id . If it is a valid id then add the entry to the list of processed tokens and set the current { @link Option } member . If it is not a valid id and <code > stopAtNonOption< / code > is true then the remaining entries are copied to the list of processed tokens . Otherwise the current entry is ignored . < / li > <li > if the current <code > arguments< / code > entry is more than two characters in length and the first character is <b > - < / b > then we need to burst the entry to determine its constituents . For more information on the bursting algorithm see { @link GroovyInternalPosixParser#burstToken ( String boolean ) burstToken } . < / li > <li > if the current <code > arguments< / code > entry is not handled by any of the previous rules then the entry is added to the list of processed tokens . < / li > < / ol ><CODESPLIT>0
@ Override public Iterable < T > findAll ( @ NonNull Sort sort ) { notNull ( sortsort findAll null ) ; DocumentQuery query new DocumentQuery ( Criteria ( Criteria ALL ) ) with ( sort ) ; return operation. find ( query, information. getJavaType ( ), information. getCollectionName ( ) ) ; }<CODESPLIT>Returns all entities sorted by the given options .<CODESPLIT>1
void loadConfigs ( ) throws IOException { application loadConfig ( ) ; user loadConfig ( ) ; system loadConfig ( ) ; config application getConfig ( )Fallback ( user getConfig ( ) ) withFallback ( system getConfig ( ) ) ; dumpdebugLog (MERGED config ) ; }<CODESPLIT>end of class ConfigSource<CODESPLIT>0
private void appendLine ( final String timeStampStr, final int indentLevel, final String line, final StringBuilder buf ) { buf. append ( timeStampStr ) ; buf. append ( ) ; buf. append ( ClassGraph. class. ( ) ) ; buf. append ( ) ;ashes = ( indentLevel - 1 ) ; for ( ) { buf. append ('' ) ; } if (ashes ) { buf. append ('' ) ; } buf. append ( line ) ; buf. append ('' ) ; }<CODESPLIT>Add a child log node .<CODESPLIT>0
static public String createMonitor ( String monitorUrl, Node parserInstruction, String modifiesResponse, TECore core ) { MonitorCall mc = monitors. ( monitorUrl ) ; mc setCore ( core ) ; ( parser null ) mc setParserInstruction ( Dom getElement ( parserInstruction ) ) ; mc setResponse ( parseBoolean (Response ) ) ; }R. log (. CONFIGConfigured monitor without test {0}" ) ; return "" ; }<CODESPLIT>Monitor without parser that doesn t trigger a test<CODESPLIT>0
public void addRelationToResource ( CmsDbContext dbc, CmsResource resource, CmsResource target, CmsRelationType type, boolean importCase ) throws CmsException { ( type isDefinedInContent ( ) ) CmsIllegalArgumentException (. get ( ). (.ADDRELATION dbc. remove ( resource. ( ) ) dbc. remove ( target. ( ) ) type. ( dbc. ( ). ( ) ) ) ) ; } Cms relation = new Cms ( resource, target, type ) ; getVfsDriver ( dbc ). createRelation ( dbc, dbc. currentProject ( ). getUuid ( ), relation ) ; ( importCase ) log ( dbc, new Cms ( dbc, resource ( ), CmsType. RESOURCEADDRELATION, new { relation. getSourcePath ( ) relation. getTargetPath ( ) } ) false ) ; setDateLastModified ( dbc, resource, System. ( ) ) ; } }<CODESPLIT>Adds a resource to the given organizational unit . <p ><CODESPLIT>0
public void marshall ( AssociateProductWithPortfolioRequest associateProductWithPortfolioRequest, ProtocolMarshaller protocolMarshaller ) { ( associateProductWithPortfolioRequest == null ) SdkClientException ( marshall(...)" ) ; } { protocolMarshaller. marshall ( associateProductWithPortfolioRequest. getAcceptLanguage ( ), ACCEPTLANGUAGEBINDING ) ; protocolMarshaller. marshall ( associateProductWithPortfolioRequest. getProductId ( ),IDBINDING ) ; protocolMarshaller. marshall ( associateProductWithPortfolioRequest. getPortfolioId ( ), PORTFIOIDBINDING ) ; protocolMarshaller. marshall ( associateProductWithPortfolioRequest. getSourcePortfolioId ( ), SOURCEPORTFIOIDBINDING ) ; } ( ) SdkClientException ( marshall request. ( ) ) ; } }<CODESPLIT><p > To help organize your resources you can assign your own metadata to the resources that you create . Each tag is a key - value pair . < / p ><CODESPLIT>0
public static void swap ( int [ ] intArray1, int array1Index, int [ ] intArray2, int array2Index ) { if ( intArray array1Index intArray2 array2Index ) { hold =Array1 array1Index ;Array1 array1Index =Array2 array2Index ;Array2 array2Index = hold ; } }<CODESPLIT>Helper method that swaps all the elements of the arrays . This method runs in O ( <code > Math . min ( array1 . length array2 . length< / code > ) time .<CODESPLIT>1
public void marshall ( DeleteUserRequest deleteUserRequest, ProtocolMarshaller protocolMarshaller ) { if ( deleteUserRequest == null ) { throw SdkClientException (Invalid marshall(...)" ) ; } try { protocolMarshaller. marshall ( deleteUserRequest. getUserName ( ), USERNAMEBINDING ) ; protocolMarshaller. marshall ( deleteUserRequest. getAuthenticationType ( ), AUTHTYPEBINDING ) ; } ( ) { throw SdkClientException ( " marshall request JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
protected void addWebuserCondition ( CmsSelectQuery select, CmsOrganizationalUnit orgUnit, TableAlias users ) { webuserConditionTemplate ; ( hasWebuser ( ) ) webuserConditionTemplate = %1$s8 AND %1$s < 65536 ; } webuserConditionTemplate = %1$s <8 OR %1$s 65536 ; } webuserCondition = ( webuserConditionTemplate users column (Flags ( ) ) ) ; select addCondition ( webuserCondition ) ; }<CODESPLIT>Adds a check for the web user condition to an SQL query . <p ><CODESPLIT>1
void add ( LessExtend lessExtend, String [ ] mainSelector ) { ( mainSelector null mainSelector ( "@media ) ) mainSelector = lessExtend getSelectors ( ) ; } mainSelector = Selector merge ( mainSelector, lessExtend getSelectors ( ) ) ; } extendingSelector = lessExtendExtendingSelector ( ) ; ( lessExtendAll ( ) ) LessExtendResult extend = new LessExtendResult ( mainSelector extendingSelector ) ; SelectorTokenizer tokenizer = tokenizers pollLast ( ) init ( extendingSelector ) ; do { token = tokenizer next ( ) ; ( token null ) } all add ( token, extend ) ; } while ( ) ; tokenizers addLast ( tokenizer ) ; } exact add ( extendingSelector, mainSelector ) ; } }<CODESPLIT>Add to the given selectors all possible extends and return the resulting selectors .<CODESPLIT>0
JMFSchema [ ] getEncodingSchemas ( ) throws MessageEncodeFailedException { if ( TraceComponent isAnyTracingEnabled ( ) tc isEntryEnabled ( ) ) SibTr entry ( this tcgetEncodingSchemas ) ; JMFSchema [ result ; { JMFSchema result1 = ( ( JMFMessage ) headerPart.Part ). getSchemata ( ) ; JMFSchema result2 = null ; resultSize = result1. length ; if ( payloadPart null ) { result2 = ( ( JMFMessage ) payloadPart.Part ). getSchemata ( ) ; resultSize += result length ; } result = new JMFSchema resultSize ; System. arraycopy ( result1, 0, result, 0, result1. length ) ; if ( payloadPart null ) { System. arraycopy ( result2, 0, result, result1. length, result2. length ) ; } } ( JMF ) {. ( e,comibmwsfpimplJsMsgObjectgetEncodingSchemas,jmo, this, new { new { MfpConstants. DM_MESSAGE, headerPart. jmfPart, theMessage }, new { MfpConstants. DM_MESSAGE, payloadPart. jmfPart, theMessage } } ) ; if ( TraceComponent isAnyTracingEnabled ( ) tc ( ) ) SibTr ( this tcgetEncodingSchemas e ) ; MessageEncode ( ) ; } if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) SibTr. ( this tcgetEncodingSchemas ) ; return result ; }<CODESPLIT>Get a list of the JMF schemas needed to decode this message<CODESPLIT>1
public boolean add ( final int value ) { if ( size == capacity ) { IllegalStateException ( IntHashSet capacity capacity full ) ; } index =Hash ( value, mask ) ; while ( values index missingValue ) { if ( values index == value ) { return false ; } index = next ( index ) ; } values [ index = value ; size ++ ; return true ; }<CODESPLIT>Splits a { @link ClientMessage } into frames of a maximum size .<CODESPLIT>0
private void delete_obj_property ( Database database, String name, String type, String propname ) throws DevFailed { ( databaseAccesschecked ( ) ) checkAccess ( database ) ; array ; array = new ; array 0 = propname ; deleteobjproperty ( database, name, type, array ) ; }<CODESPLIT>==========================================================================<CODESPLIT>1
public static int getCtrlOrMetaModifier ( ) {Browser webBrowser = Page getCurrent ( ) getWebBrowser ( ) ; (BrowserMac ( ) ) return ShortAction. ModifierKey. META ; } return ShortAction. ModifierKey. CTRL ; }<CODESPLIT>Dynamic styles for window .<CODESPLIT>0
public User resolveUser ( final long userId ) throws SQLException { metrics userCacheTries mark ( ) ; user = userCache.If ( userId ) ; ( user ) metrics userCacheHits mark ( ) ; return user ; } user = selectUser ( userId ) ; ( user ) userCache put ( userId, user ) ; } return user ; } }<CODESPLIT>Resolves a user by username possibly with the internal cache .<CODESPLIT>1
public static String buildCleanedParametersURIRepresentation ( org. apache. commons. httpclient. URI uri, SpiderParam. HandleParametersOption handleParameters, boolean handleODataParametersVisited ) throws URIException { ( handleParameters ( HandleParametersOptionALL ) ) return uri. toString ( ) ; } ( handleParameters ( HandleParametersOption IGNORECOMPLETE ) ) return createBaseUriWithCleanedPath ( uri, handleParameters, handleODataParametersVisited ) ; } ( handleParameters ( HandleParametersOption IGNORE ) ) StringBuilder retVal = new StringBuilder ( createBaseUriWithCleanPath ( uri handleParameters handleDataParameters ) ) ; cleanedQuery = getCleQuery ( uri getEQuery ( ) ) ; ( cleanedQuery ( ) ) retVal. ( ). (Query ) ; } return retVal. toString ( ) ; } return uri. toString ( ) ; }<CODESPLIT>Tells whether or not the given port is the default for the given scheme . <p > <strong > Note : < / strong > Only HTTP and HTTPS schemes are taken into account .<CODESPLIT>0
public int run ( String arg, boolean stdin, boolean force ) throws IOException { OutputStream outputStream = null ; InputStream inputStream = null ; KeystoreWrapper keystoreWrapper ; { ( command ) { CREATE ( ksExists ( ) ) proceed = promptYesNo (An eshadoop keystore already exists Overwrite?N]" ) ; ( proceed == false ) prompt. println (Exiting without creating keystore ) ; return 0 ; } } keystoreWrapper = KeystoreWrapper. newStore ( ). build ( ) ; outputStream = openWrite ( ) ; keystoreWrapper. saveKeystore ( outputStream ) ; return 0 ; LIST (! ksExists ( ) ) prompt. (ERROR ESHadoop keystore not found Uses command to create one, Command. CREATE. getText ( ) ) ; return 5 ; } inputStream = openRead ( ) ; keystoreWrapper = KeystoreWrapper. loadStore ( inputStream ). build ( ) ; for ( keystoreWrapper. listEntries ( ) ) { prompt. println ( entry ) ; } return 0 ; ADD (! ksExists ( ) ) prompt. (ERROR ESHadoop keystore not found Uses command to create one, Command. CREATE. getText ( ) ) ; return 5 ; } inputStream = openRead ( ) ; keystoreWrapper = KeystoreWrapper. loadStore ( inputStream ). build ( ) ; ( keystoreWrapper containsEntry ( arg ) force == false ) proceed = promptYesNo (Settings already exists Overwrite?N]", arg ) ; ( proceed == false ) prompt. println (Exiting without modifying keystore ) ; return 0 ; } } ( stdin ) data = prompt. readLine ( ) ; keystoreWrapper setSecureSetting ( arg, data ) ; } data = prompt. readPassword (Enter value fors:", arg ) ; keystoreWrapper. setSecureSetting ( arg, new ( data ) ) ; Arrays. fill ( data, ( ) ) ; } outputStream = openWrite ( ) ; keystoreWrapper. saveKeystore ( outputStream ) ; return 0 ; REMOVE (! ksExists ( ) ) prompt. (ERROR ESHadoop keystore not found Uses command to create one, Command. CREATE. getText ( ) ) ; return 5 ; } inputStream = openRead ( ) ; keystoreWrapper = KeystoreWrapper. loadStore ( inputStream ). build ( ) ; ( keystoreWrapper containsEntry ( arg ) == false ) prompt. (ERROR Settings does not in the keystore, arg ) ; return 6 ; } keystoreWrapper. removeSecureSetting ( arg ) ; outputStream = openWrite ( ) ; keystoreWrapper. saveKeystore ( outputStream ) ; return 0 ; default prompt. println (ERROR command command. ( ) ) ; return 7 ; } } ( eh ) prompt. println (ERROR load keystore file eh. ( ) ) ; return 8 ; } ( FileNotFoundException ) prompt. println (ERROR load keystore file. ( ) ) ; return 9 ; } ( IOException ) prompt. println (ERROR. ( ) ) ; return 10 ; } ( outputStream null ) outputStream. close ( ) ; } ( inputStream null ) inputStream. close ( ) ; } } }<CODESPLIT>{<CODESPLIT>0
private boolean updateStreamBlacklist ( Set < Tuple2 < String, String > > processingBlacklist, Message message, Set < String > initialStreamIds ) { addedStreams = false ; for ( messageStreams ( ) ) ( initialStreamIds remove ( stream ( ) ) ) addedStreams = ; } processingBlacklist add ( tuple ( message ( ), stream ( ) ) ) ; } } return addedStreams ; }<CODESPLIT>Evaluates all pipelines that apply to the given messages based on the current stream routing of the messages .<CODESPLIT>0
protected boolean isFirehoseDrainableByClosing ( FirehoseFactory firehoseFactory ) { return firehoseFactoryReceiverFirehoseFactory ( firehoseFactory TimedShFirehoseFactory isFirehoseByClosing ( ( ( TimedShFirehoseFactory ) firehoseFactory ) getDelegateFactory ( ) ) ) ( firehoseFactoryFirehoseFactory isFirehoseByClosing ( ( (pedFirehoseFactory ) firehoseFactory ) getDelegate ( ) ) ) ; }<CODESPLIT>Is a firehose from this factory drainable by closing it? If so we should drain on stopGracefully rather than abruptly stopping . <p > This is a hack to get around the fact that the Firehose and FirehoseFactory interfaces do not help us do this . <p > Protected for tests .<CODESPLIT>1
public boolean dispatchKeyEvent ( KeyEvent event ) { GVRCursorController controller getUniqueController ( event getDevice ( ) ) ; ( ) return controller dispatchKeyEvent ( event ) ; } return false ; }<CODESPLIT>returns controller if a new device is found<CODESPLIT>0
public boolean isDerivation ( Type parent, Type child ) { ( child ( parent ) ) return true ; } ( child N ) Type. Nominal t = ( Type. Nominal ) child ; = t getLink ( ). getTarget ( ) ; return isDerivation ( parent, decl. getType ( ) ) ; } return false ; } }<CODESPLIT>Check whether one type is a derivation of another . For example in this scenario :<CODESPLIT>1
public void setSelectedClass ( java lang String selectedClass ) { getState ( ) ( PropertyKeys selectedClass selectedClass ) ; }<CODESPLIT><p > Return the value of the <code > selectedClass< / code > property . < / p > <p > Contents : CSS style class to apply to the rendered label on selected options .<CODESPLIT>0
public static T > Predicates T > attributeIn ( Function < T, > function, Iterable < > iterable ) { return new AttributePredicate, Object ( function, Pred in ( iterable ) ) ; }<CODESPLIT>Creates a predicate which returns true if an attribute selected from an object passed to accept method is contained in the iterable .<CODESPLIT>1
private void validateRequest ( DownloadRequest dreq ) throws ErrorResponseException { String path = dreq. getPath ( ) ; if ( path endsWith ( ResourceCatalog VERSIONXMLFILENAME ) path ( "__ ) ) { ErrorResponseException ( DownloadResponse. getContentResponse ( ) ) ; } }<CODESPLIT>Make sure that it is a valid request . This is also the place to implement the reverse IP lookup<CODESPLIT>1
public AutofitHelper setEnabled ( boolean enabled ) { ( enabled ) mEnabled = enabled ; ( enabled ) mTextView addTextChangedListener ( mTextWatcher ) ; mTextView addOnLayoutChangeListener ( mOnLayoutChangeListener ) ; autof ( ) ; } mTextView removeTextChangedListener ( mTextWatcher ) ; mTextView removeOnLayoutChangeListener ( mOnLayoutChangeListener ) ; mTextView setTextSize ( Typed mTextSize ) ; } } return this ; }<CODESPLIT>Set the enabled state of automatically resizing text .<CODESPLIT>1
public static void checkIfUnmodifiedSince ( final String ifUnmodifiedSince, final Instant modified ) { Instant time = parseDate ( ifUnmodifiedSince ) ; ( time modifiedTo ( SECONDS )After ( time ) ) ClientErrorException ( status ( PRECONDITION ) build ( ) ) ; } }<CODESPLIT>Check for a conditional operation .<CODESPLIT>1
public void setProgress ( CmsUploadProgessInfo info ) { currFile = info. getCurrentFile ( ) ; currFileIndex = ; ( currFile == ) } currFileIndex = currFile - 1 ; ( currFileIndex morderedFilenamesToUpload ( ) ) currFileIndex = m_orderedFilenamesToUpload. size ( ) - 1 ; } } if ( mcontentLength == ) mcontentLength = info. getContentLength ( ) ; } String currFilename = morderedFilenamesToUpload. ( currFileIndex ) ; String contentLength = CmsUploadButton. formatBytes ( mcontentLength ) ; fileCount = morderedFilenamesToUpload. size ( ) ; String readBytes = CmsUploadButton. formatBytes ( getBytesRead ( info. getPercent ( ) ) ) ; mbar. setValue ( info. getPer ( ) ) ; if ( mstarted ) mstarted = true ; mfileinfo. setHTML ( 0, 0, + Messages. ( ). key ( Messages.UPLOADPROGRESSCURRENTFILE ) + ) ; mfileinfo. setHTML (, 0, + Messages. ( ). key ( Messages.UPLOADPROGRESSUPLOAD ) + ) ; mfileinfo. setHTML (, 0, "" ) ; mfileinfo. setText ( 0,, "" ) ; mfileinfo. setText (,, "" ) ; mfileinfo. setText (,, "" ) ; mfileinfo. getColumnFormatter ( ). setWidth ( 0, ) ; } mfileinfo. setText ( 0,, currFilename ) ; mfileinfo. setText ( 1, 1, Messages. ( ). key ( Messages.UPLOADPROGRESSCURRENTVALUE, new Integer ( currFileIndex 1 ), new Integer ( fileCount ), getFileText ( ) ) ) ; mfileinfo. setText (,, Messages. ( ). key ( Messages.UPLOADPROGRESSUPLOAD2, readBytes, contentLength ) ) ; }<CODESPLIT>Returns the file text . <p ><CODESPLIT>0
public static void escape ( String str, StringBuilder rval ) { for ( str. length ( ) ) { char hi = str. charAt ( ) ; if ( hi <= 08 hi == 0xB hi == 0 ( hi >= 0xE hi <= 01F ) ( hi >= 07F hi <= 0xA0 ) ( ( hi >= 024F! Character. isHighSurrogate ( hi ) ) ) ) { rval. append ( String. format ( "\\u%04x", ( int ) hi ) ) ; } if ( Character. isHighSurrogate ( hi ) ) { char lo = str. charAt ( ++ ) ; c = ( hi << 10 ) + lo + ( 0x10000 - ( 0xD800 << 10 ) - 0xDC00 ) ; rval. append ( String. format ( "\\U%08x", c ) ) ; } { switch ( hi ) { rval. append ( "\\b" ) ; ; rval. append ( "\\n" ) ; ; rval. append ( "\\t" ) ; ; rval. append ( "\\f" ) ; ; rval. append ( "\\r" ) ; ; rval. append ( "\\\"" ) ; ; rval. append ( "\\\\" ) ; ; default : rval. append ( hi ) ; ; } } } }<CODESPLIT>Parses the authority for the pre - parsed given JsonLdUrl .<CODESPLIT>0
public static void sendClose ( final ByteBuffer data, final WebSocketChannel wsChannel, final WebSocketCallback Void > callback ) { Close new Close ( data ) ; sendClose ( callback ) ; }<CODESPLIT>Sends a complete close message invoking the callback when complete<CODESPLIT>0
public CharacterSet getInverse ( ) {SetSet ( ) ; n forbiddenCharacters = characters ; n characters = forbiddenCharacters ; return ; }<CODESPLIT>Write VCF record with the specified print writer .<CODESPLIT>0
protected boolean readFeatureParameters ( Element node ) { try { NodeList childrent = node. getChildNodes ( ) ; cpnames = new Vector String ( ) ; paras = new Vector Vector Integer ( ) ; for ( child. ( ) ) ( child. item ( ) Element ) { Element child = ( Element ) childrent. item ( ) ; String value = child. getAttribute ( "value" ) ; String parastr = value. split ( ":" ) ; Vector Integer para = new Vector Integer ( ) ; for ( 3 paras. length ) { para. add ( Integer. parseInt ( parastr [ j ) ) ; } cpnames. add ( parastr [ 2 ) ; paras. add ( para ) ; } } ( ) { System. out. println (. ( ) ) ; e. printStackTrace ( ) ; return false ; } return true ; }<CODESPLIT>Read feature parameters .<CODESPLIT>1
public Node insertBefore ( Node newChild, Node refChild ) throws DOMException { error (ErrorResourcesFUNCTIONNOT ) ; return null ; }<CODESPLIT>Unimplemented . See org . w3c . dom . Node<CODESPLIT>1
public static AuthToken basic ( String username, String password, String realm ) { Objects. requireNonNull ( username,Username null ) ; Objects. requireNonNull ( password,Password null ) ; Map, Value map = newHashMapWithSize ( ) ; map. put ( SCHEME, value (basic ) ) ; map. put ( PRIP, value ( username ) ) ; map. put ( CREDIALS, value ( password ) ) ; ( realm null ) map. put ( REALM, value ( realm ) ) ; } return new InternalAuthToken ( map ) ; }<CODESPLIT>The basic authentication scheme using a username and a password .<CODESPLIT>1
private Function Expression, Statement addNodeToPlaceholderMap ( String mapKey, StandaloneNode node ) { return putToMap ( mapKey, placeholder compileToSoProvider ( mapKey, node, ExtraCodeCompiler NO, ExtraCodeCompiler NO ) ) ; }<CODESPLIT>See go / soy - element - keyed - roots for reasoning on why this is disallowed .<CODESPLIT>0
public void marshall ( MetricDefinition metricDefinition, ProtocolMarshaller protocolMarshaller ) { if ( metricDefinition == null ) { throw SdkClientException (Invalid marshall(...)" ) ; } try { protocolMarshaller. marshall ( metricDefinition. getName ( ), NAMEBINDING ) ; protocolMarshaller. marshall ( metricDefinition. getRegex ( ), REGEXBINDING ) ; } ( ) { throw SdkClientException ( marshall request JSON ". ( ) ) ; } }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>1
static String [ ] split ( URI remoteUri, String suffix, @ Nullable String defaultBranch ) { String host = remoteUri. getHost ( ) ; if ( host == null remoteUri getScheme ( ) endsWith (file ) ) { IllegalArgumentException ( host remoteUri remoteUri ) ; } String path = remoteUri. getRawPath ( ) ; if ( path == null ) { IllegalArgumentException ( path remoteUri remoteUri ) ; } matcher = Pattern. compile ( "^?." suffix| ). matcher ( path ) ; if ( find ( ) ) { IllegalArgumentException (." suffix remoteUri path remoteUri ) ; } String newRemoteUri ; port = remoteUri. getPort ( ) ; if ( host null ) { if ( port ) { newRemoteUri = remoteUri. getScheme ( ) +://" + host + + port + matcher. group ( 1 ) ; } { newRemoteUri = remoteUri. getScheme ( ) +://" + host + matcher. group ( 1 ) ; } } { newRemoteUri = remoteUri. getScheme ( ) +://" + matcher. group ( 1 ) ; } String remotePath ; { String decoded = URLDecoder. decode ( path. ( matcher. group ( 1 ). length ( ) ),UTF ) ; decoded = normalizePath ( decoded ) ; remotePath = decoded ; } ( UnsupportedEncodingException ) { Error ( ) ; } String fragment = remoteUri. getFragment ( ) ; String remoteBranch = fragment null fragment : defaultBranch ; return new String [ ] { newRemoteUri, remotePath, remoteBranch } ; }<CODESPLIT>Splits the specified remoteUri into : - the actual remote repository URI - the path in the remote repository - the branch name .<CODESPLIT>1
public static List < Class <? > > resolveHierarchy ( final Class <? > type ) { List Class res =. newArrayList ( ) ; Class current = type ; while ( Object.. ( ) current ) { res. add ( current ) ; current = current. getSuperclass ( ) ; } return res ; }<CODESPLIT>Assigns base class in scheme for provided model type ( for example to make class vertex type it must extend V ) .<CODESPLIT>0
public void setRefreshing ( boolean refreshing ) { if ( refresh mRefresh refresh ) mRefreshing = refreshing ; endTarget = ; if ( mUsingCustomStart ) ( mDirection ) { BOTTOM endTarget getMeuredHeight ( ) ( ) (SpinnerFinalOffset ) ; ; TOP default endTarget ( ) (SpinnerFinalOffset - (OriginalOffsetTop ) ) ; ; } } endTarget = ( int ) mSpinnerFinalOffset ; } setTargetOffsetTopAndBottom ( endTarget - mCurrentTargetOffsetTop, true ) ; mNotify = false ; startScaleUpAnimation ( mRefreshListener ) ; } setRefreshing ( refreshing, false ) ; } }<CODESPLIT>Notify the widget that refresh state has changed . Do not call this when refresh is triggered by a swipe gesture .<CODESPLIT>1
private Field [ ] getAllInstanceFields ( final Object obj ) { Field fields = instanceFieldsByClass. ( obj. ( ) ) ; ( fields null ) List Field fieldList = Reflection getAllFields ( obj excludeStatic excludeTransient ) ; fields = fieldList ( new Field fieldList ( ) ) ; instanceFieldsByClass put ( obj. getClass ( ), fields ) ; } return fields ; }<CODESPLIT>Visits all the keys and entries of the given map .<CODESPLIT>0
private Map < VectorLayer, Filter > dtoAttributeCriterionToFilters ( AttributeCriterion criterion ) throws GeomajasException { Map VectorLayer, Filter filters = new LinkedHashMap VectorLayer, Filter ( ) ; Filter f ; VectorLayer l = configurationService.VectorLayer ( criterion. getServerLayerId ( ) ) ; ( l == null ) GeomException (Code. LAY criterion. getServerLayer ( ) ) ; } operator = criterion. getOperator ( ) ; (LIKE ( operator toUpperCase ( ) ) ) f = filterService. createLikeFilter ( criterion. getAttributeName ( ), criterion. getValue ( ) ) ; } ( ( operator toUpperCase ( ) )BEFORE ( operator toUpperCase ( ) )AFTER ( operator toUpperCase ( ) ) ) f = filterService. parseFilter ( criterion. toString ( ) ) ; } f = filterService. createCompareFilter ( criterion. getAttributeName ( ), criterion. getOperator ( ), criterion. getValue ( ) ) ; } filters. put ( l, f ) ; return filters ; }<CODESPLIT>Prune impossible combinations . ( eg . If And criteria filter different layers they will return nothing so they are pruned ) .<CODESPLIT>0
public Session createMailSession ( final String host, final int port, final String username, final String password ) { Properties props transportStrategy generateProperties ( ) ; props ( transportStrategy propertyNameHost ( ) host ) ; props ( transportStrategy propertyNamePort ( ) ( port ) ) ; ( username ) props put ( transportStrategy propertyNameUsername ( ) username ) ; } ( password ) props put ( transportStrategy propertyNameAuthenticate ( ) ) ; return Session. getInstance ( props, new Authenticator ( ) @ Override protected PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( username, password ) ; } } ) ; } return Session. getInstance ( props ) ; } }<CODESPLIT>Actually instantiates and configures the { @link Session } instance . Delegates resolving transport protocol specific properties to the { @link #transportStrategy } in two ways : <ol > <li > request an initial property list which the strategy may pre - populate< / li > <li > by requesting the property names according to the respective transport protocol it handles ( for the host property name it would be <em > mail . smtp . host < / em > for SMTP and <em > mail . smtps . host < / em > for SMTPS ) < / li > < / ol ><CODESPLIT>1
private PBXObjectRef addProjectConfigurationList ( final Map objects, final String baseDir, final List < DependencyDef > dependencies, final CommandLineCompilerConfiguration compilerConfig, final CommandLineLinkerConfiguration linkerConfig ) { List configurations = new ArrayList ( ) ; Map String, debugSettings = new HashMap ( ) ; debugSettings. put (GCCWARNABOUTRETURNTYPE,YES ) ; debugSettings. put (GCCWARNUNUSEDVARIABLE,YES ) ; debugSettings. put (PREBINDING, ) ; debugSettings. put (SDKROOT, "/DeveloperSDKsMacOSX104usdk ) ; PBXObjectRef debugConfig = createXCBuildConfiguration (Debug, debugSettings ) ; objects. put ( debugConfig. getID ( ), debugConfig. getProperties ( ) ) ; configurations. add ( debugConfig ) ; Map String, releaseSettings = new HashMap ( ) ; releaseSettings. put (GCCWARNABOUTRETURNTYPE,YES ) ; releaseSettings. put (GCCWARNUNUSEDVARIABLE,YES ) ; releaseSettings. put (PREBINDING, ) ; releaseSettings. put (SDKROOT, "/DeveloperSDKsMacOSX104usdk ) ; PBXObjectRef releaseConfig = createXCBuildConfiguration (Release, releaseSettings ) ; objects. put ( releaseConfig. getID ( ), releaseConfig. getProperties ( ) ) ; configurations. add ( releaseConfig ) ; PBXObjectRef configurationList = createXCConfigurationList ( configurations ) ; Map projectConfigurationListProperties = configurationList. getProperties ( ) ; projectConfigurationListProperties. put (defaultConfigurationIsVisible,0 ) ; projectConfigurationListProperties. put (defaultConfigurationName,Debug ) ; objects. put ( configurationList. getID ( ), configurationList. getProperties ( ) ) ; File includeDirs = compilerConfig. getIncludePath ( ) ; if ( includeDirs length ) List String includePaths = new ArrayList ( ) ; Map String, String includePathMap = new HashMap ( ) ; for ( File includeDir includeDirs ) { if ( CUtil isSystemPath ( includeDir ) ) String absPath = includeDir. getAbsolutePath ( ) ; if ( includePathMap ( absPath ) ) if ( absPath ( "/usr ) ) includePaths. add ( CUtil. toUnixPath ( absPath ) ) ; } String relPath = CUtil. toUnixPath ( CUtil. getRelativePath ( baseDir, includeDir ) ) ; includePaths. add ( relPath ) ; } includePathMap. put ( absPath, absPath ) ; } } } includePaths. add ( "${inherited ) ; debugSettings. put (HEADERSEARCHPATHS, includePaths ) ; releaseSettings. put (HEADERSEARCHPATHS, includePaths ) ; } String preArgs = compilerConfig. getPreArguments ( ) ; List String defines = new ArrayList ( ) ; for ( preArg preArgs ) { if ( preArg ( ) ) defines. add ( preArg. ( ) ) ; } } if ( defines size ( ) ) defines. add (inherited ) ; debugSettings. put (GCCPREPROCESSORDEFINITIONS, defines ) ; releaseSettings. put (GCCPREPROCESSORDEFINITIONS, defines ) ; } if ( linkerConfig null ) Map String, String librarySearchMap = new HashMap ( ) ; List String librarySearchPaths = new ArrayList ( ) ; List String otherLdFlags = new ArrayList ( ) ; String linkerArgs = linkerConfig. getEndArguments ( ) ; for ( linkerArg linkerArgs ) { if ( linkerArg (L ) ) String libDir = linkerArg. ( ) ; if ( librarySearchMap ( libDir ) ) if ( libDir ( "/usrlib ) ) librarySearchPaths. add ( CUtil. toUnixPath ( CUtil. getRelativePath ( baseDir, new File ( libDir ) ) ) ) ; } librarySearchMap. put ( libDir, libDir ) ; } } if ( linkerArg (l ) ) String libName = linkerArg. ( ) ; = false ; for ( DependencyDef dependency dependencies ) { if ( libName ( dependency getName ( ) ) ) { File dependencyFile = dependency. getFile ( ) ; if ( dependencyFile null File ( dependencyFile ( ) ) exists ( ) ) { = true ; ; } } } if ( ) { otherLdFlags. add ( linkerArg ) ; } } } debugSettings. put (LIBRARYSEARCHPATHS, librarySearchPaths ) ; debugSettings. put (OTHERLDFLAGS, otherLdFlags ) ; releaseSettings. put (LIBRARYSEARCHPATHS, librarySearchPaths ) ; releaseSettings. put (OTHERLDFLAGS, otherLdFlags ) ; } return configurationList ; }<CODESPLIT>Add project configuration list .<CODESPLIT>1
@ Override public ResultSet getTablePrivileges ( String catalog, String schemaPattern, String tableNamePattern ) throws SQLException { checkClosed ( ) ; VoltTable vtable = new VoltTable ( new ColumnInfo (TABLECAT VoltType STRING ) new ColumnInfo (TABLES VoltType STRING ) new ColumnInfo (TABLE VoltType STRING ), new ColumnInfo (GROR, VoltType STRING ), new ColumnInfo (GRANTEE, VoltType STRING ), new ColumnInfo (PRILEGE, VoltType STRING ), new ColumnInfo (ISGRABLE, VoltType STRING ) ) ; JDBC4ResultSet res = new JDBC4ResultSet ( this sysCatalog, vtable ) ; return res ; }<CODESPLIT>Retrieves a description of the access rights for each table available in a catalog .<CODESPLIT>1
public Observable < StorageAccount > getStorageAccountAsync ( String resourceGroupName, String accountName, String storageAccountName ) { return getStorageAccountWithServiceResponseAsync (, accountName, storage ). map ( new ServiceResponseAccount,Account ( ) @ Override public StorageAccount call ( ServiceResponse < StorageAccount > response ) { return. body ( ) ; } } ) ; }<CODESPLIT>Gets the specified Azure Storage account linked to the given Data Lake Analytics account .<CODESPLIT>1
private static double sinQ ( double xa, double xb ) { = ( ) ( ( xa 80 )5 ) ; double epsilon = xaIGHTHS ; double sintA = STABLEA ; double sintB = STABLEB ; double costA = COSTABLEA ; double costB = COSTABLEB ; double sinEpsA = epsilon ;EpsB = polyS ( epsilon ) ; doubleA =0 ; doubleB = polyCos ( epsilon ) ; double temp =A HEX4 ; double temp2 = ( sinEpsA + temp ) - temp ; sin += sin ; sinEpsA = temp2 ; double result ; double a = 0 ; double b = 0 ; double t = sintA ; double c = a + t ; d = ( c a t ) ; a = c ; b = b + d ; t = costA * sinEpsA ; c = a + t ; d = ( c a t ) ; a = c ; b = b + d ; b = b + sintA * cosEpsB + costA * sinEpsB ; b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB ; ( ) t = ( ( costA + costB ) * ( cosEpsA + cosEpsB ) - ( sintA + sintB ) * ( sinEpsA + sinEpsB ) ) * ; c = a + t ; d = ( c a t ) ; a = c ; b = b + d ; } result = a + b ; return result ; }<CODESPLIT>Compute sine over the first quadrant ( 0 < x < pi / 2 ) . Use combination of table lookup and rational polynomial expansion .<CODESPLIT>1
public void setNumExecutors ( @ Nonnegative int n ) throws IOException, IllegalArgumentException { if ( n < ) { throw IllegalArgumentException ( " field executors "negative number." ) ; } if ( this. numExecutors n ) { this. numExecutors = n ; updateComputerList ( ) ; save ( ) ; } }<CODESPLIT>{ @inheritDoc } .<CODESPLIT>0
private static boolean classNameMatchesFileName ( ClassSymbol c, Env AttrContext > env ) { return env toplevel sourcefile isNameCompatible ( name toString ( ), JavaFileObject SOURCE ) ; }<CODESPLIT>Does class have the same name as the file it appears in?<CODESPLIT>1
@ XmlElement ( namenextPageLink ) JsonProperty ( valuenextPageLink ) ApiModelProperty ( valueThe next pagination link.", position ) public PageRequestLinkDto getNextPageLink ( ) { return nextPageLink ; }<CODESPLIT>Returns the next pagination link .<CODESPLIT>1
@ Nonnull public static Homoglyph build ( @ Nonnull @ WillClose final Reader aReader ) throws IOException { ValueEnforcer. notNull ( aReader,reader ) ; ( NonBufferedReader aBR NonBufferedReader ( aReader ) ) {CommonsList IntSet aList = new CommonsArrayList ( ) ; sLine ; while ( ( sBR ( ) ) ) { sLine = sLine. trim ( ) ; ( sLine ( "#" ) sLine length ( ) == ) ; IntSet aSet = new IntSet ( sLine. length ( ) / ) ; for ( sCharCode StringHelper.Explo ( s ) ) { nVal =Parser. parseInt ( sCharCode, 16, - 1 ) ; ( nVal ) aSet add ( nVal ) ; } aList. add ( aSet ) ; } return new Homoglyph ( aList ) ; } }<CODESPLIT>Consumes the supplied Reader and uses it to construct a populated Homoglyph object .<CODESPLIT>1
private boolean hasNullifiedFK ( FieldDescriptor [ ] fkFieldDescriptors, Object [ ] fkValues ) { boolean result = true ; for ( fkValues. length ) { if (! pb. serviceBrokerHelper ( ). representsNull ( fkFieldDescriptors, fkValues ) ) { result = false ; ; } } return result ; }<CODESPLIT>to avoid creation of unmaterializable proxies<CODESPLIT>1
public HistoricDate getBeginOfYear ( HistoricEra era, int yearOfEra ) { HistDate newYear = this getNewYearStrategy ( ) newYear ( era, yearEra ) ; ( this isValid (Year ) ) PlainDate date = this convert ( newYear ) ; HistEra preferredEra = this eraPreference getPreferredEra ( newYear, date ) ; ( preferredEra era ) = preferredEra yearEra ( newYear. getE ( ), newYear. getYearEra ( ) ) ; newYear = HistDate. of ( preferredEra,, newYear. getMonth ( ), newYear. getDayOfMonth ( ) ) ; } return newYear ; } IllegalArgumentException ( determine New Year era yearOfEra ) ; } }<CODESPLIT>/ * [ deutsch ] <p > Determines the date of New Year . < / p ><CODESPLIT>1
protected static void checkNotNull ( Object [ ] array ) { checkNotNull ( ( ) array ) ; ( array ) checkNotNull ( ) ; } }<CODESPLIT>Validate the specified arguments .<CODESPLIT>1
private static String getExtentOfParticipationMention ( LinkedList < Term > eventTermList, LinkedList < Term > roleTermList, processNAFVariables vars ) { LinkedList W eventWordList = getWFListByThereTermsFromTargetList ( eventTermList, vars ) ; LinkedList W roleWordList = getWFListByThereTermsFromTargetList ( roleTermList, vars ) ; LinkedList W mergedWordList = new LinkedList W ( ) ; charStartEvent = parseInt ( eventWordList getFirst ( ) getOffset ( ) ) ; charStartRole = parseInt ( roleWordList getFirst ( ) getOffset ( ) ) ; LinkedList < Wf > firstWL secondWL ; ( charStartOfEvent charStartOfRole ) firstWL = eventWordList ; secondWL = roleWordList ; } firstWL = roleWordList ; secondWL = eventWordList ; } for ( first ) (WordList contains ( w ) ) mergedWordList. add ( w ) ; } } for ( second ) (WordList contains ( w ) ) mergedWordList. add ( w ) ; } } StringBuffer extent = new StringBuffer ( ) ; for (List ) extent. ( w. ( ) ) ; } sExtent = extent toString ( ) ; return sExtent. substring ( 0, sExtent. length ( ) - 1 ) ; }<CODESPLIT>/ * similar to generateTheMIdAndSetID () but specific for ParticipationMention<CODESPLIT>1
public EnvironmentConfig setEnvMonitorTxnsExpirationTimeout ( final int timeout ) { if ( timeout timeout < 1000 ) { InvalidSettingException (Transaction timeout second ) ; } setSetting ( ENVMONITORTXNSEXPITIMEOUT, timeout ) ; if ( timeout timeout < getEnvMonitorTxnsCheckFreq ( ) ) { setEnvMonitorTxnsCheckFreq ( timeout ) ; } return this ; }<CODESPLIT>Sets the maximum size of page of B + Tree . Default value is { @code 128 } . Only sizes in the range [ 16 .. 1024 ] are accepted . <p > Mutable at runtime : yes<CODESPLIT>0
public static void addTypeMapper ( Class <? > clz, Class <? > mapper ) { synchronized ( classMapper ) { LinkedHashSet Class =Mapper. ( clz ) ; ( h null ) h = new LinkedHashSet Class ( ) ;Mapper. put ( clz, h ) ; } h. add ( mapper ) ; } }<CODESPLIT>Field type convertor for all classes<CODESPLIT>1
public static DocumentBuilder newDocumentBuilder ( final DocumentBuilderFactory factory ) { { DocumentBuilder builder = factory. newDocumentBuilder ( ) ; return builder ; } ( ) MESSAGES.CreateInstanceOf ( DocumentBuilder. class. ( ) ) ; } }<CODESPLIT>Parse the given XML string and return the root Element This uses the document builder associated with the current thread .<CODESPLIT>0
public synchronized void clear ( ) { if ( validState ) InvalidStateException ( ) ; } { buf. clear ( ) ; fc. position ( ). truncate ( ). force ( true ) ; close ( ) ; open ( ) ; } ( ) log. error ( clear()" ) ; } }<CODESPLIT>Read value from file<CODESPLIT>0
void sendMigrationEvent ( final MigrationStatus status ) { partitionId = getPartitionId ( ) ; NodeEngine nodeEngine = getNodeEngine ( ) ; Member localMember = nodeEngine getLocalMember ( ) ; MigrationEvent event = new MigrationEvent ( partitionId null localMember status ) ; EventService eventService = nodeEngine getEventService ( ) ; Collection Event registrations = eventServiceRegistrations ( SERVICE,IGEVENTTOPIC ) ; eventService. publishEvent ( SERVICE, registrations, event, partitionId ) ; }<CODESPLIT>Sends a {<CODESPLIT>1
private void processConstraintViolation ( final Set < ConstraintViolation < Object > > violations, final CsvBindingErrors bindingErrors, final ValidationContext < Object > validationContext ) { for ( ConstraintViolation violation violations ) field = violation getPropertyPath ( ) toString ( ) ; ConstraintDescriptor cd = violationConstraintDescriptor ( ) ; errorCodes = determineErrorCode ( cd ) ; Map errorVars = createVariableForConstraint ( cd ) ; (CsvField ( field validationContext ) ) CsvFieldError fieldError = bindingErrors getFirstFieldError ( field ) ; ( fieldError null fieldErrorProcessingFailure ( ) ) } ColumnMapping columnMapping = validationContext getBeanMapping ( ) getColumnMapping ( field ) ( ) ; errorVars put (lineNumber, validationContext getCsvContext ( ) getLineNumber ( ) ) ; errorVars put (rowNumber, validationContext getCsvContext ( ) getRowNumber ( ) ) ; errorVars put (columnNumber, columnMapping getNumber ( ) ) ; errorVars put (label, columnMapping getLabel ( ) ) ; errorVars. computeIfAbsent (printer, key columnMapping. getFormatter ( ) ) ; fieldValue = violationInvalidValue ( ) ; errorVars. computeIfAbsent (validatedValue, key fieldValue ) ; defaultMessage = determineDefaltMessage ( errorVars violation ) ; bindingErrors. rejectValue ( field, columnMapping. getField ( ). getType ( ), errorCodes, errorVars, defaultMessage ) ; } bindingErrors. reject ( errorCodes, errorVars, violation. ( ) ) ; } } }<CODESPLIT>BeanValidationの検証結果をSheet用のエラーに変換する<CODESPLIT>1
public static void writeToFile ( @ NonNull File file, @ NonNull String content ) throws IOException { OutputStreamWriter writer = new OutputStreamWriter ( new FileOutputStream ( file ),UTF ) ; { writer. write ( content ) ; writer. flush ( ) ; } ( IOException ) { Log. (TAG. ( ) ) ; } { { writer. close ( ) ; } ( IOException ) { Log. (TAG. ( ) ) ; } } }<CODESPLIT>Delete file .<CODESPLIT>0
public static String extractText ( String html ) { replaceWith ( ) ; safeRemoveAllTags ( ) ; html unescapeHtml ( html ) ; return html ; }<CODESPLIT>Extracts the title of the page .<CODESPLIT>0
public static Rule getRule ( final String inequalitySymbol, final String field, final String value ) { ( field ( Logging LEVEL ) ) return LevelInequalityRule. getRule ( inequalitySymbol, value ) ; } ( field ( Logging TIMESTAMP ) ) return TimestampInequalityRule. getRule ( inequalitySymbol, value ) ; } return new InequalityRule ( inequalitySymbol, field, value ) ; } }<CODESPLIT>Create new instance from top two elements on stack .<CODESPLIT>0
public void createEquiAngle ( float radius, int numRotations, int numSamples, float jitter, Callback2d callback ) { float spacing = radius / numRotations ; for ( sample sampleSamples sample ) { float angle = 20 ( float ). ( sample numRotations ) / numSamples ; float r = radius sample / ( numSamples - 1 ) + ( rnd. nextFloat ( ) 20f - 10f ) spacing jitter ; float x = ( float ).roqu9 ( angle + 05f ( float ). ) r ; float y = ( float ).roqu9 ( angle ) r ; callback. onNewSample ( x, y ) ; } }<CODESPLIT>Create <code > numSamples< / code > number of samples on a spiral with maximum radius <code > radius< / code > around the center using <code > numRotations< / code > number of rotations along the spiral and call the given <code > callback< / code > for each sample generated . <p > The generated sample points are distributed with equal angle differences around the spiral so they concentrate towards the center . <p > Additionally the radius of each sample point is jittered by the given <code > jitter< / code > factor .<CODESPLIT>1
private void readObject ( ObjectInputStream in ) throws IOException, ClassNotFoundException { in. defaultReadObject ( ) ; severity = SEVERITY_INFO ; summary = null ; detail = null ; ordinal = in. readInt ( ) ; ( ordinal SEVERINFO getOr ( ) ) severity = FacesMessage. SEVERITY_INFO ; } ( ordinal SEVERWARN getOr ( ) ) severity = FacesMessage. SEVERITY_WARN ; } ( ordinal SEVERERROR getOr ( ) ) severity = FacesMessage. SEVERITY_ERROR ; } ( ordinal SEVERFATAL getOr ( ) ) severity = FacesMessage. SEVERITY_FATAL ; } summary = ( ) in. readObject ( ) ; detail = ( ) in. readObject ( ) ; rendered = ( Boolean ) in. readObject ( ) ; }<CODESPLIT><p > Reconstruct {<CODESPLIT>1
public void waitForLogMessage ( final String logSearchString, int waitTime ) throws TimeoutException { WaitFor waitForCondition ( Log ( thisString ) waitTime describe ( ) ) ; }<CODESPLIT>Stop and wait till given string will show in container output .<CODESPLIT>1
public Query from ( final Collection < Expression > fromColumns ) { (Columns ) return this ; } this fromColumns addAll ( fromColumns ) ; return this ; }<CODESPLIT>Adds the FROM columns .<CODESPLIT>1
public void getElementSettingsConfig ( final String clientId, final String containerId, final I_CmsSimpleCallback CmsElementSettingsConfig > callback ) { CmsRpcAction CmsElementSettingsConfig > action new CmsRpcAction CmsElementSettingsConfig > ( ) { @ Override public void execute ( ) { start ( true ) ;Service ( )Config ( ( ) ( ) clientId containerId getPageState ( ) ( ) this ) ; } @ Override protected void onResponse ( CmsElementSettingsConfig result ) { ( ) callback execute ( ) ; } stop ( false ) ; } } ; action execute ( ) ; }<CODESPLIT>Requests the element settings config data for a container element specified by the client id . The data will be provided to the given call - back function . <p ><CODESPLIT>1
protected synchronized void copy ( Writable other ) { if ( other null ) { DataOutputBuffer out = new DataOutputBuffer ( ) ; other. write ( out ) ; DataInputBuffer in = new DataInputBuffer ( ) ; in. reset ( out. getData ( ), out. getLength ( ) ) ; readFields ( in ) ; } ( IOException ) { IllegalArgumentException (map copied. ( ) ) ; } } IllegalArgumentException (source map ) ; } }<CODESPLIT>Used by child copy constructors .<CODESPLIT>1
public Cell C, T width ( Value C, T width ) { min width ; pref width ; maxWidth = width ; return this ; }<CODESPLIT>Sets the minWidth prefWidth and maxWidth to the specified value .<CODESPLIT>0
public void createReference ( Reference reference ) throws GreenPepperServerException { sessionService startSession ( ) ; sessionService beginTransaction ( ) ; Repository repository = loadRepository ( reference getSpecification ( ) getRepository ( ). getUid ( ) ) ; documentDao. createReference ( reference ) ; sessionService. commitTransaction ( ) ; log. (Created Reference reference.quire ( ). ( ) "," reference. getSpecification ( ). ( ) ) ; } ( ) sessionService. rollbackTransaction ( ) ; handleException ( REFERENCECREATE ) ; } sessionService. closeSession ( ) ; } }<CODESPLIT>{<CODESPLIT>0
public static Document buildPDFDocument ( com. snowtide. pdf. Document pdf, LucenePDFConfiguration config ) throws IOException { StringWriter sb = new StringWriter ( ) ; pdf. pipe ( new OutputTarget ( sb ) ) ; Document doc = new Document ( ) ; LUCEINTERFACE. addField ( doc, config. getBodyTextFieldName ( ), sb. toString ( ), config. storeBodyText ( ), config. indexBodyText ( ), config. tokenizeBodyText ( ) ) ; for (. metadata pdf. getAttributeMap ( ). ( ) ) { String docPropName = metadataEntry. ( ) ; String fieldName = config. getMetadataFieldMapping ( docPropName ) ; if ( fieldName == null ) { if ( config copyAllPDFMetadata ( ) ) { fieldName = docPropName ; } { ; } } value = metadataEntry. getValue ( ) ; String valueStr ; if ( value == null ) { if (DEBUG ) log (Null document property value name docPropName pdf getName ( ) ) ; ; } if ( value String ) { if ( docPropName ( com snowtide pdf Document ATTRMODDATE ) docPropName ( com snowtide pdf Document ATTRCREDATE ) ) { { valueStr = DateTools. dateToString ( PDFDateParser. parseDateString ( ( String ) value ), DateTools. Resolution. MILLISECOND ) ; } ( ) { log. warn (PDF date string parsed into a javautilDate instance value pdf. ( ) ) ; valueStr = ( String ) value ; } } { valueStr = ( String ) value ; } } if ( value Number ) { valueStr = value. toString ( ) ; } { if (DEBUG ) log ( document property value type value. ( ). getName ( ) ", name docPropName pdf. getName ( ) ) ; ; } LUCEINTERFACE. addField ( doc, fieldName, valueStr, config. storeMetadata ( ), config. indexMetadata ( ), config. tokenizeMetadata ( ) ) ; } return doc ; }<CODESPLIT>Creates a new Lucene Document instance using the PDF text and metadata provided by the PDFxStream Document using a default {<CODESPLIT>0
protected void removeTargetListeners ( Component comp ) { comp. removeMouseListener ( _targetListener ) ; comp. removeMouseMotionListener ( _targetListener ) ; ( comp Container ) Container cont = ( Container ) comp ; cont. removeContainerListener ( _childListener ) ; for (. getComponent ( ) ) { removeTargetListeners ( cont. getComponent ( ) ) ; } } }<CODESPLIT>Check to see if we need to do component - level cursor setting and take care of it if needed .<CODESPLIT>0
public Observable PolicyAssignmentInner > deleteByIdAsync ( String policyAssignmentId ) { return deleteByIdWithServiceResponseAsync ( policyAssignmentId ) map ( new ServiceResponseAssignment,Assignment ( ) @ Override public PolicyAssignmentInner call ( ServiceResponse PolicyAssignmentInner > response ) { return body ( ) ; } } ) ; }<CODESPLIT>Deletes a policy assignment by ID . When providing a scope for the assigment use / subscriptions / { subscription - id } / for subscriptions / subscriptions / { subscription - id } / resourceGroups / { resource - group - name } for resource groups and / subscriptions / { subscription - id } / resourceGroups / { resource - group - name } / providers / { resource - provider - namespace } / { resource - type } / { resource - name } for resources .<CODESPLIT>0
private void getFights ( Document doc, Event event ) { logger. info (Getting fights event #[{}]", event. getSherdogUrl ( ), event. getName ( ) ) ; SherBaseObject sEvent = new SherBaseObject ( ) ; sEvent. setName ( event. getName ( ) ) ; sEvent. setShUrl ( event. getSherUrl ( ) ) ; List Fight fights = new ArrayList ( ) ; Elements mainFightElement = doc. select (contentevent ) ; Elements fighters = mainFightElement. select (h3 a ) ; SherBaseObject mainFighter1 = new SherBaseObject ( ) ; Element mainF1Element = fters. ( ) ; mainF1. setShUrl ( mainF1. attr (href ) ) ; mainF1. setName ( mainF1. select (spanname ). html ( ) ) ; SherBaseObject mainFighter = new SherBaseObject ( ) ; Element mainF2Element = fters. ( ) ; mainF2. setShUrl ( mainF2. attr (href ) ) ; mainF2. setName ( mainF2. select (spanname ). html ( ) ) ; Fight mainFight = new Fight ( ) ; mainF. setEvent ( sEvent ) ; mainF. setF1 ( mainF1 ) ; mainF. setF2 ( mainF2 ) ; mainF. setResult ( ParserUtils.Result ( mainF. first ( ) ) ) ; Elements mainTd = mainFightElement. select ( ) ; if ( main size ( ) ) { mainF. setMethod ( main. ( ). html ( ). replaceAll (, "" ). trim ( ) ) ; mainF. setRound (. parseInt ( main. ( ). html ( ). replaceAll (, "" ). trim ( ) ) ) ; mainF. setTime ( main. ( ). html ( ). replaceAll (, "" ). trim ( ) ) ; } mainF. setDate ( event. getDate ( ) ) ; fights. add ( mainFight ) ; logger. info (F added {}", mainFight ) ; logger. info (Found fights, fights. size ( ) ) ; Elements tds = doc. select (eventmatch table tr ) ; fights. addAll ( parseEventFights ( tds, event ) ) ; event. setFights ( fights ) ; }<CODESPLIT>parses an event from a jsoup document<CODESPLIT>0
public PropertyDescriptor [ ] getTeaBeanPropertyDescriptors ( Class <? > beanClass ) { ( beanClass == null ) return NO_PROPERTIES ; } PropertyDescriptor properties = null ; Map, PropertyDescriptor allProps = null ; { allProps = BeanAnalyzer. getAllProperties ( new GenericType ( beanClass ) ) ; } ( ) return NO_PROPERTIES ; } Collection PropertyDescriptor cleanProps = new ArrayList PropertyDescriptor ( allProps. size ( ) ) ; Map. String, PropertyDescriptor = allProps. entrySet ( ). iterator ( ) ; while ( ( ) ) { Map. String, PropertyDescriptor entry =. next ( ) ; name = entry. ( ) ; PropertyDescriptor desc = entry. getValue ( ) ; ( name == null name length ( ) ==class ( name ) ) ; } ( desc KeyedPropertyDescriptor ) KeyedPropertyDescriptor keyed = ( KeyedPropertyDescriptor ) desc ; Class type = keyed.edPropertyType ( ). getRawType ( ). getType ( ) ; { desc = new ArrayIndexPropertyDescriptor ( beanClass, type ) ; } ( ) ; } } ( beanClass isArray ( ) desc getReadMethod ( ) == null ) ; } cleanProps. add ( desc ) ; } properties = cleanProps. toArray ( new PropertyDescriptor cleanProps. size ( ) ) ; sortPropertyDescriptors ( properties ) ; return properties ; }<CODESPLIT>A function that returns an array of all the available properties on a given class . <p > <b > NOTE : < / b > If possible the results of this method should be cached by the caller .<CODESPLIT>1
@ Override public synchronized void serverStopping ( ) { if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) { Tr. entry ( tc,serverStopping,generate in progress = generateInProgress ) ; } serverIsStopping = true ; for ( generateInProgress ) { { Thread. sleep ( 500 ) ; } ( ) { i = 40 ; } } if ( TraceComponent. isAnyTracingEnabled ( ) tc. isEntryEnabled ( ) ) { Tr. exit ( tc,serverStopping ) ; } }<CODESPLIT>/ * ( non - Javadoc )<CODESPLIT>1
void flattenToSubMessageBuffer ( ByteBuffer buf ) throws IOException { assert ( mitems null ) ; assert (! mitems. isEmpty ( ) ) ; buf. put ( VoltDbMessageFactory. FRAGMENTTASKID ) ; super. flattenToBuffer ( buf ) ; short nInputDepIds = 0 ; short nOutputDepIds = 0 ; short nUnplanned = 0 ; for ( FragmentData mitems ) ( item minputId )Ids ++ ; } ( item moutputId null )Ids ++ ; } ( item mfragmentPlan null )Un ++ ; } } buf. putShort ( ( short ) mitems. size ( ) ) ; buf. putShort ( nUnplanned ) ; buf. put ( misFinal ( ) 1 : ( ) ) ; buf. put ( mtaskType ) ; buf. put ( memptyForRestart ( ) 1 : ( ) ) ; buf. put ( mexecutedOnPreviousLeader ( ) 1 : ( ) ) ; buf. put ( nOutputDepIds ( ) 1 : ( ) ) ; buf. put ( nInputDepIds ( ) 1 : ( ) ) ; ( mprocNameToLoad null ) buf. putShort ( ( short ) mNameToLoad. length ) ; buf. put ( mNameToLoad ) ; } buf. putShort ( ( short ) 1 ) ; } buf. put ( mperFragmentStatsRecording ( ) 1 : ( ) ) ; buf. put ( mcoordinatorTask ( ) 1 : ( ) ) ; buf. put ( mPartTxn ( ) 1 : ( ) ) ; buf. putLong ( mrestartTimestamp ) ; buf. putLong ( mlastSpUniqueId ) ; for ( FragmentData mitems ) buf. put ( item. mplanHash ) ; } for ( FragmentData mitems ) ( item mstmtName null ) buf. putShort ( ( short ) 1 ) ; } assert ( item. mstmtName. length <= Short. MAXVALUE ) ; buf. putShort ( ( short ) item. mstmtName. length ) ; buf. put ( item. mstmtName ) ; } } for ( FragmentData mitems ) buf. putInt ( item. mparameterSet. remaining ( ) ) ; buf. put ( item. mparameterSet. asReadOnlyBuffer ( ) ) ; } ( nOutputIds ) for ( FragmentData mitems ) buf. putInt ( item. moutputDepId ) ; } } ( nInputIds ) for ( FragmentData mitems ) { ( item minputId ) buf. putShort ( ( short ) ) ; } buf. putShort ( ( short ) 1 ) ; buf. putInt ( item. minputDepId ) ; } } } ( mprocedureName null ) buf. putShort ( ( short ) 1 ) ; } assert ( mprocedureName. length <= Short. MAXVALUE ) ; buf. putShort ( ( short ) mprocedureName. length ) ; buf. put ( mprocedureName ) ; } buf. putInt ( mcurrentBatchIndex ) ; ( mbatchTimeout BatchTimeoutOverrideType NOTIMEOUT ) buf. put ( BatchTimeoutOverrideType. NOOVERRIDEFORBATCHTIMEOUT. getValue ( ) ) ; } buf. put ( BatchTimeoutOverrideType. HASOVERRIDEFORBATCHTIMEOUT. getValue ( ) ) ; buf. putInt ( mbatchTimeout ) ; } buf. putShort ( ( short ) minvolvedPartitions. size ( ) ) ; for ( pid mPartitions ) { buf. putInt ( pid ) ; } ( minitiateTaskBuffer null ) ByteBuffer dup = minitiateTaskBuffer. duplicate ( ) ; buf. putInt ( dup. remaining ( ) ) ; buf. put ( dup ) ; } buf. putInt ( ) ; } for ( short mitems. ( ) ) { FragmentData item = mitems. ( index ) ; ( item mfragmentPlan null ) buf. putShort ( index ) ; buf. putInt ( item. mfragmentPlan. length ) ; buf. put ( item. mfragmentPlan ) ; assert ( item. mstmtText null ) ; buf. putInt ( item. mstmtText. length ) ; buf. put ( item. mstmtText ) ; } } }<CODESPLIT>/ * Serialization Format [ description : type : byte count ]<CODESPLIT>0
public T readRow ( BufferedReader bufferedReader, ParseError parseError ) throws ParseException, IOException { checkConfig ( ) ; buffered ( ) ; ( ) return null ; } return processRow ( line, bufferedReader, parseError, getLineNumber ( bufferedReader ) ) ; } }<CODESPLIT>Read in all of the entities in the reader passed in but without the header .<CODESPLIT>0
private int transformToRTF ( ElemTemplateElement templateParent, DTM dtmFrag ) throws TransformerException { XPathContext = m_xcontext ; ContentHandler rtfHandler =Frag getContentHandler ( ) ; resultFragment ; SerializationHandler savedRTreeHandler = this. m_izationHandler ; ToSAXHandler = new ToXMLSAXHandler ( ) ; setContentHandler ( rHandler ) ; setTransformer ( this ) ; m_izationHandler = h ; SerializationHandler rth = m_izationHandler ; r startDocument ( ) ; r flushPending ( ) ; executeChildTemplates ( templateParent, true ) ; r flushPending ( ) ; resultFragment =Frag getDocument ( ) ; } r endDocument ( ) ; } } ( SAXException ) TransformerException ( ) ; } this. m_izationHandler = savedRTreeHandler ; } return resultFragment ; }<CODESPLIT>Take the contents of a template element process it and convert it to a string .<CODESPLIT>0
public static void encodeLength ( ByteArrayOutputStream out, int length ) { LOG. entering ( CLASS,encodeLength, new { out, length } ) ; byteCount = ; encodedLength = ; do { encodedLength <<= 8 ; encodedLength |= ( ) ( length7 ) ; length >>= 7 ; byteCount ++ ; } while ( ) ; do { byte encodedByte = ( byte ) ( encodedLength ) ; encodedLength >>= 8 ; if ( byteCount ) encodedByte |= ( byte ) 0x ; } out. write ( encodedByte ) ; } while ( byteCount ) ; }<CODESPLIT>/ * Length - bytes are written out in order from most to least significant but are computed most efficiently ( using bit shifts ) from least to most significant . An integer serves as a temporary storage which is then written out in reversed order .<CODESPLIT>1
public static synchronized PingManager getInstanceFor ( XMPPConnection connection ) { Ping ping = ( connection ) ; ( pingManager ) ping = new Ping ( connection ) ; INSTANCES put ( connection, pingManager ) ; } return pingManager ; }<CODESPLIT>Gets the account registration info from the server . @throws XMPPErrorException @throws NoResponseException @throws NotConnectedException @throws InterruptedException<CODESPLIT>0
@ Override public T List T dynamicQuery ( DynamicQuery dynamicQuery ) { returnDisplayPersistence findWithDynamicQuery ( dynamicQuery ) ; }<CODESPLIT>Returns the number of rows matching the dynamic query .<CODESPLIT>0
public void write ( String s, int off, int len ) throws IOException { ( writer ) writer write ( s, off, ) ; } ensureOpen ( ) ; strBuffer ( s ( off, off len ) ) ; nextChar += len ; } }<CODESPLIT>Write a portion of a String .<CODESPLIT>1
public void concat ( String trg, String [ ] src, boolean restricted ) throws IOException { names ( src restricted ; }<CODESPLIT>{<CODESPLIT>0
@ Override public ExecuteProvisionedProductServiceAction executeProvisionedProductServiceAction ( ExecuteProvisionedProductServiceActionRequest request ) { request beforeClientExecution request return executeExecuteProvisionedProductServiceAction ( request }<CODESPLIT><p > Executes a self - service action against a provisioned product . < / p ><CODESPLIT>1
private T getWrappedPublisher ( Publisher flexiblePublisher, Class < T > type ) { if ( ( flexiblePublisher FPublisher ) ) { throw IllegalArgumentException ( String. (Publisher type type FPublisher. classiblePublisher. ( ) ) ) ; } List ConditionalPublisher conditions = ( ( FPublisher ) flexiblePublisher ). getPublishers ( ) ; for ( ConditionalPublisher condition conditions ) { if ( type. isInstance ( condition. getPublish ( ) ) ) { return type. cast ( condition. getPublisher ( ) ) ; } } return null ; }<CODESPLIT>Gets the publisher wrapped by the specofoed FlexiblePublisher .<CODESPLIT>1
public Iterable DContact queryByUpdatedDate ( Object parent, java util Date updatedDate ) { return queryByField ( parent,ContactMapper Field UPDATEDATE ( ), updatedDate ) ; }<CODESPLIT>query - by method for field updatedDate<CODESPLIT>1
static boolean isGetOrSetKey ( Node node ) { ( node. getToken ( ) ) { GETTERDEF SETTERDEF return true ; COMPUPROP return node. getBooleanProp ( Node. COMPUPROPGETTER ) node. getBooleanProp ( Node. COMPUPROPSETTER ) ; default : break ; } return false ; }<CODESPLIT>Determines whether a node represents an object literal get or set key ( e . g . key1 in { get key1 () {} set key2 ( a ) {} ) .<CODESPLIT>1
private boolean isCtFieldACollection ( CtField ctField ) { return ctField getType ( ) equals ( cp get ( Collection getName ( ) ) ) || ctField getType ( ) equals ( cp get ( List. getName ( ) ) ) || ctField. getType ( ). equals ( cp. get ( Set.. getName ( ) ) ) ; } ( ) ( ) ; return false ; } }<CODESPLIT>Add Method to ConstPool . If method was not in the ConstPool will add and return index otherwise will return index of already existing entry of constpool<CODESPLIT>0
public static void readable ( final File path, final String message ) throws IllegalArgumentException { notNull ( path message ) ; ( ( ) ) IllegalArgumentException ( ) ; } }<CODESPLIT>FIXME me animal sniffer this is 1 . 6 API only<CODESPLIT>0
@ Override public ModifyEventSubscriptionResult modifyEventSubscription ( ModifyEventSubscriptionRequest request ) { request beforeClientExecution request return executeModify ( request ) }<CODESPLIT><p > Modifies the replication instance to apply new settings . You can change one or more parameters by specifying these parameters and the new values in the request . < / p > <p > Some settings are applied during the maintenance window . < / p > <p / ><CODESPLIT>0
public java. util. List < InventoryDeletionStatusItem > getInventoryDeletions ( ) { ( inventoryDelet ) inventoryDeletions new com amazonaws internal SdkInternalList InventoryDeletionStatus ( ) ; } return inventoryDeletions ; }<CODESPLIT><p > A list of status items for deleted inventory . < / p ><CODESPLIT>0
public static boolean validateServiceName ( Configuration conf, String nameServiceId ) { Collection String nameserviceIds = DFSUtil. getNameServiceIds ( conf ) ; if ( namesIds null namesIds. isEmpty ( ) ) { if ( name == null ) { System. err. println (Need to input a namesvice id ) ; return false ; } if ( namesIds. contains ( name ) ) { System. err. println ( invalid namesvice id nameServiceId ) ; return false ; } } if ( name null ) { System. err. println ( invalid nameservice id nameServiceId ) ; return false ; } return true ; }<CODESPLIT>Valide if the input service name is valid<CODESPLIT>1
@ Override public OUTPUT newInstance ( Map < String INPUT > inputMap ) throws FAILURE { StringBuilder builder = new StringBuilder ( ) ( getClass ( ) ( ) ) (newInstanceMap<String Input>) is unsupported." ) ; UnsupportedOperationException ( builder ( ) ) ; }<CODESPLIT><p > <b > Unsupported< / b > . Override to provide an implementation . < / p ><CODESPLIT>1
long getProposedEpoch ( ) throws IOException { { pEpoch = FileUtils. readLongFromFile ( this. fProposedEpoch ) ; return pEpoch ; } ( FileNotFoundException ) { LOG. ( "File initialize acknowledged epoch to ) ; return - 1 ; } ( IOException ) { LOG. error ( "IOException access acknowledged epoch ) ; ; } }<CODESPLIT>Gets the last proposed epoch .<CODESPLIT>1
@ SuppressWarnings (WeakerAccess" ) public ParameterizableRequest < Map < String, Object >, AuthenticationException > delegation ( ) {Url urlUrl parse ( auth0 getDomainUrl ( ) ) newBuilder ( ) addPathSegment ( DE ) build ( ) ; Map parameters = ParameterBuilder newBuilder ( ) setClientId ( getClientId ( ) ) setGrantType ( ParameterBuilder GRTYPEJWT ) asDictionary ( ) ; return factory. rawPOST ( url, client, gson, authErrorBuilder ). addParameters ( parameters ) ; }<CODESPLIT>Performs a custom <a href = https : // auth0 . com / docs / api / authentication#delegation > delegation< / a > request that will yield a delegation token . Example usage : <pre > { @code client . delegation () . addParameter ( api_type firebase ) . start ( new BaseCallback<Map<String Object >> () { { @literal } Override public void onSuccess ( Map<String Object > payload ) {}<CODESPLIT>1
public void refreshToken ( ) throws OAuthSystemException, OAuthProblemException { cleanError ( ) ; ( accessToken null refreshToken == null ) OAuth (Access token ot Refresh token ) ; }inURLConnectionClient httpClient = newinURLConnectionClient ( ) ; OAuthClientRequest request = OAuthClientRequest. tokenLocation ( settings. getURL ( Constants. TOKENREFRESHURL ) ). buildBodyMessage ( ) ; Map, headers = new HashMap, ( ) ; headers. put ( OAuth. HeaderType. CONTENTTYPE, OAuth. ContentType. JSON ) ; headers. put (UserAgent, this. userAgent ) ; Map, params = new HashMap, ( ) ; params. put (granttype, GrantType. REFRESHTOKEN ) ; params. put (accesstoken, accessToken ) ; params. put (refreshtoken, refreshToken ) ; body = JSONUtils. buildJSON ( params ) ; request setBody ( body ) ; updateTokens ( httpClient, request, headers ) ; }<CODESPLIT>Refreshing tokens provides a new set of access and refresh tokens .<CODESPLIT>1
public void syncContactTypeToMain ( ) { ReferenceFieldContactType ( ReferenceField ) this getMainRecord ( ) getField ( MessageDetailTYPEID ) ; strContactTypeParam =ContactType ( ) ; this syncRecordToMainField (ContactType, null, strContactTypeParam ) ; }<CODESPLIT>Read the current file in the header record given the current detail record .<CODESPLIT>0
@ Override SuppressWarnings (unchecked ) public ChronoZonedDateTime InternationalFixedDate zonedDateTime ( TemporalAccessor temporal ) { return (ZonedDateTimeationalFixedDate ) super zonedDateTime ( temporal ) ; }<CODESPLIT>A property tied to the map updated when the idle state event is fired .<CODESPLIT>0
private ProtoNetwork stage1 ( final File [ ] networks ) { beginStage ( PH2STAGE1HDR,1, NUMPHS ) ; net = networks. length ; StringBuilder bldr = new StringBuilder ( ) ;. (Merging ) ;. ( net ) ;. ( network ) ; ( net ). (s ) ; } stageOutput (. toString ( ) ) ; t1 = ( ) ; CollectionNetworkDescriptords = sizedArrayList ( net ) ; for ( network networks ) { root = network. getAbsolutePath ( ) ; netPath = asPath ( root, PROTONETWORKFILENAME ) ; File networkBin = new File ( netPath ) ;ds. add ( new BinaryProtoNetworkDescriptor ( networkBin ) ) ; } ProtoNetwork ret = p2. stage1Merger ( nds ) ; new File ( artifactPath. getAbsolutePath ( ) "/merged ). mkdirs ( ) ; p2. stage4WriteEquivalentProtoNetwork ( ret, artifactPath. getAbsolutePath ( ) "/merged ) ; (Debug ( ) ) { TextProtoNetworkExternalizer textExternalizer = new TextProtoNetworkExternalizer ( ) ; textExternalizer. writeProtoNetwork ( ret, artifactPath. getAbsolutePath ( ) "/merged ) ; } ( ) error ( not write out equivalence proto network." ) ; } } t = ( ) ; setLength ( 0 ) ; markTime (, t1, t2 ) ; markEndStage ( ) ; stageOutput (. toString ( ) ) ; return ret ; }<CODESPLIT>Stage one merger of networks returning the merged proto - network .<CODESPLIT>1
@ Override public EnableStreamingTaskResult enableHlsStreaming ( String spaceId, boolean secure ) throws ContentStoreException { EnableStreaming task new EnableStreaming ( ) ;Space ( spaceId ) ;Secure ( secure ) ; return EnableStreamingTaskResult deserialize ( contentStore performTask (Task. ENABLE_HLS_TASK_NAME, taskParams. serialize ( ) ) ) ; }<CODESPLIT>{<CODESPLIT>1
public static Map Entry String, Map String, > > getSystemBarsCommand ( ) { return newMap SimpleEntry ( GETSYSTEMBARS, ImmutableMap of ( ) ) ; }<CODESPLIT>This method forms a { @link Map } of parameters for the getting of a network connection value .<CODESPLIT>0
public Response postQuery ( final String system, final InputStream input, final String resource, final HttpHeaders httpHeaders ) { JaxRx impl = Systems getInstance ( system ) ; Document doc = new Schema (post ) check ( input ) ; QueryParameter param = getParameters ( doc impl ) ; path = newPath ( resource param httpHeaders ) ; return createResponse ( impl, path ) ; }<CODESPLIT>This method will be called when a HTTP client sends a POST request to an existing resource with application / query + xml as Content - Type .<CODESPLIT>1
public boolean hasValue ( int index ) { if ( mbaseCollection List ) return index ( ( List ) m_baseCollection ). size ( ) ; } if ( mbaseCollection SortedMap ) return index ( ( SortedMap, ) m_baseCollection ). size ( ) ; } return false ; }<CODESPLIT>Prepares this widget dialog parameter to be committed . <p ><CODESPLIT>0
public void marshall ( DescribeDirectConnectGatewayAssociationsRequest describeDirectConnectGatewayAssociationsRequest, ProtocolMarshaller protocolMarshaller ) { if ( describeDirectConnectGatewayAssociationsRequest == null ) { SdkClientException (Invalid marshall(...)" ) ; } { protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getAssociationId ( ),IDBINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getAssociatedGatewayId ( ), ASSIDBINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getDirectConnectGatewayId ( ), DIRECTCONNECTGATEWAYIDBINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getMaxResults ( ), MAXRESULTSBINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getNextToken ( ), NEXTTOKENBINDING ) ; protocolMarshaller. marshall ( describeDirectConnectGatewayAssociationsRequest. getVirtualGatewayId ( ), VIDBINDING ) ; } ( ) { SdkClientException ( marshall request. ( ) ) ; } }<CODESPLIT><p > The sources for the applications ( up to 10 ) . If you specify scaling plan names you cannot specify application sources . < / p > <p > <b > NOTE : < / b > This method appends the values to the existing list ( if any ) . Use { @link #setApplicationSources ( java . util . Collection ) } or { @link #withApplicationSources ( java . util . Collection ) } if you want to override the existing values . < / p ><CODESPLIT>0
public Object execEval ( String arg ) { try { return scriptEngine. eval ( "eval(" + arg + ")" ) ; } ( Script ) { throw BundProcessException (Error evaluating script ) ; } }<CODESPLIT>Returns the JSON object from a string<CODESPLIT>0
@ Override public Map < ServerGroup, EVCacheServerGroupConfig > discoverInstances ( String appName ) throws IOException { propertyName = appName "-NODES ; nodeListString = EVCacheConfig. getInstance ( ). getDynamicStringProperty ( propertyName, "" ). ( ) ; ( log ( ) ) log (List Nodes nodeListString ) ; ( nodeListString null nodeListString length ( ) ) return bootstrapFromSystemProperty ( nodeListString ) ; ( env null region null ) return bootstrapFromEure ( appName ) ; return Collections. ServerGroup, EVCacheServerGroupConfig emptyMap ( ) ; }<CODESPLIT>Netflix specific impl so we can load from eureka .<CODESPLIT>0
private boolean distinguishedNameEquals ( String dsn1, String dsn2 ) { return500 ( dsn ) equals (500Principal ( dsn ) ) ; }<CODESPLIT>Compare two DSN<CODESPLIT>1
public static BloomKFilter deserialize ( InputStream in ) throws IOException { if ( in == null ) { throw IOException ( "Input stream ) ; } try { DataInputStream dataInputStream = new DataInputStream ( in ) ;HashFunc = dataInputStream. readByte ( ) ; bitsetArrayLen = dataInputStream. readInt ( ) ; data = new bitsetArrayLen ; for ( bitsetArray ) { data = dataInputStream. readLong ( ) ; } return new BloomKFilter ( data, numHashFunc ) ; } ( ) { IOException io = new IOException (Unable to deserialize BloomKFilter ) ; io. initCause ( ) ; throw io ; } }<CODESPLIT>Deserialize a bloom filter Read a byte stream which was written by { @linkplain #serialize ( OutputStream BloomKFilter ) } into a { @code BloomKFilter }<CODESPLIT>1
public void setRestoreLastValid ( boolean restoreLastValid ) { ( hasSelection ) (Last valid text restore can changed file has selection ) ; this. restoreLastValid = restoreLastValid ; ( restoreLastValid ) ( restoreFocusListener ) restoreFocusListener LastValidFocusListener ( ) ; addListener ( restoreFocusListener ) ; } removeListener ( restoreFocusListener ) ; } }<CODESPLIT>Adds vertical or horizontal {<CODESPLIT>0
public static LongBinding decrementExact ( ObservableLongValue a ) { return createLongBinding ( ( ) decrementExact ( ( ) ), ) ; }<CODESPLIT>Binding for { @link java . lang . Math#decrementExact ( long ) }<CODESPLIT>1
public static String dgstHex ( InputStream is, Digest digest ) throws IOException { checkNotNull ( ) ;Bytes (, digest ) ; return BaseEncoding. base16 ( ). encode (stBytes ) ; }<CODESPLIT>Calculates digest and returns the value as a hex string .<CODESPLIT>1
private void write ( TargetType theTarget, ValueSetTm theValueSetTm, File theOutputDirectory, String thePackageBase ) throws IOException { (OutputDirectory exists ( ) ) theOutputDirectory. mkdirs ( ) ; } (OutputDirectory isDirectory ( ) ) IOException (OutputDirectory directory ) ; } valueSetName = theValueSetT getClassName ( ) ; prefix = myFilenamePrefix ; suffix = myFilenameSuffix ; (Target Target SOURCE ) ( suffix (java ) ) suffix +=java ; } } fileName = prefix valueSetName suffix ; f = new File ( theOutputDirectory, fileName ) ; OutputStreamWriter w = new OutputStreamWriter ( new FileOutputStream ( f, false ),UTF ) ; ourLog. (Writing file {}", f. ( ) ) ; VelocityContext ctx = new VelocityContext ( ) ; InputStream template = null ; ctx. put (valueSet, theValueSetT ) ; ctx. put (packageBase, thePackageBase ) ; ctx put (esc, new EscapeTool ( ) ) ; VelocityEngine v = VelocityHelper. configureVelocityEngine ( myTemplateFile, myVelocityPath, myVelocityProperties ) ; (TemplateFile null ) template = new FileInputStream ( myTemplateFile ) ; } templateName = myTemplate ; ( null templateName ) templateName = "/vm/valuesetvm ; } templateIs = this. getClass ( ). getResourceAsStream ( templateName ) ; } InputStreamReader templateReader = new InputStreamReader ( template,UTF ) ; v. evaluate ( ctx, w, "", templateReader ) ; w. close ( ) ; }<CODESPLIT>}<CODESPLIT>1
@ Override public void store ( Issue issue ) { ( issue primary ( ) input ( ) DefaultInput ) DefaultInputFile defaultInputFile ( DefaultInputFile ) issue primaryLocation ( ) inputComponent ( ) ; ( shouldSkipStorage ( defaultInput ) ) return ; } defaultInputPublished ( ) ; } moduleIssues initAndAddIssue ( issue ) ; }<CODESPLIT>Thread safe assuming that each issues for each file are only written once .<CODESPLIT>1
@ Deprecated public Class <? > getClassFromCollection ( final String collection ) { Set MappedClass mcs = mappedClassesByCollection. ( collection ) ; if ( mcs == null mcs. isEmpty ( ) ) { MappingException ( ( collection mapped java class." collection ) ) ; } if ( mcs. size ( ) > ) { if (. isInfoEnabled ( ) ) {. info ( format (Found more one class mapped to collections collection mcs ) ) ; } } return mcs. iterator ( ). next ( ). getClazz ( ) ; }<CODESPLIT>Converts a DBObject back to a type - safe java object ( POJO )<CODESPLIT>0
private Token eventuallyMatch ( Token. Kind kind ) { checkNotE ( ) ; token = tokens. ( index ) ; ( token ) return null ; } index = index + 1 ; return token ; } }<CODESPLIT>Match a given sequence of tokens whilst moving passed any whitespace encountered inbetween . In the case that meet the end of the stream or we don t match the expected tokens in the expected order then an error is thrown .<CODESPLIT>0
public static Waehrung of ( CurrencyUnit currencyUnit ) { ( currencyrun ) return ( Whrung ) currencyUnit ; } return of ( currencyUnit. getCurrencyCode ( ) ) ; } }<CODESPLIT>Gibt die entsprechende Currency als Waehrung zurueck .<CODESPLIT>1
private Content processParamTags ( boolean isNonTypeParams, ParamTag [ ] paramTags, Map < String, String > rankMap, TagletWriter writer, Set < String > alreadyDocumented ) { Content result = writer. getOutputInstance ( ) ; ( paramTags length ) for ( paramTags. ) { ParamTag pt = paramTags [ ; paramName = isNonTypeParams pt. parameterName ( ) "<" pt. parameterName ( ) ">" ; ( rankMap ( parameterName ( ) ) ) writer. getMsgRetriever ( ). warning ( pt. position ( ), isNonTypeParamsdocletParameterswarn :docletTypeParameterswarn, paramName ) ; } rank = rankMap. ( pt. parameterName ( ) ) ; ( rank null alreadyDocumented contains ( rank ) ) writer. getMsgRetriever ( ). warning ( pt. position ( ), isNonTypeParamsdocletParametersdupwarn :docletTypeParametersdupwarn, paramName ) ; } result. addContent ( processParamTag ( isNonTypeParams, writer, pt, pt. parameterName ( ), alreadyDocumented. size ( ) ) ) ; alreadyDocumented. add ( rank ) ; } } return result ; }<CODESPLIT>Checks the current system time against the time limit throwing an InterruptedException if the time is up .<CODESPLIT>0
public void setVersions ( java. util. Collection < String > versions ) { ( versions null ) this versions = null ; return ; } this versions = new com amazonaws internal SdkInternalList ( versions ) ; }<CODESPLIT><p > The version numbers of one or more launch template versions to delete . < / p ><CODESPLIT>0
private static ScriptRunner getRunner ( ) throws IOException { if ( sharedRunner ( ) == null ) ScriptRunner runner = ScriptRunnerFactory. createRunner ( ) ; { runner. loadScript ( CSL. class. getResource (dumpjs ) ) ; runner. loadScript ( CSL. class. getResource (itejs ) ) ; runner. loadScript ( CSL. class. getResource (formatsjs ) ) ; runner. loadScript ( CSL. class. getResource (loadsysjs ) ) ; } ( Script ) ( b javascript file ) ; }Runner. set ( runner ) ; } return sharedRunner. get ( ) ; }<CODESPLIT>Calculates a list of available citation locales<CODESPLIT>0
public AbstractPrintQuery addMsgPhrase ( final SelectBuilder _selectBldr, final UUID... _msgPhrase ) throws EFapsException {Phraseph = new ( ) ; for ( phraseUUID _msgPhrase ) msg add ( MsgPhrase (UUID ) ) ; } return addMsgPhrase ( _selectBldr, msgph. toArray ( new MsgPhrase [ msgph. size ( ) ] ) ) ; }<CODESPLIT>Adds the msg phrase .<CODESPLIT>1
private String extractAttributes ( SoyMsg msg ) { StringBuilder attributes = new StringBuilder ( ) ; = MESSAGEATTRIBUTEPATTERN ( msg getDesc ( ) ) ; while ( ( ) ) attributes. (. group ( ) ) ; } return attributes. toString ( ) ; }<CODESPLIT>Extracts message attributes from the message description . Returns an empty {<CODESPLIT>1
VoltTable [ ] executeSlowHomogeneousBatch ( final List < QueuedSQL > batch, final boolean finalTask ) { MpTransactionState txnState = ( MpTransactionState ) m_txnState ; assert ( txnState null ) ; BatchState state = new BatchState ( batch. size ( ), txnState, msite. getCorSiteId ( ),Task, mprocedureName, mprocNameToLoadForFragmentTasks, mCallStats. samplingStmts ( ) ) ; for ( batch. ( ) ) { QueSQL queuedSQL = batch. ( ) ; assert ( queuedSQL. stmt null ) ; collectorOutputDepId = mtxnState. getNextDependencyId ( ) ; state. m_ToResume [ i = collectorOutputDepId ; ByteBuffer paramBuf = null ; { paramBuf = ByteBuffer. allocate ( queuedSQL. params.SerializedSize ( ) ) ; queuedSQL. params. flattenToBuffer ( paramBuf ) ; } ( IOException ) { ( serial parameters SQL statementSQL. stmt. ( ) paramsSQL. params.String ( ) ) ; } assert ( paramBuf null ) ; paramBuf. flip ( ) ; state. addStatement (, queuedSQL. stmt, paramBuf, msite ) ; } mState. setupProcedureResume ( state. mdepsToResume ) ; for ( state. mdepsForLocalTask. ) { if ( state. mdepsForLocalTask < ) { ; } state. mlocalTask. setInputId (, state. mdepsForLocalTask ) ; } mtxnState. createLocalFragmentWork ( state. mlocalTask, state. mlocalFragsAreNonTransactional && finalTask ) ; if ( state. mdistributedTask. isEmpty ( ) ) { state. mdistributedTask. setBatch ( mbatchIndex ) ; mtxnState. createAllPartatingFragmentWork ( state. mdistributedTask ) ; } Map Integer, List VoltTable mapResults = msite. recursableRun ( mtxnState ) ; assert ( mapResults null ) ; assert ( state. mdepsToResume null ) ; assert ( state. mdepsToResume. length batch. size ( ) ) ; for ( batch. ( ) ) { List VoltTable matchingTablesForId = mapResults. ( state. mdepsToResume ) ; assert ( matchingTablesForId null ) ; assert ( matchingTablesForId. size ( ) 1 ) ; state. mresults = matchingTablesForId. ( ) ; } return state. m_results ; }<CODESPLIT>/ * Execute a batch of homogeneous queries i . e . all reads or all writes .<CODESPLIT>1
public GrpcServer start ( ) throws IOException { RetryUtils retry (Starting gRPC server ( ) mServer start ( ) new ExponentBackoffRetry ( 100 500 ) ) ; mStarted = true ; return this ; }<CODESPLIT>Start serving .<CODESPLIT>1
public Chunk new_close ( ) { Chunk chk compress ( ) ; (vec AppendVec ) ( ( AppendVec )vec ) closeChunk ( this ) return chk ; }<CODESPLIT>Slow - path append data<CODESPLIT>0
public static K, V > Predicate Map < K, V > > anyEntry ( Predicate < Map. Entry < K, V > > p ) { return forEntries ( Pred Map Entry, V any ( p ) ) ; }<CODESPLIT>Returns a predicate that evaluates to {<CODESPLIT>0
public static T, U BiPredicate T, U biPredicate ( CheckedBiPredicate T, U predicate ) { return biPredicate ( predicate, THROWTORUNTIMEEXCEPTION ) ; }<CODESPLIT>Wrap a {<CODESPLIT>0
private int calcFuByJanto ( ) { Tile jantoTile = comp. getJanto ( ). getTile ( ) ; = 0 ; if (antoTile == generalS. getB ( ) ) { += ; } if (antoTile == personalS. getJik ( ) ) { += ; } if (antoTile. getType ( ) == S ) { += ; } return tmp ; }<CODESPLIT>待ちの種類による可符<CODESPLIT>0
@ Override public AddRoleToDBInstanceResult addRoleToDBInstance ( AddRoleToDBInstanceRequest request ) { request beforeClientExecution request return executeAddDBInstance ( request }<CODESPLIT>Marshall the given parameter object .<CODESPLIT>0
public static Object getValue ( Name name, int index ) { Assert. notNull ( name,name not null ) ; LdapName ldapName = returnOrConstructLdapNameFromName ( name ) ; Rdn rdn = ldapName. getRdn ( index ) ; if ( rdn ( ) ) LOGGER. warn (Rdn at position index of dn name is multivalue - returned value is not to trustedConsider using namebased getValue method instead ) ; } return rdn. getValue ( ) ; }<CODESPLIT>Get the value of the Rdn with the requested key in the supplied Name as a String .<CODESPLIT>0
