public final Data get Selected Data ( ) { Set String > all Selected = get Selected ( ) ; ( all Selected == all Selected . is Empty ( ) ) { return null ; } for ( String selected Item : all Selected Items ) { List < Integer > row Index = Tree Item Util . row Index String To List ( selected Item ) ; return get Tree Model ( ) . get Example Data ( row Index ) ; } return null ; }<CODESPLIT>Get the example which is selected in the tree .
public void At ( float alpha ) { ( Dim ) { ; } ( Dim View null ) { m Dim View = make Dim View ( ) ; } if ( ! m Dim View . is Shown ( ) ) { m Dim View . set Visibility ( VISIBLE ) ; m Dim View . set Background Color ( m Dim Color ) ; } m Dim View . set Alpha ( alpha ) ; }<CODESPLIT>Set the dim - behind layer a specific opacity .
public Path extract ( ) { ( is Found ( ) ) ( Extract only called once ) ; extract SW . start ( ) ; SPT Entry = spt Entry ; set Node ( . adj Node ) ; boolean Valid = Iterator . . is Valid ( curr Edge . edge ) ; int next Edge ; while ( next Edge Valid ) { next Edge Valid = Edge Iterator . Edge . is Valid ( curr Edge . parent . edge ) ; next Edge = next Edge Valid ? curr Edge . parent . edge : Edge Iterator . NO _ EDGE ; process Edge ( curr Edge . edge , curr Edge . adj Node , next Edge ) ; curr Edge = curr Edge . parent ; } set From Node ( curr Edge . adj Node ) ; reverse Order ( ) ; extract SW . stop ( ) ; return set Found ( true ) ; }<CODESPLIT>Extracts the Path from the shortest - path - tree determined by sptEntry .
public static int write Int ( [ , int , int value ) { [ = ( ) ( value 24 ) ; target [ offset + 1 ] = ( byte ) ( value >>> 16 ) ; target [ offset + 2 ] = ( byte ) ( value >>> 8 ) ; target [ offset + 3 ] = ( byte ) value ; return Integer . BYTES ; }<CODESPLIT>Writes the given 32 - bit Integer to the given byte array at the given offset .
private void visit Get ( ) { expect Match ( n , get JS Type ( n . get First Child ( ) ) , get JS Type ( n . get Last Child ( ) ) ) ; ensure Typed ( n ) ; }<CODESPLIT>Visits a GETELEM node .
private static Class get Typed Class ( java . lang . reflect . Type type ) { ( type Class ) { return ( ( Class ) type ) ; } ( type Parameterized Type ) { java . lang . reflect . Type raw Paramterized Type = ( ( Parameterized Type ) type ) . get Raw Type ( ) ; return get Typed Class ( raw Paramterized Type ) ; } ( type Type Variable ) { java . lang . reflect . Type upper Bound = ( ( Type Variable ) type ) . get ( ) [ 0 ] ; return get Typed Class ( upper Bound ) ; } Argument Exception ( " Error while finding generic class for :" + type ) ; }<CODESPLIT>Gets the typed class .
public to ( Jimfs Path path ) { file Store . state ( ) . check ( ) ; path . to Uri ( uri , path . to Absolute Path ( ) ) ; }<CODESPLIT>Gets the URI of the given path in this file system .
public Interface get Interface ( ) { ( activity Interface == ) { activity Interface = new Activity Interface ( api Key , shared Secret , transport ) ; } return activity Interface ; }<CODESPLIT>Get the ActivityInterface .
private void init Before List ( ) { List Process Advice before Request Process Advices = Array List ( ) ; Method invoke = get ( ) ; Class processor Class = invoke . get Class ( ) ; ( != processor Class && processor Class . is Annotation Present ( Before . class ) ) { final Class < ? extends Process Advice > [ ] bcs = processor Class . get Annotation ( Before . class ) . value ( ) ; for ( int i = 0 ; i < bcs . length ; i ++ ) { final Class < ? extends Process Advice > bc = bcs [ i ] ; final Process Advice before Request Process Advice = Bean Manager . get Instance ( ) . get Reference ( bc ) ; before Request Process Advices . add ( before Request Process Advice ) ; } } if ( invoke Holder . is Annotation Present ( Before . class ) ) { final Class < ? extends Process Advice > [ ] bcs = invoke Holder . get Annotation ( Before . class ) . value ( ) ; for ( int i = 0 ; i < bcs . length ; i ++ ) { final Class < ? extends Process Advice > bc = bcs [ i ] ; final Process Advice before Request Process Advice = Bean Manager . get Instance ( ) . get Reference ( bc ) ; before Request Process Advices . add ( before Request Process Advice ) ; } } }<CODESPLIT>Initializes before process advices .
private void init ( ) { js Json ( ) ; js configure ( Json Feature . ALLOW _ COMMENTS , true ) ; js Factory . configure ( Json Parser . Feature . ALLOW _ SINGLE _ QUOTES , true ) ; js Factory . configure ( Json Parser . Feature . ALLOW _ NON _ NUMERIC _ NUMBERS , true ) ; }<CODESPLIT>Creates the JsonFactory .
static void flush Leaks ( Looper looper ) { Handler = Handler ( looper ) { public void handle ( ) { send Delayed ( obtain Message ( ) , THREAD _ LEAK _ CLEANING _ MS ) ; } } ; handler . send Message Delayed ( handler . obtain Message ( ) , THREAD _ LEAK _ CLEANING _ MS ) ; }<CODESPLIT>Prior to Android 5 HandlerThread always keeps a stack local reference to the last message that was sent to it . This method makes sure that stack local reference never stays there for too long by sending new messages to it every second .
public void add Reset ( String ) { ( buttons == ) buttons At Bottom ( ) ; Element = Input ( Input . Reset , Reset " , label ) ; if ( extend Row ) add Field ( null , e ) ; else buttons . add ( e ) ; }<CODESPLIT>Add a reset button .
public static int get Volume ( Context context ) { ( ( Audio ) context . get Service ( Context . AUDIO _ SERVICE ) ) . get Stream Volume ( Audio Manager . STREAM _ MUSIC ) ; }<CODESPLIT>Returns maximum volume the media volume can have
public void remove SR Es ( ISRE Install ... sres ) { ISRE Install SRE get Default SRE ( ) ; String Id SRE SRE get Id ( ) ; int ; ( Id ) { ( int 0 ; . sre Table . get Item Count ( ) ; ++ i ) { if ( default Id . equals ( ( ( ISRE Install ) this . sre Table . get Item ( i ) . get Data ( ) ) . get Id ( ) ) ) { default Index = i ; } } } final String normed Default Id = Strings . null To Empty ( default Id ) ; boolean default Is Removed = false ; for ( final ISRE Install sre : sres ) { if ( this . sre Array . remove ( sre ) && sre . get Id ( ) . equals ( normed Default Id ) ) { default Is Removed = true ; } } refresh SRE List UI ( ) ; if ( default Is Removed ) { if ( this . sre Table . get Item Count ( ) == 0 ) { set Selection ( null ) ; } else { if ( default Index < 0 ) { default Index = 0 ; } else if ( default Index >= this . sre Table . get Item Count ( ) ) { default Index = this . sre Table . get Item Count ( ) - 1 ; } set Selection ( new Structured Selection ( this . sre Table . get Item ( default Index ) . get Data ( ) ) ) ; } } this . sres List . refresh ( true ) ; if ( default Is Removed ) { fire Default SRE Changed ( ) ; } update UI ( ) ; }<CODESPLIT>Removes the given SREs from the table .
public static Wiki User get User ( String wiki Id , String siteurl ) { Wiki User ; { Properties get Properties ( wiki Id ) ; Wiki User ( ) ; . set Username ( . get Property ( user ) ) ; . set Email ( . get Property ( ) ) ; Crypt Crypt ( props . get Property ( " cypher " ) , props . get Property ( " salt " ) ) ; result . set Password ( pcf . decrypt ( props . get Property ( " secret " ) ) ) ; } catch ( File Not Found Exception e ) { String msg = help ( wiki Id , siteurl ) ; LOGGER . log ( Level . SEVERE , msg ) ; } catch ( IO Exception e ) { LOGGER . log ( Level . SEVERE , e . get Message ( ) ) ; } catch ( General Security Exception e ) { LOGGER . log ( Level . SEVERE , e . get Message ( ) ) ; } return result ; }<CODESPLIT>get the Wiki user for the given wikiid
public T ( ) { int retry Count = 0 ; do { T = delegate . ( ) ; ( ! Generated . contains ( ) ) { Generated . add ( ) ; return ; } retry Count ; } while ( retry Count <= number Of Retries ) ; throw new Illegal State Exception ( on ( " " ) . join ( " Exhausted " , number Of Retries , " retries trying to generate unique value " ) ) ; }<CODESPLIT>Returns unique &lt ; T&gt ; generated by delegate Generator&lt ; T&gt ;
private boolean is Inside List ( ) { return ( . get Type ( ) . _ NODE || node . get Node Name ( ) . equals Ignore Case ( TAG _ LI ) ) && ( node . get Node Type ( ) != Node . TEXT _ NODE || node . get Node Value ( ) . trim ( ) . length ( ) == 0 ) ; }<CODESPLIT>Checks if a given node is allowed or not as a child of a &lt ; ul&gt ; or &lt ; ol&gt ; element .
public static Residue Number match Sequence To ( Protein Sequence seq , struct ) { Map , Group atom Position Map , Group ( ) ; Protein Sequence struct Seq get Protein Sequence For ( struct , atom Position ) ; Substitution Matrix Amino Acid Compound Substitution Matrix Amino Acid Compound ( Amino Acid Compound get Amino Acid Compound ( ) , ( ) , ( ) ) ; Substitution Matrix Amino Acid Compound ( Amino Acid Compound get Amino Acid Compound ( ) , Input Stream Reader ( Substitution Matrix get As Stream ( "/ matrices blosum txt ) ) , blosum 100 " ) ; Sequence Pair < Protein Sequence , Amino Acid Compound > pair = Alignments . get Pairwise Alignment ( seq , struct Seq , Pairwise Sequence Aligner Type . GLOBAL , new Simple Gap Penalty ( ) , matrix ) ; Aligned Sequence < Protein Sequence , Amino Acid Compound > aligned Seq = pair . get Query ( ) ; Aligned Sequence < Protein Sequence , Amino Acid Compound > aligned Struct = pair . get Target ( ) ; assert ( aligned Seq . get Length ( ) == aligned Struct . get Length ( ) ) ; Residue Number [ ] ca = new Residue Number [ seq . get Length ( ) ] ; for ( int pos = aligned Seq . get Start ( ) . get Position ( ) ; pos <= aligned Seq . get End ( ) . get Position ( ) ; pos ++ ) { if ( aligned Seq . is Gap ( pos ) ) { int struct Index = aligned Struct . get Sequence Index At ( pos ) - 1 ; assert ( struct Index > 0 ) ; Group g = atom Index Position . get ( struct Index ) ; logger . warn ( " Chain {} residue {} in the Structure {} has no corresponding amino acid in the sequence ." , g . get Chain Id ( ) , g . get Residue Number ( ) . to String ( ) , g . get Chain ( ) . get Structure ( ) . get PDB Code ( ) ) ; continue ; } if ( ! aligned Struct . is Gap ( pos ) ) { int seq Index = aligned Seq . get Sequence Index At ( pos ) - 1 ; int struct Index = aligned Struct . get Sequence Index At ( pos ) - 1 ; Group g = atom Index Position . get ( struct Index ) ; assert ( 0 <= seq Index && seq Index < ca . length ) ; ca [ seq Index ] = g . get Residue Number ( ) ; } } return ca ; }<CODESPLIT>Given a sequence and the corresponding Structure get the ResidueNumber for each residue in the sequence .
public static merge ( , , , 2 ) { Map String , Object map ( ( Map String , Object ) ) ; Entry String , Object set map Set ( ) ; Map < String , Object > map 2 = ( ( Map < String , Object > ) meta Data 2 ) ; Set < Entry < String , Object > > set 2 = map 2 . entry Set ( ) ; Map < String , Object > rep = new Hash Map < String , Object > ( ) ; for ( Entry < String , Object > entry 1 : set 1 ) { String key 1 = entry 1 . get Key ( ) ; if ( map 2 . contains Key ( key 1 ) ) { Object value 1 = map 1 . get ( key 1 ) ; Object value 2 = map 2 . get ( key 1 ) ; if ( value 1 instanceof Double ) { if ( Double . value Of ( value 1 . to String ( ) ) . double Value ( ) < Double . value Of ( value 2 . to String ( ) ) . double Value ( ) ) { rep . put ( key 1 , value 2 ) ; } } else if ( value 1 instanceof Integer ) { if ( Integer . value Of ( value 1 . to String ( ) ) . int Value ( ) < Integer . value Of ( value 2 . to String ( ) ) . int Value ( ) ) { rep . put ( key 1 , value 2 ) ; } else if ( value 1 instanceof Long ) { if ( Long . value Of ( value 1 . to String ( ) ) . long Value ( ) < Long . value Of ( value 2 . to String ( ) ) . long Value ( ) ) { rep . put ( key 1 , value 2 ) ; if ( value 1 instanceof Boolean ) { if ( ! Boolean . value Of ( value 1 . to String ( ) ) && Boolean . value Of ( value 2 . to String ( ) ) ) { rep . put ( key 1 , value 2 ) ; set 1 . remove All ( rep . entry Set ( ) ) ; set 1 . add All ( rep . entry Set ( ) ) ; set 1 . add All ( set 2 ) ; return meta Data 1 ;<CODESPLIT>Merges the two Meta objects
public List T sub List ( int arg 0 , int arg ) { ( all . size ( ) arg && next Results Available ( ) ) { move Next Results ( ) ; } return Collections . unmodifiable List ( all Results . sub List ( arg 0 , arg 1 ) ) ; }<CODESPLIT>Returns a sub - list in the range specified loading more results as necessary .
private prepare ( String , message , Recipient recipients ) { message set Metadata ( cwf pub , Id ) ; message . set Metadata ( " cwf . pub . channel " , channel ) ; message . set Metadata ( " cwf . pub . event " , UUID . random UUID ( ) . to String ( ) ) ; message . set Metadata ( " cwf . pub . when " , System . current Time Millis ( ) ) ; message . set Metadata ( " cwf . pub . recipients " , recipients ) ; return message ; }<CODESPLIT>Adds publication - specific metadata to the message .
private T Graph Request T ( String object , Type type , Param ... params ) { this . check For Batch ( ) ; Graph Request T req = new Graph Request < T > ( object , params , this . mapper , this . < T > create Mapping Chain ( type ) ) ; this . graph Requests . add ( req ) ; return req ; }<CODESPLIT>The actual implementation of this after we ve converted to proper Jackson JavaType
public void write Length ( long ) { ( 251 ) { ( ) ; } ( < 65536 ) { buf [ position ++ ] = ( byte ) 0 xfc ; buf [ position ++ ] = ( byte ) length ; buf [ position ++ ] = ( byte ) ( length >>> 8 ) ; } else if ( length < 16777216 ) { buf [ position ++ ] = ( byte ) 0 xfd ; buf [ position ++ ] = ( byte ) length ; buf [ position ++ ] = ( byte ) ( length >>> 8 ) ; buf [ position ++ ] = ( byte ) ( length >>> 16 ) ; } else { buf [ position ++ ] = ( byte ) length ; buf [ position ++ ] = ( byte ) ( length >>> 8 ) ; buf [ position ++ ] = ( byte ) ( length >>> 16 ) ; buf [ position ++ ] = ( byte ) ( length >>> 24 ) ; buf [ position ++ ] = ( byte ) ( length >>> 32 ) ; buf [ position ++ ] = ( byte ) ( length >>> 40 ) ; buf [ position ++ ] = ( byte ) ( length >>> 48 ) ; buf [ position ++ ] = ( byte ) ( length >>> 54 ) ; } }<CODESPLIT>Write length .
public static T Source , T Result List T Result map ( Collection T Source , T Source , T Result mapper ) { ( is Empty ( items ) ) { return new Array List < > ( ) ; } List < T Result > result = new Array List < > ( items . size ( ) ) ; for ( T Source item : items ) { T Result mapped Item = mapper . map ( item ) ; result . add ( mapped Item ) ; } return result ; }<CODESPLIT>Projects each element of a collection into a new collection .
private static void serialize Real ( Number , Content Handler ) throws Exception { serialize Element ( " real " , String . value Of ( real . double Value ( ) ) , handler ) ; }<CODESPLIT>Serialize a Number as a real element .
public Bar ( Action Listener Action , boolean Add Help ) { Application = Base Applet . get Shared Instance ( ) . get Application ( ) ; Resource Resources = . get Resource ( ) ; . get Resources ( , ) ; this . Actions ( Action ) ; Bar Bar = Bar ( ) { private static long serial Version UID = 1 L ; public Dimension get Maximum Size ( ) { return new Dimension ( super . get Maximum Size ( ) . width , super . get Preferred Size ( ) . height ) ; } } ; menu Bar . set Opaque ( false ) ; J Menu menu ; char [ ] rgch Item Shortcuts = new char [ 20 ] ; menu = this . add Menu ( menu Bar , Thin Menu Constants . FILE ) ; this . add Menu Item ( menu , Thin Menu Constants . PRINT , rgch Item Shortcuts ) ; menu . add Separator ( ) ; this . add Menu Item ( menu , Thin Menu Constants . LOGON , rgch Item Shortcuts ) ; this . add Menu Item ( menu , Thin Menu Constants . LOGOUT , rgch Item Shortcuts ) ; this . add Menu Item ( menu , Thin Menu Constants . CHANGE _ PASSWORD , rgch Item Shortcuts ) ; menu . add Separator ( ) ; this . add Menu Item ( menu , Thin Menu Constants . CLOSE , rgch Item Shortcuts ) ; rgch Item Shortcuts = new char [ 20 ] ; menu = this . add Menu ( menu Bar , Thin Menu Constants . EDIT ) ; this . add Menu Item ( menu , Thin Menu Constants . CUT , rgch Item Shortcuts ) ; this . add Menu Item ( menu , Thin Menu Constants . COPY , rgch Item Shortcuts ) ; this . add Menu Item ( menu , Thin Menu Constants . PASTE , rgch Item Shortcuts ) ; menu . add Separator ( ) ; this . add Menu Item ( menu , Thin Menu Constants . PREFERENCES , rgch Item Shortcuts ) ; if ( old Resources != null ) application . set Resource Bundle ( old Resources ) ; return menu Bar ; }<CODESPLIT>Setup the standard menu items .
public static String get Preferred Attribute Name For Lane Count ( ) { Preferences prefs = Preferences . user For Package ( Road Network . class ) ; ( prefs ) { return prefs . get ( LANE _ COUNT _ ATTR _ " , DEFAULT _ ATTR _ LANE _ COUNT ) ; } return DEFAULT _ ATTR _ LANE _ COUNT ; }<CODESPLIT>Replies the preferred name for the number of lanes of the roads .
public static nsrollbackcmd [ ] get ( nitro _ , nsrollbackcmd _ ) throws { nsrollbackcmd = nsrollbackcmd ( ) ; option = options ( ) ; option . set _ args ( nitro _ util . object _ to _ string _ withoutquotes ( args ) ) ; nsrollbackcmd [ ] response = ( nsrollbackcmd [ ] ) obj . get _ resources ( service , option ) ; return response ; }<CODESPLIT>Use this API to fetch all the nsrollbackcmd resources that are configured on netscaler . This uses nsrollbackcmd_args which is a way to provide additional arguments while fetching the resources .
private int Element No ( int ) { ( ! List 0 ) { return ; } int j = 0 ; Pattern Rule rule = ( Pattern Rule ) this . rule ; for ( int k = 0 ; k < i ; k ++ ) { j += rule . get Element No ( ) . get ( k ) ; } return j ; }<CODESPLIT>Gets the index of the element indexed by i adding any offsets because of the phrases in the rule .
public String get Proxy Hosts White List ( ) { ( Hosts White List proxy Hosts White List . size ( ) == 0 ) return new String [ 0 ] ; String [ ] hosts = new String [ _ proxy Hosts White List . size ( ) ] ; hosts = ( String [ ] ) _ proxy Hosts White List . to Array ( hosts ) ; return hosts ; }<CODESPLIT>Get proxy host white list .
public boolean add Metatype Ad ( Metatype Ad metatype Ad ) { ( this . metatype Ads == ) this . metatype Ads = List Metatype Ad ( ) ; ( Metatype Ad ad metatype Ads ) ( ad . get ID ( ) . equals ( metatype Ad . get ID ( ) ) ) return false ; this . metatype Ads . add ( metatype Ad ) ; return true ; }<CODESPLIT>Adds a metatype AD .
public long ( long ) throws { ( Input Stream . available ( ) >= ) { return Input Stream . ( ) ; } Input Stream . close ( ) ; += n ; try { m Object = m Client . get Object ( m Bucket Name , m Key , null , null , null , null , m Pos , null ) ; m Input Stream = new Buffered Input Stream ( m Object . get Data Input Stream ( ) ) ; } catch ( Service Exception e ) { throw new IO Exception ( e ) ; } return n ; }<CODESPLIT>This method leverages the ability to open a stream from GCS from a given offset . When the underlying stream has fewer bytes buffered than the skip request the stream is closed and a new stream is opened starting at the requested offset .
public static boolean is Super ( JC tree ) { Name name = called Method Name ( tree ) ; ( name != ) { Names = name . table . ; return name == names . _ super ; } else { return false ; } }<CODESPLIT>Is this a call to super?
public static String get Request ( String from Method , boolean include , Request request ) { String String ( ) ; append ( ) append ( 8601 get ( ) ) append ( "\ ) ; append ( from Method ) append ( from Method ) append ( "\ ) ; append ( Method : " ) . append ( request . get Method ( ) ) . append ( '\ n ' ) ; dump . append ( " Scheme : " ) . append ( request . get Scheme ( ) ) . append ( '\ n ' ) ; dump . append ( " URI : " ) . append ( request . get Request URI ( ) ) . append ( '\ n ' ) ; dump . append ( " Query - String : " ) . append ( request . get Query String ( ) ) . append ( '\ n ' ) ; dump . append ( " Auth - Type : " ) . append ( request . get Auth Type ( ) ) . append ( '\ n ' ) ; dump . append ( " Remote - Addr : " ) . append ( request . get Remote Addr ( ) ) . append ( '\ n ' ) ; dump . append ( " Scheme : " ) . append ( request . get Scheme ( ) ) . append ( '\ n ' ) ; dump . append ( " Content - Type : " ) . append ( request . get Content Type ( ) ) . append ( '\ n ' ) ; dump . append ( " Content - Length : " ) . append ( request . get Content Length ( ) ) . append ( '\ n ' ) ; if ( include Headers ) { dump . append ( " Headers :\ n " ) ; Enumeration < String > headers = request . get Header Names ( ) ; while ( headers . has More Elements ( ) ) { dump . append ( "\ t " ) . append ( header ) . append ( ": " ) . append ( request . get Header ( header ) ) . append ( '\ n ' ) ; } } return ( dump . to String ( ) ) ; }<CODESPLIT>Build a String containing a short multi - line dump of an HTTP request .
public static void validate Not Empty ( String To Check , boolean trim , String argument Name ) throws Null Argument { validate Not Null ( To Check , argument Name ) ; ( To Check . ( ) 0 ( trim string To Check . trim ( ) . length ( ) == 0 ) ) { throw new Null Argument Exception ( argument Name + IS _ EMPTY ) ; } }<CODESPLIT>Validates that the string is not null and not an empty string .
public static create With Vertical Layout ( ) { _ panel = new J Panel ( ) ; _ panel . set Layout ( new Box Layout ( _ panel , Box Layout . Y _ AXIS ) ) ; return _ panel ; }<CODESPLIT>Create a panel that lays out components vertically .
protected boolean should Analyze ( ) { ( analyzer File Type ) { File Type file Type = ( File Type Analyzer ) analyzer ; return file Type Analyzer . accept ( dependency . get Actual File ( ) ) ; } return true ; }<CODESPLIT>Determines if the analyzer can analyze the given dependency .
public void register Class ( Class Class ) { . put ( service Class . get Simple Name ( ) , service Class ) ; Settings . Services . add Available Option ( service Class . get Simple Name ( ) ) ; }<CODESPLIT>Registers a service enabling the service layer to automatically start autorun servies .
public String get Text ( String Title , int Number ) throws { String = this . get Page Content ( page Title , "& rvsection =" + section Number , false ) ; return result ; }<CODESPLIT>get the text for the given section
public static double pearson ( int [ ] x , int [ ] y ) { ( x . != y . ) Argument ( String . format ( Arrays have different length : x [% d ], y [% d ]" , x . length , y . length ) ) ; return 1 - Math . cor ( x , y ) ; }<CODESPLIT>Pearson correlation distance between the two arrays of type int .
public static Tile get Tile From WGS 84 ( Point point , int ) { Projection projection Projection Factory . get Projection ( Projection . EPSG WORLD _ GEODETIC _ SYSTEM ) ; return get Tile Grid ( point , zoom , projection ) ; }<CODESPLIT>Get the tile grid for the location specified as WGS84
public List Vector Layer get Vector Layers ( ) { Array List Vector Layer list = Array List Vector Layer ( ) ; for ( Layer < ? > layer : layers ) { if ( layer instanceof Vector Layer ) { list . add ( ( Vector Layer ) layer ) ; } } return list ; }<CODESPLIT>Return a list containing all vector layers within this model .
private void Rmsd ( Point d [ , Point d [ ) { ( centered ) { Product ( , ) ; } { xref = Calc Point . clone Point d Array ( ) ; xtrans = Calc Point . centroid ( xref ) ; . ( x centroid : " + xtrans ) ; xtrans . negate ( ) ; Calc Point . translate ( new Vector 3 d ( xtrans ) , xref ) ; yref = Calc Point . clone Point 3 d Array ( y ) ; ytrans = Calc Point . centroid ( yref ) ; logger . debug ( " y centroid : " + ytrans ) ; ytrans . negate ( ) ; Calc Point . translate ( new Vector 3 d ( ytrans ) , yref ) ; inner Product ( yref , xref ) ; } calc Rmsd ( wsum ) ; }<CODESPLIT>Calculates the RMSD value for superposition of y onto x . This requires the coordinates to be precentered .
public void set Heading ( Title v ) { ( _ Type . Ok ( ( _ Type ) Type ) . cas Feat _ Heading == ) Type . . throw Feat Missing ( " section Heading " , " de . julielab . jules . types . Section " ) ; jcas Type . ll _ cas . ll _ set Ref Value ( addr , ( ( Section _ Type ) jcas Type ) . cas Feat Code _ section Heading , jcas Type . ll _ cas . ll _ get FS Ref ( v ) ) ; }<CODESPLIT>setter for sectionHeading - sets the title of the section
public Response process ( Input Stream is ) throws , , Configuration { Sxmp = Sxmp ( version ) ; Operation = ; { = . parse ( is ) ; ( Sxmp ) { ( . get Operation ( ) . get Operation ( ) . get Type ( ) ) { . ( Unable to fully parse XML into a request , returning Error Response ; error . get ( ) . get Operation ( ) ) ; return new Error Response ( e . get Operation ( ) . get Type ( ) , e . get Error Code ( ) . get Int Value ( ) , e . get Error Message ( ) ) ; else { throw new SAX Exception ( e . get Message ( ) , e ) ; } try { if ( ! ( operation instanceof Request ) ) { throw new Sxmp Error Exception ( Sxmp Error Code . UNSUPPORTED _ OPERATION , " A session can only process requests " ) ; } if ( req . get Account ( ) == null ) { throw new Sxmp Error Exception ( Sxmp Error Code . MISSING _ REQUIRED _ ELEMENT , " A request must include account credentials " ) ; } if ( ! processor . authenticate ( req . get Account ( ) ) ) { throw new Sxmp Error Exception ( Sxmp Error Code . AUTHENTICATION _ FAILURE , " Authentication failure " ) ; } if ( operation instanceof Submit Request ) { return processor . submit ( req . get Account ( ) , ( Submit Request ) operation ) ; } else if ( operation instanceof Deliver Request ) { return processor . deliver ( req . get Account ( ) , ( Deliver Request ) operation ) ; } else if ( operation instanceof Delivery Report Request ) { return processor . delivery Report ( req . get Account ( ) , ( Delivery Report Request ) operation ) ; } else { throw new Sxmp Error Exception ( Sxmp Error Code . UNSUPPORTED _ OPERATION , " Unsupported operation request type " ) ; } } catch ( Sxmp Error Exception e ) { logger . warn ( e . get Message ( ) ) ; return new Error Response ( operation . get Type ( ) , e . get Error Code ( ) . get Int Value ( ) , e . get Error Message ( ) ) ; } catch ( Throwable t ) { logger . error ( " Major uncaught throwable while processing request , generating an Error Response " , t ) ; return new Error Response ( operation . get Type ( ) , Sxmp Error Code . GENERIC . get Int Value ( ) , " Generic error while processing request " ) ; }<CODESPLIT>Processes an InputStream that contains a request . Does its best to only produce a Response that can be written to an OutputStream . Any exception this method throws should be treated as fatal and no attempt should be made to print out valid XML as a response .
private void submit ( String url , Http Request . Connection Settings Settings , String Object , String Application Id , String master , Response , List String redirect Urls ) { ( redirect Urls . contains ( url ) ) { Push Sender ( The site contains an redirect ! url url ) ; } { redirect Urls . add ( url ) ; Http URL Connection http URL Connection ; { String Application Id ':' master ; String . encode Bytes ( . get Bytes ( 8 ) ) ; http URL Connection ( Http URL Connection ) Http Request . post ( url , encoded , json Payload Object , UTF _ 8 , proxy , custom Trust Store , connection Settings ) ; final int status Code = http URL Connection . get Response Code ( ) ; logger . log ( Level . INFO , String . format ( " HTTP Response code from Unified Push Server : % s " , status Code ) ) ; if ( is Redirect ( status Code ) ) { String redirect URL = http URL Connection . get Header Field ( " Location " ) ; logger . log ( Level . INFO , String . format ( " Performing redirect to '% s '" , redirect URL ) ) ; submit Payload ( redirect URL , push Configuration . get Connection Settings ( ) , json Payload Object , push Application Id , master Secret , callback , redirect Urls ) ; } else if ( status Code >= 400 ) { logger . log ( Level . SEVERE , " The Unified Push Server returned status code : " + status Code ) ; throw new Push Sender Http Exception ( status Code ) ; } else { if ( callback != null ) { callback . on Complete ( ) ; } } } catch ( Push Sender Http Exception pshe ) { throw pshe ; } catch ( Exception e ) { logger . log ( Level . INFO , " Error happening while trying to send the push delivery request " , e ) ; throw new Push Sender Exception ( e . get Message ( ) , e ) ; } finally { if ( http URL Connection != null ) { http URL Connection . disconnect ( ) ; } } }<CODESPLIT>The actual method that does the real send and connection handling
public String [ ] get Child Names ( ) { ( == . size ( ) == 0 ) return EMPTY _ NAMES ; String [ ] = String [ . size ( ) ] ; for ( int = 0 ; i < arr . length ; i ++ ) { arr [ i ] = ( ( Ram Resource Core ) children . get ( i ) ) . get Name ( ) ; } return arr ; }<CODESPLIT>Gibt den Feldnamen children zurueck .
public static Object get Index ( Object array , int index ) throws Util Target Error { Interpreter . ( get Index : , array , ", index =" , index ) ; { ( array List ) return ( ( List < > ) array ) . get ( index ) ; Object = Array . get ( array , index ) ; return Primitive . wrap ( , Types . array Element Type ( array . get Class ( ) ) ) ; } ( Index Out Of 1 ) { int = array List ( ( List < > ) array ) . size ( ) : Array . get Length ( array ) ; throw new Util Target Error ( " Index " + index + " out - of - bounds for length " + len , e 1 ) ; } }<CODESPLIT>Get object from array or list at index .
public static add ( nitro client , aaakcdaccount ) throws { aaakcdaccount addresource aaakcdaccount ( ) ; addresource kcdaccount = resource . kcdaccount ; addresource . keytab = resource . keytab ; addresource . realmstr = resource . realmstr ; addresource . delegateduser = resource . delegateduser ; addresource . kcdpassword = resource . kcdpassword ; addresource . usercert = resource . usercert ; addresource . cacert = resource . cacert ; return addresource . add _ resource ( client ) ; }<CODESPLIT>Use this API to add aaakcdaccount .
public synchronized void ( ) { ( Trace Component . is Tracing ( ) tc . is Entry ( ) ) Sib Tr . ( this , tc , , this ) ; boolean interrupted = ; ( ! ( ) ) { { ( Trace Component . is Tracing ( ) tc . is Debug ( ) ) Sib Tr . ( this , tc , Waiting to get exclusive lock " ) ; wait ( 1000 ) ; } catch ( Interrupted Exception e ) { interrupted = true ; } } while ( i Lock Count > 0 ) { try { if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Debug Enabled ( ) ) Sib Tr . debug ( this , tc , " Waiting for lock count to reach 0 " + i Lock Count ) ; wait ( 1000 ) ; } catch ( Interrupted Exception e ) { interrupted = true ; } } if ( interrupted ) { Thread . current Thread ( ) . interrupt ( ) ; } if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) Sib Tr . exit ( this , tc , " lock Exclusive " ) ; }<CODESPLIT>This method locks the mutex so no other lockers can get the lock .
public void set CP Option Value ( . liferay . commerce . product . . CP Option Value Service cp Option Value Local Service ) { this . cp Option Value Local Service = cp Option Value Local Service ; }<CODESPLIT>Sets the cp option value local service .
public static String infer Module Path From Type ( Type Declaration type ) { Package Declaration = type . get Package ( ) ; return != '/' pkg . get Qualified Name ( ) . replace ( '.' , '/' ) : "/" ; }<CODESPLIT>Infers the Struts module path from the given controller class .
int get Leap Month ( int cycle , int year Of Cycle ) { int [ ] leap Months = this . get Leap Months ( ) ; int Years = ( cycle ) year Of Cycle ; int index = 2 ( ( Years leap Months [ 0 ] ) / ) ; int lm = 0 ; ( ( index leap Months . ) ) { int test = leap Months [ index ] ; if ( test < elapsed Years ) { index += Math . max ( 2 * ( ( elapsed Years - test ) / 3 ) , 2 ) ; } else if ( test > elapsed Years ) { break ; } else { lm = leap Months [ index + 1 ] ; break ; } } return lm ; }<CODESPLIT>number of leap month or zero if no leap year
public Snippet get Snippet ( Integer snippet Id , boolean download Content ) throws Git Lab Api { ( snippet Id == ) { ( snippet Id ' t " ) ; } Response response = get ( Response . Status . OK , null , " snippets " , snippet Id ) ; Snippet snippet = response . read Entity ( Snippet . class ) ; if ( download Content ) { snippet . set Content ( get Snippet Content ( snippet . get Id ( ) ) ) ; } return snippet ; }<CODESPLIT>Get a specific Snippet .
public get ( ) { value ; ix ; ( >= 0 ) { ( 0 0 d 800 ( 0 0 dbff <= 0 0 ffff ) ) { ix index >> UTRIE 2 SHIFT 2 ; ix ( ix << UTRIE 2 _ SHIFT ) + ( code Point & UTRIE 2 _ DATA _ MASK ) ; value = data 32 [ ix ] ; return value ; } if ( code Point <= 0 xffff ) { ix = index [ UTRIE 2 _ LSCP _ INDEX _ 2 _ OFFSET + ( ( code Point - 0 xd 800 ) >> UTRIE 2 _ SHIFT _ 2 ) ] ; ix = ( ix << UTRIE 2 _ INDEX _ SHIFT ) + ( code Point & UTRIE 2 _ DATA _ MASK ) ; value = data 32 [ ix ] ; return value ; } if ( code Point < high Start ) { ix = ( UTRIE 2 _ INDEX _ 1 _ OFFSET - UTRIE 2 _ OMITTED _ BMP _ INDEX _ 1 _ LENGTH ) + ( code Point >> UTRIE 2 _ SHIFT _ 1 ) ; ix = index [ ix ] ; ix += ( code Point >> UTRIE 2 _ SHIFT _ 2 ) & UTRIE 2 _ INDEX _ 2 _ MASK ; ix = index [ ix ] ; ix = ( ix << UTRIE 2 _ INDEX _ SHIFT ) + ( code Point & UTRIE 2 _ DATA _ MASK ) ; value = data 32 [ ix ] ; return value ; } if ( code Point <= 0 x 10 ffff ) { value = data 32 [ high Value Index ] ; return value ; } } return error Value ; }<CODESPLIT>Get the value for a code point as stored in the Trie2 .
public static Object get M Bean Attribute Object ( String name , String Name ) throws JM { M Bean Server server get M Bean Server ( ) ; Object Name Name Object Name ( name ) ; return server . get Attribute ( obj Name , attr Name ) ; }<CODESPLIT>Get MBean attribute object
public synchronized void set Selected Index ( final int selected Index ) { ( . size ( ) <= selected Index selected Index 1 ) { Index Out Of ( argument to Combo . set Selected Index : selected Index ) ; } final int = this . selected Index ; this . selected Index = selected Index ; ( selected Index == - 1 ) { update Text ( "" ) ; } else { update Text ( items . get ( selected Index ) . to String ( ) ) ; } run On GUI Thread If Exists Otherwise Run Direct ( new Runnable ( ) { public void run ( ) { for ( Listener listener : listeners ) { listener . on Selection Changed ( selected Index , old Selection ) ; } } } ) ; invalidate ( ) ; }<CODESPLIT>Programmatically selects one item in the combo box which causes the displayed text to change to match the label of the selected index .
public Stats get Photo Stats ( String photo Id , Date ) throws Flickr { get Stats ( METHOD _ PHOTO _ STATS , " photo _ id " , photo Id , date ) ; }<CODESPLIT>Get the number of views comments and favorites on a photo for a given date .
public Service Document get Document ( Get Document get Document ) { Validator . not Null ( get Document , get Document cannot ) ; String [ path Segments = { v / environments , collections , documents } ; String [ path Parameters = { get Document Status Options . environment Id ( ) , get Document Status Options . collection Id ( ) , get Document Status Options . document Id ( ) } ; Request Builder builder = Request Builder . get ( Request Builder . construct Http Url ( get End Point ( ) , path Segments , path Parameters ) ) ; builder . query ( " version " , version Date ) ; Map < String , String > sdk Headers = Sdk Common . get Sdk Headers ( " discovery " , " v 1 " , " get Document Status " ) ; for ( Entry < String , String > header : sdk Headers . entry Set ( ) ) { builder . header ( header . get Key ( ) , header . get Value ( ) ) ; } builder . header ( " Accept " , " application / json " ) ; return create Service Call ( builder . build ( ) , Response Converter Utils . get Object ( Document Status . class ) ) ; }<CODESPLIT>Get document details .
public Pager > get Closes Issues ( Object project Id Or Path , Integer merge Request Iid , int Per Page ) throws Git Lab Api { return Pager > ( this , . class , Per Page , null , " projects " , get Project Id Or Path ( project Id Or Path ) , " merge _ requests " , merge Request Iid , " closes _ issues " ) ; }<CODESPLIT>Get a Pager containing all the issues that would be closed by merging the provided merge request .
public static final void loge ( Class < > clazz , String , ... ) { ( DEBUG ) { String exception = "" ; ( != . == 1 ) { String Writer sw = String Writer ( ) ; Print Writer = Print Writer ( sw ) ; e [ 0 ] . print Stack Trace ( pw ) ; pw . flush ( ) ; exception Str = " exception = " + sw . to String ( ) ; } System . err . println ( "[" + s Sdf . format ( new Date ( ) ) + "]" + "-" + "[" + clazz . get Simple Name ( ) + "] " + msg + " " + exception Str ) ; } }<CODESPLIT>To output the error log message to the error out
public static Html TH ( Html Style style Class , String , Content body ) { Html htmltree Html ( Html Tag . TH , Check ( body ) ) ; ( style Class != null ) htmltree . add Style ( style Class ) ; htmltree . add Attr ( Html Attr . SCOPE , null Check ( scope ) ) ; return htmltree ; }<CODESPLIT>Generates a TH tag with style class and scope attributes and some content .
private void obtain Divider Margin ( int theme Id ) { Typed Array typed Array get Context ( ) . get Theme ( ) . obtain Styled Attributes ( theme Id , int { R . . material Dialog Divider Margin } ) ; set Divider Margin ( typed Array . get Dimension Pixel Size ( 0 , 0 ) ) ; }<CODESPLIT>Obtains the left and right margin of dividers from a specific theme .
public void set Default Button ( S Button button ) { this get Screen Field View ( ) set Default Button ( button ? null : button . get Screen Field View ( ) ) ; }<CODESPLIT>Set the default button for this basepanel .
public Key select ( int k ) { ( k < 0 k >= size ( root ) ) Argument ( ) ; Red Black Tree Node < Key , Value > x = select ( root , k ) ; return x . get Key ( ) ; }<CODESPLIT>Return the kth smallest key in the symbol table .
public void add ( Request Handler request ) { write ( ) ( ) ; try { new Session Requests . add ( request ) ; } finally { lock . write Lock ( ) . unlock ( ) ; } }<CODESPLIT>Adds a request handler to this queue .
public static T > T with Print Writer ( Output Stream stream , @ Closure Params ( value = Type . class , = java . . Print Writer ) Closure T > closure ) throws IO Exception { return with Writer ( new Print Writer ( stream ) , closure ) ; }<CODESPLIT>Create a new PrintWriter for this OutputStream . The writer is passed to the closure and will be closed before this method returns .
public void add Route ( String url Pattern , Class < extends Actor > actor Class ) throws Route Mapped { add Route ( Route ( url Pattern , true ) , actor Class ) ; }<CODESPLIT>Add a URL pattern to the routing table .
public synchronized void send Queued Events ( Keen , Keen ) { ( ! is Active ) { handle Inactive ( ) ; return ; } ( == default == ) { handle Failure ( , State ( No specified , but no default ) ) ; return ; } ( ! is Network Connected ( ) ) { Keen Logging . log ( Not sending events because is no network connection . Events will retried ` send Queued Events ` is called ." ) ; handle Failure ( callback , new Exception ( " Network not connected ." ) ) ; return ; } Keen Project use Project = ( project == null ? default Project : project ) ; try { String project Id = use Project . get Project Id ( ) ; Map < String , List < Object > > event Handles = event Store . get Handles ( project Id ) ; Map < String , List < Map < String , Object > > > events = build Event Map ( project Id , event Handles ) ; String response = publish All ( use Project , events ) ; if ( response != null ) { try { handle Add Events Response ( event Handles , response ) ; } catch ( Exception e ) { Keen Logging . log ( " Error handling response to batch publish : " + e . get Message ( ) ) ; } } handle Success ( callback ) ; } catch ( Exception e ) { handle Failure ( callback , e ) ; } }<CODESPLIT>Synchronously sends all queued events for the given project . This method will immediately publish the events to the Keen server in the current thread .
public int get Queued Connections ( ) { return get Thread ( ) == ( ( get Thread ( ) . get Queue ( ) Array Blocking Queue ) ? ( ( Array Blocking Queue ) get Thread Pool ( ) . get Queue ( ) ) . size ( ) + ( ( Array Blocking Queue ) get Thread Pool ( ) . get Queue ( ) ) . remaining Capacity ( ) : - 1 ) ; }<CODESPLIT>this should only be used as an estimate
final public Auxiliary Root ( boolean requires Foot ) throws Parse { Simple Node 000 = Simple Node ( JJTTREEROOT ) ; boolean 000 = ; jjtree . open Node Scope ( 000 ) ; t ; { t = Node ( ) ; jjtree . close Node Scope ( 000 , ) ; { if ( true ) return new Auxiliary Tree ( t , requires Foot ) ; } } catch ( Throwable jjte 000 ) { if ( jjtc 000 ) { jjtree . clear Node Scope ( jjtn 000 ) ; } else { jjtree . pop Node ( ) ; } if ( jjte 000 instanceof Runtime Exception ) { { if ( true ) throw ( Runtime Exception ) jjte 000 ; } } if ( jjte 000 instanceof Parse Exception ) { { if ( true ) throw ( Parse Exception ) jjte 000 ; } } { if ( true ) throw ( Error ) jjte 000 ; } } finally { if ( jjtc 000 ) { jjtree . close Node Scope ( jjtn 000 , true ) ; } } throw new Error ( " Missing return statement in function " ) ; }<CODESPLIT>the argument says whether there must be a foot node on the aux tree .
I Directory add To Parent ( [ ] , I Directory I , I , boolean propagate Mod Time , int child Index ) { I Directory Parent = ; write ( ) ; { { Parent = . add To Parent ( , , I Node , false , propagate Mod Time , child Index ) ; cache Name ( new Node ) ; } catch ( File Not Found Exception e ) { return null ; } if ( new Parent == null ) return null ; if ( ! new Node . is Directory ( ) ) { I Node File new F = ( I Node File ) new Node ; Block Info [ ] blocks = new F . get Blocks ( ) ; for ( int i = 0 ; i < blocks . length ; i ++ ) { new F . set Block ( i , get FS Namesystem ( ) . blocks Map . add I Node For Loading ( blocks [ i ] , new F ) ) ; } } } finally { write Unlock ( ) ; } return new Parent ; }<CODESPLIT>Add node to parent node when loading the image .
public void set Model ( Mind Map model , boolean notify Model Change ) { this . ( ) ; { ( this . Under != ) { . safe Blocking ( Runnable ( ) { public void run ( ) { end ( false ) ; } } ) ; } List int [ ] selected Paths = Array List int [ ] ( ) ; for ( Topic this . selected Topics ) { selected Paths . add ( . get Position Path ( ) ) ; } this . selected Topics . clear ( ) ; Mind Map Model = this . model ; this . model = assert Not Null ( Model must not " , model ) ; for ( final Panel Aware Plugin p : Mind Map Plugin Registry . get Instance ( ) . find For ( Panel Aware Plugin . class ) ) { p . on Panel Model Change ( this , old Model , this . model ) ; } do Layout ( ) ; revalidate ( ) ; boolean selection Changed = false ; for ( final int [ ] pos Path : selected Paths ) { final Topic topic = this . model . find For Position Path ( pos Path ) ; if ( topic == null ) { selection Changed = true ; } else if ( ! Mind Map Utils . is Hidden ( topic ) ) { this . selected Topics . add ( topic ) ; } } if ( selection Changed ) { fire Notification Selection Changed ( ) ; repaint ( ) ; finally { this . unlock ( ) ; if ( notify Model Change Listeners ) { fire Notification Mind Map Changed ( true ) ;<CODESPLIT>Set model for the panel allows to notify listeners optionally .
public Operation Future Balancer delete ( Balancer load Balancer ) { Balancer Metadata load Balancer Metadata find By ( load Balancer ) ; load Balancer Client . delete ( load Balancer Metadata . get Data Center Id ( ) , load Balancer Metadata . get Id ( ) ) ; new Operation Future < > ( load Balancer , new No Waiting Job Future ( ) ) ; }<CODESPLIT>Delete load balancer
public Get Response get ( Get Request request ) { check Not Null ( request , request should not ." ) ; check String Not Empty ( request . get Id ( ) , request snapshot Id should no ." ) ; Internal Request internal Request = this . create Request ( request , Http Method Name . GET , SNAPSHOT _ PREFIX , request . get Snapshot Id ( ) ) ; return invoke Http Client ( internal Request , Get Snapshot Response . class ) ; }<CODESPLIT>Getting the detail information of specified snapshot .
void Loggers ( ) { { Bugsnag Appender . add Excluded Pattern ( . apache . catalina . . Container Base ." "\\[ Tomcat .*\\][.]\\[.*\\][.]\\[/.*\\][.]\\[.*\\]" ) ; Bugsnag Appender . add Excluded Pattern ( org . eclipse . jetty . server . Http Channel " ) ; Bugsnag Appender . add Excluded Logger Pattern ( " io . undertow . request " ) ; } catch ( No Class Def Found Error ignored ) { } }<CODESPLIT>If using Logback stop any configured appender from creating Bugsnag reports for Spring log messages as they effectively duplicate error reports for unhandled exceptions .
public void subtract ( R 1 relationships ) { ( == base ) { Error ( ) ; } for ( int = 0 ; base . ; ) { if ( null == base [ i ] ) { continue ; } final I Concept Set set = data [ i ] = new Sparse Concept Hash Set ( ) ; set . add All ( base [ i ] ) ; if ( null != relationships . data [ i ] ) { set . remove All ( relationships . data [ i ] ) ; } } }<CODESPLIT>This should only ever be called when the relationships wrap an initial state and no other methods have been called .
private static E E get ( Class E type , String name , Reflections reflections ) { E = ; Class E = reflections . get Sub Types Of ( type ) ; Class E = ( ) ; for ( Class ? extends E > clazz : found Classes ) { if ( ! Modifier . is Abstract ( clazz . get Modifiers ( ) ) ) { endpoint Classes . add ( clazz ) ; } } Iterator < Class < ? extends E > > iterator = endpoint Classes . iterator ( ) ; while ( iterator . has Next ( ) ) { Class < ? extends E > next = iterator . next ( ) ; if ( String Utils . starts With Ignore Case ( next . get Name ( ) , " com . github . davidcarboni . restolino . routes ." ) ) { iterator . remove ( ) ; } } if ( endpoint Classes . size ( ) != 0 ) { if ( endpoint Classes . size ( ) > 1 ) { log . info ( " Warning : found multiple candidates for {} endpoint : {}" , name , endpoint Classes ) ; } try { result = endpoint Classes . iterator ( ) . next ( ) . new Instance ( ) ; } catch ( Exception e ) { log . info ( " Error : cannot instantiate {} endpoint class {}" , name , endpoint Classes . iterator ( ) . next ( ) ) ; e . print Stack Trace ( ) ; } } return result ; }<CODESPLIT>Locates a single endpoint class .
public void ( AO Stream stream , ) { ( Trace Component . is Tracing ( ) tc . is Entry ( ) ) Sib Tr . ( tc , ) ; String key SIMP . get Remote Get Key ( stream . get Remote ME Uuid ( ) , stream . get Gathering Target Uuid ( ) ) ; Stream sinfo stream Table . get ( key ) ; ( ( sinfo ) sinfo . stream Id . equals ( stream . stream Id ) ) { synchronized ( sinfo ) { sinfo . item ( AO ) ; } } { SI Error SI Error Exception ( nls . get Formatted Message ( " INTERNAL _ MESSAGING _ ERROR _ CWSIP 0001 " , new Object [ ] { " com . ibm . ws . sib . processor . impl . Anycast Output Handler " , " 1 : 2858 : 1 . 89 . 4 . 1 " } , null ) ) ; FFDC Filter . process Exception ( e , " com . ibm . ws . sib . processor . impl . Anycast Output Handler . written Started Flush " , " 1 : 2865 : 1 . 89 . 4 . 1 " , this ) ; Sib Tr . exception ( tc , e ) ; Sib Tr . error ( tc , " INTERNAL _ MESSAGING _ ERROR _ CWSIP 0001 " , new Object [ ] { " com . ibm . ws . sib . processor . impl . Anycast Output Handler " , " 1 : 2872 : 1 . 89 . 4 . 1 " } ) ; if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) Sib Tr . exit ( tc , " written Started Flush " , e ) ; throw e ; } if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) Sib Tr . exit ( tc , " written Started Flush " ) ; }<CODESPLIT>Callback when the Item that records that flush has been started has been committed to persistent storage
public static List get Subreports ( Layout report Layout ) { List subreports Array List ( ) ; Band band report Layout . get Band ( ) ; ( int i = 0 , rows = band . get Row Count ( ) ; i < rows ; i ++ ) { List < Band Element > list = band . get Row ( i ) ; for ( int j = 0 , size = list . size ( ) ; j < size ; j ++ ) { Band Element be = list . get ( j ) ; if ( be instanceof Report Band Element ) { subreports . add ( ( ( Report Band Element ) be ) . get Report ( ) ) ; } } } return subreports ; }<CODESPLIT>Get detail band subreports for a report layout
public Api App List get Api Apps ( ) throws Hello Sign { Api App List ( http Client . with Auth ( ) . get ( _ + API _ APP _ LIST _ URI ) . as Json ( ) ) ; }<CODESPLIT>Retrieves a paged list of API apps for the authenticated account .
public void detach ( Object p Vm ) { { ( p Vm != ) { Class clazz = p Vm . get Class ( ) ; Method method = clazz . get Method ( detach ) ; method . set Accessible ( ) ; method . invoke ( p Vm ) ; } } ( Invocation Target ) { Processing ( Error while detaching " , e , options ) ; } catch ( No Such Method Exception e ) { throw new Processing Exception ( " Error while detaching " , e , options ) ; } catch ( Illegal Access Exception e ) { throw new Processing Exception ( " Error while detaching " , e , options ) ; } }<CODESPLIT>Detach from the virtual machine
public Object Graph Classes ( Class < > ... classes ) { for ( Class < > c : classes ) { ( c == ) { new Null Pointer Exception ( " Null class not allowed " ) ; } excluded Classes . add ( c ) ; } return this ; }<CODESPLIT>Exclude any object that extends from these classes .
public void set Sampling ( double , double , int ) { this . sample Min = ; this . sample = max ; this . num Samples = total ; this . scores = new double [ num Samples ] ; }<CODESPLIT>Specifies how focal lengths are sampled on a log scale . Remember 1 . 0 = nominal length
private void calc Product At Var ( int v , Var Tensor prod , int excl , int excl 2 ) { for ( int nb = 0 ; nb . Nbs T ( v ) ; nb ) { ( nb == excl nb == excl 2 ) { ; } Var Tensor nb Msg = msgs [ bg . opposing T 1 ( v , nb ) ] ; prod . elem Multiply ( nb Msg ) ; } }<CODESPLIT>Computes the product of all messages being sent to a node optionally excluding messages sent from another node or two .
protected State find Last State ( Q Path item Path ) { for ( int = item Add . size ( ) ; >= 0 ; -- ) { Item State istate = item Add States . get ( i ) ; if ( istate . get Data ( ) . get Q Path ( ) . equals ( item Path ) ) return istate ; } return null ; }<CODESPLIT>Find last ItemState .
public void add ( String dispatcher Id , Abs Actor dispatcher ) { synchronized ( dispatchers ) { ( dispatchers contains ( dispatcher Id ) ) { return ; } dispatchers . put ( dispatcher Id , dispatcher ) ; } }<CODESPLIT>Registering custom dispatcher
private void sgd Train ( Classification Data , Matrix Of Vecs , Vec , int sign mul , boolean parallel ) { Int List Int List ( . ( ) ) ; List . add ( , 0 , . ( ) , ) ; double lambda adj lambda / ( . ( ) epochs ) ; int owned int ; int assigned positive 0 ; int int . ( ) ; . fill ( , ) ; Vec dots = new Dense Vector ( W . rows ( ) ) ; long t = 0 ; for ( int epoch = 0 ; epoch < epochs ; epoch ++ ) { Collections . shuffle ( order ) ; for ( int i : order ) { t ++ ; double eta = 1 / ( lambda _ adj * t ) ; Vec x _ i = D . get Data Point ( i ) . get Numerical Values ( ) ; int y _ i = ( D . get Data Point Category ( i ) * 2 - 1 ) * sign _ mul ; b . copy To ( dots ) ; W . multiply ( x _ i , 1 . 0 , dots ) ; if ( y _ i == - 1 ) { for ( int k = 0 ; k < K ; k ++ ) if ( dots . get ( k ) > - 1 ) { W . get Row View ( k ) . mutable Subtract ( eta , x _ i ) ; b . increment ( k , - eta ) ; } } else { int k _ true _ max = 0 ; for ( int k = 1 ; k < dots . length ( ) ; k ++ ) if ( dots . get ( k ) > dots . get ( k _ true _ max ) ) k _ true _ max = k ; if ( dots . get ( k _ true _ max ) < 1 ) { int z = ASSIGN ( dots , i , k _ true _ max , owned , assignments , assigned _ positive _ instances ) ; W . get Row View ( z ) . mutable Add ( eta , x _ i ) ; b . increment ( z , eta ) ; if ( assignments [ i ] < 0 ) assigned _ positive _ instances ++ ; else owned [ assignments [ i ] ] -- ; owned [ z ] ++ ; } } W . mutable Multiply ( 1 - 1 . 0 / t ) ; b . mutable Multiply ( 1 - 1 . 0 / t ) ; } } }<CODESPLIT>Training procedure that can be applied to each version of the CPM sub - problem .
public static appfwfieldtype [ get ( nitro _ ) throws { appfwfieldtype = new appfwfieldtype ( ) ; appfwfieldtype [ ] response = ( appfwfieldtype [ ] ) obj . get _ resources ( service ) ; return response ; }<CODESPLIT>Use this API to fetch all the appfwfieldtype resources that are configured on netscaler .
public Future Channel create ( Promise Channel Ready Promise ) { long delay = this . current Delay . get ( ) ; Ready Promise . add Listener ( Generic Future Listener Future Channel ( ) { public void operation Complete ( Future Channel ) { long Delay = . is ( ) 0 . ( . ( delay 2 , _ CONNECT _ DELAY _ SECONDS ) , _ CONNECT _ DELAY _ SECONDS ) ; Apns Channel Factory . this . current Delay . compare And ( delay , Delay ) ; } } ) ; this . bootstrap Template . ( ) . group ( ) . schedule ( Runnable ( ) { public void run ( ) { bootstrap = Apns Channel Factory . this . bootstrap Template . clone ( ) . Factory ( new Augmenting Reflective Channel Factory < > ( Client Channel Class Util . get Socket Channel Class ( Apns Channel Factory . this . bootstrap Template . config ( ) . group ( ) ) , CHANNEL _ READY _ PROMISE _ ATTRIBUTE _ KEY , channel Ready Promise ) ) ; final Channel Future connect Future = bootstrap . connect ( ) ; connect Future . add Listener ( new Generic Future Listener < Channel Future > ( ) { public void operation Complete ( final Channel Future future ) { if ( ! future . is Success ( ) ) { try Failure And Log Rejected Cause ( channel Ready Promise , future . cause ( ) ) ; } } } ) ; connect Future . channel ( ) . close Future ( ) . add Listener ( new Generic Future Listener < Channel Future > ( ) { public void operation Complete ( final Channel Future future ) { channel Ready Promise . try Failure ( new Illegal State Exception ( " Channel closed before HTTP / 2 preface completed ." ) ) ; } } ) ; } } , delay , Time Unit . SECONDS ) ; return channel Ready Promise ; }<CODESPLIT>Creates and connects a new channel . The initial connection attempt may be delayed to accommodate exponential back - off requirements .
public static List String > load ( String option File Name ) { List String > = Array List String > ( ) ; File option File = File ( option File Name ) ; String Writer string Writer = String Writer ( ) ; { Input Stream Stream = File Input Stream ( option File ) ; . copy ( Stream , string Writer ) ; } ( File Not Found ) { . . ( Error reading file : " + e . get Message ( ) ) ; System . exit ( 1 ) ; } catch ( IO Exception e ) { System . err . println ( " Error reading options file : " + e . get Message ( ) ) ; System . exit ( 1 ) ; } String string = string Writer . to String ( ) ; String Tokenizer string Tokenizer = new String Tokenizer ( string ) ; while ( string Tokenizer . has More Tokens ( ) ) { args . add ( string Tokenizer . next Token ( ) ) ; } return args ; }<CODESPLIT>Load options from a file
public void run ( ) { { this . current = this . Queue . take ( ) ; Context context = Context ( ) ; { this . execution Context Manager . initialize ( context ) ; } ( Context ) { throw new Runtime Exception ( " Failed to initialize Job " + this . current Job + " execution context " , e ) ; } this . current Job . run ( ) ; } catch ( Interrupted Exception e ) { } finally { this . execution . remove Context ( ) ; } }<CODESPLIT>Execute one job .
public Response ( String name , Object model ) { get Locals ( ) put ( name , model ) ; this ; }<CODESPLIT>Binds an object to the response .
public [ ] get Byte Array ( Integer ) { [ ] = ; if ( offset != null ) { result = m _ map . get ( offset ) ; } return ( result ) ; }<CODESPLIT>This method retrieves a byte array containing the data at the given offset in the block . If no data is found at the given offset this method returns null .
public Object [ ] get Methods ( ) { Class Class = . get Class ( object Under Inspection ) ; List Methods = Class . get Methods ( ) ; Object [ ] = Object [ Methods . size ( ) ] ; int i = 0 ; for ( Iterator iter = meta Methods . iterator ( ) ; iter . has Next ( ) ; i ++ ) { Meta Method meta Method = ( Meta Method ) iter . next ( ) ; result [ i ] = method Info ( meta Method ) ; } return result ; }<CODESPLIT>Get info about instance and class Methods that are dynamically added through Groovy .
static long [ ] parse ( String pollers ) { String [ ] periods = pollers . split ( ",\\ *" ) ; long [ ] = long [ periods . ] ; boolean = false ; = Factory . get ( Pollers . class ) ; for ( int = 0 ; periods . ; ) { String period = periods [ ] ; { [ ] = Long . parse Long ( period ) ; ( [ ] <= 0 ) { logger . error ( " Invalid polling interval : {} must be positive ." , period ) ; errors = true ; } } catch ( Number Format Exception e ) { logger . error ( " Cannot parse '{}' as a long : {}" , period , e . get Message ( ) ) ; errors = true ; } } if ( errors || periods . length == 0 ) { logger . info ( " Using a default configuration for poller intervals : {}" , join ( DEFAULT _ PERIODS ) ) ; return DEFAULT _ PERIODS ; } else { return result ; } }<CODESPLIT>Parse the content of the system property that describes the polling intervals and in case of errors use the default of one poller running every minute .
public void set ( String key , String value ) { . Non Null ( value ) ; int 0 ; boolean has ; ( Keys . size ( ) ; >= 0 ; i -- ) { String old Key = _ footer Keys . get ( i ) ; if ( old Key . equals Ignore Case ( key ) ) { if ( has Footer ) { _ footer Keys . remove ( i ) ; _ footer Values . remove ( i ) ; } else { has Footer = true ; _ footer Values . set ( i , value ) ; } } } if ( ! has Footer ) { _ footer Keys . add ( key ) ; _ footer Values . add ( value ) ; } }<CODESPLIT>Sets a footer replacing an already - existing footer
public void add Attribute ( String name , String value ) { ( _ Context . _ start Tag ) { String patched Name = patch Name ( name ) ; String Name = get Local Name ( patched Name ) ; final String uri = get Namespace URI ( patched Name , false ) ; add Attribute Always ( uri , local Name , patched Name , " CDATA " , value , false ) ; } }<CODESPLIT>Adds the given attribute to the set of collected attributes but only if there is a currently open element .
public Mime Message create Mime Message ( Session session ) throws { ( is Empty ( Part ) is Empty ( text Part ) ) { Argument ( Missing content ) ; } final Mime Message msg = new Mime Message ( session ) ; msg . set Subject ( subject ) ; msg . set From ( new Internet Address ( from ) ) ; msg . set Content ( create Multi Part ( ) ) ; msg . set Recipients ( Message . Recipient Type . TO , Internet Address . parse ( recipients , false ) ) ; return msg ; }<CODESPLIT>Creates a MimeMessage containing given Multipart . Subject sender and content and session will be set .
public static Forward Curve Interpolation create Forward Curve From Monte Carlo Libor ( String name , LIBOR Monte Carlo Simulation , double start Time ) Calculation { get Time ( start Time ) ; Array Random Variable libors At Time Array ( ) ; Libor get Libor Period Discretization ( ) get Time Nearest Or ( start Time ) ; double Libor Time get Libor Period Discretization ( ) . get Time ( first Libor Index ) ; if ( first Libor Time > start Time ) { libors At Time Index . add ( model . get LIBOR ( start Time , start Time , first Libor Time ) ) ; } double [ ] times = new double [ first Libor Time == start Time ? ( model . get Number Of Libors ( ) - first Libor Index ) : ( model . get Number Of Libors ( ) - first Libor Index + 1 ) ] ; times [ 0 ] = 0 ; int index Offset = first Libor Time == start Time ? 0 : 1 ; for ( int i = first Libor Index ; i < model . get Number Of Libors ( ) ; i ++ ) { libors At Time Index . add ( model . get LIBOR ( time Index , i ) ) ; times [ i - first Libor Index + index Offset ] = model . get Libor Period Discretization ( ) . get Time ( i ) - start Time ; } Random Variable [ ] libors = libors At Time Index . to Array ( new Random Variable [ libors At Time Index . size ( ) ] ) ; return Forward Curve Interpolation . create Forward Curve From Forwards ( name , times , libors , model . get Libor Period Discretization ( ) . get Time Step ( first Libor Index ) ) ; }<CODESPLIT>Create a forward curve from forwards given by a LIBORMonteCarloModel .
public Service Void delete Word ( Delete Word delete Word ) { Validator . not Null ( delete Word , delete Word cannot ) ; String [ ] path Segments = { v / customizations , } ; String [ ] path Parameters = { delete Word . customization Id ( ) , delete Word . ( ) } ; Request builder = Request Builder . delete ( Request Builder . construct Http Url ( get End Point ( ) , path Segments , path Parameters ) ) ; Map < String , String > sdk Headers = Sdk Common . get Sdk Headers ( " text _ to _ speech " , " v 1 " , " delete Word " ) ; for ( Entry < String , String > header : sdk Headers . entry Set ( ) ) { builder . header ( header . get Key ( ) , header . get Value ( ) ) ; } return create Service Call ( builder . build ( ) , Response Converter Utils . get Void ( ) ) ; }<CODESPLIT>Delete a custom word .
private boolean Move ( float , float ) { float newx player ; float newy player ; if ( blocked ( newx , newy ) ) { if ( blocked ( newx , player Y ) ) { if ( blocked ( player X , newy ) ) { return false ; } else { player Y = newy ; return true ; } } else { player X = newx ; return true ; } } else { player X = newx ; player Y = newy ; return true ; } }<CODESPLIT>Try to move in the direction specified . If it s blocked try sliding . If that doesn t work just don t bother
public void recover ( ) { { this . . clear ( ) ; this . data Logger . prepare For Read ( ) ; this . data Logger . recover ( this ) ; } ( Exception ) { Delegated Runtime Exception ( e ) ; } }<CODESPLIT>recovers the dataRecorder all messages are removed and all the messsages of the logger are recoverd
public void clear Sources ( ) { synchronized ( Audio Sources ) { ( GVR Audio Source source Audio Sources ) { source set Listener ( null ) ; } m Audio Sources . clear ( ) ; } }<CODESPLIT>Remove all of the audio sources from the audio manager . This will stop all sound from playing .
public static V Number Vector Number Vector . Factory V guess Factory ( Type V in ) { Number Vector . Factory V factory = ; ( in Vector Type ) { factory = ( Number Vector . Factory V > ) ( ( Vector Type Information < V > ) in ) . get Factory ( ) ; } if ( factory == null ) { try { Field f = in . get Restriction Class ( ) . get Field ( " FACTORY " ) ; factory = ( Number Vector . Factory < V > ) f . get ( null ) ; } catch ( Exception e ) { Logging Util . warning ( " Cannot determine factory for type " + in . get Restriction Class ( ) , e ) ; } } return factory ; }<CODESPLIT>Try to guess the appropriate factory .
public void balance ( ) { ( ! . ( ) ) . ( ) ; ( ! Save . ( ) ) Save . ( ) ; ( paths == ) paths = Maps . Map ( ) ; ( Root Dirs == ) Root Dirs = . Array List ( ) ; for ( int = 0 ; < num Labels ; i ++ ) { paths . put ( i , new Array List < File > ( ) ) ; label Root Dirs . add ( new File ( root Dir , String . value Of ( i ) ) ) ; } while ( data Set Iterator . has Next ( ) ) { Data Set next = data Set Iterator . next ( ) ; if ( mini Batch Size < 0 ) mini Batch Size = next . num Examples ( ) ; for ( int i = 0 ; i < next . num Examples ( ) ; i ++ ) { Data Set curr Example = next . get ( i ) ; if ( ! label Root Dirs . get ( curr Example . outcome ( ) ) . exists ( ) ) label Root Dirs . get ( curr Example . outcome ( ) ) . mkdirs ( ) ; File example = new File ( label Root Dirs . get ( curr Example . outcome ( ) ) , String . value Of ( paths . get ( curr Example . outcome ( ) ) . size ( ) ) ) ; curr Example . save ( example ) ; paths . get ( curr Example . outcome ( ) ) . add ( example ) ; } } int nums Saved = 0 ; while ( ! paths . is Empty ( ) ) { List < Data Set > mini Batch = new Array List < > ( ) ; while ( mini Batch . size ( ) < mini Batch Size && ! paths . is Empty ( ) ) { for ( int i = 0 ; i < num Labels ; i ++ ) { if ( paths . get ( i ) != null && ! paths . get ( i ) . is Empty ( ) ) { Data Set d = new Data Set ( ) ; d . load ( paths . get ( i ) . remove ( 0 ) ) ; mini Batch . add ( d ) ; } else paths . remove ( i ) ; } } if ( ! root Save Dir . exists ( ) ) root Save Dir . mkdirs ( ) ; if ( ! mini Batch . is Empty ( ) ) { Data Set merge = Data Set . merge ( mini Batch ) ; if ( data Normalization != null ) data Normalization . transform ( merge ) ; } } }<CODESPLIT>Generate a balanced dataset minibatch fileset .
private static boolean isunixtimeleap ( double unix Time ) { double gps Time unix Time 315964800 ; gps Time += countleaps ( gps Time , ) 1 ; return isleap ( gps Time ) ; }<CODESPLIT>Test to see if a unixtime second is a leap second
public static void set Sun XML ( Marshaller a Marshaller , String XML ) { final String s Property Name = SUN _ XML _ HEADERS ; _ set Property ( a Marshaller , s Property Name , s XML Headers ) ; }<CODESPLIT>Set the Sun specific XML header string .
private void send Keep Alive Bridge ( int Id , String bridge Id , String , Stats Http 2 Client http Client ) { long TS . current Time ( ) ; Bridge Keep Alive message Bridge Keep Alive ( bridge Id , TS ) ; String request String gson . to Json ( message ) ; http Client . send Bridge Alive ( keep Alive Event Url , , request String , Stats Http 2 Response Listener ( ) { public void on Response ( Response ) { int . code ( ) ; Bridge Keep Alive Response keep Alive Response ; { String String . body ( ) . ( ) ; keep Alive Response gson . from Json ( String , Bridge Keep Alive Response . class ) ; } ( ) { . print Trace ( ) ; throw new Runtime Exception ( e ) ; } catch ( Json Syntax Exception e ) { logger . error ( " Json Syntax Exception " + e . get Message ( ) , e ) ; e . print Stack Trace ( ) ; throw new Runtime Exception ( e ) ; } http Client . set Disrupted ( false ) ; if ( response Status == Call Stats Response Status . RESPONSE _ STATUS _ SUCCESS ) { keep Alive Status Listener . on Success ( ) ; } else if ( response Status == Call Stats Response Status . INVALID _ AUTHENTICATION _ TOKEN ) { stop Keep Alive Sender ( ) ; keep Alive Status Listener . on Keep Alive Error ( Call Stats Errors . AUTH _ ERROR , keep Alive Response . get Msg ( ) ) ; } else { http Client . set Disrupted ( true ) ; } } public void on Failure ( Exception e ) { logger . info ( " Response exception " + e . to String ( ) ) ; http Client . set Disrupted ( true ) ; } } ) ; }<CODESPLIT>Send keep alive bridge message .
public Streaming Output get Resource ( String Name , long Id , Map Query Parameter , String query ) throws Jax { Streaming Output Output = Streaming Output ( ) { public void write ( Output Stream output ) throws , Jax { String revision = query . get ( Query Parameter . REVISION ) ; final String wrap = query Params . get ( Query Parameter . WRAP ) ; final String do Node Id = query Params . get ( Query Parameter . OUTPUT ) ; final boolean wrap Result = ( wrap == null ) ? false : wrap . equals Ignore Case ( YESSTRING ) ; final boolean nodeid = ( do Node Id == null ) ? false : do Node Id . equals Ignore Case ( YESSTRING ) ; final Long rev = revision == null ? null : Long . value Of ( revision ) ; serialize ( resource Name , node Id , rev , nodeid , output , wrap Result ) ; } } ; return s Output ; }<CODESPLIT>This method is responsible to deliver the whole XML resource addressed by a unique node id .
public static Entity [ ] create Entities ( Server Connection , Object Reference [ ] mors ) { ( mors == ) { return Entity [ 0 ] ; } Entity [ ] mes = Managed Entity [ mors . length ] ; for ( int i = 0 ; i < mors . length ; i ++ ) { mes [ i ] = create Exact Managed Entity ( sc , mors [ i ] ) ; } return mes ; }<CODESPLIT>Given a ServerConnection and an array of MORs return an array of MEs
public static Function String , String create String Template Source ( Cms Bean , Supplier Cms Xml Content content Supplier ) { key -> { String = ; if ( formatter != null ) { result = formatter . get Attributes ( ) . get ( key ) ; } if ( result == null ) { Cms Xml Content content = content Supplier . get ( ) ; if ( content != null ) { result = content . get Handler ( ) . get Parameter ( key ) ; } } return result ; } ; }<CODESPLIT>Helper method to create a string template source for a given formatter and content .
private static Byte Buffer create Read Write Message ( Code , int logical Block , short Length ) { Byte Buffer cdb = Byte Buffer . allocate ( _ CDB _ ) ; cdb . put ( Code ) ; cdb . position ( LOGICAL _ BLOCK _ ADDRESS _ OFFSET ) ; cdb . put Int ( logical Block Address ) ; cdb . position ( TRANSFER _ LENGTH _ OFFSET ) ; cdb . put Short ( transfer Length ) ; cdb . rewind ( ) ; return cdb ; }<CODESPLIT>Creates the Command Descriptor Block for a given Operation Message .
public long read ( Byte Buffer [ dsts , int , int ) throws { long rc = fill App Read ( ) ; ( rc <= 0 ) { return rc ; } return Byte Buffers . move ( app Read , dsts , offset , length ) ; }<CODESPLIT>Reads ByteBuffer from peer . Starts handshaking if needed .
public static void set Int ( Memory segments , int , int value ) { ( First ( segments , offset , 4 ) ) { segments [ 0 ] . put Int ( offset , value ) ; } else { set Int Multi Segments ( segments , offset , value ) ; } }<CODESPLIT>set int from segments .
public User get User ( String username ) { { return ( . of Nullable ( get User ( username ) ) ) ; } catch ( Git Lab Api Exception glae ) { return ( Git Lab Api . create Optional From Exception ( glae ) ) ; } }<CODESPLIT>Lookup a user by username and return an Optional instance .
protected void register Limiter Component ( ) { String Prop Gateway Config Limiter Component get ( ) ; set Config ( Prop , ES Rate Limiter Component . class . get Name ( ) ) ; set Config Property ( component Prop Name + ". client . type " , " jest " ) ; set Config Property ( component Prop Name + ". client . protocol " , "${ apiman . es . protocol }" ) ; set Config Property ( component Prop Name + ". client . host " , "${ apiman . es . host }" ) ; set Config Property ( component Prop Name + ". client . port " , "${ apiman . es . port }" ) ; set Config Property ( component Prop Name + ". client . username " , "${ apiman . es . username }" ) ; set Config Property ( component Prop Name + ". client . password " , "${ apiman . es . password }" ) ; }<CODESPLIT>The rate limiter component .
public Point d get From Point ( int Point ) { int = 0 ; Point d point = Point d ( 0 , 0 , 0 ) ; ( int = 0 ; [ 0 ] [ 0 ] . ; ++ ) { for ( int y = 0 ; y < grid [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < grid . length ; x ++ ) { if ( dim Counter == grid Point ) { point . x = minx + lattice Constant * x ; point . y = miny + lattice Constant * y ; point . z = minz + lattice Constant * z ; return point ; } dim Counter ++ ; } } } return point ; }<CODESPLIT>Method calculates coordinates from a given grid array position .
public void set Color ( Color COLOR ) { ( == ) { _ color = COLOR ; } else { color . set ( COLOR ) ; } }<CODESPLIT>Defines the color that will be used to colorize the section in a clock .
public void release Event ( Event Id event Id ) throws { Lockable event Wrapper = Buffer . get Event ( event Id ) ; ( event Wrapper ) { if ( event Wrapper . release ( ) ) { shared Buffer . remove Event ( event Id ) ; } else { shared Buffer . upsert Event ( event Id , event Wrapper ) ; } } }<CODESPLIT>Decreases the reference counter for the given event so that it can be removed once the reference counter reaches 0 .
public String to Sql ( boolean show Parameters ) { String ; ( for Paginator ) { = . get Dialect ( ) . Select ( , , Query , Bys , limit , ) ; } { = Query != ? full Query : meta Model . get Dialect ( ) . form Select ( meta Model . get Table Name ( ) , null , sub Query , order Bys , limit , offset ) ; } if ( show Parameters ) { String Builder sb = new String Builder ( sql ) . append ( ", with parameters : " ) ; join ( sb , params , ", " ) ; sql = sb . to String ( ) ; } return sql ; }<CODESPLIT>Use to see what SQL will be sent to the database .
private Source get Source From ( Stylesheet Handler ) throws Transformer { Source = ; Transformer Factory processor = . get Stylesheet Processor ( ) ; URI uriresolver = processor . get URI Resolver ( ) ; if ( uriresolver != null ) { String href = get Href ( ) ; String base = handler . get Base Identifier ( ) ; s = uriresolver . resolve ( href , base ) ; } return s ; }<CODESPLIT>Get the Source object for the included or imported stylesheet module obtained from the user s URIResolver if there is no user provided URIResolver null is returned .
public String get Title ( ) { ( Journal _ Type . ( ( Journal _ Type ) Type ) . cas Feat _ == ) Type . . throw Feat Missing ( " title " , " de . julielab . jules . types . Journal " ) ; return jcas Type . ll _ cas . ll _ get String Value ( addr , ( ( Journal _ Type ) jcas Type ) . cas Feat Code _ title ) ; }<CODESPLIT>getter for title - gets Full journal title C
public static of ( Object o ) { ( o != o instanceof Val ) { return Cast . as ( o ) ; } return new Val ( o ) ; }<CODESPLIT>Convenience method for creating a Convertible Object
protected void add Context Terms ( Sparse Double Vector meaning , Queue String , int distance ) { for ( String term ) { ( ! term . equals ( Iterator Factory . EMPTY _ TOKEN ) ) { int dimension = basis . get ( term ) ; ( dimension == 1 ) continue ; meaning . set ( dimension , weighting . weight ( distance , window Size ) ) ; ++ distance ; } } }<CODESPLIT>Adds a feature for each word in the context that has a valid dimension . Feature are scored based on the context word s distance from the focus word .
public Array List < View > get ( ) { { ( config . command Logging ) { Log . d ( config . command Logging Tag , get ()" ) ; } return view Fetcher . get ( , false ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }<CODESPLIT>Returns an ArrayList of all the View objects located in the focused Activity or Dialog .
private E Weighted Sparse Double Vector get Weight Vector ( Weighted Graph E , int vertex ) { ( keep Weight Vectors ) { Sparse Double Vector weight Vec vertex To Weight Vector get ( vertex ) ; ( weight Vec null ) { synchronized ( this ) { weight Vec = vertex To Weight Vector . get ( vertex ) ; if ( weight Vec == null ) { weight Vec = compute Weight Vector ( g , vertex ) ; vertex To Weight Vector . put ( vertex , weight Vec ) ; } } } return weight Vec ; } else return compute Weight Vector ( g , vertex ) ; }<CODESPLIT>Returns the normalized weight vector for the specified row to be used in edge comparisons . The weight vector is normalized by the number of edges from the row with positive weights and includes a weight for the row to itself which reflects the similarity of the keystone nod .
static int fill ( Row , Type Description schema , Vectorized Row Batch , int selected Fields ) { int To Read . ( ( int ) . count ( ) , . ) ; List < Type Description > field Types = schema . get Children ( ) ; for ( int field Idx = 0 ; field Idx < selected Fields . length ; field Idx ++ ) { int orc Idx = selected Fields [ field Idx ] ; read Field ( rows , field Idx , field Types . get ( orc Idx ) , batch . cols [ orc Idx ] , rows To Read ) ; } return rows To Read ; }<CODESPLIT>Fills an ORC batch into an array of Row .
public List I Cal Property get Properties ( T component ) { Array List < I Cal Property > ( component . get Properties ( ) . values ( ) ) ; }<CODESPLIT>Gets the properties to marshal . Child classes can override this for better control over which properties are marshalled .
public static double compute Tau And Divide ( final int , final int , final double [ ] , final double ) { double tau = 0 ; for ( int = ; Rows ; i ++ ) { double d = u [ i ] /= max ; tau += d * d ; } tau = Math . sqrt ( tau ) ; if ( u [ j ] < 0 ) tau = - tau ; return tau ; }<CODESPLIT>Normalizes elements in u by dividing by max and computes the norm2 of the normalized array u . Adjust the sign of the returned value depending on the size of the first element in u . Normalization is done to avoid overflow .
public Epic get Epic ( String epic Key , Map String , Epic epic Map ) { { String url = feature Settings . get Jira Base Url ( ) ( feature Settings . get Jira Base Url ( ) . With ( "/" ) : "/" ) String . format ( EPIC _ REST _ SUFFIX , epic Key ) ; Response Entity String Entity = make Rest Call ( url ) ; String Body = Entity . get Body ( ) ; JSON Object issue = ( JSON Object ) . parse ( Body ) ; ( issue == ) { return ; } return save Epic ( issue , epic Map , false ) ; } ( Parse Exception pe ) { LOGGER . error ( " Parser exception when parsing teams " , pe ) ; } catch ( Hygieia Exception e ) { LOGGER . error ( " Error in calling JIRA API " , e ) ; } return null ; }<CODESPLIT>Get Epic using Jira API
public Serializable get Layout Constraints ( Component child ) { model = get Component ( ) ; if ( model . layout Constraints != null ) { return model . layout Constraints . get ( child ) ; } return null ; }<CODESPLIT>Retrieves the layout constraints for the given component if they have been set .
public Map String , String get Reverse Map ( ) { Map . Entry String , String = map . ( ) ; Map String , String > r Map = new Hash Map < String , Set < String > > ( entries . size ( ) ) ; for ( Map . Entry < String , Set < String > > me : entries ) { String k = me . get Key ( ) ; Set < String > trans List = me . get Value ( ) ; for ( String trans : trans List ) { Set < String > entry = r Map . get ( trans ) ; if ( entry == null ) { Set < String > to Add = new Linked Hash Set < String > ( 6 ) ; to Add . add ( k ) ; r Map . put ( trans , to Add ) ; } else { entry . add ( k ) ; } } } return r Map ; }<CODESPLIT>Returns a reversed map of the current map .
public Credential set Refresh Token ( String refresh Token ) { . ( ) ; { ( refresh Token != ) { . check Argument ( json Factory != transport != client Authentication != && token Server Encoded Url != null , " Please use the Builder and call set Json Factory , set Transport , set Client Authentication " + " and set Token Server Url / set Token Server Encoded Url " ) ; } this . refresh Token = refresh Token ; } finally { lock . unlock ( ) ; } return this ; }<CODESPLIT>Sets the refresh token .
public void make Current ( EGL egl ) { ( EGL Display == EGL 14 . EGL _ NO _ DISPLAY ) { Log . d ( TAG , " NOTE : make Current / display " ) ; } ( ! EGL 14 . egl Make Current ( EGL Display , egl , egl Surface , m EGL Context ) ) { throw new Runtime Exception ( " egl Make Current failed " ) ; } }<CODESPLIT>Makes our EGL context current using the supplied surface for both draw and read .
public static T T navigate Safe ( T Value , final Object source , final Object ... paths ) { return navigate Or Default ( default Value , source , paths ) ; }<CODESPLIT>Use navigateOrDefault which is a much better name .
public void clear ( Commerce Warehouse commerce Warehouse ) { . remove Result ( Commerce Warehouse . ENTITY CACHE ENABLED , Commerce Warehouse Impl . class , commerce Warehouse Item . get Primary Key ( ) ) ; finder Cache . clear Cache ( FINDER _ CLASS _ NAME _ LIST _ WITH _ PAGINATION ) ; finder Cache . clear Cache ( FINDER _ CLASS _ NAME _ LIST _ WITHOUT _ PAGINATION ) ; clear Unique Finders Cache ( ( Commerce Warehouse Item Model Impl ) commerce Warehouse Item , true ) ; }<CODESPLIT>Clears the cache for the commerce warehouse item .
private void process ( String , String output ) throws MPXJ , { MPP Reader reader = MPP Reader ( ) ; _ = reader . read ( ) ; String Data File Name ; String Name ; int mpp File Type = Number . get Int ( _ . get Properties ( ) . get Mpp File Type ( ) ) ; ( mpp File Type ) { 8 { Name = ; ; } { Name = 19 ; ; } 12 { project Dir Name = " 112 " ; var Data File Name = " Var 2 Data " ; break ; } case 14 : { project Dir Name = " 114 " ; break ; } default : { throw new Illegal Argument Exception ( " Unsupported file type " + mpp File Type ) ; } } File Input Stream is = new File Input Stream ( input ) ; POIFS File System fs = new POIFS File System ( is ) ; is . close ( ) ; Directory Entry root = fs . get Root ( ) ; m _ project Dir = ( Directory Entry ) root . get Entry ( project Dir Name ) ; Map < String , String > replacements = new Hash Map < String , String > ( ) ; for ( Task task : m _ project . get Tasks ( ) ) { map Text ( task . get Name ( ) , replacements ) ; } process Replacements ( ( ( Directory Entry ) m _ project Dir . get Entry ( " T Bknd Task " ) ) , var Data File Name , replacements , true ) ; replacements . clear ( ) ; for ( Resource resource : m _ project . get Resources ( ) ) { map Text ( resource . get Name ( ) , replacements ) ; map Text ( resource . get Initials ( ) , replacements ) ; } process Replacements ( ( Directory Entry ) m _ project Dir . get Entry ( " T Bknd Rsc " ) , var Data File Name , replacements , true ) ; replacements . clear ( ) ; Project Properties properties = m _ project . get Project Properties ( ) ; map Text ( properties . get Project Title ( ) , replacements ) ; process Replacements ( m _ project Dir , " Props " , replacements , true ) ; replacements . clear ( ) ; map Text ( properties . get Project Title ( ) , replacements ) ; map Text ( properties . get Subject ( ) , replacements ) ; map Text ( properties . get Author ( ) , replacements ) ; map Text ( properties . get Keywords ( ) , replacements ) ; map Text ( properties . get Comments ( ) , replacements ) ; process Replacements ( root , "\ 005 Summary Information " , replacements , false ) ; replacements . clear ( ) ; map Text ( properties . get Manager ( ) , replacements ) ; map Text ( properties . get Company ( ) , replacements ) ; map Text ( properties . get Category ( ) , replacements ) ; process Replacements ( root , "\ 005 Document Summary Information " , replacements , false ) ; File Output Stream os = new File Output Stream ( output ) ; fs . write Filesystem ( os ) ; os . flush ( ) ; os . close ( ) ; fs . close ( ) ; }<CODESPLIT>Process an MPP file to make it anonymous .
public void set Rollback Only ( ) { final boolean is Trace On = Trace Component . is Any Tracing ( ) ; ( is Trace On tc . is Entry ( ) ) { Tr . ( tc , set Rollback Only , this ) ; } Transaction Coordinator Coord = get Coord ( ) ; ( Coord != ) { Coord . set Rollback Only ( ) ; } { { tx Service . set Rollback Only ( ) ; } ( e ) { FFDC Filter . process Exception ( e , CLASS _ NAME + ". set Rollback Only " , " 556 " , this ) ; throw new Illegal State Exception ( " No active transaction " ) ; } } if ( is Trace On && tc . is Entry Enabled ( ) ) { Tr . exit ( tc , " set Rollback Only " ) ; } }<CODESPLIT>Marks the current local or global transaction to be rolled back
private static boolean analyse 404 Response ( final String content ) { ( content . contains ( "\" reason \":\" missing \"" ) ) { return ; } . ( Design not found , error is {}" , content ) ; return false ; }<CODESPLIT>Analyses the content of a 404 response to see if it is legible for retry .
private Listenable Future write Blocks To Targets ( Collection DBB . Container output Buffers , int [ serialized ) { . check Argument ( _ table . size ( ) == serialized . ) ; . check Argument ( output Buffers . size ( ) == serialized . ) ; List Listenable Future write = Array List Listenable Future ( output Buffers . size ( ) ) ; Iterator DBB . Container container Iter = output Buffers . iterator ( ) ; int serialized Index = 0 ; for ( Snapshot Table Task task : m _ table Tasks ) { final DBB Pool . BB Container container = container Iter . next ( ) ; final Byte Buffer buf = container . b ( ) ; buf . limit ( serialized [ serialized Index ++ ] + task . m _ target . get Header Size ( ) ) ; buf . position ( 0 ) ; Callable < DBB Pool . BB Container > value For Target = Callables . returning ( container ) ; if ( task . m _ filters != null ) { for ( Snapshot Data Filter filter : task . m _ filters ) { value For Target = filter . filter ( value For Target ) ; } } Listenable Future < ? > write Future = task . m _ target . write ( value For Target , m _ table Id ) ; if ( write Future != null ) { write Futures . add ( write Future ) ; } } return Futures . all As List ( write Futures ) ; }<CODESPLIT>Finalize the output buffers and write them to the corresponding data targets
private boolean is Terminal ( I Atom atom , Map I Atom , Integer atom To Index ) { return [ atom To Index . get ( atom ) ] . == 1 ; }<CODESPLIT>Is the atom terminal having only one connection .
private Handler Async Result Void create Handler ( Json Object message ) { Handler Async Result Void > > ( ) { public void handle ( Async Result < Void > result ) { if ( result . failed ( ) ) { message . reply ( new Json Object ( ) . put String ( " status " , " error " ) . put String ( " message " , result . cause ( ) . get Message ( ) ) ) ; } else { message . reply ( new Json Object ( ) . put String ( " status " , " ok " ) ) ; } } } ; }<CODESPLIT>Creates a platform undeploy handler .
public Photo All Context get All Contexts ( String photo Id ) throws Flickr { Photo List Photo set List = Photo List Photo ( ) ; List pool List = List ( ) ; Photo All Context all Context = Photo All Context ( ) ; parameters . put ( method , METHOD _ _ ALL _ CONTEXTS ) ; parameters . put ( photo _ id " , photo Id ) ; Response response = transport . get ( transport . get Path ( ) , parameters , api Key , shared Secret ) ; if ( response . is Error ( ) ) { } Collection < Element > photos Element = response . get Payload Collection ( ) ; for ( Element set Element : photos Element ) { if ( set Element . get Tag Name ( ) . equals ( " set " ) ) { Photo Set pset = new Photo Set ( ) ; pset . set Title ( set Element . get Attribute ( " title " ) ) ; pset . set Secret ( set Element . get Attribute ( " secret " ) ) ; pset . set Id ( set Element . get Attribute ( " id " ) ) ; pset . set Farm ( set Element . get Attribute ( " farm " ) ) ; pset . set Primary ( set Element . get Attribute ( " primary " ) ) ; pset . set Server ( set Element . get Attribute ( " server " ) ) ; pset . set View Count ( Integer . parse Int ( set Element . get Attribute ( " view _ count " ) ) ) ; pset . set Comment Count ( Integer . parse Int ( set Element . get Attribute ( " comment _ count " ) ) ) ; pset . set Count Photo ( Integer . parse Int ( set Element . get Attribute ( " count _ photo " ) ) ) ; pset . set Count Video ( Integer . parse Int ( set Element . get Attribute ( " count _ video " ) ) ) ; set List . add ( pset ) ; all Context . set Photo Set List ( set List ) ; } else if ( set Element . get Tag Name ( ) . equals ( " pool " ) ) { Pool pool = new Pool ( ) ; pool . set Title ( set Element . get Attribute ( " title " ) ) ; pool . set Id ( set Element . get Attribute ( " id " ) ) ; pool . set Url ( set Element . get Attribute ( " url " ) ) ; pool . set Icon Server ( set Element . get Attribute ( " iconserver " ) ) ; pool . set Icon Farm ( set Element . get Attribute ( " iconfarm " ) ) ; pool . set Member Count ( Integer . parse Int ( set Element . get Attribute ( " members " ) ) ) ; pool . set Pool Count ( Integer . parse Int ( set Element . get Attribute ( " pool _ count " ) ) ) ; pool List . add ( pool ) ; all Context . set Pool List ( pool List ) ; } } return all Context ; }<CODESPLIT>Returns all visble sets and pools the photo belongs to .
public Map String , Object get Field Data ( Map String , Object properties ) { Map String , Object Return = ; ( properties ) { Return = String , Object ( ) ; ( int = ; ; ) { String Field Number = . FIELD + Integer . to String ( i ) ; String str Field Name = ( String ) properties . get ( str Field Number ) ; if ( str Field Name == null ) break ; Record record = this . get Main Record ( ) ; if ( str Field Name . index Of ( '.' ) != - 1 ) { record = this . get Record ( str Field Name . substring ( 0 , str Field Name . index Of ( '.' ) ) ) ; str Field Name = str Field Name . substring ( str Field Name . index Of ( '.' ) + 1 ) ; } Base Field field = null ; if ( record != null ) field = record . get Field ( str Field Name ) ; if ( field != null ) prop Return . put ( str Field Number , field . get Data ( ) ) ; } } return prop Return ; }<CODESPLIT>GetFieldData Method .
protected void connect ( , int port ) throws { Block Guard . get Thread Policy ( ) . on Network ( ) ; connect 0 ( , port ) ; connected Address = address ; connected Port = port ; connected = true ; }<CODESPLIT>Connects a datagram socket to a remote destination . This associates the remote address with the local socket so that datagrams may only be sent to this destination and received from this destination .
private char get Escaped ( ) { ; ( == ) { State Exception ( " end of DN : " + dn ) ; } ( chars [ pos ] ) { case '"' : case '\\' : case ',' : case '=' : case '+' : case '<' : case '>' : case '#' : case ';' : case ' ' : case '*' : case '%' : case '_' : return chars [ pos ] ; default : return get UTF 8 ( ) ; } }<CODESPLIT>returns escaped char
private static String cut Matchers Prefix ( String expression ) { ( expression . With ( Citrus . VALIDATION _ MATCHER _ ) expression . With ( Citrus . VALIDATION _ MATCHER _ SUFFIX ) ) { return expression . ( Citrus . VALIDATION _ MATCHER _ . length ( ) , expression . length ( ) - Citrus . VALIDATION _ MATCHER _ SUFFIX . length ( ) ) ; } return expression ; }<CODESPLIT>Cut off validation matchers prefix and suffix .
public Type Element implementing ( Type Element type Element ) { Type Element get ( implementing , type Element ) ; Type Element intfcs = all Sub Classes ( type Element , false ) ; Iterator < Type Element > sub Interfaces Iter = intfcs . iterator ( ) ; while ( sub Interfaces Iter . has Next ( ) ) { Iterator < Type Element > implementing Classes Iter = implementing Classes ( sub Interfaces Iter . next ( ) ) . iterator ( ) ; while ( implementing Classes Iter . has Next ( ) ) { Type Element c = implementing Classes Iter . next ( ) ; if ( ! result . contains ( c ) ) { result . add ( c ) ; } } } return result ; }<CODESPLIT>Return the set of classes which implement the interface passed .
public void add ( Result validation ) { validation . ; ( ! validate ) return ; errors . add All ( validation . errors ) ; warnings . add All ( validation . warnings ) ; }<CODESPLIT>Adds a validation result to this .
public static String to Field String ( Object ) { String Buffer = String Buffer ( ) ; Field [ ] fields = to Field Array ( , , ) ; for ( int = 0 ; fields . ; ++ ) { Meta Field Info field = fields [ i ] ; buf . append ( field . name ) ; buf . append ( "=" ) ; if ( field . actual Value != null && field . actual Value . get Class ( ) . equals ( String . class ) ) { buf . append ( '"' ) ; buf . append ( field . value ) ; buf . append ( '"' ) ; } else { buf . append ( field . value ) ; } if ( i + 1 < fields . length ) buf . append ( "," ) ; } return buf . to String ( ) ; }<CODESPLIT>Creates a string for an object based on the MetaField annotations .
public String get Array Class Name ( Class clazz ) { ( clazz is Array ( ) ) { get Array Class Name ( clazz . get Component Type ( ) ) + "[]" ; } return clazz . get Name ( ) ; }<CODESPLIT>Formats the class name with trailing square brackets .
synchronized void add Block ( Block block ) { ( ! is Initialized ( ) ) { return ; } Block Scan = block Map . get ( block ) ; ( ) { . ( Adding an existing block " + block ) ; del Block Info ( info ) ; } info = new Block Scan Info ( block ) ; info . last Scan Time = get New Block Scan Time ( ) ; add Block Info ( info ) ; adjust Throttler ( ) ; }<CODESPLIT>Adds block to list of blocks
public String get Tile ( int x , int y ) { ( ( x get Array Width ( ) ) ( y get Array Height ( ) ) ( x 0 ) ( y < 0 ) ) { throw new Illegal Argument Exception ( ) ; } return image [ x ] [ y ] ; }<CODESPLIT>Gets a tile of the XPM Image .
public JBBP Dsl Array ( String name , String Len Expression , String size Expression ) { item = Item ( Bin Type . BIT _ ARRAY , name , this . byte Order ) ; item . bit Len Expression = assert Expression Chars ( bit Len Expression ) ; item . size Expression = assert Expression Chars ( size Expression ) ; this . add Item ( item ) ; return this ; }<CODESPLIT>Add named bit array where each bit length is calculated through expression .
public static Object index Of ( String Pattern , String Input , int , boolean , boolean match All ) throws Pattern { Pattern Matcher Input = Pattern Matcher Input ( Input ) ; Perl 5 Matcher = Perl 5 Matcher ( ) ; int compile = 0 : Perl 5 Compiler . _ _ MASK ; compile += Perl 5 Compiler . SINGLELINE _ MASK ; ( 1 ) = 1 ; Pattern pattern = get Pattern ( str Pattern , compile Options ) ; if ( offset <= str Input . length ( ) ) input . set Current Offset ( offset - 1 ) ; if ( offset <= str Input . length ( ) ) { Array matches = new Array Impl ( ) ; while ( matcher . contains ( input , pattern ) ) { int match = matcher . get Match ( ) . begin Offset ( 0 ) + 1 ; if ( ! match All ) { return new Double ( match ) ; } matches . append EL ( match ) ; } if ( matches . size ( ) != 0 ) { return matches ; } } return 0 ; }<CODESPLIT>return index of the first occurence of the pattern in input text
private Object check Services By Ldap Filter ( String filter ) throws Exception { Service Reference < ? > [ ] references = get Bundle Context ( ) . get Service ( ( String ) , filter ) ; ( is Empty Or Null ( references ) ) { return ; } ( references . == 1 ) { return get Bundle Context ( ) . get Service ( references [ 0 ] ) ; } Runtime Exception ( " Too many services registered for filter : " + filter ) ; }<CODESPLIT>Checks the OSGi ServiceRegistry if a service matching the given filter is present .
public void Event ( D Event event ) { ( tevent ) { tevent . Event ( event ) ; } ( omgr != null ) { _ omgr . post Event ( event ) ; } else { log . info ( " Dropping event for non - or no longer managed object " , " oid " , get Oid ( ) , " class " , get Class ( ) . get Name ( ) , " event " , event ) ; } }<CODESPLIT>Posts the specified event either to our dobject manager or to the compound event for which we are currently transacting .
public static create Overlay Manager Group ( String name ) { return Extended Identifiers . create Extended Identifier ( Ifmap . ICS _ _ NS _ URI , Ifmap . ICS _ _ , " overlay - manager - group " , name ) ; }<CODESPLIT>Create a overlay - manager - group identifier that is an extended identity identifier .
public static Double Matrix cholesky ( Double Matrix A ) { Double Matrix = A . dup ( ) ; int = Native . dpotrf ( ' U ' , A . , . data , 0 , A . ) ; ( < 0 ) { Lapack Argument ( DPOTRF " , - info ) ; } else if ( info > 0 ) { throw new Lapack Positivity Exception ( " DPOTRF " , " Minor " + info + " was negative . Matrix must be positive definite ." ) ; } clear Lower ( result ) ; return result ; }<CODESPLIT>Compute Cholesky decomposition of A
public static boolean is Caller ( String class Name , String method Name ) { Throwable = Throwable ( ) ; Trace Element [ ] stack Elements = . get Trace ( ) ; ( == stack Elements ) { . log ( Level . WARN , Empty call stack ) ; return false ; } boolean match All Method = "*" . equals ( method Name ) ; for ( int = 1 ; i < stack Elements . length ; i ++ ) { if ( stack Elements [ i ] . get Class Name ( ) . equals ( class Name ) ) { return match All Method ? true : stack Elements [ i ] . get Method Name ( ) . equals ( method Name ) ; } } return false ; }<CODESPLIT>Checks the current method is whether invoked by a caller specified by the given class name and method name .
public Input Stream set Flag ( String name , String value ) throws { execute Command ( " setflag " , name , value ) ; }<CODESPLIT>set JVM command line flag
public Q add Flag ( Position , String , Expression expr ) { Expression > flag = Expressions . template ( expr . get Type ( ) , prefix + "{ 0 }" , expr ) ; return query Mixin . add Flag ( new Query Flag ( position , flag ) ) ; }<CODESPLIT>Add the given prefix and expression as a general query flag
static Connection Info Connection Info ( Channel ) { Channel = ( Channel ) ; Address host Address = . local Address ( ) ; Inet Socket Address remote Address = get Remote Address ( channel ) ; String scheme = channel . pipeline ( ) . get ( Ssl Handler . class ) != null ? " https " : " http " ; return new Connection Info ( host Address , remote Address , scheme ) ; }<CODESPLIT>Retrieve the connection information from the current connection directly
public PDP Domain get PDP Domain ( String pdp Domain Name ) throws IO { Sorted Set < String > domain Ranges = ; ( serialized Cache != ) { ( serialized Cache . contains Key ( pdp Domain Name ) ) { domain Ranges = serialized Cache . get ( pdp Domain Name ) ; } } boolean should Request Domain Ranges = check Domain Ranges ( domain Ranges ) ; { ( should Request Domain Ranges ) { URL = URL ( server " get PDP Domain pdp Id =" pdp Domain Name ) ; . info ( " Fetching {}" , ) ; Input Stream response = URL Connection Tools . get Input Stream ( ) ; String xml = Fat Cat Client . convert Stream To String ( response ) ; domain Ranges = XML Util . get Domain Ranges From XML ( xml ) ; ( domain Ranges != ) cache ( pdp Domain Name , domain Ranges ) ; } } catch ( Malformed URL Exception e ) { logger . error ( " Problem generating PDP request URL for " + pdp Domain Name , e ) ; } String pdb Id = null ; List < Residue Range > ranges = new Array List < Residue Range > ( ) ; for ( String domain Range : domain Ranges ) { Substructure Identifier struc Id = new Substructure Identifier ( domain Range ) ; if ( pdb Id == null ) { pdb Id = struc Id . get Pdb Id ( ) ; } else if ( ! pdb Id . equals ( struc Id . get Pdb Id ( ) ) ) { throw new Runtime Exception ( " Don ' t know how to take the union of domains from multiple PDB I Ds ." ) ; } ranges . add All ( struc Id . get Residue Ranges ( ) ) ; } return new PDP Domain ( pdp Domain Name , ranges ) ; }<CODESPLIT>Get a StructureIdentifier representing the specified PDP domain .
public Context get Context ( ) { ( search View != ) { return search View . get Context ( ) ; } ( support View != ) { return support View . get Context ( ) ; } new Illegal State Exception ( ERROR _ NO _ SEARCHVIEW ) ; }<CODESPLIT>Returns the context the view is running in through which it can access the current theme resources etc .
private boolean is Macro Cycle ( I Ring ring , I Ring ) { ( ring . get Atom Count ( ) 8 ) ; ( I Bond bond ring . bonds ( ) ) { boolean = ; ( I Atom Container other : rs . atom Containers ( ) ) { if ( ring == other ) continue ; if ( other . contains ( bond ) ) { found = true ; break ; } } if ( ! found ) return true ; } return false ; }<CODESPLIT>Check if a ring in a ring set is a macro cycle . We define this as a ring with > = 10 atom and has at least one bond that isn t contained in any other rings .
public < T > T datastore To Java ( Entity entity ) { { ( entity == ) { return ; } T = ( T ) persistent Class . Instance ( ) ; populate ( entity , ) ; return ; } ( Instantiation Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( e ) ; } }<CODESPLIT>Convert a value from Google representation to a Java value
private void update Cache State ( Map < String , Object > ) { get Authentication Config ( ) ; ( ) { Cache Service Ref . activate ( cc ) ; } else { auth Cache Service Ref . deactivate ( cc ) ; } }<CODESPLIT>Based on the configuration properties the auth cache should either be active or not .
public static Query with ( Query query , read Time , Document , List Document Change ) { Query ( query , read Time ) { volatile List Query Document documents ; public List Query Document get ( ) { ( documents ) { synchronized ( ) { ( documents null ) { documents = document Set . to List ( ) ; } } } return Collections . unmodifiable List ( documents ) ; } public List < Document Change > get Document Changes ( ) { return Collections . unmodifiable List ( document Changes ) ; } public int size ( ) { return document Set . size ( ) ; } public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || get Class ( ) != o . get Class ( ) ) { return false ; } Query Snapshot that = ( Query Snapshot ) o ; return Objects . equals ( query , that . query ) && Objects . equals ( this . size ( ) , that . size ( ) ) && Objects . equals ( this . get Document Changes ( ) , that . get Document Changes ( ) ) && Objects . equals ( this . get Documents ( ) , that . get Documents ( ) ) ; } public int hash Code ( ) { return Objects . hash ( query , this . get Document Changes ( ) , this . get Documents ( ) ) ; } } ; }<CODESPLIT>Creates a new QuerySnapshot representing a snapshot of a Query with changed documents .
private boolean read ( In In , Outbox Amp outbox , Amp headers ) throws { Method Hamp method Hamp = ; { method Hamp = read Method ( In ) ; } ( Throwable ) { log . log ( Level . FINER , . to String ( ) , ) ; ( In ) ; ; } Method Amp method = method Hamp . get Method ( ) ; Class Loader = method Hamp . get Class Loader ( ) ; Thread = Thread . current Thread ( ) ; . set Context Class Loader ( ) ; Object [ = read ( method Hamp , In ) ; ( log . is Loggable ( log Level ) ) { log . log ( _ log Level , this + " send - r " + method . get Name ( ) + debug Args ( args ) + " { to :" + method + ", " + headers + "}" ) ; } Send Message _ N send Message = new Send Message _ N ( outbox , headers , method . service Ref ( ) , method . method ( ) , args ) ; long timeout = 1000 L ; try { send Message . offer ( timeout ) ; } catch ( Throwable e ) { log . fine ( e . to String ( ) ) ; if ( log . is Loggable ( Level . FINEST ) ) { log . log ( Level . FINEST , e . to String ( ) , e ) ; } } return true ; }<CODESPLIT>The send message is a on - way call to a service .
private String get Remote File Name ( Upload File file ) { ( file . get Property ( PARAM REMOTE ) . With ( "/" ) ) { file . get Name ( ) ; } ( file . get Property ( PARAM REMOTE ) . contains ( "/" ) ) { String [ ] tmp = file . get Property ( PARAM _ REMOTE _ PATH ) . split ( "/" ) ; return tmp [ tmp . length - 1 ] ; } return file . get Property ( PARAM _ REMOTE _ PATH ) ; }<CODESPLIT>Checks if the remote file path contains also the remote file name . If it s not specified the name of the local file will be used .
public void initialize Buffer ( task ) { Metric Group buffers add Group ( buffers ) ; buffers gauge ( Length , new Input Buffers Gauge ( task ) ) ; buffers . gauge ( " output Queue Length " , new Output Buffers Gauge ( task ) ) ; buffers . gauge ( " in Pool Usage " , new Input Buffer Pool Usage Gauge ( task ) ) ; buffers . gauge ( " out Pool Usage " , new Output Buffer Pool Usage Gauge ( task ) ) ; }<CODESPLIT>Initialize Buffer Metrics for a task .
public void double Click ( String file Name ) throws Q Taste { { Region ( this . rect ) . double Click ( file Name ) ; } ( ) { throw new Q Taste Exception ( ex . get Message ( ) , ex ) ; } }<CODESPLIT>Simulates a double click on the specified image of the area .
public void set Destination SSE Customer Key ( SSE Customer Key sse Key ) { ( sse Key != this . sse Aws Key Management Params != ) { Argument ( " Either SSE Customer Key or SSE Aws Key Management Params must not be set at the same time ." ) ; } this . destination SSE Customer Key = sse Key ; }<CODESPLIT>Sets the optional customer - provided server - side encryption key to use to encrypt the destination object being copied .
public void on Failure ( Throwable ) { Toast . make Text ( this , . get ( ) , _ LONG ) . show ( ) ; }<CODESPLIT>show any error messages posted to the bus .
private void paint Drop ( Sea Glass Context context , ) { Table . Drop Location loc = table . get Drop Location ( ) ; ( loc == ) { return ; } Color = ( Color ) style . get ( context , Table . drop Line Color ) ; Color short Color = ( Color ) style . get ( context , Table . drop Line Color ) ; ( == short Color == ) { return ; } rect ; rect = get H Drop Line ( loc ) ; if ( rect != null ) { int x = rect . x ; int w = rect . width ; if ( color != null ) { extend Rect ( rect , true ) ; g . set Color ( color ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } if ( ! loc . is Insert Column ( ) && short Color != null ) { g . set Color ( short Color ) ; g . fill Rect ( x , rect . y , w , rect . height ) ; } } rect = get V Drop Line Rect ( loc ) ; if ( rect != null ) { int y = rect . y ; int h = rect . height ; if ( color != null ) { extend Rect ( rect , false ) ; g . set Color ( color ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } g . set Color ( short Color ) ; g . fill Rect ( rect . x , y , rect . width , h ) ; } } }<CODESPLIT>Paint the drop lines if any .
public Datalog Program create Datalog ( SWRL Rule rule ) { rule . accept ( this ) ; ( not Supported ) { log . ( Not Supported of ) ; errors . clear ( ) ; } Datalog Program dp = datalog Factory . get Datalog Program ( ) ; dp . append Rule ( facts ) ; return dp ; }<CODESPLIT>Translate the swrl_rule Return a datalog program containing the supported datalog facts
protected String inflate Authn Request ( [ ] decoded Bytes ) { inflated = . inflate ( decoded Bytes ) ; ( ! String Utils . is Empty ( inflated ) ) { return inflated ; } return Compression Utils . decode Byte Array To String ( decoded Bytes ) ; }<CODESPLIT>Inflate authn request string .
public static Framework Config create ( String name , File property File , Properties properties , Filesystem Framework filesystem Framework ) { ( ! property File . exists ( ) ) { generate Project Properties File ( name , property File , false , properties , true ) ; } return create ( name , property File , filesystem Framework ) ; }<CODESPLIT>Create and generate file with the given properties if not null
static synchronized void clear Context ( ) { Context embedded Context = . _ ; configurator = embedded Context . get ( ) . detach ( . ATTACHMENT _ ) ; ( configurator Property ) { Context Configuration log Context Configuration = ( ( Property ) configurator ) . get Context Configuration ( ) ; clear Context ( log Context Configuration ) ; } if ( configurator instanceof Log Context Configuration ) { clear Log Context ( ( Log Context Configuration ) configurator ) ; } else { final List < String > logger Names = Collections . list ( embedded Log Context . get Logger Names ( ) ) ; for ( String name : logger Names ) { final Logger logger = embedded Log Context . get Logger If Exists ( name ) ; if ( logger != null ) { final Handler [ ] handlers = logger . clear Handlers ( ) ; if ( handlers != null ) { for ( Handler handler : handlers ) { handler . close ( ) ; } } logger . set Filter ( null ) ; logger . set Use Parent Filters ( false ) ; logger . set Use Parent Handlers ( true ) ; logger . set Level ( Level . INFO ) ; } }<CODESPLIT>Attempts to clear the global log context used for embedded servers .
public Api Response execute ( long , Time Unit ) { return Blocking . block For Single ( delegate . execute ( ) , timeout , time Unit ) ; }<CODESPLIT>Executes the API request in a synchronous fashion using the given timeout .
public Input Stream get Input Stream ( Http Servlet Request request , Object [ source Map Result ) throws { [ = this . ; [ source Map = this . source Map ; String filename = this . filename ; Input Stream = ; ( ) { = Byte Array Input Stream ( ) ; ( source Map Result && source Map Size > 0 ) { source Map Result . set Value ( source Map ) ; } } else if ( filename != null ) { I Cache Manager cmgr = ( ( I Aggregator ) request . get Attribute ( I Aggregator . AGGREGATOR _ REQATTRNAME ) ) . get Cache Manager ( ) ; File file = new File ( cmgr . get Cache Dir ( ) , filename ) ; if ( source Map Size == 0 ) { result = new File Input Stream ( file ) ; } else { Cache Data data ; Object Input Stream is = new Object Input Stream ( new File Input Stream ( file ) ) ; try { data = ( Cache Data ) is . read Object ( ) ; } catch ( Class Not Found Exception e ) { throw new IO Exception ( e . get Message ( ) , e ) ; } finally { IO Utils . close Quietly ( is ) ; } bytes = data . bytes ; if ( source Map Result != null ) { source Map Result . set Value ( source Map ) ; } result = new Byte Array Input Stream ( bytes ) ; } } else { throw new IO Exception ( ) ; } return result ; }<CODESPLIT>Return an input stream to the layer . Has side effect of setting the appropriate Content - Type Content - Length and Content - Encoding headers in the response .
public void Include And ( Web Element ) { ( get By Matches ( ) ) { set By Matches ( Array List Web Element ( ) ) ; ( By by get Rows Matching ( ) ) { get Ignore By Matches ( ) . add All ( table . find Elements ( by ) ) ; } } if ( get Include By Matches ( ) == null ) { set Include By Matches ( new Array List < Web Element > ( ) ) ; for ( By by : get Include Only Rows Matching ( ) ) { get Include By Matches ( ) . add All ( table . find Elements ( by ) ) ; } } }<CODESPLIT>Does the table comparison
public < E > List < Diff < E > > inline ( List < E > , List < E > ) { set Error ( ) ; { return this . inline Diff Displayer . display ( this . diff Manager . diff ( , , null ) ) ; } catch ( Diff Exception e ) { set Error ( e ) ; return null ; } }<CODESPLIT>Builds an in - line diff between two versions of a list of elements .
public static Completable Future Message get Messages Around Until ( Text Channel , Predicate Message , long around ) { Completable Future Message = Completable Future ( ) ; . get Api ( ) . get Thread ( ) . get Service ( ) . submit ( ( ) -> { { List < Message > messages = new Array List < > ( ) ; Optional < Message > until Message = get Messages Around As Stream ( channel , around ) . peek ( messages :: add ) . filter ( condition ) . find First ( ) ; future . complete ( new Message Set Impl ( until Message . map ( message -> messages ) . or Else ( Collections . empty List ( ) ) ) ) ; } catch ( Throwable t ) { future . complete Exceptionally ( t ) ; } } ) ; return future ; }<CODESPLIT>Gets messages in the given channel around a given message in any channel until one that meets the given condition is found . If no message matches the condition an empty set is returned . The given message will be part of the result in addition to the messages around if it was sent in the given channel and is matched against the condition and will abort retrieval . Half of the messages will be older than the given message and half of the messages will be newer . If there aren t enough older or newer messages the halves will not be same - sized . It s also not guaranteed to be perfectly balanced .
public static boolean find Sip Application Annotation ( Input Stream stream ) { { [ ] raw Class Bytes ; raw Class Bytes = [ stream . available ( ) ] ; stream . read ( raw Class Bytes ) ; boolean one = contains ( raw Class Bytes , SIP _ _ BYTES ) ; boolean two = contains ( raw Class Bytes , _ BYTES ) ; ( one two ) return ; } ( Exception e ) { } return false ; }<CODESPLIT>Determine if this stream contains SipApplication annotations
protected Map String , Object build Data Map ( Jmx Command Command , Object [ ] params ) throws M Bean { Map String , Object Data Map = Map String , Object ( ) ; { int ind = 0 ; for ( Jmx Option option : Jmx Options . get Options ( ) ) { option . process ( job Data Map , String . value Of ( params [ ind ++ ] ) ) ; } for ( Argument arg : this . remote Program . get Arguments ( ) ) { arg . set Value Using Parser ( String . value Of ( params [ ind ++ ] ) ) ; } } catch ( Exception e ) { throw new M Bean Exception ( e ) ; } return job Data Map ; }<CODESPLIT>Initialize the JobDataMap with the Program arguments
private void V ( String Builder ) { Token = get Next Token ( ) ; ( . Type != Token Type . VALUE ) { State ( token " + t ) ; } buf . append ( t . get Value ( ) ) ; t = get Next Token ( ) ; if ( t . token Type == Token Type . EOL ) { return ; } else if ( t . token Type == Token Type . TRAILING _ BACKSLASH ) { Vopt ( buf ) ; } }<CODESPLIT>Vopt = EOL V
public void add Header ( String Name , String Value ) { if ( s Value != null ) _ add Header ( s Name , s Value ) ; }<CODESPLIT>Add the passed header as is .
public static N Number Number ( List < N > number List ) { return cal ( number List , Double Stream :: max ) ; }<CODESPLIT>Max number .
public int get Chaincode Action Response ( ) throws Argument { ( status Return Code != 1 ) { return status Return Code ; } { Proposal Response Deserializer proposal Response Deserializer = get Proposal Response Deserializer ( ) ; status Return Code = proposal Response Deserializer . get Extension ( ) . get Response Status ( ) ; return status Return Code ; } catch ( Invalid Argument Exception e ) { throw e ; } catch ( Exception e ) { throw new Invalid Argument Exception ( e ) ; } }<CODESPLIT>getChaincodeActionResponseStatus returns the what chaincode executions set as the return status .
public void generate ( Queue < < < Context > , JC Class Decl > > queue ) { generate ( queue , null ) ; }<CODESPLIT>Generates the source or class file for a list of classes . The decision to generate a source file or a class file is based upon the compiler s options . Generation stops if an error occurs while writing files .
public static Enhanced Mime Type create ( final String primary , final String sub , final encoding , final String version , final Map < String , String > parameters ) { { return Enhanced Mime Type ( primary , sub , encoding , version , parameters ) ; } ( final Mime Type Parse ) { Exception ( " Failed to create versioned mime type : " + primary + "/" + sub , ex ) ; } }<CODESPLIT>Creates an instance with all data and exceptions wrapped to runtime exceptions .
public static long to Long With Default ( Object value , long default Value ) { Long = to Nullable Long ( value ) ; return ? ( long ) result : default Value ; }<CODESPLIT>Converts value into integer or returns default when conversion is not possible .
public void set Isolation ( String iso ) throws Tag { ( READ COMMITTED . equals ( iso ) ) { Connection . READ COMMITTED ; } ( _ READ _ UNCOMMITTED . equals ( iso ) ) { isolation = Connection . TRANSACTION _ READ _ UNCOMMITTED ; } else if ( TRANSACTION _ REPEATABLE _ READ . equals ( iso ) ) { isolation = Connection . TRANSACTION _ REPEATABLE _ READ ; } else if ( TRANSACTION _ SERIALIZABLE . equals ( iso ) ) { isolation = Connection . TRANSACTION _ SERIALIZABLE ; } else { throw new Jsp Tag Exception ( Resources . get Message ( " TRANSACTION _ INVALID _ ISOLATION " ) ) ; } }<CODESPLIT>Setter method for the transaction isolation level .
public void traverse ( Node root ) { { init Traversal ( root ) ; Node = root ; push Scope ( root ) ; traverse Branch ( root , ) ; pop Scope ( ) ; } ( Error Exception unexpected Exception ) { Unexpected Exception ( unexpected Exception ) ; } }<CODESPLIT>Traverses a parse tree recursively .
public Collection Request Tag find By Workspace ( String workspace ) { String path = String . format ( "/ workspaces /% / tags , workspace ) ; Collection Request < Tag > ( this , Tag . class , path , " GET " ) ; }<CODESPLIT>Returns the compact tag records for all tags in the workspace .
public Rule Criteria ( ) { Sequence ( peek ( ) is Cli Query ( ) , Json Parameter ( Json Object ( ) ) , peek ( ) . set Operation ( Operation . FIND ) , peek ( ) . set Criteria ( match ( ) ) ) ; }<CODESPLIT>A find query only given as criterion . Leave it to MongoDB s own parser to handle it .
private E unlink Last ( Node < E > l ) { final E = l . item ; final Node < E > = l . ; l . item = ; l . = ; last = ; ( prev == null ) first = null ; else prev . next = null ; size -- ; mod Count ++ ; return element ; }<CODESPLIT>Unlinks non - null last node l .
private static void Security Properties ( String , Object , String user Dn , char [ ] pwd ) { . put ( Context . SECURITY _ AUTHENTICATION , simple " ) ; env . put ( Context . SECURITY _ PRINCIPAL , user Dn ) ; env . put ( Context . SECURITY _ CREDENTIALS , new String ( pwd ) ) ; }<CODESPLIT>Sets the environment properties needed for a simple username + password authenticated jndi connection .
public Team create Team ( String name , String tag ) { client send Rpc And ( , " create Team " , name , tag ) ; }<CODESPLIT>Create a new ranked team with the specified name and tag
private static void check File Pattern ( String ) throws Problem { Pattern = ; ( File . separator Char == '\\' ) { = Pattern . compile ( "\\*?(.+\\\\)*.+" ) ; } ( File . separator Char == '/' ) { = Pattern . compile ( "\\*?(.+/)*.+" ) ; } { Problem ( This platform uses the unsupported " + File . separator Char + " as file separator character . Please add support for it !" ) ; } Matcher m = p . matcher ( s ) ; if ( ! m . matches ( ) ) { throw new Problem Exception ( " The string \"" + s + "\" is not a proper file name ." ) ; } }<CODESPLIT>Verify that a source file name is valid .
public void close ( ) throws { for ( Entry Transaction Type , Sharding Transaction Manager : Manager Map . entry Set ( ) ) { entry . get Value ( ) . close ( ) ; } }<CODESPLIT>Close sharding transaction managers .
protected static String get Bar ( long percentage ) { String = String ( ) ; . append ( percentage ) ; . append ( "% [" ) ; for ( int = 0 ; ; ) { if ( percentage == 100 || i < percentage - 1 ) { sb . append ( "=" ) ; } else if ( i == percentage - 1 ) { sb . append ( ">" ) ; } else { sb . append ( " " ) ; } } sb . append ( "] " ) ; return sb . to String ( ) ; }<CODESPLIT>Generates the progress bar for the given percentage
private void resolve ( T , List T ) { Set T = blocked By . get ( element ) ; if ( dependencies != null ) { for ( T dependency : dependencies ) { resolve ( dependency , result ) ; } blocked By . remove ( element ) ; result . add ( element ) ; } }<CODESPLIT>Resolves an element .
public camunda Out ( String source , String ) { Camunda Out param model Instance Instance ( Camunda Out class ) ; param . set Camunda Source ( source ) ; param . set Camunda Target ( target ) ; add Extension Element ( param ) ; return myself ; }<CODESPLIT>Sets a camunda out parameter to pass a variable from a sub process instance to the super process instance
create Arguments Reference ( ) { = IR . name ( " ) ; if ( is Adding Types ( ) ) { result . set JS Type ( arguments Type Supplier . get ( ) ) ; } return result ; }<CODESPLIT>Creates a reference to arguments with the type specified in externs or unknown if the externs for it weren t included .
public Date to Date ( String date String ) { Date date = ; Date Format df = Simple Date Format ( yyyy - MM - dd ) ; { date = df . parse ( date String ) ; } ( Parse ) { System . out . println ( ex . fill In Stack Trace ( ) ) ; } return date ; }<CODESPLIT>Takes a String and converts it to a Date
public static cusolver Rf Numeric ( cusolver Rf handle double zero , double boost ) { return check Result ( cusolver Rf Set Numeric Properties Native ( handle , zero , boost ) ) ; }<CODESPLIT>CUSOLVERRF set and get numeric properties
public static Object quote If String ( Object ) { return String ? quote ( ( String ) obj ) : obj ; }<CODESPLIT>Turn the given Object into a String with single quotes if it is a String ; keeping the Object as - is else .
public Deferred < Object > delete Uid Async ( final String type , final String name ) { final Unique Id Type uid _ type = Unique Id . string To Unique Id Type ( type ) ; ( uid _ type ) { METRIC : return . delete Async ( name ) ; TAGK : return tag _ . delete Async ( name ) ; TAGV : return tag _ . delete Async ( name ) ; default : Argument ( " Unrecognized UID type : " + uid _ type ) ; } }<CODESPLIT>Attempts to delete the given UID name mapping from the storage table as well as the local cache .
public boolean scroll Down List ( int index ) { ( . command Logging ) { . d ( . command Logging Tag , scroll Down List index + ")" ) ; } return scroller . scroll List ( waiter . wait For And Get View ( index , List View . class ) , Scroller . DOWN , false ) ; }<CODESPLIT>Scrolls down a ListView matching the specified index .
protected void make Type Element Doc ( Method meth , Path tree Path ) { Type Element Doc ( Type Element Doc ) method Map . get ( meth ) ; ( result != null ) { if ( tree Path != null ) result . set Tree Path ( tree Path ) ; } else { result = new Annotation Type Element Doc Impl ( this , meth , tree Path ) ; method Map . put ( meth , result ) ; } }<CODESPLIT>Create the AnnotationTypeElementDoc for a MethodSymbol . Should be called only on symbols representing annotation type elements .
public Object call ( String method , Object ... ) throws Pickle , Pyro , Exception { return internal _ call ( method , null , 0 , true , arguments ) ; }<CODESPLIT>Call a method on the remote Pyro object this proxy is for .
public static String format As Percentage ( int value , int ) { float average = == 0 0 F * value / total ; return PERCENT _ FORMATTER . format ( average ) ; }<CODESPLIT>Returns value converted to percentage format .
public static T Geometry JTS Geometry Expression T ( Expression T > expr , float deltax , float deltay ) { return geometry Operation ( expr . get Type ( ) , Spatial Ops . TRANSLATE , expr , Constant Impl . create ( deltax ) , Constant Impl . create ( deltay ) ) ; }<CODESPLIT>Translates the geometry to a new location using the numeric parameters as offsets .
private static request Web Content ( String url ) throws TV Rage { { Http Get http Get = Http Get ( url ) ; http Get . add Header ( accept , / xml ) ; Digested Response = Digested Response Reader . request Content ( http Client , http Get , CHARSET ) ; ( . get Code ( ) >= 500 ) { TV Rage ( Api Exception Type . HTTP _ 503 _ ERROR , url ) ; } else if ( response . get Status Code ( ) >= 300 ) { throw new TV Rage Exception ( Api Exception Type . HTTP _ 404 _ ERROR , url ) ; } return response . get Content ( ) . get Bytes ( DEFAULT _ CHARSET ) ; } catch ( IO Exception ex ) { throw new TV Rage Exception ( Api Exception Type . MAPPING _ FAILED , UNABLE _ TO _ PARSE , url , ex ) ; } }<CODESPLIT>Get content from URL in byte array
private static boolean is Numeric ( String value ) { ( char value . to Char Array ( ) ) { ( ! Character . is Digit ( ) ) { return false ; } } return true ; }<CODESPLIT>Returns a boolean indicating whether the given string value is numeric .
public Map String , String get Foo ( ) { final Map String , String foo = new Hash Map < > ( ) ; foo Obj . put ( " foo " , " bar " ) ; return foo Obj ; }<CODESPLIT>Controller to just support pinging .
protected static void fire Array Event ( Json Config json Config ) { ( json Config . is Event Triggering ( ) ) { for ( Iterator listeners = json Config . get Json Event ( ) . iterator ( ) ; listeners . has Next ( ) ; ) { Json Event Listener listener = ( Json Event Listener ) listeners . ( ) ; { listener . on Array ( ) ; } ( e ) { log . warn ( e ) ; } } } }<CODESPLIT>Fires a start of array event .
public static E Runnable sneaked ( Sneaky Runnable E runnable ) { return ( ) -> { @ Suppress Warnings ( " unchecked " ) Sneaky Runnable < Runtime Exception > casted Runnable = ( Sneaky Runnable < Runtime Exception > ) runnable ; casted Runnable . run ( ) ; } ; }<CODESPLIT>Sneaky throws a Runnable lambda .
public static Domain update ( final Bandwidth Client client , final String id , final Map String , Object > params ) throws App , Parse , , { assert ( client != id != ) ; final String domains = client . get User Resource Instance ( Bandwidth Constants . DOMAINS _ URI _ PATH , id ) ; final Rest Response response = client . post ( domains Uri , params ) ; final JSON Object json Object = to JSON Object ( client . get ( domains Uri , null ) ) ; return new Domain ( client , json Object ) ; }<CODESPLIT>Convenience method to return a Domain .
public static Stream String get Resource Types ( Event event ) { ( event . modeshape . jcr . . observation . Event ) { { . modeshape . jcr . . observation . Event Event = ( . modeshape . jcr . . observation . Event ) event ; Stream . Builder Node Type types = Stream . builder ( ) ; for ( final Node Type type : mode Event . get Mixin Node Types ( ) ) { types . add ( type ) ; } types . add ( mode Event . get Primary Node Type ( ) ) ; return types . build ( ) . map ( Node Type :: get Name ) ; } catch ( final Repository Exception e ) { throw new Repository Runtime Exception ( e ) ; } } return empty ( ) ; }<CODESPLIT>Get the RDF Types of the resource corresponding to this JCR Event
private void process Default Header ( Context context ) { for ( String context . get File ( ) ) { ( has Header ( line ) ) { break ; } process Header Line ( line , context . get Document Model ( ) ) ; } }<CODESPLIT>Process the header of the file .
public Connection get Connection ( String url , String username , String password ) throws { boolean alive is Connection Alive ( ) ; ( ! alive ) { create Connection ( url , username , password ) ; } connection ; }<CODESPLIT>Retrieves the connection object . If the connection doesnt exist or is dead it will attempt to create a new connection .
protected static String Builder render Pad ( String Builder , int pad , boolean Line ) { render New Line ( , new Line ) ; for ( int i = 0 ; i < pad ; i ++ ) { builder . append ( ' ' ) ; } return builder ; }<CODESPLIT>Render some leading spaces onto a line of html .
public Ovh Async Array Ovh Line eligibility active POST ( Ovh City city , String contact Name , Ovh Street street , String street Number ) throws { String Path = "/ xdsl / eligibility / / active ; String = path ( Path ) ; Map String , Object > o = new Hash Map < String , Object > ( ) ; add Body ( o , " city " , city ) ; add Body ( o , " contact Name " , contact Name ) ; add Body ( o , " street " , street ) ; add Body ( o , " street Number " , street Number ) ; String resp = exec ( q Path , " POST " , sb . to String ( ) , o ) ; return convert To ( resp , t 5 ) ; }<CODESPLIT>Get the active lines at given address
private static String evaluate Expression ( Deque String operators , Deque String ) { while ( ! operators . is Empty ( ) ) { values . push ( get Boolean Result As String ( operators . pop ( ) , values . pop ( ) , values . pop ( ) ) ) ; } return replace Integer String By Boolean Representation ( values . pop ( ) ) ; }<CODESPLIT>This method takes stacks of operators and values and evaluates possible expressions This is done by popping one operator and two values applying the operator to the values and pushing the result back onto the value stack
public int write ( [ ] , int , int , boolean is ) throws { int ; long request Expire Time = _ request Expire Time ; ( request Expire Time > 0 request Expire Time Current Time . current Time ( ) ) { close ( ) ; Client Disconnect ( L . ( "{ 0 }: request timeout write exp ={ 0 } , address Remote ( ) , Current Time . current Time ( ) request Expire Time ) ) ; } synchronized ( _ write ) { long now = Current Time . get Current Time Actual ( ) ; long expires = _ socket Timeout + now ; do { result = write Native ( _ socket Fd , buffer , offset , length ) ; } while ( result == Jni Stream . TIMEOUT _ EXN && Current Time . get Current Time Actual ( ) < expires ) ; } if ( is End ) { close Write ( ) ; } return result ; }<CODESPLIT>Writes to the socket .
public void set Ambient Light ( float , float , float ) { float ambient { , , , 255 } ; normalize ( ambient ) ; gl . gl Enable ( GL 2 . GL _ LIGHTING ) ; gl . gl Enable ( GL 2 . GL _ LIGHT 0 ) ; gl . gl Lightfv ( GL 2 . GL _ LIGHT 0 , GL 2 . GL _ AMBIENT , ambient , 0 ) ; }<CODESPLIT>Sets the RGB value of the ambientLight
Big Integer set Multi Choice Count ( ) { ( fields != ) for ( int = 0 ; fields . ; i ++ ) multi Choice Count = multi Choice Count . multiply ( fields [ i ] . set Multi Choice Count ( ) ) ; return multi Choice Count ; }<CODESPLIT>Set the multiChoiceCount for this tuple
public void delete ( boolean force ) throws API { Http Response = client . delete ( get Url ( ) "? force =" force Delete ) ; Http Client Helpers . throw If Not Ok ( response ) ; }<CODESPLIT>Creates this directory vi the Algorithmia Data API
protected void add Name To Application Map ( String name ) { String Name = get Application Name ( ) ; ( Name ) ; Concurrent String list = Map . get ( app Name ) ; if ( list == null ) { Concurrent Linked Queue < String > new List = new Concurrent Linked Queue < String > ( ) ; list = application Map . put If Absent ( app Name , new List ) ; if ( list == null ) list = new List ; } list . add ( name ) ; }<CODESPLIT>Adds the metric name to an application map . This map is not a complete list of metrics owned by an application produced metrics are managed in the MetricsExtension
public static get Table ( Connection connection , Table Location location , String Field ) throws { ( Field == Field . is Empty ( ) ) { List String Fields = get Geometry Fields ( connection , location ) ; ( Fields . is Empty ( ) ) { ( The table " + location + " does not contain a Geometry field , then the extent " + " cannot be computed " ) ; } geometry Field = geometry Fields . get ( 0 ) ; } Result Set rs = connection . create Statement ( ) . execute Query ( " SELECT ST _ Extent (" + Table Location . quote Identifier ( geometry Field ) + ") ext FROM " + location ) ; if ( rs . next ( ) ) { return ( ( Geometry ) rs . get Object ( 1 ) ) . get Envelope Internal ( ) ; } throw new SQL Exception ( " Unable to get the table extent it may be empty " ) ; }<CODESPLIT>Merge the bounding box of all geometries inside the provided table .
private void do Get ( Json Object ) { String name body ( ) get String ( name ) ; ( name ) { reply ( Json Object ( ) String ( status , error ) String ( , No name specified ." ) ) ; return ; } final Integer index = message . body ( ) . get Integer ( " index " ) ; if ( index == null ) { message . reply ( new Json Object ( ) . put String ( " status " , " error " ) . put String ( " message " , " No index specified ." ) ) ; return ; } context . execute ( new Action < Object > ( ) { public Object perform ( ) { return data . get List ( format Key ( name ) ) . get ( index ) ; } } , new Handler < Async Result < Object > > ( ) { public void handle ( Async Result < Object > result ) { if ( result . failed ( ) ) { message . reply ( new Json Object ( ) . put String ( " status " , " error " ) . put String ( " message " , result . cause ( ) . get Message ( ) ) ) ; } else { message . reply ( new Json Object ( ) . put String ( " status " , " ok " ) . put Value ( " result " , result . result ( ) ) ) ; } } } ) ; }<CODESPLIT>Handles a list get .
public static Plot Canvas plot ( String id , double [ ) { Histogram histogram = Histogram ( ) ; histogram . set ID ( id ) ; double [ lower Bound = { . ( ) , 0 } ; double [ upper Bound = { . ( ) , 0 } ; double [ [ freq = histogram . get Histogram ( ) ; ( int = 0 ; < freq . length ; i ++ ) { if ( freq [ i ] [ 1 ] > upper Bound [ 1 ] ) { upper Bound [ 1 ] = freq [ i ] [ 1 ] ; } } Plot Canvas canvas = new Plot Canvas ( lower Bound , upper Bound ) ; canvas . get Axis ( 0 ) . set Grid Visible ( false ) ; canvas . add ( histogram ) ; return canvas ;<CODESPLIT>Create a plot canvas with the histogram plot .
public static List Tuple , List Tuple split Data ( List Tuple training Data , double proportion ) { ( proportion 0 proportion ) { ( Proportion should 0 . 0 . 0 ) ; } ( proportion 0 . 5 ) { proportion = proportion ; } List Tuple small List = Array List ( ) ; List Tuple > large List = new Array List < > ( ) ; int small List Size = ( int ) Math . floor ( proportion * training Data . size ( ) ) ; int ct = 0 ; Set < Integer > indices = new Hash Set < > ( ) ; while ( ct < small List Size && training Data . size ( ) > indices . size ( ) ) { int index = ( int ) ( Math . random ( ) * ( training Data . size ( ) - 1 ) ) ; while ( indices . contains ( index ) ) { index = ( int ) ( Math . random ( ) * ( training Data . size ( ) - 1 ) ) ; } indices . add ( index ) ; ct ++ ; } small List . add All ( indices . stream ( ) . map ( training Data :: get ) . collect ( Collectors . to List ( ) ) ) ; Int Stream . range ( 0 , training Data . size ( ) ) . filter ( x -> ! indices . contains ( x ) ) . for Each ( i -> large List . add ( training Data . get ( i ) ) ) ; return new Immutable Pair < > ( small List , large List ) ; }<CODESPLIT>Shuffle the data and split by proportion
public static void get Screen Shot ABGR ( Byte Buffer bgra , Buffered Image ) { Writable Raster wr = . get Raster ( ) ; Data Buffer Byte db = ( Data Buffer Byte ) wr . get Data Buffer ( ) ; [ ] Array = db . get Data ( ) ; bgra . clear ( ) ; bgra . get ( Array ) ; bgra . clear ( ) ; int width = wr . get ( ) ; int = wr . get Height ( ) ; for ( int y = 0 ; y / 2 ; y ) { for ( int x = 0 ; x < width ; x ++ ) { int in Ptr = ( y * width + x ) * 4 ; int out Ptr = ( ( height - y - 1 ) * width + x ) * 4 ; byte b 1 = cpu Array [ in Ptr + 0 ] ; byte g 1 = cpu Array [ in Ptr + 1 ] ; byte r 1 = cpu Array [ in Ptr + 2 ] ; byte a 1 = cpu Array [ in Ptr + 3 ] ; byte b 2 = cpu Array [ out Ptr + 0 ] ; byte g 2 = cpu Array [ out Ptr + 1 ] ; byte r 2 = cpu Array [ out Ptr + 2 ] ; byte a 2 = cpu Array [ out Ptr + 3 ] ; cpu Array [ out Ptr + 0 ] = a 1 ; cpu Array [ out Ptr + 1 ] = b 1 ; cpu Array [ out Ptr + 2 ] = g 1 ; cpu Array [ out Ptr + 3 ] = r 1 ; cpu Array [ in Ptr + 0 ] = a 2 ; cpu Array [ in Ptr + 1 ] = b 2 ; } } }<CODESPLIT>Good format for java swing .
public int [ ] [ ] [ ] , int [ ] To Data And Labels ( List ) { int Size = . size ( ) ; int [ ] [ ] [ ] data = int [ Size ] [ window Size ] [ ] ; int [ ] labels = int [ Size ] ; ( . Reverse ) { . ( ) ; } for ( int = 0 ; Size ; ) { CRF Datum < List < String > , CRF Label > d = make Datum ( document , j , feature Factory ) ; List < List < String > > features = d . as Features ( ) ; for ( int k = 0 , f Size = features . size ( ) ; k < f Size ; k ++ ) { Collection < String > clique Features = features . get ( k ) ; data [ j ] [ k ] = new int [ clique Features . size ( ) ] ; int m = 0 ; for ( String feature : clique Features ) { int index = feature Index . index Of ( feature ) ; if ( index >= 0 ) { m ++ ; } else { } } if ( m < data [ j ] [ k ] . length ) { int [ ] f = new int [ m ] ; System . arraycopy ( data [ j ] [ k ] , 0 , f , 0 , m ) ; data [ j ] [ k ] = f ; } } IN wi = document . get ( j ) ; labels [ j ] = class Index . index Of ( wi . get ( Answer Annotation . class ) ) ; } if ( flags . use Reverse ) { Collections . reverse ( document ) ; } return new Pair < int [ ] [ ] [ ] , int [ ] > ( data , labels ) ; }<CODESPLIT>Convert a document List into arrays storing the data features and labels .
public static synchronized List < Class < > > locate All ( final String service Name ) { ( service Name == ) { Argument ( service Name cannot ) ; } List < Class < > > = Array List < Class < ? > > ( ) ; if ( factories != null ) { List < Callable < Class < ? > > > l = factories . get ( service Name ) ; if ( l != null ) { for ( Callable < Class < ? > > c : l ) { try { classes . add ( c . call ( ) ) ; } catch ( Exception e ) { } } } } return classes ; }<CODESPLIT>Finds all providers for the given service .
String decode C String ( Byte buffer ) throws IO { int = buffer . bytes Before ( Bson Constants . STRING _ TERMINATION ) ; ( < 0 ) IO ( " string termination not " ) ; String result = buffer . to String ( buffer . reader Index ( ) , length , Standard Charsets . UTF _ 8 ) ; buffer . skip Bytes ( length + 1 ) ; return result ; }<CODESPLIT>default visibility for unit test
public void add Case ( JMF Type the Case ) { ( the Case == ) Null ( cannot ) ; JS Type Case = ( JS Type ) the Case ; ( cases == null ) cases = new JS Type [ 1 ] ; else { JS Type [ ] old Cases = cases ; cases = new JS Type [ old Cases . length + 1 ] ; System . arraycopy ( old Cases , 0 , cases , 0 , old Cases . length ) ; } new Case . parent = this ; new Case . sibling Position = cases . length - 1 ; cases [ new Case . sibling Position ] = new Case ; }<CODESPLIT>Add a case to the variant . Note that every variant must have at least one case .
public String summarize ( ) { String = String ( ) ; . append ( clip Vol =" ) . append ( _ clip Vol ) ; . append ( =[" ) ; int ii = 0 ; for ( Sound Type sound Type : _ disabled Types ) { if ( ii ++ > 0 ) { buf . append ( ", " ) ; } buf . append ( sound Type ) ; } return buf . append ( "]" ) . to String ( ) ; }<CODESPLIT>Returns a string summarizing our volume settings and disabled sound types .
private Map String , String get Map ( Pattern key Pattern ) { Map String , String map Map ( ) ; ( Iterator Object it = props . key Set ( ) . iterator ( ) ; it . has Next ( ) ; ) { String key = ( String ) it . next ( ) ; Matcher matcher = key Pattern . matcher ( key ) ; if ( matcher . matches ( ) ) { String id = matcher . group ( 2 ) ; String property Value = props . get Property ( key ) ; map . put ( id , property Value ) ; } } return map ; }<CODESPLIT>Returns the map where the key is the 2 group of the pattern and the value is the property value
public static long raw Uncompress ( long , long Size , long Addr ) throws IO Exception { return impl . raw Uncompress ( input Addr , input Size , dest Addr ) ; }<CODESPLIT>Zero - copy decompress using memory addresses .
public void write ( [ , int off , int ) { this . check Increase Array ( ) ; . arraycopy ( b , off , this . buffer , this . pos , len ) ; this . pos += len ; }<CODESPLIT>Writes a byte array content into the stream
public Operation patch Health Check ( Health Check Name health Check , Health Check health Check Resource , List String field ) { Patch Health Check Http Request request = Patch Health Check Http Request . ( ) . set Health Check ( health Check == null : health Check . to String ( ) ) . set Health Check Resource ( health Check Resource ) . add All Field Mask ( field Mask ) . build ( ) ; return patch Health Check ( request ) ; }<CODESPLIT>Updates a HealthCheck resource in the specified project using the data included in the request . This method supports PATCH semantics and uses the JSON merge patch format and processing rules .
private void initialize Nox Margin ( Typed attributes ) { float nox Margin Value get Resources ( ) get ( dimen . default _ nox _ item _ margin ) ; float nox Item Margin = attributes . get Dimension ( R . styleable . nox _ item _ margin , nox Item Margin Default Value ) ; nox Config . set Nox Item Margin ( nox Item Margin ) ; }<CODESPLIT>Configures the nox item default margin used in NoxConfig Shape and NoxItemCatalog to draw nox item instances during the onDraw execution .
public static Operation Result failed ( long index , long , Throwable error ) { Operation Result ( index , event Index , error , null ) ; }<CODESPLIT>Returns a failed operation result .
public static List Integers Equal ( List lhs , List rhs , List ) { . not Null ( lhs ) ; . not Null ( rhs ) ; . not Null ( ) ; List = Insn List ( ) ; Label Node not Equal Label Node = new Label Node ( ) ; ret . add ( lhs ) ; ret . add ( rhs ) ; ret . add ( new Jump Insn Node ( Opcodes . IF _ ICMPNE , not Equal Label Node ) ) ; ret . add ( action ) ; ret . add ( not Equal Label Node ) ; return ret ; }<CODESPLIT>Compares two integers and performs some action if the integers are equal .
public static Format Options of ( int , int width , int ) { ( ! check Flag Consistency ( , width != UNSET ) ) { Argument ( : 0 x Integer . to String ( ) ) ; } if ( ( width < 1 || width > MAX _ ALLOWED _ WIDTH ) && width != UNSET ) { throw new Illegal Argument Exception ( " invalid width : " + width ) ; } if ( ( precision < 0 || precision > MAX _ ALLOWED _ PRECISION ) && precision != UNSET ) { throw new Illegal Argument Exception ( " invalid precision : " + precision ) ; } return new Format Options ( flags , width , precision ) ; }<CODESPLIT>Creates a options instance with the given values .
public void triple Click ( where ) { Point = get Point ( where , triple click ) ; . mouse Action ( p . x , p . y , 3 , Opera Mouse Keys . LEFT ) ; }<CODESPLIT>Triple click is an Opera specific way of selecting a sentence .
private void initialize Nox Placeholder ( Typed attributes ) { Drawable placeholder attributes get Drawable ( R styleable nox item placeholder ) ; if ( placeholder == null ) { placeholder = get Context ( ) . get Resources ( ) . get Drawable ( R . drawable . ic _ nox ) ; } nox Config . set Placeholder ( placeholder ) ; }<CODESPLIT>Configures the placeholder used if there is no another placeholder configured in the NoxItem instances during the onDraw execution .
public void prune ( Explorer Output output , Keys Keys ) { Graph . Graph Pruner pruned Graph = Graph . Graph Pruner ( output . get Graph ( ) ) ; ( Key < ? > key : invalid Keys . get Invalid Optional Keys ( ) ) { pruned Graph . remove ( key ) ; output . remove Binding ( key ) ; } output . set Graph ( pruned Graph . update ( ) ) ; }<CODESPLIT>Prune all of the invalid optional keys from the graph . After this method all of the keys remaining in the graph are resolvable .
private Persistent Resource XML Description get ( ) { ( version . equals ( . _ _ 0 ) ) { return Mapper Parser _ 1 _ 0 ; } else if ( version . equals ( Version . VERSION _ 1 _ 1 ) ) { return simple Mapper Parser _ 1 _ 1 ; } return simple Mapper Parser ; }<CODESPLIT>1 . 0 version of parser is different at simple mapperParser
public String get Absolute Template ( String template Name , boolean include ) { Fast String Writer Fast String Writer ( ) ; String template Name . ( , template Name . ( ) ) ; ( . index Of ( ) ) { . append ( ) ; int = tmp . last Index Of ( SLASH ) ; buf . append ( tmp . substring ( 0 , i ) ) ; buf . append ( SLASH _ UNDR ) ; buf . append ( tmp . substring ( i + 1 , tmp . length ( ) ) ) ; } else { buf . append ( SLASH _ UNDR ) ; buf . append ( template Name . substring ( 1 , template Name . length ( ) ) ) ; } if ( include Extension ) { buf . append ( EXTENSION ) ; } String uri = buf . to String ( ) ; buf . close ( ) ; return uri ; }<CODESPLIT>Used to resolve template names that are not relative to a controller .
protected void scan Resource Paths ( String start Path ) throws , { String List = context . get Resource Paths ( start Path ) ; ( List ) { for ( String path List ) { ( path . With ( "/ WEB / classes /" ) ) { } else if ( path . starts With ( "/ WEB - INF / lib /" ) ) { } else if ( path . ends With ( "/" ) ) { scan Resource Paths ( path ) ; } else if ( path . starts With ( "/ WEB - INF / tags /" ) ) { if ( path . ends With ( "/ implicit . tld " ) ) { parse Tld ( path ) ; } } else if ( path . ends With ( TLD _ EXT ) ) { parse Tld ( path ) ; } } } }<CODESPLIT>Scan web application resources for TLDs recursively .
protected boolean Drag ( SVG Point start Point , SVG Point drag Point , Event , boolean inside ) { ( listener ) { listener . during Drag ( start Point , drag Point , evt , inside ) ; } return true ; }<CODESPLIT>Method called during drags .
private PGP Ring create Ring ( String user Id , String password , ) { ( create Ring ( String , String , )" ) ; ( User {}, {}, {}" , user Id , password not set "********" , ) ; PGP Ring generator ; { ( Creating RSA pair generator ) ; RSA generator RSA ( ) ; generator init ( RSA Generation Parameters ( Big Integer value Of ( 0 x 10001 ) , get Secure Random ( ) , key Size , 12 ) ) ; LOGGER . debug ( " Generating Signing Key Pair " ) ; Bc PGP Key Pair signing Key Pair = new Bc PGP Key Pair ( PGP Public Key . RSA _ SIGN , generator 1 . generate Key Pair ( ) , new Date ( ) ) ; LOGGER . debug ( " Generating Encyption Key Pair " ) ; Bc PGP Key Pair encryption Key Pair = new Bc PGP Key Pair ( PGP Public Key . RSA _ ENCRYPT , generator 1 . generate Key Pair ( ) , new Date ( ) ) ; LOGGER . debug ( " Generating Signature Key Properties " ) ; PGP Signature Subpacket Generator signature Subpacket Generator = new PGP Signature Subpacket Generator ( ) ; signature Subpacket Generator . set Key Flags ( false , Key Flags . SIGN _ DATA | Key Flags . CERTIFY _ OTHER ) ; signature Subpacket Generator . set Preferred Symmetric Algorithms ( false , get Preferred Encryption Algorithms ( ) ) ; signature Subpacket Generator . set Preferred Hash Algorithms ( false , get Preferred Hashing Algorithms ( ) ) ; signature Subpacket Generator . set Preferred Compression Algorithms ( false , get Preferred Compression Algorithms ( ) ) ; LOGGER . debug ( " Generating Encyption Key Properties " ) ; PGP Signature Subpacket Generator encryption Subpacket Generator = new PGP Signature Subpacket Generator ( ) ; encryption Subpacket Generator . set Key Flags ( false , Key Flags . ENCRYPT _ COMMS | Key Flags . ENCRYPT _ STORAGE ) ; LOGGER . info ( " Creating PGP Key Ring Generator " ) ; generator = new PGP Key Ring Generator ( PGP Public Key . RSA _ SIGN , signing Key Pair , user Id , new Bc PGP Digest Calculator Provider ( ) . get ( Hash Algorithm Tags . SHA 1 ) , signature Subpacket Generator . generate ( ) , null , new Bc PGP Content Signer Builder ( PGP Public Key . RSA _ SIGN , Hash Algorithm Tags . SHA 256 ) , new Bc PBE Secret Key Encryptor Builder ( get Encryption Algorithm ( ) ) . build ( password . to Char Array ( ) ) ) ; generator . add Sub Key ( encryption Key Pair , encryption Subpacket Generator . generate ( ) , null ) ; } catch ( PGP Exception e ) { LOGGER . error ( "{}" , e . get Message ( ) ) ; generator = null ; } return generator ; }<CODESPLIT>creates and initializes a PGP Key Ring Generator
public static Date get Date From String ( final String String , final String pattern ) { { Date Format df = build Date Format ( pattern ) ; return df . parse ( String ) ; } ( Parse ) { Date Exception ( String . format ( " Could not parse % s with pattern % s ." , date String , pattern ) , e ) ; } }<CODESPLIT>Get data from data string using the given pattern and the default date format symbols for the default locale .
public Object remove ( Object key ) { synchronized ( L 2 ) { ( L contains Key ( key ) L 2 contains Key ( key ) ) { return null ; } Object retval ; Map new Map ; synchronized ( _ cache L 1 ) { new Map = Hash Map Utils . merge ( _ cache L 1 , _ cache L 2 ) ; retval = new Map . remove ( key ) ; } _ cache L 1 = new Map ; _ cache L 2 . clear ( ) ; _ miss Count = 0 ; return retval ; } }<CODESPLIT>This operation is very expensive . A full copy of the Map is created
private get Cmdb cmdb ) { item ; cmdb get ) ; cmdb get ) ; hpsm Settings hpsm Settings get App ) ; hpsm Settings hpsm Settings get App ) ; boolean false ; boolean sub Type Check = false ; if ( ! "" . equals ( hpsm Settings Type ) ) { type Check = true ; } if ( ! "" . equals ( hpsm Settings Sub Type ) ) { sub Type Check = true ; } if ( ! type Check && sub Type Check ) { if ( sub Type != null && sub Type . equals ( hpsm Settings . get App Sub Type ( ) ) ) { item Type = APP _ TYPE ; } else if ( sub Type != null && sub Type . equals ( hpsm Settings . get Comp Sub Type ( ) ) ) { item Type = COMPONENT _ TYPE ; } else if ( sub Type != null && sub Type . equals ( hpsm Settings . get Env Sub Type ( ) ) ) { item Type = ENVIRONMENT _ TYPE ; } } else if ( type Check && ! sub Type Check ) { if ( type != null && type . equals ( hpsm Settings . get App Type ( ) ) ) { item Type = APP _ TYPE ; } else if ( type != null && type . equals ( hpsm Settings . get Comp Type ( ) ) ) { item Type = COMPONENT _ TYPE ; } else if ( type != null && type . equals ( hpsm Settings . get Env Type ( ) ) ) { item Type = ENVIRONMENT _ TYPE ; } } else { if ( sub Type != null && sub Type . equals ( hpsm Settings . get App Sub Type ( ) ) && type != null && type . equals ( hpsm Settings . get App Type ( ) ) ) { item Type = APP _ TYPE ; } else if ( sub Type != null && sub Type . equals ( hpsm Settings . get Comp Sub Type ( ) ) && type != null && type . equals ( hpsm Settings . get Comp Type ( ) ) ) { item Type = COMPONENT _ TYPE ; } else if ( sub Type != null && sub Type . equals ( hpsm Settings . get Env Sub Type ( ) ) && type != null && type . equals ( hpsm Settings . get Env Type ( ) ) ) { } } return item Type ; }<CODESPLIT>Returns the type of the configuration item .
public void read XML ( List String _ tags , Map String , String _ attributes , String _ text ) throws , E Faps { ( _ tags . size ( ) ) { String value = _ tags . get ( 0 ) ; ( uuid . equals ( value ) ) { this . uuid = _ text ; } ( file . equals ( value ) ) { this . file Application = _ text ; } if ( " definition " . equals ( value ) ) { this . definitions . add ( new Definition ( ) ) ; } } else if ( " definition " . equals ( _ tags . get ( 0 ) ) ) { final Abstract Definition cur Def = this . definitions . get ( this . definitions . size ( ) - 1 ) ; cur Def . read XML ( _ tags . sub List ( 1 , _ tags . size ( ) ) , _ attributes , _ text ) ; } else { throw new SAX Exception ( " Unknown XML Tag : " + _ tags + " for : " + this . install File ) ; } }<CODESPLIT>Read event for given tags path with attributes and text .
public String get Update ( boolean Current Values ) { String Recordset = this . get Base Record ( ) . make Table Names ( ) ; Key Area key Area = this . get Base Record ( ) . get Key Area ( 0 ) ; boolean Current Key Values = Current Values key Area . is Null ( . TEMP AREA , ) ; boolean Is Query Record = this . get Base Record ( ) . is Query Record ( ) ; String Filter = key Area . add Select ( "=" , . TEMP KEY _ AREA , false , b Is Query Record , b Use Current Key Values , null , true , true ) ; if ( s Filter . length ( ) > 0 ) s Filter = " WHERE " + s Filter ; String str Set Values = this . get Base Record ( ) . get SQL Fields ( DB Constants . SQL _ UPDATE _ TYPE , b Use Current Values ) ; if ( str Set Values . length ( ) == 0 ) return null ; str Recordset = " UPDATE " + str Recordset + " SET " + str Set Values + s Filter ; return str Recordset ; }<CODESPLIT>Get the SQL Update string . UPDATE table SET field1 = value1 field2 = value2 WHERE key = value
public static synchronized void verify ( Object ... objects ) { for ( Object : objects ) { ( Class < > ) { verify Class ( ( Class < > ) ) ; } { Easy Mock Method Invocation Control invocation Control = ( Easy Mock Method Invocation Control ) Mock Repository . get Instance Method Invocation Control ( ) ; ( invocation Control != ) { invocation Control . verify ( ) ; } { ( is Nice Replay And Verify Mode ( ) ! is Easy Mocked ( ) ) { } { try { org . easymock . Easy Mock . verify ( mock ) ; } catch ( Runtime Exception e ) { throw new Runtime Exception ( mock + " is not a mock object " , e ) ; } } } } } }<CODESPLIT>Switches the mocks or classes to verify mode . Note that you must use this method when using PowerMock!
public void map Tile Request Failed ( Map Tile Request ) { ( Tile Not Found Image ) { put Tile Into Cache ( . get Map Tile ( ) , Tile Not Found Image , Expirable Bitmap Drawable . NOT _ ) ; ( Handler Tile Request Complete Handlers ) { ( != null ) { handler . send Empty Message ( MAPTILE _ SUCCESS _ ID ) ; } } } else { for ( final Handler handler : m Tile Request Complete Handlers ) { if ( handler != null ) { handler . send Empty Message ( MAPTILE _ FAIL _ ID ) ; } } } if ( Configuration . get Instance ( ) . is Debug Tile Providers ( ) ) { Log . d ( I Map View . LOGTAG , " Map Tile Provider Base . map Tile Request Failed (): " + Map Tile Index . to String ( p State . get Map Tile ( ) ) ) ; } }<CODESPLIT>Called by implementation class methods indicating that they have failed to retrieve the requested map tile . a MAPTILE_FAIL_ID message is sent .
static void validate Factory And Class ( Field fd , int factory Id , int class Id , String Path ) { ( factory Id fd . get Factory Id ( ) ) { ( factory Id ! Expected fd . get Factory Id ( ) + ", Current : " + factory Id + " in path " + full Path ) ; } if ( class Id != fd . get Class Id ( ) ) { throw new Illegal Argument Exception ( " Invalid class Id ! Expected : " + fd . get Class Id ( ) + ", Current : " + class Id + " in path " + full Path ) ; } }<CODESPLIT>Validates if the given factoryId and classId match the ones from the fieldDefinition
public static String get Label For ( Input Component , , boolean add Colon ) { String = . get Label ( ) ; ( label == null ) { label = input . get Name ( ) ; } if ( add Colon && ! label . ends With ( COLON ) ) { label += COLON ; } return label ; }<CODESPLIT>Returns the label for this component
protected View inflate Placeholder View ( View convert View , int ) { View view = convert View ; ( ! ( view Placeholder View ) ) { view = new Placeholder View ( get Context ( ) ) ; } view . set Minimum Height ( height ) ; return view ; }<CODESPLIT>Inflates an invisible placeholder view with a specific height .
public void stop ( ) throws { ( , stop " , " Stopping Ldap Server " ) ; this . server . stop ( ) ; Log . info ( c , " stop Service " , " Stopping Directory Service " ) ; service . shutdown ( ) ; Log . info ( c , " stop Service " , " Ldap stopped ." ) ; }<CODESPLIT>Stop the LdapServer and the Directory service . Use for JUnit teardown . If the service is not stopped then future instances with the same name cannot clean up the file directory .
public void set Cache Minutes ( int Minutes ) { ( Minutes == 1 ) Minutes = _ CACHED _ MINUTES ; Minutes = Minutes ; ( Minutes == 0 ) { ( timer Cache ) { timer Cache . ( ) ; timer Cache = null ; this . stop Cache ( ) ; } } else { if ( timer Cache != null ) { timer Cache . cancel ( ) ; } this . start Cache ( ) ; timer Task = new DB Timer Task ( ) ; timer Cache = new java . util . Timer ( ) ; timer Cache . schedule ( timer Task , cache Minutes * 60 * 1000 ) ; } }<CODESPLIT>This will set this database to start caching records until they haven t been used for iMinutes minutes .
protected void propagate On Enter ( GVR Picked Object hit ) { GVR Scene Object hit Object = hit . get Object ( ) ; GVR Event event = get GVR Context ( ) . get Event ( ) ; ( Event . contains ( Event . SEND TOUCH EVENTS ) ) { ( Event Options . contains ( Event Options . SEND _ TO _ LISTENERS ) ) { event Manager . send Event ( this , I Touch Events . class , " on Enter " , hit Object , hit ) ; } if ( m Event Options . contains ( Event Options . SEND _ TO _ HIT _ OBJECT ) ) { event Manager . send Event ( hit Object , I Touch Events . class , " on Enter " , hit Object , hit ) ; } if ( m Event Options . contains ( Event Options . SEND _ TO _ SCENE ) && ( m Scene != null ) ) { event Manager . send Event ( m Scene , I Touch Events . class , " on Enter " , hit Object , hit ) ; } } if ( m Event Options . contains ( Event Options . SEND _ PICK _ EVENTS ) ) { if ( m Event Options . contains ( Event Options . SEND _ TO _ LISTENERS ) ) { event Manager . send Event ( this , I Pick Events . class , " on Enter " , hit Object , hit ) ; } if ( m Event Options . contains ( Event Options . SEND _ TO _ HIT _ OBJECT ) ) { event Manager . send Event ( hit Object , I Pick Events . class , " on Enter " , hit Object , hit ) ; } event Manager . send Event ( m Scene , I Pick Events . class , " on Enter " , hit Object , hit ) ; } } }<CODESPLIT>Propagate onEnter events to listeners
public java . . concurrent . Future Get Quota Result get Quota Async ( . amazonaws . handlers . Async Handler Get Send Quota Request , Get Send Quota Result > async Handler ) { return get Send Quota Async ( new Get Send Quota Request ( ) , async Handler ) ; }<CODESPLIT>Simplified method form for invoking the GetSendQuota operation with an AsyncHandler .
public short short Value ( ) throws Otp Erlang Range { final long = long Value ( ) ; final short = ( short ) ; ( != ) { throw new Otp Erlang Range Exception ( " Value too large for short : " + val ) ; } return i ; }<CODESPLIT>Get this number as a short .
private Mjdbc Prefix ( String reason , String , int Code , ) { Mjdbc = ; String = get Sql ( ) ; String Prefix = ; ( . ( ) >= 2 ) { Prefix = sql State . substring ( 0 , 2 ) ; if ( Spring Exception Handler Constants . SQL _ STATE _ PREFIX _ BAD _ SQL _ GRAMMAR . contains ( sql State Prefix ) == true ) { result = new Bad Sql Grammar Exception ( reason , SQL State , vendor Code ) ; } else if ( Spring Exception Handler Constants . SQL _ STATE _ PREFIX _ DATA _ INTEGRITY _ VIOLATION . contains ( sql State Prefix ) == true ) { result = new Data Integrity Violation Exception ( reason , SQL State , vendor Code ) ; } else if ( Spring Exception Handler Constants . SQL _ STATE _ PREFIX _ DATA _ ACCESS _ RESOURCE _ FAILURE . contains ( sql State Prefix ) == true ) { result = new Data Access Resource Failure Exception ( reason , SQL State , vendor Code ) ; } else if ( Spring Exception Handler Constants . SQL _ STATE _ PREFIX _ TRANSIENT _ DATA _ ACCESS _ RESOURCE _ EXCEPTION . contains ( sql State Prefix ) == true ) { result = new Transient Data Access Resource Exception ( reason , SQL State , vendor Code ) ; } else if ( Spring Exception Handler Constants . SQL _ STATE _ PREFIX _ CONCURRENCY _ FAILURE . contains ( sql State Prefix ) == true ) { result = new Concurrency Failure Exception ( reason , SQL State , vendor Code ) ; } } return result ; }<CODESPLIT>Checks SQL state and tries to convert it into Spring SQL Exception . This implementation is vendor free .
public boolean ( String name ) { ( name == ) { return pattern . equals ( ) ; } ( all ) { return all . equals ( name ) ; } ( != null ) { return name . contains ( middle ) ; } if ( start != null && ! name . starts With ( start ) ) { return false ; } return end == null || name . ends With ( end ) ; }<CODESPLIT>Checks if Simon name matches this pattern .
public static nslimitselector get ( nitro _ , String selectorname ) throws { nslimitselector = nslimitselector ( ) ; . set _ selectorname ( selectorname ) ; nslimitselector response = ( nslimitselector ) obj . get _ resource ( service ) ; return response ; }<CODESPLIT>Use this API to fetch nslimitselector resource of given name .
public static int Quad ( double eqn , double res ) { double a = eqn 2 ; double = eqn ; double = eqn 0 ; int rc = 0 ; ( a 0 f ) { ( == 0 f ) { return - 1 ; } res [ rc ++ ] = - c / b ; } else { double d = b * b - 4 f * a * c ; if ( d < 0 f ) { return 0 ; } d = Math . sqrt ( d ) ; res [ rc ++ ] = ( - b + d ) / ( a * 2 f ) ; if ( d != 0 f ) { res [ rc ++ ] = ( - b - d ) / ( a * 2 f ) ; } } return fix Roots ( res , rc ) ; }<CODESPLIT>Solves quadratic equation
public Term get All Terms ( ) { Term = new Hash Set < Term > ( ) ; for ( final Statement Group sg : statement Groups ) { for ( final Statement stmt : sg . get All Statements ( ) ) { ret . add All ( stmt . get All Terms ( ) ) ; } } return ret ; }<CODESPLIT>Returns the set of all terms contained within the document .
public void ( Operation ) throws { ( ! has ( ) ) { PSQL ( GT . tr ( Tried to an inactive copy operation ) , PSQL State . OBJECT _ NOT _ IN _ STATE ) ; } error = ; int = 0 ; { ( In ) { synchronized ( this ) { . log ( Level . FINEST , FE => Fail ) ; final [ ] = . encode 8 ( requested ) ; pg Stream . send Char ( ' f ' ) ; pg Stream . send Integer 4 ( 5 . ) ; pg Stream . send ( msg ) ; pg Stream . send Char ( 0 ) ; pg Stream . flush ( ) ; do { try { process Copy Results ( op , true ) ; } catch ( SQL Exception se ) { errors ++ ; if ( error != null ) { SQL Exception e = se ; SQL Exception next ; while ( ( next = e . get Next Exception ( ) ) != null ) { e = next ; } e . set Next Exception ( error ) ; } } } while ( has Lock ( op ) ) ; } } else if ( op instanceof Copy Out ) { send Query Cancel ( ) ; } } catch ( IO Exception ioe ) { throw new PSQL Exception ( GT . tr ( " Database connection failed when canceling copy operation " ) , PSQL State . CONNECTION _ FAILURE , ioe ) ; } finally { synchronized ( this ) { if ( has Lock ( op ) ) { unlock ( op ) ; } } } if ( op instanceof Copy In ) { if ( errors < 1 ) { throw new PSQL Exception ( GT . tr ( " Missing expected error response to copy cancel request " ) , PSQL State . COMMUNICATION _ ERROR ) ; } else if ( errors > 1 ) { throw new PSQL Exception ( GT . tr ( " Got { 0 } error responses to single copy cancel request " , String . value Of ( errors ) ) , PSQL State . COMMUNICATION _ ERROR , error ) ; } } }<CODESPLIT>Finishes a copy operation and unlocks connection discarding any exchanged data .
public . . . ads . adwords . . v 201809 . o . Attribute Type [ ] get Requested Attribute Types ( ) { return requested Attribute Types ; }<CODESPLIT>Gets the requestedAttributeTypes value for this TargetingIdeaSelector .
public void set ( Annotation v ) { ( Ont Relation Mention _ Type . ( ( Ont Relation Mention _ Type ) Type ) . cas Feat _ == ) Type . . Feat Missing ( " range " , " de . julielab . jules . types . Ont Relation Mention " ) ; jcas Type . ll _ cas . ll _ set Ref Value ( addr , ( ( Ont Relation Mention _ Type ) jcas Type ) . cas Feat Code _ range , jcas Type . ll _ cas . ll _ get FS Ref ( v ) ) ; }<CODESPLIT>setter for range - sets
public List com . ibm . wsspi . . wim . model . Player get Related Player ( ) { ( Role Player == null ) { related Role Player = new Array List < com . ibm . wsspi . security . wim . model . Role Player > ( ) ; } return this . related Role Player ; }<CODESPLIT>Gets the value of the relatedRolePlayer property .
public JC Expression get Underlying Binding ( Unifier unifier ) { return ( unifier == ) unifier . get Binding ( new U Free Ident . Key ( identifier ( ) ) ) ; }<CODESPLIT>Gets the binding of the underlying identifier in the unifier .
public void clear ( ) { clear ( Commerce Price Entry ) ; finder Cache . clear Cache ( FINDER _ CLASS _ NAME _ ENTITY ) ; finder Cache . clear Cache ( FINDER _ CLASS _ NAME _ LIST _ WITH _ PAGINATION ) ; finder Cache . clear Cache ( FINDER _ CLASS _ NAME _ LIST _ WITHOUT _ PAGINATION ) ; }<CODESPLIT>Clears the cache for all commerce price entries .
private int compute Capacity ( int ) { ( MINIMUM _ CAPACITY ) { return MINIMUM _ CAPACITY ; } ( > MAXIMUM _ CAPACITY ) { return MAXIMUM _ CAPACITY ; } int capacity = 1 ; while ( capacity < initial ) { capacity <<= 1 ; } return capacity ; }<CODESPLIT>Compute capacity given initial capacity .
public V get ( k , long timeout , Time unit ) throws , Timeout Exception { await ( k , timeout , unit ) ; return cache . get ( k ) ; }<CODESPLIT>Retrieve the value associated with the given key blocking as long as necessary up to the specified maximum .
public static void Classpath ( Path Class Path , Path intermediate Class Path , ) throws { String classpath Property = . get Property ( druid . hadoop . internal . classpath ) ; ( classpath Property == ) { classpath Property = . get Property ( java . class . path ) ; } String [ ] jar Files = classpath Property . split ( File . path ) ; Configuration conf = . get Configuration ( ) ; File = Class Path . get File ( conf ) ; ( Local File System ) { return ; } for ( String jar File Path : jar Files ) { final File jar File = new File ( jar File Path ) ; if ( jar File . get Name ( ) . ends With ( ". jar " ) ) { try { Retry Utils . retry ( ( ) -> { if ( is Snapshot ( jar File ) ) { add Snapshot Jar To Class Path ( jar File , intermediate Class Path , fs , job ) ; } else { add Jar To Class Path ( jar File , distributed Class Path , intermediate Class Path , fs , job ) ; } return true ; } , should Retry Predicate ( ) , NUM _ RETRIES ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } } } }<CODESPLIT>Uploads jar files to hdfs and configures the classpath . Snapshot jar files are uploaded to intermediateClasspath and not shared across multiple jobs . Non - Snapshot jar files are uploaded to a distributedClasspath and shared across multiple jobs .
public void ( String javascript ) throws Widget { Web Element = find Element ( false ) ; Web Driver wd = get GUI Driver ( ) . get Wrapped Driver ( ) ; { ( ( Javascript ) wd ) . execute Script ( javascript , ) ; } ( ) { long time = . current Time Millis ( ) 2000 ; boolean success = false ; ( ! success . current Time Millis ( ) time ) { { ( ( Javascript Executor ) wd ) . execute Script ( javascript , element ) ; success = true ; } catch ( Exception e 2 ) { try { Thread . sleep ( 500 ) ; } catch ( Interrupted Exception e 1 ) { } e = e 2 ; } } if ( ! success ) { throw new Runtime Exception ( e ) ; } }<CODESPLIT>Executes JavaScript code on the current element in the current frame or window .
public long add Field ( long instant , int ) { return set ( instant , Field . get Wrapped Value ( get ( instant ) , , 0 , Divisor - 1 ) ) ; }<CODESPLIT>Add the specified amount to the specified time instant wrapping around within the remainder range if necessary . The amount added may be negative .
protected synchronized Request make Channel Contract ( Coin value To Me ) { Transaction Transaction ( wallet get ( ) ) ; ( ! get Total Value ( ) subtract ( value To Me ) ( Coin ZERO ) ) { tx . add Output ( get Total Value ( ) . subtract ( value To Me ) , Legacy Address . from Key ( wallet . get Params ( ) , get Client Key ( ) ) ) ; } tx . add Input ( contract . get Output ( 0 ) ) ; return Send Request . for Tx ( tx ) ; }<CODESPLIT>Create a payment transaction with valueToMe going back to us
public static String get User Name From Token ( String Token ) { ( Token ) { return null ; } return auth Token . split ( TOKEN _ SEPARATOR ) [ 0 ] ; }<CODESPLIT>Extracts the user name from token .
protected Class > resolve Proxy Class ( String [ ] Names ) throws Class Not Found { Class Loader Class Loader = class Loader ; Class > [ ] = Class [ Names . ] ; Class > non = ; for ( int = 0 ; Names . ; ) { Class ? > intf = load Class ( interface Names [ i ] ) ; if ( ! Modifier . is Public ( intf . get Modifiers ( ) ) ) { Class Loader class Loader = get Class Loader ( intf ) ; if ( non Public Interface != null ) { if ( class Loader != proxy Class Loader ) { throw new Illegal Access Error ( non Public Interface + " and " + intf + " both declared non - public in different class loaders " ) ; } } else { non Public Interface = intf ; proxy Class Loader = class Loader ; } } interfaces [ i ] = intf ; } try { return Proxy . get Proxy Class ( proxy Class Loader , interfaces ) ; } catch ( Illegal Argument Exception ex ) { throw new Class Not Found Exception ( null , ex ) ; } }<CODESPLIT>Delegates class loading to the specified class loader .
public static double [ ] row Sums ( double [ ] [ ] data ) { double [ ] = double [ data . ] ; ( int = 0 ; x . length ; i ++ ) { x [ i ] = sum ( data [ i ] ) ; } return x ; }<CODESPLIT>Returns the row sums for a matrix .
protected void rehash ( int Capacity ) { int Capacity = table . ; long Table [ ] = table ; int Values [ ] = ; long Table [ ] = long [ Capacity ] ; int Values [ ] = int [ Capacity ] ; State [ ] = [ new Capacity ] ; this . low Water Mark = choose Low Water Mark ( new Capacity , this . min Load Factor ) ; this . high Water Mark = choose High Water Mark ( new Capacity , this . max Load Factor ) ; this . table = new Table ; this . values = new Values ; this . state = new State ; this . free Entries = new Capacity - this . distinct ; for ( int i = old Capacity ; i -- > 0 ; ) { if ( old State [ i ] == FULL ) { long element = old Table [ i ] ; int index = index Of Insertion ( element ) ; new Table [ index ] = element ; new Values [ index ] = old Values [ i ] ; new State [ index ] = FULL ; } } }<CODESPLIT>Rehashes the contents of the receiver into a new table with a smaller or larger capacity . This method is called automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water mark .
public void add ( Hpack Header Field header ) { int header = header . size ( ) ; ( header ) { clear ( ) ; return ; } ( size header Size ) { remove ( ) ; } hpack Header Fields [ head ++ ] = header ; size += header . size ( ) ; if ( head == hpack Header Fields . length ) { head = 0 ; } }<CODESPLIT>Add the header field to the dynamic table . Entries are evicted from the dynamic table until the size of the table and the new header field is less than or equal to the table s capacity . If the size of the new entry is larger than the table s capacity the dynamic table will be cleared .
private void fired ( Direction ) { ( Launcher Listener listener listeners Launcher ) { listener notify Fired ( ) ; } ( Launchable Config launchable Config launchables ) { Media media Medias create ( launchable Config get Media ( ) ) ; Featurable featurable factory create ( media ) ; { final Launchable launchable = featurable . get Feature ( Launchable . class ) ; if ( launchable Config . get Delay ( ) > 0 ) { delayed . add ( new Delayed Launch ( launchable Config , initial , featurable , launchable ) ) ; } else { launch ( launchable Config , initial , featurable , launchable ) ; } } catch ( final Lion Engine Exception exception ) { featurable . get Feature ( Identifiable . class ) . destroy ( ) ; throw exception ; } } }<CODESPLIT>Called when fire is performed .
public static void init ( Invocation invmgr , Root Object omgr ) { invmgr invmgr ; _ omgr = omgr ; invmgr . register Provider ( new Time Base Provider ( ) , Time Base Marshaller . class , GLOBAL _ GROUP ) ; }<CODESPLIT>Registers the time provider with the appropriate managers . Called by the presents server at startup .
static Ufs Journal File create File ( location , long start , long end ) { Ufs Journal File ( location , start , end , false ) ; }<CODESPLIT>Creates a journal log file .
protected Object write Replace ( ) throws java . . Object Stream { { return Certificate Rep ( type , get Encoded ( ) ) ; } ( Certificate ) { new java . io . Not Serializable Exception ( " java . security . cert . Certificate : " + type + ": " + e . get Message ( ) ) ; } }<CODESPLIT>Replace the Certificate to be serialized .
private static Throwable extract Throwable ( final Object [ ] ) { return . == 0 null : extract Throwable ( arguments [ arguments . length - 1 ] ) ; }<CODESPLIT>Returns a throwable if the last argument is one .
public static List Map Bond , Bond make Bond Maps Of Atom Maps ( Atom Container , Atom Container 2 , List Map < I Atom , I Atom > > mappings ) { List < Map < I Bond , I Bond > > bond Maps = new Array List < Map < I Bond , I Bond > > ( ) ; for ( Map < I Atom , I Atom > mapping : mappings ) { bond Maps . add ( make Bond Map Of Atom Map ( ac 1 , ac 2 , mapping ) ) ; } return bond Maps ; }<CODESPLIT>Returns bond maps between source and target molecules based on the atoms
public Long Constant add Long ( long value ) { Long Constant = get Long By Value ( value ) ; ( ) ; entry = new Long Constant ( this , _ entries . size ( ) , value ) ; add Constant ( entry ) ; add Constant ( null ) ; return entry ; }<CODESPLIT>Adds a long constant .
public Package get Or ( String name , File file ) { get Or Open ( name , file , true ) ; }<CODESPLIT>Get the cached GeoPackage or open and cache the GeoPackage file
public static int extract Version From Schema Name ( String clz _ name ) { int = clz _ name . last Index Of ( ' V ' ) ; ( == 1 ) return 1 ; { return Integer . value Of ( clz _ name . ( + 1 ) ) ; } catch ( Number Format Exception ex ) { return - 1 ; } }<CODESPLIT>Extract the version number from the schema class name . Returns - 1 if there s no version number at the end of the classname .
private void draw Shape ( Canvas , Paint paint , Path path , Shape Appearance Appearance , bounds ) { ( Appearance . is Round ( ) ) { float corner Size = shape Appearance Model . get Top Right Corner ( ) . get Corner Size ( ) ; canvas . draw Round Rect ( bounds , corner Size , corner Size , paint ) ; } else { canvas . draw Path ( path , paint ) ; } }<CODESPLIT>Draw the path or try to draw a round rect if possible .
public get ( String descriptor Name , String analyzer Name , String analyzer Input Name ) { List candidates = Array List ( _ ) ; candidates = Collection 2 . refine Candidates ( candidates , -> { String Descriptor Name = . get Descriptor ( ) . get Name ( ) ; return descriptor Name . equals ( Descriptor Name ) ; } ) ; ( analyzer Name ) { candidates = Collection 2 . refine Candidates ( candidates , -> { String Analyzer Name = o . get Name ( ) ; return analyzer Name . equals ( actual Analyzer Name ) ; } ) ; } if ( analyzer Input Name != null ) { candidates = Collection Utils 2 . refine Candidates ( candidates , o -> { final Input Column < ? > input Column = get Identifying Input Column ( o ) ; if ( input Column == null ) { return false ; } return analyzer Input Name . equals ( input Column . get Name ( ) ) ; } ) ; } if ( candidates . is Empty ( ) ) { logger . error ( " No more Analyzer Job candidates to choose from " ) ; return null ; } else if ( candidates . size ( ) > 1 ) { logger . warn ( " Multiple ({}) Analyzer Job candidates to choose from , picking first " ) ; } return candidates . iterator ( ) . next ( ) ; }<CODESPLIT>Gets the best candidate analyzer job based on search criteria offered in parameters .
public boolean remove Trade Callback ( Bitfinex Trade trade , final Bi Consumer < Bitfinex Executed Trade Symbol , Bitfinex Executed Trade > callback ) throws Bitfinex Client Exception { return trades Callbacks . remove Callback ( trade Symbol , callback ) ; }<CODESPLIT>Remove a executed trade callback
public Health Dto do Health Check ( ) { List Health primary Health Dependencies = health Dependencies . ( ) . stream ( ) . filter ( Health :: is Primary ) . collect ( Collectors . to List ( ) ) ; return check Health ( primary Health Dependencies ) ; }<CODESPLIT>Performs the Primary Health Check .
public static appfwxmlerrorpage get ( nitro _ ) throws { appfwxmlerrorpage = appfwxmlerrorpage ( ) ; appfwxmlerrorpage [ ] response = ( appfwxmlerrorpage [ ] ) obj . get _ resources ( service ) ; return response [ 0 ] ; }<CODESPLIT>Use this API to fetch all the appfwxmlerrorpage resources that are configured on netscaler .
private void Client ( Http Client client ) { this . client . add Response Interceptor ( Http Response Interceptor ( ) { public void process ( Http Response , Http Context context ) throws Http , Exception { Header header = response . get First Header ( " Location " ) ; if ( header != null ) context . set Attribute ( " Location " , header . get Value ( ) ) ; } } ) ; }<CODESPLIT>This method is used to capture Location headers after HttpClient redirect handling .
private void quick Select ( List P , int split Axis , int median ) { int Points = . size ( ) ; ( . Points ) { = new double [ num Points ] ; indexes = new int [ num Points ] ; } for ( int i = 0 ; i < num Points ; i ++ ) { tmp [ i ] = distance . value At ( points . get ( i ) , split Axis ) ; } Quick Select . select Index ( tmp , median Num , num Points , indexes ) ; }<CODESPLIT>Uses quick - select to find the median value
public void write Html ( Jsp Writer Out , String Html ) throws { String = String ( Html , "<>&" , ) ; ( . has More ( ) ) { String = parser . next Token ( ) ; if ( token . equals ( "<" ) ) { p Out . print ( "& lt ;" ) ; } else if ( token . equals ( ">" ) ) { p Out . print ( "& gt ;" ) ; } else if ( token . equals ( "&" ) ) { p Out . print ( "& amp ;" ) ; } else { p Out . print ( token ) ; } } }<CODESPLIT>writeHtml ensures that the text being outputted appears as it was entered . This prevents users from hacking the system by entering html or jsp code into an entry form where that value will be displayed later in the site .
protected String get Node Name ( Node ) { String = . get Name ( ) ; return result == null ? node . get Node Name ( ) : result ; }<CODESPLIT>Returns the node name . First tries local name . If this is null returns instead the full node name .
public void set Expiry Date ( @ Int ( from , to 12 ) month , @ Int ( from 0 , to = 9999 ) int year ) { m Expiry Date Edit Text . set Text ( Date Utils . create Date String From Integer Input ( month , year ) ) ; }<CODESPLIT>Set the expiration date . Method invokes completion listener and changes focus to the CVC field if a valid date is entered .
protected void write Ddl Ddl Write write ) { script set Ddl "-- \ write . apply Drop Dependencies ( ) . get Buffer ( ) + "\ n " + "-- apply changes \ n " + write . apply ( ) . get Buffer ( ) + write . apply Foreign Keys ( ) . get Buffer ( ) + write . apply History View ( ) . get Buffer ( ) + write . apply History Trigger ( ) . get Buffer ( ) ) ; }<CODESPLIT>Write the Apply DDL buffers to the writer .
protected static boolean class Equals ( Class clz 1 , Class clz 2 ) { ( clz 1 == clz 2 == ) { Null Pointer Exception ( ) ; } return clz 1 == clz 2 || clz 1 . get Name ( ) . equals ( clz 2 . get Name ( ) ) ; }<CODESPLIT>Compares if two classes are equal or their class names are equal .
public void add Shared Function ( Source source ) { String file Name source File Source ( ( File Source ) source ) . get File Name ( ) null ; do Add Shared Function ( source , file Name ) ; }<CODESPLIT>Add shared function by ISource
public void set Commerce Price List ( liferay commerce price . list . service . Commerce Price List Service commerce Price List Service ) { this . commerce Price List Service = commerce Price List Service ; }<CODESPLIT>Sets the commerce price list remote service .
public static Html ( ) { Html htmltree = Html Tree ( Html Tag . MAIN ) ; htmltree . set Role ( Role . MAIN ) ; return htmltree ; }<CODESPLIT>Generates a MAIN tag with role attribute .
public static cachepolicylabel _ stats get ( nitro _ , String labelname ) throws { cachepolicylabel _ stats = cachepolicylabel _ stats ( ) ; . set _ labelname ( labelname ) ; cachepolicylabel _ stats = ( cachepolicylabel _ stats ) obj . stat _ resource ( service ) ; return response ; }<CODESPLIT>Use this API to fetch statistics of cachepolicylabel_stats resource of given name .
protected void save Broker ( File mapfile , Hash Map ID Broker ) throws { ( ! . is Modified ( ) ) { return ; } { Buffered Writer bout = Buffered Writer ( File Writer ( mapfile ) ) ; . write To ( bout ) ; bout . close ( ) ; } ( IO Exception ioe ) { throw new Runtime Exception ( " Unable to store component ID map [ mapfile =" + mapfile + "]" , ioe ) ; } }<CODESPLIT>Stores a persistent representation of the supplied hashmap ID broker in the specified file .
public void update ( final Collection T ) throws Data Access { Template . execute ( Connection Callback Object > ( ) { public Object do In Connection ( Connection connection ) throws SQL Exception , Data Access Exception { crud . update ( connection , values ) ; return null ; } } ) ; }<CODESPLIT>update the objects .
public static Int from ( Int Supplier , Int Consumer ) { Int ( ) { public int get As Int ( ) { return s . get As Int ( ) ; } public Integer get ( ) { return get As Int ( ) ; } public Mutable Int set ( final int value ) { c . accept ( value ) ; return this ; } } ; }<CODESPLIT>Construct a MutableInt that gets and sets an external value using the provided Supplier and Consumer
public void configure ( Config config ) { . ( Reloading configuration ." ) ; this . config Write Lock . ( ) ; { this . config = config ; process App ( config ) ; } finally { this . config Write Lock . unlock ( ) ; } }<CODESPLIT>Replace the configuration of this instance directly .
protected void add ( String type ) { ( Host . name ( ) , Ip Utils . get Host Name ( ) ) ; put Property ( Property Key . Type . name ( ) , type ) ; put Property ( Property Key . Status . name ( ) , Status . Start . name ( ) ) ; }<CODESPLIT>Add properties to properties map on transaction start
public List Sequence List Type . Sequence get Sequence ( ) { ( sequence == ) { sequence = Array List < Sequence List Type . Sequence > ( ) ; } return this . sequence ; }<CODESPLIT>Gets the value of the sequence property .
public Map add Number ( String field Name , boolean include , Supplier Number supplier ) { ( include ) { Number value supplier . get ( ) ; ( value null ) { map . put ( get Field Name ( field Name ) , value ) ; } } return this ; }<CODESPLIT>Adds the number value to the provided map under the provided field name if it should be included . The supplier is only invoked if the field is to be included .
public void disconnect Card One Consumer ( ) { ( Trace Component . is Tracing ( ) tc . is Entry ( ) ) Sib Tr . ( tc , disconnect Card One Consumer ) ; Object [ cloned Consumer Points = ; synchronized ( consumer Points ) { cloned Consumer Points = consumer Points . to Array ( ) ; } SI Exceeded = SI Exceeded ( nls . get Formatted ( CONSUMERCARDINALITY LIMIT REACHED CWSIP 0472 , Object [ { get Name ( ) , get Localisation Uuid ( ) . to String ( ) } , ) ) ; FFDC Filter . process ( e , " com . ibm . ws . sib . processor . impl . Remote Consumer Dispatcher . disconnect Card One Consumer " , " 1 : 945 : 1 . 97 . 2 . 21 " , this ) ; Sib Tr . exception ( tc , e ) ; for ( int i = 0 ; i < cloned Consumer Points . length ; i ++ ) { Dispatchable Key ck = ( Dispatchable Key ) cloned Consumer Points [ i ] ; ck . notify Consumer Point About Exception ( e ) ; } if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) Sib Tr . exit ( tc , " disconnect Card One Consumer " ) ; }<CODESPLIT>The disconnectCardOneConsumer method is invoked by the Anycast Input Handler to notify it that the current cardinality - one consumer must be disconnected . This can happen when this RME becomes unreachable and the DME allows a consumer in a separate RME to connect . As soon as this RME becomes reachable again the DME sends ControlCardinalityInfo to trigger this consumer s disconnection .
public boolean is Administrator ( Auth Context ) { . get Username ( ) ctx . get Username ( ) . equals ( admin Name ) && ctx . get Password ( ) != null && ctx . get Password ( ) . equals ( admin Pass ) ; }<CODESPLIT>Check if the given credentials allow administrative access
protected void init ( ) { ( settings . autostart ( ) ) { = settings . get Runner ( ) ; . config ( Using . get Class ( ) . get Simple Name ( ) ) ; } { settings . set ( Opera . SERVER _ DEFAULT _ PORT _ IDENTIFIER ) ; } create Scope ( ) ; ( != ) { . start Opera ( ) ; } services . init ( ) ; debugger = services . get ( ) ; debugger . set Driver ( this ) ; window Manager = services . get Window Manager ( ) ; = services . get Exec ( ) ; core = services . get Core ( ) ; cookie Manager = services . get Cookie Manager ( ) ; mouse = new Opera Mouse ( this ) ; keyboard = new Opera Keyboard ( this ) ; services . get Console Logger ( ) . on Console Message ( new Console Message Converter ( logs ) ) ; settings . set Product ( utils ( ) . get Product ( ) ) ; if ( ! utils ( ) . get User Agent ( ) . contains ( " Mini " ) ) { preferences ( ) . set ( " User Prefs " , " Ignore Unrequested Popups " , false ) ; if ( utils ( ) . get Product ( ) . is ( MOBILE ) ) { preferences ( ) . set ( " User Prefs " , " Allow Autofocus Form Element " , true ) ; } } proxy = new Opera Proxy ( this ) ; proxy . parse ( settings . get Proxy ( ) ) ; }<CODESPLIT>Initialize required Scope services .
public static String calculate MD 5 ( String string ) { [ ] hash ; { hash = Message . get Instance ( MD 5 ) . digest ( string . get Bytes ( - 8 ) ) ; } ( No ) { ( Huh , MD 5 should be supported ?" , e ) ; } catch ( Unsupported Encoding Exception e ) { throw new Runtime Exception ( " Huh , UTF - 8 should be supported ?" , e ) ; } String Builder hex = new String Builder ( hash . length * 2 ) ; for ( byte b : hash ) { int i = ( b & 0 x FF ) ; if ( i < 0 x 10 ) hex . append ( ' 0 ' ) ; hex . append ( Integer . to Hex String ( i ) ) ; } return hex . to String ( ) ; }<CODESPLIT>Calculate the MD5 of a given String
protected static File find Raw ( File ) { for ( int = 0 ; != < 20 ; i ++ ) { File raw Dir = find Res Raw Dir ( dir ) ; if ( raw Dir != null ) { return raw Dir ; } dir = dir . get Parent File ( ) ; } return null ; }<CODESPLIT>Look for the resource - directory in the current directory or the directories above . Then look for the raw - directory underneath the resource - directory .
public Object resolve Variable ( String Name ) throws { Context = this . get EL Context ( ) ; return ctx . get EL Resolver ( ) . get Value ( ctx , null , p Name ) ; }<CODESPLIT>LIDB4147 - 9 Begin - modified for JSP 2 . 1
protected Dependant Value create Key Value ( In Flight Metadata mappings , Persistent Property property , Collection , Map , persistent ) { Key Value key Value ; Dependant Value key ; String property = . get Referenced Property Name ( ) ; ( property == ) { key Value = . get Owner ( ) . get Identifier ( ) ; } { key Value = ( Key Value ) . get Owner ( ) . get Property ( property ) . get Value ( ) ; } ( . is Debug ( ) ) LOG . debug ( "[ Grails Domain Binder ] creating dependant key value to table [" + key Value . get Table ( ) . get Name ( ) + "]" ) ; key = new Dependant Value ( metadata Building Context , collection . get Collection Table ( ) , key Value ) ; key . set Type Name ( null ) ; key . set Nullable ( true ) ; key . set Updateable ( false ) ; return key ; }<CODESPLIT>Creates the DependentValue object that forms a primary key reference for the collection .
protected Variable Exp get Var Exp ( Lex Name Token name , P vardef , P Type type ) { Variable Exp = get Var Exp ( name , vardef ) ; var . set Type ( type ) ; return var ; }<CODESPLIT>Generate Var Exp with everything!
public static boolean is Null Or White ( String arg ) { ( . is Null Or Empty ( arg ) arg . trim ( ) . is Empty ( ) ) { return ; } return false ; }<CODESPLIT>Determines whether the parameter string is null empty or whitespace .
public Block query Block By Number ( long block Number ) throws Argument , Proposal { return query Block By Number ( get Shuffled Peers ( Set . of ( Peer Role . LEDGER _ QUERY ) ) , block Number ) ; }<CODESPLIT>query this channel for a Block by the blockNumber . The request is retried on all peers till successful
public static get ( Class , String name ) { return get Getters As Map ( type ) . get ( name ) ; }<CODESPLIT>Search getter for given class and property name .
public static String decode LZ To String ( byte [ ] data , String dictionary ) { { return String ( decode LZ ( data ) , " - 8 " ) ; } ( Unsupported Encoding Exception ) { new Runtime Exception ( e ) ; } }<CODESPLIT>Decode lz to string string .
public static Airline Flight Update Template add Airline Flight Update Template ( intro , , pnr Number , Update Type update Type ) { return new Airline Flight Update Template Builder ( intro Message , locale , pnr Number , update Type ) ; }<CODESPLIT>Adds an Airline Flight Update Template to the response .
private void add Modules Argument ( String argument , List String , Module [ modules , String aditionalpath , String ) throws { String = String ( ) ; ( aditionalpath ) { . add ( argument ) ; . append ( aditionalpath ) ; } ( modules modules . 0 ) { ( ! . contains ( argument ) ) { . add ( argument ) ; } ( int = 0 ; modules . ; ) { Module = modules [ ; Artifact artifact = ; @ Suppress Warnings ( " unchecked " ) Set < Artifact > all Artifacts = project . get Artifacts ( ) ; for ( Artifact art : all Artifacts ) { if ( art . get Group Id ( ) . equals ( module . get Group Id ( ) ) && art . get Artifact Id ( ) . equals ( module . get Artifact Id ( ) ) && String Utils . default String ( module . get Classifier ( ) ) . equals ( String Utils . default String ( art . get Classifier ( ) ) ) && String Utils . default String ( module . get Type ( ) , " jar " ) . equals ( String Utils . default String ( art . get Type ( ) ) ) ) { artifact = art ; break ; } } if ( artifact == null ) { throw new Mojo Execution Exception ( " The artifact " + module . to String ( ) + " referenced in aspectj plugin as " + role + ", is not found the project dependencies " ) ; } if ( buf . length ( ) != 0 ) { buf . append ( File . path Separator Char ) ; } buf . append ( artifact . get File ( ) . get Path ( ) ) ; } } if ( buf . length ( ) > 0 ) { String path String = buf . to String ( ) ; arguments . add ( path String ) ; get Log ( ) . debug ( " Adding " + argument + ": " + path String ) ; } }<CODESPLIT>Finds all artifacts in the weavemodule property and adds them to the ajc options .
public static String extract Aero Gear Sender ( Http Servlet Request request ) { String client = request . get Header ( aerogear ) ; if ( has Value ( client ) ) { return client ; } return request . get Header ( " user - agent " ) ; }<CODESPLIT>Reads the aerogear - sender header to check if an AeroGear Sender client was used . If the header value is NULL the value of the standard user - agent header is returned
public Flux Service Message request ( Service Message request , Class Type , address ) { return Flux . defer ( ( ) -> { Non Null ( address , request address parameter is and must not be null " ) ; require Non Null ( transport , " transport is required and must not be null " ) ; return transport . create ( address ) . request Stream ( request ) . map ( message -> Service Message Codec . decode Data ( message , response Type ) ) . map ( this :: throw If Error ) ; } ) ; }<CODESPLIT>Given an address issues request to remote service which returns stream of service messages back .
public void incremental Restore ( File incremental File ) throws File Not Found , IO , Class Not Found , Repository { Object Input Stream ois = ; { ois = Object Input Stream ( File . file Input Stream ( incremental File ) ) ; ( ) { Transaction Changes Log changes Log = read External ( ois ) ; changes Log . set Id ( Constants . JCR _ CORE _ RESTORE _ WORKSPACE _ INITIALIZER _ SYSTEM _ ID ) ; Changes Log Iterator cli = changes Log . get Log Iterator ( ) ; ( cli . has Next Log ( ) ) { ( cli . Log ( ) . get Event Type ( ) == Extended Event . LOCK ) { cli . remove Log ( ) ; } } save Changes Log ( changes Log ) ; } } ( ) { if ( LOG . is Trace Enabled ( ) ) { LOG . trace ( " An exception occurred : " + ioe . get Message ( ) ) ; } } }<CODESPLIT>Perform incremental restore operation .
public Key Integer start ( ) { Key Integer object Key Integer > ( ) ; consumers . put ( object , new Consumer < Integer > ( ) { int count ; public void consume ( final Byte Buffer buffer ) { count += buffer . remaining ( ) ; } public Integer finish ( ) { return count ; } } ) ; return object ; }<CODESPLIT>Initializes a byte counter on this channel .
public static boolean is Element Present ( String locator ) { . ( locator ) ; boolean flag = false ; { flag = Html Element . locate Element ( locator ) != ; } ( No Such Element e ) { } logger . exiting ( flag ) ; return flag ; }<CODESPLIT>Checks if the provided element is present on the page based on the locator provided
public static void main ( String [ ] ) throws { String Buffer = String Buffer ( The lazy fox ) ; Thread = Thread ( ) { public void run ( ) { synchronized ( ) { . delete ( 0 , 4 ) ; . append ( the " ) ; System . err . println ( " Middle " ) ; try { Thread . sleep ( 4000 ) ; catch ( Exception e ) { } buffer . append ( " of fall " ) ; System . err . println ( " Fall " ) ; } } } ; Thread t 2 = new Thread ( ) { public void run ( ) { try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { buffer . append ( " jump over the fence " ) ; System . err . println ( " Fence " ) ; t 1 . start ( ) ; t 2 . start ( ) ; t 1 . join ( ) ; t 2 . join ( ) ; System . err . println ( buffer ) ;<CODESPLIT>We have more input since wait started
protected double interpolate ( double , double ) { double ; ( Double Na ( gp ) ) { Interpolate quadratic ( fprev , gprev , stprev , fp , stp ) ; } { = Search Interpolate . cubic 2 ( fprev , gprev , stprev , fp , gp , stp ) ; if ( Double . is Na N ( alpha New ) ) alpha New = Search Interpolate . quadratic ( fprev , gprev , stprev , fp , stp ) ; } double l , u ; if ( bound A < bound B ) { l = bound A ; u = bound B ; } else { l = bound B ; u = bound A ; } if ( alpha New < l ) alpha New = l ; else if ( alpha New > u ) alpha New = u ; return alpha New ; }<CODESPLIT>Use either quadratic of cubic interpolation to guess the minimum .
private List Semantic Error check ( Data Type Type ) { . finer ( semantic on datatype Type . name ) ; List Semantic Error = Array List Semantic Error ( ) ; String constructor Names = String ( ) ; ( Constructor constructor : data Type . constructors ) { logger . finest ( " Checking semantic constraints on constructor " + constructor . name + " in datatype " + data Type . name ) ; if ( data Type . constructors . size ( ) > 1 && data Type . name . equals ( constructor . name ) ) { logger . info ( " Constructor with same name as its data type " + data Type . name + "." ) ; errors . add ( _ Constructor Data Type Conflict ( data Type . name ) ) ; } if ( constructor Names . contains ( constructor . name ) ) { logger . info ( " Two constructors with same name " + constructor . name + " in data type " + data Type . name + "." ) ; errors . add ( _ Duplicate Constructor ( data Type . name , constructor . name ) ) ; } else { constructor Names . add ( constructor . name ) ; } errors . add All ( check ( data Type , constructor ) ) ; } return errors ; }<CODESPLIT>Checks a data type for duplicate constructor names or constructors having the same name as the data type
protected void register ( List List , Grails Plugin ) { ( . contains ( plugin . get Name ( ) ) ) { added Names . add ( plugin . get Name ( ) ) ; additional List . add ( plugin ) ; add Plugin Dependencies ( additional List , plugin ) ; } }<CODESPLIT>Adds a plugin to the additional if this hasn t happened already
private Json Node execute Request ( Http Post request ) throws IO , Grooveshark { Http Response response = http Client . execute ( request ) ; ( Logging ) { log Request ( request , response ) ; } String response = Char . to String ( Input Stream Reader ( response . get Entity ( ) . get Content ( ) , Charsets . _ 8 ) ) ; { return json Mapper . read ( String Reader ( response ) ) ; } ( Json Processing e ) { throw new Grooveshark Exception . Server Error Exception ( " Failed to parse response - received data was not valid JSON : " + response Payload ) ; } }<CODESPLIT>Boilerplate to send the request and parse the response payload as JSON .
public Map < String , T > parse Map ( Json ) throws { Map < String , T > map = Map < String , T > ( ) ; ( . Token ( ) != Json Token . _ OBJECT ) { String key = json Parser . get Text ( ) ; json Parser . next Token ( ) ; if ( json Parser . get Current Token ( ) == Json Token . VALUE _ NULL ) { map . put ( key , null ) ; } else { map . put ( key , parse ( json Parser ) ) ; } } return map ; }<CODESPLIT>Parse a map of objects from a JsonParser .
public Date Func Sup subtract ( Date Seperator d ) { set Time ( get Time ( ) - d . parse ( ) ) ; return this ; }<CODESPLIT>subtract date on supported date
private double radical Inverse ( long ) { double = . 0 / ( double ) ; double radical = ; double inverse = 0 . 0 ; ( > 0 ) { inverse += digit * ( double ) ( i % base ) ; digit *= radical ; i /= base ; } return inverse ; }<CODESPLIT>Compute the radical inverse of i .
public static String get Temp ( ) { synchronized ( File . class ) { ( TEMP _ DIR == ) { String = . get Property ( java . . tmpdir ) ; ( String Util . is Empty ( tmp Dir ) ) { if ( new File ( "/ temp " ) . exists ( ) ) { tmp Dir = "/ temp " ; } else { tmp Dir = "/ tmp " ; } } TEMP _ DIR = tmp Dir ; } } return TEMP _ DIR ; }<CODESPLIT>Gets the default temp directory for the system .
public static Accumulator , Value Accumulator reduce ( List Value list , Accumulator init , Reduce Closure Accumulator , Value f ) { Accumulator accumulator = init ; for ( Value value : list ) { accumulator = f . eval ( accumulator , value ) ; } return accumulator ; }<CODESPLIT>Applies a binary function between each element of the given list .
protected Process Output execute Process ( Fax fax , String command , Fax Action Type fax Action Type ) { ( command == ) { this . ( ) ; } String Command = command ; ( this . Windows Command Prefix ) { String = String ( Command . ( ) this . windows Command Prefix . ( ) + 1 ) ; buffer . append ( this . windows Command Prefix ) ; buffer . append ( " " ) ; buffer . append ( updated Command ) ; updated Command = buffer . to String ( ) ; } Process Output process Output = Process Executor Helper . execute Process ( this , updated Command ) ; this . validate Process Output ( process Output , fax Action Type ) ; this . update Fax Job ( fax Job , process Output , fax Action Type ) ; return process Output ; }<CODESPLIT>Executes the process and returns the output .
public Model Node get Connector ( String name ) throws { address = . ( ) . add ( SUBSYSTEM , SUBSYSTEM _ WEB , CONNECTOR , name ) ; return read Resource ( address , true ) ; }<CODESPLIT>Returns the connector node with all its attributes . Will be null if it doesn t exist .
int match ( Detector det , int [ ] common Chars ) { int double Byte Char Count = 0 ; int common Char Count = 0 ; int bad Char Count = 0 ; int Char Count = 0 ; int confidence = 0 ; iterated Char = iterated Char ( ) ; detect Block : { for ( . reset ( ) ; Char ( , det ) ; ) { Char Count ; ( . error ) { bad Char Count ; } { long cv = . char Value & 0 x FFFFFFFFL ; ( cv <= 0 xff ) { Byte Char Count ; } { double Byte Char Count ; ( common Chars != ) { ( . binary Search ( common Chars , ( int ) cv ) >= 0 ) { common Char Count ++ ; } } } } if ( bad Char Count >= 2 && bad Char Count * 5 >= double Byte Char Count ) { break detect Block ; } } if ( double Byte Char Count <= 10 && bad Char Count == 0 ) { if ( double Byte Char Count == 0 && total Char Count < 10 ) { confidence = 0 ; } else { confidence = 10 ; } break detect Block ; } if ( double Byte Char Count < 20 * bad Char Count ) { confidence = 0 ; break detect Block ; } if ( common Chars == null ) { confidence = 30 + double Byte Char Count - 20 * bad Char Count ; if ( confidence > 100 ) { confidence = 100 ; } } else { double max Val = Math . log ( ( float ) double Byte Char Count / 4 ) ; double scale Factor = 90 . 0 / max Val ; confidence = ( int ) ( Math . log ( common Char Count + 1 ) * scale Factor + 10 ) ; confidence = Math . min ( confidence , 100 ) ; } } return confidence ;<CODESPLIT>Test the match of this charset with the input text data which is obtained via the CharsetDetector object .
public static void extract ( Matrix , , 1 , int src X 0 , int src X 1 , D Matrix dst ) { ( ( Reshape Matrix ) dst ) . reshape ( src Y 1 - src Y 0 , src X 1 - src X 0 ) ; extract ( src , src Y 0 , src Y 1 , src X 0 , src X 1 , dst , 0 , 0 ) ; }<CODESPLIT>Extract where the destination is reshaped to match the extracted region
public void resize Eip ( Resize Eip Request request ) { check Not ( request get Bandwidth In Mbps ( ) , Bandwidth In Mbps should not ) ; check String Not Empty ( request get Eip ( ) , eip should not ) ; ( is Or Empty ( request get Client Token ( ) ) ) { request . set Client Token ( generate Default Client Token ( ) ) ; } Internal Request internal Request = this . create Request ( request , Http Method Name . PUT , request . get Eip ( ) ) ; internal Request . add Parameter ( " resize " , null ) ; internal Request . add Parameter ( CLIENT _ TOKEN _ IDENTIFY , request . get Client Token ( ) ) ; fill Payload ( internal Request , request ) ; invoke Http Client ( internal Request , Abstract Bce Response . class ) ; }<CODESPLIT>Resizing eip The Prepaid eip can not be downgrade . This is an asynchronous interface .
private void Next As New Contact Seed Broker ( ) { ( current Contact Seed Broker Index == seed Broker . ) { current Contact Seed Broker Index = 0 ; } URL Contact Url = Net . get Correct Hostname ( seed Broker [ current Contact Seed Broker Index ] ) ; this . consumer = Simple Consumer ( new Contact Url . get Host ( ) , new Contact Url . get Port ( ) , so Timeout , buffer Size , dummy Client Id ) ; }<CODESPLIT>Re - establish broker connection using the next available seed broker address .
private String unescape ( String value ) { String Builder = String Builder ( ) ; for ( int = 0 ; < value . ( ) ; ) { char = value . char At ( ) ; ( == ESCAPE _ ) { String code String = value . ( 1 , 3 ) ; int code = Integer . parse Int ( code String , ) ; ( code < reserved Chars . length && reserved Chars [ code ] == code ) { result . append ( reserved Chars [ code ] ) ; i += 2 ; } else { throw new Service Location Exception ( " Unknown escaped character " + ESCAPE _ PREFIX + code String + " at position " + ( i + 1 ) + " of " + value , SLP Error . PARSE _ ERROR ) ; } } else { result . append ( c ) ; } } return result . to String ( ) ; }<CODESPLIT>Unescapes the scope string following RFC 2608 6 . 4 . 1
protected Map read File ( Map br Map ) throws { Map = Map ( ) ; Array List Map exp Arr = Array List Map ( ) ; Map String , Map = read Obv Data ( br Map ) ; Array List < Hash Map > obv Data ; for ( String exname : files . key Set ( ) ) { obv Data = ( Array List ) files . get ( exname ) . get ( obv Data Key ) ; for ( Hash Map obv Sub : obv Data ) { exp Data = new Hash Map ( ) ; obv = new Hash Map ( ) ; copy Item ( exp Data , files . get ( exname ) , " exname " ) ; copy Item ( exp Data , files . get ( exname ) , " crid " ) ; copy Item ( exp Data , files . get ( exname ) , " local _ name " ) ; exp Data . put ( json Key , obv ) ; obv . put ( obv File Key , obv Sub . get ( obv Data Key ) ) ; exp Arr . add ( exp Data ) ; } } Array List id Names = new Array List ( ) ; id Names . add ( " trno _ t " ) ; remove Index ( exp Arr , id Names ) ; ret . put ( " experiments " , exp Arr ) ; return ret ; }<CODESPLIT>DSSAT TFile Data input method for Controller using
public static Fixed String Interpolator create Interpolator ( Parameters params , String filter ) { String delimiters extract ( filter ) ; ( delimiters ) { Fixed String Interpolator . create ( ) ; } Docker Assembly Configuration Source Source Docker Assembly Configuration Source ( params , null , null ) ; return Assembly Interpolator . full Interpolator ( params . get Project ( ) , Default Assembly Reader . create Project Interpolator ( params . get Project ( ) ) . with Expression Markers ( delimiters [ 0 ] , delimiters [ 1 ] ) , config Source ) . with Expression Markers ( delimiters [ 0 ] , delimiters [ 1 ] ) ; }<CODESPLIT>Create an interpolator for the given maven parameters and filter configuration .
public static boolean is Cleanup In Progress ( Zoo Keeper zk ) throws Keeper , { List String = zk . get Children ( Volt ZK . leaders _ initiators , ) ; List ZK . Children Callbacks = . Array List ( ) ; ( String child : children ) { ZK Util . Children Callback callback = new ZK Util . Children Callback ( ) ; zk . get Children ( ZK Util . join ZK Path ( Volt ZK . leaders _ initiators , child ) , false , callback , null ) ; children Callbacks . add ( callback ) ; } for ( ZK Util . Children Callback callback : children Callbacks ) { if ( callback . get ( ) . is Empty ( ) ) { return true ; } } return false ; }<CODESPLIT>Checks if the cluster suffered an aborted join or node shutdown and is still in the process of cleaning up .
private [ ] unify L Data ( CEMI ldata , boolean Src , List Integer types ) { [ ] data ; ( ldata CEMIL Data Ex ) { CEMIL Data Ex ext = ( ( CEMIL Data Ex ) ldata ) ; List Add = ext . ( ) ; synchronized ( ) { ( final Iterator < Add Info > i = additional Info . iterator ( ) ; i . has Next ( ) ; ) { final Add Info info = i . next ( ) ; if ( ! types . contains ( info . get Type ( ) ) ) { logger . warn ( " remove L - Data additional info {}" , info ) ; i . remove ( ) ; } } } } data = ldata . to Byte Array ( ) ; data [ 0 ] = 0 ; data [ 1 + data [ 1 ] + 1 ] = 0 ; if ( empty Src ) { data [ 1 + data [ 1 ] + 3 ] = 0 ; data [ 1 + data [ 1 ] + 4 ] = 0 ; } return data ; }<CODESPLIT>additional info . types provides the list of add . info types we want to keep everything else is removed
public static T Number int [ ] as Array ( final T ... array ) { int [ ] = int [ array . ] ; for ( int = 0 ; i < b . length ; i ++ ) { b [ i ] = array [ i ] . int Value ( ) ; } return b ; }<CODESPLIT>Convert any number class to array of integer .
synchronized void set Active ( handle ) { . check Argument ( handle == ! handle . is Read ( ) , Active handle cannot readonly ." ) ; Chunk last = last Chunk ( ) ; Preconditions . check State ( last != null , " Cannot set an Active Segment Chunk handle when there are no Segment Chunks ." ) ; Preconditions . check Argument ( handle == null || handle . get Segment Name ( ) . equals ( last . get Name ( ) ) , " Active Segment Chunk handle must be for the last Segment Chunk ." ) ; this . active Chunk Handle = handle ; }<CODESPLIT>Sets the Active SegmentChunk handle .
public String get Empty Value ( ) { ( Timex 3 Interval _ Type . ( ( Timex 3 Interval _ Type ) Type ) . cas _ Value == ) Type . . throw Feat Missing ( " empty Value " , " de . unihd . dbs . uima . types . heideltime . Timex 3 Interval " ) ; return jcas Type . ll _ cas . ll _ get String Value ( addr , ( ( Timex 3 Interval _ Type ) jcas Type ) . cas Feat Code _ empty Value ) ; }<CODESPLIT>getter for emptyValue - gets
public static Account Account ( Bitstamp Balance bitstamp Balance , String user Name ) { Balance balances Array ( ) ; ( knowm xchange bitstamp dto account . Bitstamp Balance . Balance b : bitstamp Balance . get Balances ( ) ) { Balance xchange Balance = new Balance ( Currency . get Instance ( b . get Currency ( ) . to Upper Case ( ) ) , b . get Balance ( ) , b . get Available ( ) , b . get Reserved ( ) , ZERO , ZERO , b . get Balance ( ) . subtract ( b . get Available ( ) ) . subtract ( b . get Reserved ( ) ) , ZERO ) ; balances . add ( xchange Balance ) ; } return new Account Info ( user Name , bitstamp Balance . get Fee ( ) , new Wallet ( balances ) ) ; }<CODESPLIT>Adapts a BitstampBalance to an AccountInfo
public void after Connection ( Web Session session , Close status ) { . debug ( Web Socket closed : {}, Close Status : {}" , session , status . to String ( ) ) ; }<CODESPLIT>Invoked after the web socket connection is closed . You can override this method in the child classes .
public static String trim Last Path ( String path ) { String [ ] sections = path . split ( "/" ) ; String Path = String ( "/" ) ; ( int = ; < sections . length - 1 ; i ++ ) { new Path . append ( sections [ i ] ) . append ( "/" ) ; } return new Path . to String ( ) ; }<CODESPLIT>Removes the last part of a file path .
public static Style red ( ) { Style style = Style ( ) ; style . = Palette . get Solid Color ( Palette Utils . MATERIAL _ RED ) ; return style ; }<CODESPLIT>Default material red transparent style for SuperToasts .
public Object Context create Context ( ) { Bean T = ; Descriptor T Descriptor = get Descriptor ( ) ; ( ! ejb Descriptor . is Message Driven ( ) ) { bean = get Bean ( ) ; } Weld Manager bean Manager = get Bean Manager ( ) ; Weld Creational Context < T > creational Context = bean Manager . create Creational Context ( bean ) ; Managed Object Context managed Object Context = new CDI Managed Object State ( creational Context ) ; return managed Object Context ; }<CODESPLIT>This version creates a ManagedObjectContext which contains a CreationalContext for an EJB .
public void delete Operation ( String name ) { Operation Request request Operation Request new Builder ( ) . set Name ( name ) . build ( ) ; delete Operation ( request ) ; }<CODESPLIT>Deletes a long - running operation . This method indicates that the client is no longer interested in the operation result . It does not cancel the operation . If the server doesn t support this method it returns google . rpc . Code . UNIMPLEMENTED .
public boolean is Member ( int x ) { . check ( current State != State . ) ; return 0 <= x x ( bits . << wordshift ) && ( bits [ x >>> wordshift ] & ( 1 << ( x & wordmask ) ) ) != 0 ; }<CODESPLIT>Is x an element of this set?
public Handler add Finish Handler ( Finish Event . Search Finish Handler handler ) { return add Handler ( handler , Search Finish Event . TYPE ) ; }<CODESPLIT>This handler will be triggered when search is finish
public void set Foreign Bus ( boolean send ) { ( Trace Component . is Tracing ( ) tc . is Entry ( ) ) { Sib Tr . ( tc , set Foreign Bus , Boolean . value Of ( send ) ) ; } send On Target Foreign Bus = Boolean . value Of ( send ) ; ( aliases Target This != null ) { synchronized ( aliases That Target This Dest ) { Iterator i = aliases That Target This Dest . iterator ( ) ; while ( i . has Next ( ) ) { Abstract Alias Destination Handler abstract Alias Destination Handler = ( Abstract Alias Destination Handler ) i . next ( ) ; abstract Alias Destination Handler . set Foreign Bus Send Allowed ( send Allowed ) ; } } } if ( Trace Component . is Any Tracing Enabled ( ) && tc . is Entry Enabled ( ) ) { Sib Tr . exit ( tc , " set Foreign Bus Send Allowed " ) ; } }<CODESPLIT>Set the Foreign Bus Level sendAllowed flag
public void processing Instruction ( String , String data ) throws SAX { ( Handler != null ) document Handler . processing Instruction ( target , data ) ; }<CODESPLIT>Adapt a SAX2 processing instruction event .
public static Integer get File On FTP Server ( String host Name , Integer port , String user Name , String password , String file Path ) { Integer = ; String reply String = execute Command On FTP Server ( host Name , port , user Name , password , , file Path ) ; ( reply String == ! reply String . contains ( ) ) { ( String . format ( Unable to get size of the % s file . Got [% s ] reply from FTP server ." , file Path , reply String ) ) ; } else { result = Integer . value Of ( reply String . split ( " " ) [ 1 ] . replace All ( "[\ r \ n ]" , "" ) ) ; } return result ; }<CODESPLIT>Get size of the FTP file .
public static base _ responses enable ( nitro _ client , String trapname [ ] ) throws { base _ responses = ; ( trapname != trapname . > 0 ) { snmpalarm enableresources [ ] = snmpalarm [ trapname . ] ; for ( int = 0 ; < trapname . length ; i ++ ) { enableresources [ i ] = new snmpalarm ( ) ; enableresources [ i ] . trapname = trapname [ i ] ; } result = perform _ operation _ bulk _ request ( client , enableresources , " enable " ) ; } return result ; }<CODESPLIT>Use this API to enable snmpalarm resources of given names .
public void ordered ( Consumer T ) { Topo Sorter T > sorter = new Topo Sorter < > ( this ) ; sorter . ordered ( action ) ; }<CODESPLIT>Traverse this graph and performs the given action in topological order
public static Seq Server Group parse ( String asg ) { int d asg index Of ( '-' ) ; int d 2 asg index Of ( '-' , d ) ; int d N asg last Index Of ( '-' ) ; if ( d N < 0 || ! is Sequence ( asg , d N ) ) { d N = asg . length ( ) ; } return new Seq Server Group ( asg , d 1 , d 2 , d N ) ; }<CODESPLIT>Create a new instance of a server group object by parsing the group name .
private static int get Map Count ( int Count , int Nodes ) { int Maps = ( int ) ( Count / _ PER _ ) ; Maps = Math . min ( num Maps , num Nodes * MAX _ MAPS _ PER _ NODE ) ; return Math . max ( num Maps , 1 ) ; }<CODESPLIT>Calculate how many maps to run .
protected void Read 0 ( Channel Handler Context , Full Binary Memcache Response ) throws { ( . get ( ) ) { : original Promise . set ( ) ; . pipeline ( ) . remove ( this ) ; . fire Channel Active ( ) ; ; ACCESS _ ERROR : original Promise . set Failure ( Authentication Exception ( " Authentication failure on Select Bucket command " ) ) ; break ; case NOTFOUND _ ERROR : original Promise . set Failure ( new Authentication Exception ( " Bucket not found on Select Bucket command " ) ) ; break ; default : original Promise . set Failure ( new Authentication Exception ( " Unhandled select bucket status : " + msg . get Status ( ) ) ) ; } }<CODESPLIT>Handles incoming Select bucket responses .
private Dice Expression unwrap ( Dice Expression expression ) { Dice Expression result ; if ( expression instanceof Expression Wrapper ) { result = ( ( Expression Wrapper ) expression ) . get Wrapped Expression ( ) ; } else { result = expression ; } return result ; }<CODESPLIT>Removes the expression wrappers used to temporally prune the nodes .
public static float [ check Array Elements In ( float [ value , float lower , float upper , String value Name ) { check Not Null ( value , value Name must not ) ; ( int = 0 ; value . ; ) { float v = value [ ; ( Float . is Na N ( v ) ) { Argument ( value Name + "[" + i + "] must not be Na N " ) ; } else if ( v < lower ) { throw new Illegal Argument Exception ( String . format ( "% s [% d ] is out of range of [% f , % f ] ( too low )" , value Name , i , lower , upper ) ) ; } else if ( v > upper ) { throw new Illegal Argument Exception ( String . format ( "% s [% d ] is out of range of [% f , % f ] ( too high )" , value Name , i , lower , upper ) ) ; } } return value ; }<CODESPLIT>Ensures that all elements in the argument floating point array are within the inclusive range
public static void copy ( Input Stream Stream , Output Stream output Stream ) { copy ( input Stream , output Stream , true ) ; }<CODESPLIT>Writes the content provided by the given source input stream into the given destination output stream .
private static Collection Tuple get Tuples ( List Var Def var Defs , int var , int var , int tuple Size ) { Collection Tuple tuples = Array List Tuple ( ) ; for ( int = var ; var ; ) { Var Def Var = var Defs . get ( ) ; Iterator Var Value Def = Var . get Valid Values ( ) ; ( ! . has Next ( ) ) { State ( Can ' t complete tuples -- no valid values defined for var =" + next Var ) ; } Collection < Tuple > sub Tuples = tuple Size == 1 ? null : get Tuples ( var Defs , i + 1 , var End + 1 , tuple Size - 1 ) ; if ( sub Tuples == null ) { while ( values . has Next ( ) ) { tuples . add ( new Tuple ( new Var Binding Def ( next Var , values . next ( ) ) ) ) ; } } else if ( ! sub Tuples . is Empty ( ) ) { while ( values . has Next ( ) ) { Var Binding Def next Binding = new Var Binding Def ( next Var , values . next ( ) ) ; for ( Tuple sub Tuple : sub Tuples ) { Tuple next Tuple = new Tuple ( next Binding ) . add All ( sub Tuple ) ; if ( next Tuple . is Compatible ( ) ) { tuples . add ( next Tuple ) ; } } } } } return tuples ; }<CODESPLIT>Returns all valid tuples of values for the given input variables .
public V get ( key ) { int hash = hash ( key ) ; int slot = index Of ( hash ) ; for ( Entry , V = table [ slot ] ; null ; entry = entry . next ) { if ( entry . hash Code == hash && entry . key . equals ( key ) ) { return entry . value ; } } return null ; }<CODESPLIT>Looks up the value mapped under the given key . Returns null if no value is mapped under this key .
public boolean valid ( String , String ) { . Non Null ( , Required . SECRET . to String ( ) ) ; Objects . require Non Null ( number , Required . TOTP . to String ( ) ) ; return Totp Utils . verified Totp ( secret , number ) ; }<CODESPLIT>Checks if a given number for 2FA is valid for the given secret
protected void update Edges DL ( S , L , S , L , Emissions ) { update Outgoing Edges ( curr S , curr L , States . DL , prev S , prev L , States . DL , Transitions . t _ DL _ in , emission ) ; update Outgoing Edges ( curr S , curr L , States . DL , prev S , prev L , States . S , Transitions . t _ S _ to _ DL , emission ) ; }<CODESPLIT>Enumerates the possible transitions into state DL .
public void set Prefix ( String key , String ) { Pdf Name fieldname = Pdf Name ( key ) ; Pdf Object = get ( fieldname ) ; ( ) Argument ( You must set a value before adding a prefix ." ) ; Pdf Dictionary dict = new Pdf Dictionary ( Pdf Name . COLLECTIONSUBITEM ) ; dict . put ( Pdf Name . D , o ) ; dict . put ( Pdf Name . P , new Pdf String ( prefix , Pdf Object . TEXT _ UNICODE ) ) ; put ( fieldname , dict ) ; }<CODESPLIT>Adds a prefix for the Collection item . You can only use this method after you have set the value of the item .
protected Expression replace Expressions With Pve ( Expression expr ) { assert ( expr != ) ; ( expr Tuple Value Expression ) { int param = Parameterization . get Next Param Index ( ) ; Parameter Value Expression pve = Parameter Value Expression ( param , expr ) ; _ Tve Map . put ( param , expr ) ; return pve ; } ( expr Aggregate Expression ) { int param = Parameterization . get Next Param Index ( ) ; Parameter Value Expression pve = Parameter Value Expression ( param , expr ) ; List < Tuple Value Expression > tves = Expression Util . get Tuple Value Expressions ( expr ) ; assert ( m _ parent Stmt != null ) ; for ( Tuple Value Expression tve : tves ) { int orig Id = tve . get Orig Stmt Id ( ) ; if ( m _ stmt Id != orig Id && m _ parent Stmt . m _ stmt Id != orig Id ) { } } m _ parameter Tve Map . put ( param Idx , expr ) ; return pve ; } if ( expr . get Left ( ) != null ) { expr . set Left ( replace Expressions With Pve ( expr . get Left ( ) ) ) ; } if ( expr . get Right ( ) != null ) { expr . set Right ( replace Expressions With Pve ( expr . get Right ( ) ) ) ; } if ( expr . get Args ( ) != null ) { List < Abstract Expression > new Args = new Array List < > ( ) ; for ( Abstract Expression argument : expr . get Args ( ) ) { new Args . add ( replace Expressions With Pve ( argument ) ) ; } expr . set Args ( new Args ) ; } return expr ; }<CODESPLIT>Helper method to replace all TVEs and aggregated expressions with the corresponding PVEs . The original expressions are placed into the map to be propagated to the EE . The key to the map is the parameter index .
private static boolean add ( String Id , ) { boolean is First = false ; List list = BACKLOG . get ( application Id ) ; if ( null == list ) { list = new Array List < Delayed Callback > ( ) ; BACKLOG . put ( application Id , list ) ; is First = true ; } list . add ( callback ) ; return is First ; }<CODESPLIT>Add a delayed callback for the given application id . Returns whether this is the first request for the application id .
public static [ gunzip Bytes ( [ compressed Bytes ) throws { Byte Array Output Stream bos = Byte Array Output Stream ( ( int ) ( compressed Bytes . 1 . 5 ) ) ; Inflater Output Stream dos = new Inflater Output Stream ( bos ) ; dos . write ( compressed Bytes ) ; dos . close ( ) ; return bos . to Byte Array ( ) ; }<CODESPLIT>to avoid linking all that jazz into the client code
public Value Expression get Output Expression ( index ) { Column schema get Column ( index ) ; Value Expression tve new Tuple Value Expression ( get Table Alias ( ) , get Table Alias ( ) , schema Col . get Column Alias ( ) , schema Col . get Column Alias ( ) , index ) ; return tve ; }<CODESPLIT>Produce a tuple value expression for a column produced by this subquery
