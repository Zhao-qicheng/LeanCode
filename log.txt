0：} ; ) , , , , ( . } } ; { ) ) 
0：protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
0：protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter (    return    QueueDrainHelper  drainLoop  q  observer  delayError  disposable  this   

1：} ; ) ) ( > < ( . 
1：@ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1：@ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins  onAssembly  new ObservableFromUnsafeSource  T   source    

2：} ; ) ) ( > > < < 
2：@ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
2：@ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions .  List  T   identity     

3：} ; ) ) , ( > 
3：public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
3：public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T   co  observable    

4：} ; ) ( 
4：public static < T > UnicastProcessor < T > create ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
4：public static < T > UnicastProcessor < T > create ( int capacityHint ) { return new UnicastProcessor < T >  capacityHint   

5：} ; ) , ( > 
5：public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
5：public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T   capacityHint  onCancelled   

6：} ; } ; } ; ) ( . { } ; ) ) , ( > < ( . } ; ; ) ( . { ) == ( } 
6：@ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return true ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return true ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return true ; } return false ; }
6：@ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return true ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ;  if  u  null   EmptySubscription  complete  subscriber   return true   subscriber  onSubscribe  new ScalarSubscription  R   subscriber  u     else  r  subscribe  subscriber    return true   return false  

7：} ; ) ) , ( > 
7：public static < T , U > Flowable < U > scalarXMap ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
7：public static < T , U > Flowable < U > scalarXMap ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U   value  mapper    

8：} ; ) ( ; ) ( ; ) ( ; ) ( ; ) ( ; ) ( ; ) 
8：public static void reset ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( false ) ; setOnBeforeBlocking ( null ) ; }
8：public static void reset ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null   setOnConnectableObservableAssembly  null   setOnMaybeAssembly  null   setOnMaybeSubscribe  null   setOnParallelAssembly  null   setFailOnNonBlockingScheduler  false   setOnBeforeBlocking  null   

9：} ; ) ) ( > < ( 
9：@ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
9：@ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly  new MaybeFromCompletable  T   completableSource    

10：} ; ) ) ( > < 
10：@ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
10：@ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle  T   singleSource    

11：} ; ) ( . 
11：@ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
11：@ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate )  singleElement    

12：} ; } ; 
12：public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
12：public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message )   return object  

13：} ; ) > 
13：@ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > identity ( ) { return ( Function < T , T > ) IDENTITY ; }
13：@ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > identity ( ) { return ( Function < T , T   IDENTITY  

14：} ; ) 
14：public static < T > Callable < T > justCallable ( T value ) { return new JustValue < Object , T > ( value ) ; }
14：public static < T > Callable < T > justCallable ( T value ) { return new JustValue < Object , T > ( value   

15：} ; ) ( 
15：public static < T , U > Function < T , U > justFunction ( U value ) { return new JustValue < T , U > ( value ) ; }
15：public static < T , U > Function < T , U > justFunction ( U value ) { return new JustValue < T , U >  value   

16：} ; ) ( 
16：public static < T , U > Function < T , U > castFunction ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
16：public static < T , U > Function < T , U > castFunction ( Class < U > target ) { return new CastToClass < T , U >  target   

17：} ; ) , 
17：public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , true ) ; }
17：public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( )  true   

18：} ; ) , 
18：public static < T > UnicastSubject < T > create ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , true ) ; }
18：public static < T > UnicastSubject < T > create ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint  true   

19：} ; ) , , 
19：public static < T > UnicastSubject < T > create ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , true ) ; }
19：public static < T > UnicastSubject < T > create ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint  onTerminate  true   

20：} ; ) , 
20：public static < T > UnicastSubject < T > create ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
20：public static < T > UnicastSubject < T > create ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( )  delayError   

21：} ; } } ; ; 
21：public Throwable blockingGetError ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
21：public Throwable blockingGetError ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( )  return ex    return error  

22：} ; } } ; ) ( . ; ) 
22：public Throwable blockingGetError ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
22：public Throwable blockingGetError ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose (   throw ExceptionHelper  wrapOrThrow  ex     return error  

23：} ; } ; ) ( . { ) != 
23：public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return false ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return true ; }
23：public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return false ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex  null   throw ExceptionHelper  wrapOrThrow  ex    return true  

24：} } } ; { ) == ( ; ) - ( . = } } ; ; ) ) ( ( . } ; ) ( 
24：public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
24：public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose     a  onError  new MissingBackpressureException  "Could not emit value due to lack of requests."    return    missed  qd  leave   missed   if  missed  0   break    

25：} ; ) 
25：public static void request ( Subscription s , int prefetch ) { s . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
25：public static void request ( Subscription s , int prefetch ) { s . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch   

26：} } } ; } ; ) , , , , ( { ) != ( 
26：public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ; if ( state . compareAndSet ( r , u ) ) { if ( r != 0L ) { postCompleteDrain ( u , actual , queue , state , isCancelled ) ; } return ; } } }
26：public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ; if ( state . compareAndSet ( r , u ) ) { if  r  0L   postCompleteDrain  u  actual  queue  state  isCancelled    return    

27：} } ; = } ; { ) ) , ( ( ; = 
27：protected final void complete ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
27：protected final void complete ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value  n  if  compareAndSet  0  COMPLETE_MASK    return   value  null   

28：} ; } ; ) 
28：@ SuppressWarnings ( "unchecked" ) public T getValue ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
28：@ SuppressWarnings ( "unchecked" ) public T getValue ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T  value   return null  

29：} ; } ; 
29：public Throwable getError ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
29：public Throwable getError ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o )   return null  

30：} ; } ; } ; ) ( 
30：public static boolean validate ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return false ; } return true ; }
30：public static boolean validate ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription  observer    return false   return true  

31：} ; } ; } ; ) ( { ) 
31：public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return false ; } return true ; }
31：public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED   reportDoubleSubscription  observer    return false   return true  

32：} ; } ; } ; ) ( 
32：public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return false ; } return true ; }
32：public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription  subscriber    return false   return true  

33：} ; } ; } ; ) ( { 
33：public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return false ; } return true ; }
33：public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED )  reportDoubleSubscription  subscriber    return false   return true  

34：} ; } ; 
34：public static long addCap ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
34：public static long addCap ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE   return u  

35：} ; } } ; . 
35：public static long multiplyCap ( long a , long b ) { long u = a * b ; if ( ( ( a | b ) >>> 31 ) != 0 ) { if ( u / a != b ) { return Long . MAX_VALUE ; } } return u ; }
35：public static long multiplyCap ( long a , long b ) { long u = a * b ; if ( ( ( a | b ) >>> 31 ) != 0 ) { if ( u / a != b ) { return Long  MAX_VALUE    return u  

36：} } } ; { ) ) , 
36：public static long add ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
36：public static long add ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r  u    return r    

37：} ; ; ) ( 
37：private static NullPointerException toNpe ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
37：private static NullPointerException toNpe ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause  ex   return npe  

38：} } ; ++ ; ++ ; = ] [ { } ; 
38：public void add ( Object o ) { if ( size == 0 ) { head = new Object [ capacityHint + 1 ] ; tail = head ; head [ 0 ] = o ; indexInTail = 1 ; size = 1 ; } else if ( indexInTail == capacityHint ) { Object [ ] t = new Object [ capacityHint + 1 ] ; t [ 0 ] = o ; tail [ capacityHint ] = t ; tail = t ; indexInTail = 1 ; size ++ ; } else { tail [ indexInTail ] = o ; indexInTail ++ ; size ++ ; } }
38：public void add ( Object o ) { if ( size == 0 ) { head = new Object [ capacityHint + 1 ] ; tail = head ; head [ 0 ] = o ; indexInTail = 1 ; size = 1 ; } else if ( indexInTail == capacityHint ) { Object [ ] t = new Object [ capacityHint + 1 ] ; t [ 0 ] = o ; tail [ capacityHint ] = t ; tail = t ; indexInTail = 1 ; size ++   else  tail  indexInTail   o  indexInTail   size    

39：} ; ) ( . 
39：public static void shutdown ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
39：public static void shutdown ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS  clear    

40：} ; ; ) , 
40：public static ScheduledExecutorService create ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
40：public static ScheduledExecutorService create ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED  exec   return exec  

41：} ; ) ( } ; ) ( . { ) && != ( 
41：public final void setSubscription ( Subscription s ) { if ( cancelled ) { s . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( s , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = s ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { s . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( s ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
41：public final void setSubscription ( Subscription s ) { if ( cancelled ) { s . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( s , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = s ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { s . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( s ) ; if  a  null  cancelOnReplace   a  cancel     drain    

42：} } ; ) ( . 
42：void emitLoop ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = false ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
42：void emitLoop ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = false ; return ; } queue = null ; } q  forEachWhile  this    

43：} ; ) ( } 
43：public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
43：public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ;  return new RuntimeException  error   

44：} ; } } ; ) ( . { } } ; ) ) ( . 
44：public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
44：public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions  get  i      else  list  add  e     return list  

45：} ; ) ( } 
45：@ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
45：@ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ;  throw  E  e  

46：} ; ) ( } ; 
46：public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
46：public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null   dispose  set   

47：} } ; : ) ( 
47：public int size ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
47：public int size ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size    0   

48：} ; } ; } ; ) ( . { } ; ) ( . ; ) ( . ; ) , ( > < = > < } ; ; ) ( . 
48：@ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return true ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return true ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return true ; } return false ; }
48：@ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return true ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( u == null ) { EmptyDisposable  complete  observer   return true   ScalarDisposable  R  sd  new ScalarDisposable  R   observer  u   observer  onSubscribe  sd   sd  run     else  r  subscribe  observer    return true   return false  

49：} ; ) ) , ( > 
49：public static < T , U > Observable < U > scalarXMap ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
49：public static < T , U > Observable < U > scalarXMap ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U   value  mapper    

50：} ; } ; ] [ ) ] [ ( = 
50：public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return true ; } } a = ( Object [ ] ) a [ c ] ; } return false ; }
50：public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return true ; } } a   Object    a  c    return false  

51：} ; } ; ] [ ) ] [ ( = 
51：public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return true ; } } a = ( Object [ ] ) a [ c ] ; } return false ; }
51：public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return true ; } } a   Object    a  c    return false  

52：} } ; ) 
52：public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
52：public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize    

53：} } ; ) ( 
53：public void startUnbounded ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
53：public void startUnbounded ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T >  bufferSize    

54：} ; } } ; ; ) ( { 
54：public boolean offer ( T t ) { if ( once . get ( ) ) { return false ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return true ; } } return false ; }
54：public boolean offer ( T t ) { if ( once . get ( ) ) { return false ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) )  drain    return true    return false  

55：} ; } ; ) 
55：public Disposable get ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
55：public Disposable get ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed (    return d  

56：} } ; ) ( . { ) != ) ( ( 
56：public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
56：public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if  get    DISPOSED   a  onComplete     

57：} ; ) ( . ; ) ( 
57：public final void error ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
57：public final void error ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet  TERMINATED   downstream  onError  t   

58：} ; ) ( . ; ) 
58：public final void complete ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
58：public final void complete ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED   downstream  onComplete    

59：} ; ) , , ( { 
59：@ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , true ) ; }
59：@ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper )  return concatMapDelayError  mapper  2  true   

60：} ; ) , ( { ) 
60：@ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return concatMapIterable ( mapper , 2 ) ; }
60：@ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > mapper   return concatMapIterable  mapper  2   

61：} ; ) ) ( > > < < . 
61：@ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
61：@ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions   List  T   identity     

62：} ; } } ; ) 
62：public PerfAsyncConsumer await ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
62：public PerfAsyncConsumer await ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex     return this  

63：} } ; ) 
63：protected final void request ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
63：protected final void request ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n    

64：} } } ; { ) ) , ( . ( ; = 
64：boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return false ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return true ; } } }
64：boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return false ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ]  ps  if  subscribers  compareAndSet  a  b    return true    

65：} } } ; { ) ) , ( . ( } ; ) - - , , , + , 
65：@ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
65：@ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a  j  1  b  j  n  j  1    if  subscribers  compareAndSet  a  b    return    

66：} ; ) ) , ( > < 
66：public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
66：public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay  T   cf  flowable    

67：} } ; ) , ) > > < , < ( , , , ( > < ) > , < ( { } ; ) ) > > < , < ( , , , ( > < ) > , < ( { ) ( } ; ) , , , ( > < 
67：static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = false ; boolean continuationBodyNullable = false ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) { responseType = Utils . getParameterUpperBound ( 0 , ( ParameterizedType ) responseType ) ; continuationWantsResponse = true ; } else { } adapterType = new Utils . ParameterizedTypeImpl ( null , Call . class , responseType ) ; annotations = SkipCallbackExecutorImpl . ensurePresent ( annotations ) ; } else { adapterType = method . getGenericReturnType ( ) ; } CallAdapter < ResponseT , ReturnT > callAdapter = createCallAdapter ( retrofit , method , adapterType , annotations ) ; Type responseType = callAdapter . responseType ( ) ; if ( responseType == okhttp3 . Response . class ) { throw methodError ( method , "'" + getRawType ( responseType ) . getName ( ) + "' is not a valid response body type. Did you mean ResponseBody?" ) ; } if ( responseType == Response . class ) { throw methodError ( method , "Response must include generic type (e.g., Response<String>)" ) ; } if ( requestFactory . httpMethod . equals ( "HEAD" ) && ! Void . class . equals ( responseType ) ) { throw methodError ( method , "HEAD method must use Void as response type." ) ; } Converter < ResponseBody , ResponseT > responseConverter = createResponseConverter ( retrofit , method , responseType ) ; okhttp3 . Call . Factory callFactory = retrofit . callFactory ; if ( ! isKotlinSuspendFunction ) { return new CallAdapted < > ( requestFactory , callFactory , responseConverter , callAdapter ) ; } else if ( continuationWantsResponse ) { return ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForResponse < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter ) ; } else { return ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForBody < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter , continuationBodyNullable ) ; } }
67：static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = false ; boolean continuationBodyNullable = false ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) { responseType = Utils . getParameterUpperBound ( 0 , ( ParameterizedType ) responseType ) ; continuationWantsResponse = true ; } else { } adapterType = new Utils . ParameterizedTypeImpl ( null , Call . class , responseType ) ; annotations = SkipCallbackExecutorImpl . ensurePresent ( annotations ) ; } else { adapterType = method . getGenericReturnType ( ) ; } CallAdapter < ResponseT , ReturnT > callAdapter = createCallAdapter ( retrofit , method , adapterType , annotations ) ; Type responseType = callAdapter . responseType ( ) ; if ( responseType == okhttp3 . Response . class ) { throw methodError ( method , "'" + getRawType ( responseType ) . getName ( ) + "' is not a valid response body type. Did you mean ResponseBody?" ) ; } if ( responseType == Response . class ) { throw methodError ( method , "Response must include generic type (e.g., Response<String>)" ) ; } if ( requestFactory . httpMethod . equals ( "HEAD" ) && ! Void . class . equals ( responseType ) ) { throw methodError ( method , "HEAD method must use Void as response type." ) ; } Converter < ResponseBody , ResponseT > responseConverter = createResponseConverter ( retrofit , method , responseType ) ; okhttp3 . Call . Factory callFactory = retrofit . callFactory ; if ( ! isKotlinSuspendFunction ) { return new CallAdapted    requestFactory  callFactory  responseConverter  callAdapter    else if  continuationWantsResponse   return  HttpServiceMethod  ResponseT  ReturnT   new SuspendForResponse    requestFactory  callFactory  responseConverter   CallAdapter  ResponseT  Call  ResponseT    callAdapter    else  return  HttpServiceMethod  ResponseT  ReturnT   new SuspendForBody    requestFactory  callFactory  responseConverter   CallAdapter  ResponseT  Call  ResponseT    callAdapter  continuationBodyNullable    

68：} ; ) ( . 
68：public void setDelay ( long amount , TimeUnit unit ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = unit . toMillis ( amount ) ; }
68：public void setDelay ( long amount , TimeUnit unit ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = unit  toMillis  amount   

69：} ; } ; ) ( { ) ) ( 
69：public Response < ? > createErrorResponse ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
69：public Response < ? > createErrorResponse ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful     throw new IllegalStateException  "Error factory returned successful response."    return call  

70：} ; ) , ( . ; ) * 
70：public long calculateDelay ( TimeUnit unit ) { float delta = variancePercent / 100f ; float lowerBound = 1f - delta ; float upperBound = 1f + delta ; float bound = upperBound - lowerBound ; float delayPercent = lowerBound + ( random . nextFloat ( ) * bound ) ; long callDelayMs = ( long ) ( delayMs * delayPercent ) ; return MILLISECONDS . convert ( callDelayMs , unit ) ; }
70：public long calculateDelay ( TimeUnit unit ) { float delta = variancePercent / 100f ; float lowerBound = 1f - delta ; float upperBound = 1f + delta ; float bound = upperBound - lowerBound ; float delayPercent = lowerBound + ( random . nextFloat ( ) * bound ) ; long callDelayMs = ( long ) ( delayMs  delayPercent   return MILLISECONDS  convert  callDelayMs  unit   

71：} } ; ) ( . { } ; ) , ( ; ) , , , ( ; ) , , , ( ; ) ( . ; 
71：private void createSampleData ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try { SecurityContextHolder . getContext ( ) . setAuthentication ( auth ) ; Directory home = new Directory ( username , Directory . ROOT_DIRECTORY ) ; documentDao . create ( home ) ; addPermission ( documentDao , home , username , LEVEL_GRANT_ADMIN ) ; addPermission ( documentDao , home , "ROLE_USER" , LEVEL_GRANT_READ ) ; createFiles ( documentDao , home ) ; Directory confid = new Directory ( "confidential" , home ) ; documentDao . create ( confid ) ; addPermission ( documentDao , confid , "ROLE_USER" , LEVEL_NEGATE_READ ) ; createFiles ( documentDao , confid ) ; Directory shared = new Directory ( "shared" , home ) ; documentDao . create ( shared ) ; addPermission ( documentDao , shared , "ROLE_USER" , LEVEL_GRANT_READ ) ; addPermission ( documentDao , shared , "ROLE_USER" , LEVEL_GRANT_WRITE ) ; createFiles ( documentDao , shared ) ; } finally { SecurityContextHolder . clearContext ( ) ; } }
71：private void createSampleData ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try { SecurityContextHolder . getContext ( ) . setAuthentication ( auth ) ; Directory home = new Directory ( username , Directory . ROOT_DIRECTORY ) ; documentDao . create ( home ) ; addPermission ( documentDao , home , username , LEVEL_GRANT_ADMIN ) ; addPermission ( documentDao , home , "ROLE_USER" , LEVEL_GRANT_READ ) ; createFiles ( documentDao , home ) ; Directory confid = new Directory ( "confidential" , home ) ; documentDao . create ( confid ) ; addPermission ( documentDao , confid , "ROLE_USER" , LEVEL_NEGATE_READ ) ; createFiles ( documentDao , confid ) ; Directory shared = new Directory ( "shared" , home )  documentDao  create  shared   addPermission  documentDao  shared  "ROLE_USER"  LEVEL_GRANT_READ   addPermission  documentDao  shared  "ROLE_USER"  LEVEL_GRANT_WRITE   createFiles  documentDao  shared    finally  SecurityContextHolder  clearContext     

72：} ; } { 
72：private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
72：private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e )   return null  

73：} } ; } ; ) " + + " ( { ) == ) 
73：public DirContextOperations searchForUser ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; } throw notFound ; } }
73：public DirContextOperations searchForUser ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize (   0   throw new UsernameNotFoundException  "User   username   not found in directory."    throw notFound   

74：} ; ) , 
74：public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
74：public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt  rawPassword   

75：} ; ) , ) ( 
75：public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
75：public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString    rawPasswordEncoded   

76：} } ; ) + " " + + " ( . { ) < 
76：private static void performVersionChecks ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; } String springVersion = SpringVersion . getVersion ( ) ; String version = getVersion ( ) ; if ( disableChecks ( springVersion , version ) ) { return ; } logger . info ( "You are running with Spring Security Core " + version ) ; if ( new ComparableVersion ( springVersion ) . compareTo ( new ComparableVersion ( minSpringVersion ) ) < 0 ) { logger . warn ( "**** You are advised to use Spring " + minSpringVersion + " or later with this version. You are running: " + springVersion ) ; } }
76：private static void performVersionChecks ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; } String springVersion = SpringVersion . getVersion ( ) ; String version = getVersion ( ) ; if ( disableChecks ( springVersion , version ) ) { return ; } logger . info ( "You are running with Spring Security Core " + version ) ; if ( new ComparableVersion ( springVersion ) . compareTo ( new ComparableVersion ( minSpringVersion ) )  0   logger  warn  "**** You are advised to use Spring   minSpringVersion   or later with this version. You are running:   springVersion    

77：} ; ) ( . } 
77：private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return true ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
77：private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return true ;  return Boolean  getBoolean  DISABLE_CHECKS   

78：} ; ) ( . } ; { ) 
78：private static String getSpringVersion ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
78：private static String getSpringVersion ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e   return null   return properties  getProperty  "org.springframework:spring-core"   

79：} ; ; ) ( . 
79：public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
79：public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers  add  attributeExchangeConfigurer   return attributeExchangeConfigurer  

80：} ; ; ) ( . 
80：public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer < > ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
80：public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer < > ( ) ) ; this  postProcess  configurer   return configurer  

81：} ; ; ) ( . ; 
81：public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer < > ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
81：public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer < > ( getContext ( ) ) )  this  postProcess  configurer   return configurer  

82：} ; ) ( . 
82：public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer < > ( context ) ) . getRegistry ( ) ; }
82：public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer < > ( context ) )  getRegistry    

83：} ; ) ( . ; ) ) ( ( ) ( = } } ; ; ) 
83：public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
83：public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results   return match    Boolean matches   Boolean  executeReadOnly  new LdapCompareCallback     return matches  booleanValue    

84：} ; ) } } ; ) ) ) ( 
84：public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ; return new DirContextAdapter ( attrs , new DistinguishedName ( dn ) , new DistinguishedName ( ctx . getNameInNamespace ( ) ) ) ; } } ) ; }
84：public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ; return new DirContextAdapter ( attrs , new DistinguishedName ( dn ) , new DistinguishedName ( ctx . getNameInNamespace          

85：} ; } } ; ) ( . { ) != ( ; 
85：public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet < > ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
85：public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet < > ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName )  if  values  null   result  addAll  values     return result  

86：} ; ; ) , , , ( ; ) : ? > . && != ( . ; ) ) ( . ( . ; ) ( = ; } } ; ; ) ( . ; ) ) ) ( 
86：public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { Object [ ] encodedParams = new String [ params . length ] ; for ( int i = 0 ; i < params . length ; i ++ ) { encodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; } String formattedFilter = MessageFormat . format ( filter , encodedParams ) ; logger . debug ( "Using filter: " + formattedFilter ) ; final HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; ContextMapper roleMapper = new ContextMapper ( ) { public Object mapFromContext ( Object ctx ) { DirContextAdapter adapter = ( DirContextAdapter ) ctx ; Map < String , List < String > > record = new HashMap < String , List < String > > ( ) ; if ( attributeNames == null || attributeNames . length == 0 ) { try { for ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; ae . hasMore ( ) ; ) { Attribute attr = ( Attribute ) ae . next ( ) ; extractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; } } catch ( NamingException x ) { org . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; } } else { for ( String attributeName : attributeNames ) { extractStringAttributeValues ( adapter , record , attributeName ) ; } } record . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; set . add ( record ) ; return null ; } } ; SearchControls ctls = new SearchControls ( ) ; ctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; ctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; search ( base , formattedFilter , ctls , roleMapper ) ; return set ; }
86：public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { Object [ ] encodedParams = new String [ params . length ] ; for ( int i = 0 ; i < params . length ; i ++ ) { encodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; } String formattedFilter = MessageFormat . format ( filter , encodedParams ) ; logger . debug ( "Using filter: " + formattedFilter ) ; final HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; ContextMapper roleMapper = new ContextMapper ( ) { public Object mapFromContext ( Object ctx ) { DirContextAdapter adapter = ( DirContextAdapter ) ctx ; Map < String , List < String > > record = new HashMap < String , List < String > > ( ) ; if ( attributeNames == null || attributeNames . length == 0 ) { try { for ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; ae . hasMore ( ) ; ) { Attribute attr = ( Attribute ) ae . next ( ) ; extractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; } } catch ( NamingException x ) { org . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; } } else { for ( String attributeName : attributeNames ) { extractStringAttributeValues ( adapter , record , attributeName ) ; } } record . put ( DN_KEY , Arrays . asList ( getAdapterDN  adapter     set  add  record   return null     SearchControls ctls  new SearchControls    ctls  setSearchScope  searchControls  getSearchScope     ctls  setReturningAttributes  attributeNames  null  attributeNames  length  0  attributeNames  null   search  base  formattedFilter  ctls  roleMapper   return set  

87：} ; ) ( . ) ( . } ; ) ) ( . , ( { ) > ) ( . ( } ; ) , ( { ) == ) ( . ( } ; 
87：public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet < > ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
87：public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet < > ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" )   if  results  size    0   throw new IncorrectResultSizeDataAccessException  1  0    if  results  size    1   throw new IncorrectResultSizeDataAccessException  1  results  size      return results  iterator    next    

88：} ; ) ) ( . , 
88：private static SearchControls buildControls ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
88：private static SearchControls buildControls ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT  originalControls  getDerefLinkFlag     

89：} } ; ) , , ( { ) > ) ( . ( ; ) ) , ( 
89：private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ; if ( parentsToLookup . size ( ) > 0 ) { lookupPrimaryKeys ( acls , parentsToLookup , sids ) ; } }
89：private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet  acls  sids    if  parentsToLookup  size    0   lookupPrimaryKeys  acls  parentsToLookup  sids    

90：} ; ; ) , ( = } ; ) + + + + 
90：public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
90：public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles ["  j2eeUserRoles  "] mapped to Granted Authorities: ["  userGas  "]"    PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result  new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails  context  userGas   return result  

91：} ; ) ( . ) ( ; ) , . ( . ) ( . } ; ) , ( . ) ( . { ) ) . ( . ) ( . ( ; ) + " ( . ; ) , ( . ) 
91：private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
91：private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues (   addPropertyValue  "port"  port   logger  info  "Embedded LDAP server bean definition created for URL:   url   if  parserContext  getRegistry    containsBeanDefinition  BeanIds  EMBEDDED_APACHE_DS    parserContext  getReaderContext    error  "Only one embedded server bean is allowed per application context"  element    parserContext  getRegistry    registerBeanDefinition  BeanIds  EMBEDDED_APACHE_DS  apacheContainer   return  RootBeanDefinition  contextSource  getBeanDefinition    

92：} } ; ) , ( . ) ( . ; ) . , ( . = 
92：private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
92：private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter  GrantedAuthorityDefaultsParserUtils  registerWithDefaultRolePrefix  pc  SecurityContextHolderAwareRequestFilterBeanFactory  class   servApiFilter  getPropertyValues    add  "authenticationManager"  authenticationManager    

93：} } ; ) . ( = { ) ) ( . ( } 
93：private void createJaasApiFilter ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
93：private void createJaasApiFilter ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ;  if  "true"  equals  provideJaasApi    jaasApiFilter  new RootBeanDefinition  JaasApiIntegrationFilter  class    

94：} ; ; ) . . ( . = 
94：private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
94：private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result  result  inclusion  JsonTypeInfo  As  PROPERTY   return result  

95：} ; ) , , , ( } ; 
95：private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , true , filterName , springSecurityFilterChain ) ; }
95：private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute )   registerFilter  servletContext  true  filterName  springSecurityFilterChain   

96：} ; } ; ) , + " ( . { ) ( } ; ) " + + + ( . { 
96：public PersistentRememberMeToken getTokenForSeries ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
96：public PersistentRememberMeToken getTokenForSeries ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne )  logger  error  "Querying token for series '"  seriesId  "' returned more than one value. Series"   should be unique"    catch  DataAccessException e   logger  error  "Failed to load token for series   seriesId  e    return null  

97：} ; } ; ) ) ( 
97：public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList < > ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
97：public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList < > ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority  attribute     return result  

98：} } ; ) , ( { 
98：public static Cipher newCipher ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
98：public static Cipher newCipher ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e )  throw new IllegalStateException  "Should not happen"  e    

99：} ; ) , ( . 
99：public void afterPropertiesSet ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) { throw new RuntimeException ( e ) ; } Assert . notNull ( authenticationManager , "An AuthenticationManager must be set" ) ; }
99：public void afterPropertiesSet ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) { throw new RuntimeException ( e ) ; } Assert  notNull  authenticationManager  "An AuthenticationManager must be set"   

100：} ; ) , ( . } ; ) ) 
100：public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
100：public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse  response    chain  doFilter  request  response   

101：} ; } ; ) " + + " ( . { 
101：protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return false ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return false ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return true ; }
101：protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return false ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return false ; } if ( logger . isDebugEnabled ( ) )  logger  debug  "Pre-authenticated principal has changed to   principal   and will be reauthenticated"    return true  

102：} } } ; { ) ! ( ; ) , , ( { ) ( } ; ) , , 
102：private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
102：private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request  response  authResult    catch  AuthenticationException failed   unsuccessfulAuthentication  request  response  failed   if   continueFilterChainOnUnsuccessfulAuthentication   throw failed    

103：} } ; ) ( { ) || ( 
103：private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
103：private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if  isBodyFullyWritten  requiresFlush   doOnResponseCommitted     

104：} ; } ; ) ( . { ) 
104：public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet < > ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
104：public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet < > ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null   mapped  add  defaultAuthority    return mapped  

105：} ; ) ( ; 
105：public T loginProcessingUrl ( String loginProcessingUrl ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) ) ; return getSelf ( ) ; }
105：public T loginProcessingUrl ( String loginProcessingUrl ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) )  return getSelf    

106：} } ; ) + ( . { ) ) ( . 
106：protected final void updateAuthenticationDefaults ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
106：protected final void updateAuthenticationDefaults ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer  isCustomLogoutSuccess     logoutConfigurer  logoutSuccessUrl  loginPage  "?logout"    

107：} } ; ) 
107：protected final void updateAccessDefaults ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
107：protected final void updateAccessDefaults ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl    

108：} ; ) ( } 
108：protected String mapPassword ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) { passwordValue = new String ( ( byte [ ] ) passwordValue ) ; } return ( String ) passwordValue ; }
108：protected String mapPassword ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) { passwordValue = new String ( ( byte [ ] ) passwordValue ) ;  return  String  passwordValue  

109：} ; } } ; ) ( . 
109：protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
109：protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie  getValue      return null  

110：} ; ) ( . } ; ) - ) ( . ( . { ) == ) - 
110：protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == '=' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
110：protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( )  1   '='   sb  deleteCharAt  sb  length    1    return sb  toString    

111：} ; ) ( . ; ) ( . } ; ) ( . { 
111：protected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( true ) ; response . addCookie ( cookie ) ; }
111：protected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else  cookie  setSecure  useSecureCookie    cookie  setHttpOnly  true   response  addCookie  cookie   

112：} ; ) } ; ) ) ( . ( . : ? == 
112：public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
112：public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter  null  o  Mono  just  adapter  fromPublisher  o       

113：} ; : ) ( . ? ) ( 
113：private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; } return result . startsWith ( "&" ) ? result . substring ( 1 ) : result ; }
113：private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; } return result . startsWith  "&"   result  substring  1   result  

114：} ; } ; ) 
114：private static int getServicePort ( URL casServiceUrl ) { int port = casServiceUrl . getPort ( ) ; if ( port == - 1 ) { port = casServiceUrl . getDefaultPort ( ) ; } return port ; }
114：private static int getServicePort ( URL casServiceUrl ) { int port = casServiceUrl . getPort ( ) ; if ( port == - 1 ) { port = casServiceUrl . getDefaultPort (    return port  

115：} } ; ) + ( { } ; } ; ) ( . { ) ) 
115：public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
115：public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled (    log  debug  "Anonymous Authentication, returning empty String as Principal"    return ""   else  throw new IllegalArgumentException  "The principal property of the authentication object"  "needs to be an LdapUserDetails."    

116：} ; ) ( . } ; ) ( . ; ) 
116：public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( false ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
116：public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( false ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext (   context  setAuthentication  null    SecurityContextHolder  clearContext    

117：} } ; ; ) , ( ; ) ( . . = { ) ( } ; ; ) ( ; ) , ) ( > < 
117：public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try { LoginContext loginContext = createLoginContext ( new InternalCallbackHandler ( auth ) ) ; loginContext . login ( ) ; authorities = new HashSet < > ( ) ; Set < Principal > principals = loginContext . getSubject ( ) . getPrincipals ( ) ; for ( Principal principal : principals ) { for ( AuthorityGranter granter : this . authorityGranters ) { Set < String > roles = granter . grant ( principal ) ; if ( ( roles != null ) && ! roles . isEmpty ( ) ) { for ( String role : roles ) { authorities . add ( new JaasGrantedAuthority ( role , principal ) ) ; } } } } JaasAuthenticationToken result = new JaasAuthenticationToken ( request . getPrincipal ( ) , request . getCredentials ( ) , new ArrayList < > ( authorities ) , loginContext ) ; publishSuccessEvent ( result ) ; return result ; } catch ( LoginException loginException ) { AuthenticationException ase = this . loginExceptionResolver . resolveException ( loginException ) ; publishFailureEvent ( request , ase ) ; throw ase ; } }
117：public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try { LoginContext loginContext = createLoginContext ( new InternalCallbackHandler ( auth ) ) ; loginContext . login ( ) ; authorities = new HashSet < > ( ) ; Set < Principal > principals = loginContext . getSubject ( ) . getPrincipals ( ) ; for ( Principal principal : principals ) { for ( AuthorityGranter granter : this . authorityGranters ) { Set < String > roles = granter . grant ( principal ) ; if ( ( roles != null ) && ! roles . isEmpty ( ) ) { for ( String role : roles ) { authorities . add ( new JaasGrantedAuthority ( role , principal ) ) ; } } } } JaasAuthenticationToken result = new JaasAuthenticationToken ( request . getPrincipal ( ) , request . getCredentials ( ) , new ArrayList    authorities   loginContext   publishSuccessEvent  result   return result   catch  LoginException loginException   AuthenticationException ase  this  loginExceptionResolver  resolveException  loginException   publishFailureEvent  request  ase   throw ase   

118：} ; ) ( . } ; ) " " ( . ; ) ( . } ; 
118：private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
118：private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" )   providerUrl  append  trimmedBaseDn   providerUrl  append       return providerUrl  toString    

119：} ; ) ( > 
119：public void setContextEnvironmentProperties ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable < > ( environment ) ; }
119：public void setContextEnvironmentProperties ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <   environment   

120：} ; ) 
120：public String getRedirectUrl ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
120：public String getRedirectUrl ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString   

121：} ; } ; ) ( { ) 
121：public int doEndTag ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
121：public int doEndTag ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e   throw new JspException  e    return EVAL_PAGE  

122：} } ; ) ( . ) 
122：protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
122：protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService (   createUser  userDetails    

123：} ; ] [ ) ( . ) ( . ) ( } ; ) + 
123：private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
123：private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please "  "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements."    return  UserDetailsService  beans  values    toArray    0   

124：} } ; ) , . ( . { ) ( } ; ) , . 
124：private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
124：private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames  CODE_CHALLENGE_METHOD  "S256"    catch  NoSuchAlgorithmException e   additionalParameters  put  PkceParameterNames  CODE_CHALLENGE  codeVerifier    

125：} ; } ; ) + " = ( 
125：protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
125：protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug  "requiresAuthentication    result    return result  

126：} ; } ; ) + 
126：private boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
126：private boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = "  result    return result  

127：} ; } ; ) + " = 
127：private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return false ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
127：private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return false ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest    result    return result  

128：} ; ) ( ! 
128：private boolean authenticated ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
128：private boolean authenticated ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) &&   authentication instanceof AnonymousAuthenticationToken   

129：} ; } ; ) + " 
129：private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
129：private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest =   result    return result  

130：} ; ; ) ) ( ( . ; ) 
130：protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
130：protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( )   root  setDefaultRolePrefix  getDefaultRolePrefix     return root  

131：} ; ) ( . ) ) ) ( 
131：private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
131：private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just  jwkSet     cache    

132：} } ; ; ) ( . ; 
132：private String utf8UrlEncode ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
132：private String utf8UrlEncode ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." )  err  initCause  e   throw err   

133：} ; } ; ) + " " + + " ( 
133：private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
133：private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug  "WebSphere groups:   webSphereGroups   mapped to Granted Authorities:   userGas    return userGas  

134：} ; ) ( . 
134：protected UserDetails loadUserByAssertion ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
134：protected UserDetails loadUserByAssertion ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService  loadUserDetails  token   

135：} ; } ; ) + 
135：protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
135：protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: "  principal    return principal  

136：} ; } ; . ; ) . , , 
136：public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
136：public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , newArray  destPos  array  length   destPos += array  length   return newArray  

137：} ; ; ) , , 
137：public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
137：public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray  0  length   return subarray  

138：} ; ; ) ( . } } ; ) 
138：public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList < > ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
138：public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList < > ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c     gaList  trimToSize    return gaList  

139：} ; } ; ) ) ) ( . ( , ) ( . ) 
139：private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
139：private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String  entry  getKey    getGrantedAuthorityCollection  entry  getValue       return result  

140：} ; ; ) , 
140：private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > result = new ArrayList < > ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
140：private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > result = new ArrayList < > ( ) ; addGrantedAuthorityCollection ( result  value   return result  

141：} } ; ) ) ( . ) ( . + " ( { } ; 
141：private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { addGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { addGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { addGrantedAuthorityCollection ( result , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) value ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + value . getClass ( ) . getName ( ) ) ; } }
141：private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { addGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { addGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { addGrantedAuthorityCollection ( result , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) value )   else  throw new IllegalArgumentException  "Invalid object type:   value  getClass    getName      

142：} ; } ; ) + " 
142：protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object principal = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + principal ) ; } return principal ; }
142：protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object principal = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal:   principal    return principal  

143：} ; ) ( 
143：@ SuppressWarnings ( "unchecked" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get ( sharedType ) ; }
143：@ SuppressWarnings ( "unchecked" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get  sharedType   

144：} ; ; ) + " ( . } ; ) ( . ; ) ) ( . ( . 
144：protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; } logger . warn ( "Unable to redirect to HTTPS as no port mapping found for HTTP port " + serverPort ) ; return null ; }
144：protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder  setQuery  request  getQueryString     return urlBuilder  getUrl     logger  warn  "Unable to redirect to HTTPS as no port mapping found for HTTP port   serverPort   return null  

145：} ; ) , ( . } ; 
145：public Object invoke ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
145：public Object invoke ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token )   return super  afterInvocation  token  result   

146：} ; + ; ) " + 
146：private static String hasRole ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
146：private static String hasRole ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role   should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead."   return "ROLE_"  role  

147：} ; } ; ] 
147：private static String [ ] hasAnyRole ( String ... roles ) { for ( int i = 0 ; i < roles . length ; i ++ ) { roles [ i ] = "ROLE_" + roles [ i ] ; } return roles ; }
147：private static String [ ] hasAnyRole ( String ... roles ) { for ( int i = 0 ; i < roles . length ; i ++ ) { roles [ i ] = "ROLE_" + roles [ i    return roles  

148：} ; ) ) ( . ( . ) ( } ; ) ( ; ) , " ( . { ) ( } ; ) , , ( ; ) ) ( . , ) ( . , ) ( . ( . { 
148：protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) { throw new RememberMeAuthenticationException ( "No persistent token found for series id: " + presentedSeries ) ; } if ( ! presentedToken . equals ( token . getTokenValue ( ) ) ) { tokenRepository . removeUserTokens ( token . getUsername ( ) ) ; throw new CookieTheftException ( messages . getMessage ( "PersistentTokenBasedRememberMeServices.cookieStolen" , "Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack." ) ) ; } if ( token . getDate ( ) . getTime ( ) + getTokenValiditySeconds ( ) * 1000L < System . currentTimeMillis ( ) ) { throw new RememberMeAuthenticationException ( "Remember-me login has expired" ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Refreshing persistent login token for user '" + token . getUsername ( ) + "', series '" + token . getSeries ( ) + "'" ) ; } PersistentRememberMeToken newToken = new PersistentRememberMeToken ( token . getUsername ( ) , token . getSeries ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . updateToken ( newToken . getSeries ( ) , newToken . getTokenValue ( ) , newToken . getDate ( ) ) ; addCookie ( newToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to update token: " , e ) ; throw new RememberMeAuthenticationException ( "Autologin failed due to data access problem" ) ; } return getUserDetailsService ( ) . loadUserByUsername ( token . getUsername ( ) ) ; }
148：protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) { throw new RememberMeAuthenticationException ( "No persistent token found for series id: " + presentedSeries ) ; } if ( ! presentedToken . equals ( token . getTokenValue ( ) ) ) { tokenRepository . removeUserTokens ( token . getUsername ( ) ) ; throw new CookieTheftException ( messages . getMessage ( "PersistentTokenBasedRememberMeServices.cookieStolen" , "Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack." ) ) ; } if ( token . getDate ( ) . getTime ( ) + getTokenValiditySeconds ( ) * 1000L < System . currentTimeMillis ( ) ) { throw new RememberMeAuthenticationException ( "Remember-me login has expired" ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Refreshing persistent login token for user '" + token . getUsername ( ) + "', series '" + token . getSeries ( ) + "'" ) ; } PersistentRememberMeToken newToken = new PersistentRememberMeToken ( token . getUsername ( ) , token . getSeries ( ) , generateTokenData ( ) , new Date ( ) ) ; try  tokenRepository  updateToken  newToken  getSeries    newToken  getTokenValue    newToken  getDate     addCookie  newToken  request  response    catch  Exception e   logger  error  "Failed to update token:   e   throw new RememberMeAuthenticationException  "Autologin failed due to data access problem"    return getUserDetailsService    loadUserByUsername  token  getUsername     

149：} } ; ) , " ( . { ) ( } ; 
149：protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
149：protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response )   catch  Exception e   logger  error  "Failed to save persistent token   e    

150：} ; } ; ) ) , ) ( . ) ( . ( ( . . { ) 
150：protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ; targetUserRequest = createSwitchUserToken ( request , targetUser ) ; if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Switch User Token [" + targetUserRequest + "]" ) ; } if ( this . eventPublisher != null ) { this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) , targetUser ) ) ; } return targetUserRequest ; }
150：protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ; targetUserRequest = createSwitchUserToken ( request , targetUser ) ; if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Switch User Token [" + targetUserRequest + "]" ) ; } if ( this . eventPublisher != null   this  eventPublisher  publishEvent  new AuthenticationSwitchUserEvent  SecurityContextHolder  getContext    getAuthentication    targetUser     return targetUserRequest  

151：} ; } ; ) ) , ( ( . . { ) != . ( } ; ) ( = 
151：protected Authentication attemptExitUser ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException { Authentication current = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( null == current ) { throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( "SwitchUserFilter.noCurrentUser" , "No current user associated with this request" ) ) ; } Authentication original = getSourceAuthentication ( current ) ; if ( original == null ) { this . logger . debug ( "Could not find original user Authentication object!" ) ; throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( "SwitchUserFilter.noOriginalAuthentication" , "Could not find original Authentication object" ) ) ; } UserDetails originalUser = null ; Object obj = original . getPrincipal ( ) ; if ( ( obj != null ) && obj instanceof UserDetails ) { originalUser = ( UserDetails ) obj ; } if ( this . eventPublisher != null ) { this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( current , originalUser ) ) ; } return original ; }
151：protected Authentication attemptExitUser ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException { Authentication current = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( null == current ) { throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( "SwitchUserFilter.noCurrentUser" , "No current user associated with this request" ) ) ; } Authentication original = getSourceAuthentication ( current ) ; if ( original == null ) { this . logger . debug ( "Could not find original user Authentication object!" ) ; throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( "SwitchUserFilter.noOriginalAuthentication" , "Could not find original Authentication object" ) ) ; } UserDetails originalUser = null ; Object obj = original . getPrincipal ( ) ; if ( ( obj != null ) && obj instanceof UserDetails ) { originalUser   UserDetails  obj   if  this  eventPublisher  null   this  eventPublisher  publishEvent  new AuthenticationSwitchUserEvent  current  originalUser     return original  

152：} ; ) ( = . ; 
152：public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( exitUserUrl ) ; }
152：public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" )  this  exitUserMatcher  createMatcher  exitUserUrl   

153：} ; ) , , ( 
153：@ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
153：@ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView  "hello"  "contact"  rnd   

154：} ; ) ( . } ; ) ( . ; 
154：@ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter springSecurityFilterChain ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
154：@ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter springSecurityFilterChain ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } )  webSecurity  apply  adapter    return webSecurity  build    

155：} ; ) ) ( . ) ( 
155：public Jwt decode ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
155：public Jwt decode ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader    getAlgorithm     

156：} ; ) ) ( , ( . } ; ; ) 
156：public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return false ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
156：public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return false ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e   throw ioException   return ExpressionUtils  evaluateAsBoolean  accessExpression  createExpressionEvaluationContext  handler    

157：} ; ) , ) ( , 
157：public boolean authorizeUsingUrlCheck ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
157：public boolean authorizeUsingUrlCheck ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( )  getMethod    currentUser   

158：} ; ) ) ( . 
158：public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
158：public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors  toList     

159：} ; ) 
159：public CsrfToken generateToken ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
159：public CsrfToken generateToken ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request )   

160：} ; ) , , ( ; ) , ( . ; ) , 
160：@ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap < > ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
160：@ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap < > ( ) ; model . put ( "contact"  contact   model  put  "acl"  acl   return new ModelAndView  "adminPermission"  "model"  model   

161：} ; ) , ( ; ) ) ( , ( . ; ) ) 
161：@ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap < > ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
161：@ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap < > ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients (    model  put  "permissions"  listPermissions     return new ModelAndView  "addPermission"  model   

162：} ; } ; ; ) ) ( , ( . ; ) ) ( , ( . ; ) , , ( . 
162：@ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
162：@ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result  rejectValue  "recipient"  "err.recipientExistsForContact"  "Addition failure."   model  put  "recipients"  listRecipients     model  put  "permissions"  listPermissions     return "addPermission"   return "redirect:/secure/index.htm"  

163：} ; ) , , ( ; ) , ( . ; ) , ( . ; ) 
163：@ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap < > ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
163：@ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap < > ( ) ; model . put ( "contact" , contact   model  put  "sid"  sidObject   model  put  "permission"  permission   return new ModelAndView  "deletePermission"  "model"  model   

164：} ; + } ; { ) ) 
164：private static String getRoleWithDefaultPrefix ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix ) ) { return role ; } return defaultRolePrefix + role ; }
164：private static String getRoleWithDefaultPrefix ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix    return role   return defaultRolePrefix  role  

165：} ; ) ( 
165：public static UserDetailsResourceFactoryBean fromString ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
165：public static UserDetailsResourceFactoryBean fromString ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource  resource   

166：} ; } ; ) ( 
166：public List < String > getAttributeValues ( String name ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
166：public List < String > getAttributeValues ( String name ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = Collections . emptyList     return result  

167：} } ; ) ( 
167：public String getFirstAttributeValue ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
167：public String getFirstAttributeValue ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get  0    

168：} } ; ) , ( { ) ( } ; 
168：public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
168：public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy   catch  CharacterCodingException e   throw new IllegalArgumentException  "Encoding failed"  e    

169：} } ; ) , ( 
169：public static String decode ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
169：public static String decode ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException  "Decoding failed"  e    

170：} ; : ? } } ; = ] [ ; = { ) 
170：private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = false ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = true ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
170：private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = false ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null   found  true  paramNames  i   parameterName    return found  paramNames  null  

171：} ; ; ) ( . ; ) ) ( 
171：@ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
171：@ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail     contactManager  create  contact   return "redirect:/secure/index.htm"  

172：} ; ) , ( 
172：protected Collection < ConfigAttribute > findAttributes ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
172：protected Collection < ConfigAttribute > findAttributes ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst  method  targetClass   

173：} ; ) , ( . . } ; 
173：private void addSecureMethod ( RegisteredMethod method , List < ConfigAttribute > attr ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + attr + "]" ) ; } this . methodMap . put ( method , attr ) ; }
173：private void addSecureMethod ( RegisteredMethod method , List < ConfigAttribute > attr ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + attr + "]" )   this  methodMap  put  method  attr   

174：} ; } ; ) ( 
174：public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > allAttributes = new HashSet < > ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { allAttributes . addAll ( attributeList ) ; } return allAttributes ; }
174：public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > allAttributes = new HashSet < > ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { allAttributes . addAll  attributeList    return allAttributes  

175：} ; ) ) ) ) ( . 
175：private boolean isMatch ( String methodName , String mappedName ) { return ( mappedName . endsWith ( "*" ) && methodName . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && methodName . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
175：private boolean isMatch ( String methodName , String mappedName ) { return ( mappedName . endsWith ( "*" ) && methodName . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && methodName . endsWith ( mappedName . substring ( 1 , mappedName  length       

176：} ; ; = . ; 
176：public C anyRequest ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = true ; return configurer ; }
176：public C anyRequest ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST )  this  anyRequestConfigured  true  return configurer  

177：} } ; ) + 
177：protected void handleBindException ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
177：protected void handleBindException ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": "  cause    

178：} ; ) ( . ; ) 
178：@ Transactional ( readOnly = true ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
178：@ Transactional ( readOnly = true ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( )   return contacts  get  getNumber   

179：} ; ) . ( 
179：protected final void clearAuthenticationAttributes ( HttpServletRequest request ) { HttpSession session = request . getSession ( false ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
179：protected final void clearAuthenticationAttributes ( HttpServletRequest request ) { HttpSession session = request . getSession ( false ) ; if ( session == null ) { return ; } session . removeAttribute  WebAttributes  AUTHENTICATION_EXCEPTION   

180：} } ; ) + " + + ( } ; 
180：public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) { if ( clazz . getSuperclass ( ) != null ) { return getField ( clazz . getSuperclass ( ) , fieldName ) ; } throw new IllegalStateException ( "Could not locate field '" + fieldName + "' on class " + clazz ) ; } }
180：public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) { if ( clazz . getSuperclass ( ) != null ) { return getField ( clazz . getSuperclass ( ) , fieldName )   throw new IllegalStateException  "Could not locate field '"  fieldName  "' on class   clazz    

181：} ; ) . , ) 
181：protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
181：protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter (   this  encodeServiceUrlWithSessionId   

182：} ; ) , ) ( 
182：protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , false ) ; }
182：protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew    false   

183：} ; ) + , ( . } 
183：private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int secondBrace = encPass . lastIndexOf ( '}' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , secondBrace + 1 ) ; }
183：private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int secondBrace = encPass . lastIndexOf ( '}' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ;  return encPass  substring  0  secondBrace  1   

184：} ; ) , . ( . 
184：public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
184：public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response  sendError  HttpServletResponse  SC_FORBIDDEN  "Access Denied"   

185：} ; ) , . ( ; ) , . ( ; 
185：private void checkFilterStack ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
185：private void checkFilterStack ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters )  checkForDuplicates  ExceptionTranslationFilter  class  filters   checkForDuplicates  FilterSecurityInterceptor  class  filters   

186：} ; ) ] ) ( . 
186：@ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] getRegisteredTypes ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
186：@ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] getRegisteredTypes ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList  size      

187：} ; } } ; ) ( . ; 
187：private Throwable extractCause ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
187：private Throwable extractCause ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( )  return extractor  extractCause  throwable     return null  

188：} ; ; ) ) , ( ( . ; ) ( . ) ( . = ; ) ( . = ; 
188：@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
188：@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters )  BeanDefinition accessManager  accessMgrBuilder  getBeanDefinition    String id  pc  getReaderContext    generateBeanName  accessManager   pc  registerBeanComponent  new BeanComponentDefinition  accessManager  id    return id  

189：} ; } ; ) ) ( . ( 
189：public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet < > ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
189：public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet < > ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add  authority  getAuthority      return set  

190：} ; == } ; ] [ ^ 
190：private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return false ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
190：private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return false ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ]  actual  i    return result  0  

191：} ; = . ; ) 
191：public void setDefaultFailureUrl ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
191：public void setDefaultFailureUrl ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL"   this  defaultFailureUrl  defaultFailureUrl  

192：} ; = . ; ) 
192：public void setResolveHiddenInputs ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = resolveHiddenInputs ; }
192：public void setResolveHiddenInputs ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null"   this  resolveHiddenInputs  resolveHiddenInputs  

193：} ; ) ( . } ; ) ( . ) ( 
193：private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
193：private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append  "?"   append  queryString    return url  toString    

194：} ; ) ( . ) ( . 
194：public static boolean isAbsoluteUrl ( String url ) { if ( url == null ) { return false ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
194：public static boolean isAbsoluteUrl ( String url ) { if ( url == null ) { return false ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL  matcher  url   matches    

195：} ; ) ( . } } ; 
195：public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
195：public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( )    return Collections  emptyList    

196：} ; } ; ) ( = { 
196：Serializable identifierFrom ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else { identifier = convertToLong ( identifier ) ; } return identifier ; }
196：Serializable identifierFrom ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else  identifier  convertToLong  identifier    return identifier  

197：} ; ) } } ; ) ) ( . , ( . ; ) ) ( . , ( . ; ) ) ( . 
197：protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , true ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
197：protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , true ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry  isGranting     stmt  setBoolean  6  entry  isAuditSuccess     stmt  setBoolean  7  entry  isAuditFailure         

198：} ; ) . , , ) ( . 
198：protected void createObjectIdentity ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , true ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , true , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
198：protected void createObjectIdentity ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , true ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , true , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( )  toString    sidId  Boolean  TRUE   

199：} } ; ) ( { ) != ( ; ) ) ( . , ) ) ( . 
199：protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , true ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
199：protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , true ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl  isEntriesInheriting     acl  getId     if  count  1   throw new NotFoundException  "Unable to locate ACL to update"    

200：} } ; ) ( . { } } ; ) + 
200：public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( false ) != null ) { request . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; logger . debug ( "DefaultSavedRequest added to Session: " + savedRequest ) ; } } else { logger . debug ( "Request not saved as configured RequestMatcher did not match" ) ; } }
200：public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( false ) != null ) { request . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; logger . debug ( "DefaultSavedRequest added to Session: "  savedRequest     else  logger  debug  "Request not saved as configured RequestMatcher did not match"    

201：} ; ) ( } ; ) ) 
201：public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList < > ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
201：public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList < > ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method     return new OrServerWebExchangeMatcher  matchers   

202：} ; } } ; ) 
202：public static ServerWebExchangeMatcher anyExchange ( ) { return new ServerWebExchangeMatcher ( ) { public Mono < MatchResult > matches ( ServerWebExchange exchange ) { return ServerWebExchangeMatcher . MatchResult . match ( ) ; } } ; }
202：public static ServerWebExchangeMatcher anyExchange ( ) { return new ServerWebExchangeMatcher ( ) { public Mono < MatchResult > matches ( ServerWebExchange exchange ) { return ServerWebExchangeMatcher . MatchResult . match (      

203：} ; ) ) 
203：public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
203：public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt    

204：} ; ) ) 
204：public static TextEncryptor text ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
204：public static TextEncryptor text ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt    

205：} ; ) ) , 
205：public static TextEncryptor queryableText ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
205：public static TextEncryptor queryableText ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( )  salt    

206：} } ; ) ) ( . , ( . { } } } ; ) + " " + ) 
206：public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
206：public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode (      allowFromValue      else  response  setHeader  XFRAME_OPTIONS_HEADER  frameOptionsMode  getMode      

207：} ; ) 
207：protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( request , response ) ; }
207：protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( request , response   

208：} ; } ; ) + " ( . ; = { ) ) ( . ! ( 
208：protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; } String targetUrl = null ; if ( targetUrlParameter != null ) { targetUrl = request . getParameter ( targetUrlParameter ) ; if ( StringUtils . hasText ( targetUrl ) ) { logger . debug ( "Found targetUrlParameter in request: " + targetUrl ) ; return targetUrl ; } } if ( useReferer && ! StringUtils . hasLength ( targetUrl ) ) { targetUrl = request . getHeader ( "Referer" ) ; logger . debug ( "Using Referer header: " + targetUrl ) ; } if ( ! StringUtils . hasText ( targetUrl ) ) { targetUrl = defaultTargetUrl ; logger . debug ( "Using default Url: " + targetUrl ) ; } return targetUrl ; }
208：protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; } String targetUrl = null ; if ( targetUrlParameter != null ) { targetUrl = request . getParameter ( targetUrlParameter ) ; if ( StringUtils . hasText ( targetUrl ) ) { logger . debug ( "Found targetUrlParameter in request: " + targetUrl ) ; return targetUrl ; } } if ( useReferer && ! StringUtils . hasLength ( targetUrl ) ) { targetUrl = request . getHeader ( "Referer" ) ; logger . debug ( "Using Referer header: " + targetUrl ) ; } if   StringUtils  hasText  targetUrl    targetUrl  defaultTargetUrl  logger  debug  "Using default Url:   targetUrl    return targetUrl  

209：} ; = . } ; 
209：public void setTargetUrlParameter ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
209：public void setTargetUrlParameter ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" )   this  targetUrlParameter  targetUrlParameter  

210：} ; ) } } ; ; ) ) ) ( . ( , , ( . ; ) , 
210：private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) { parentDirectory = getDirectoryWithImmediateParentPopulated ( parentDirectoryId ) ; } Directory directory = new Directory ( rs . getString ( "directory_name" ) , parentDirectory ) ; FieldUtils . setProtectedFieldValue ( "id" , directory , new Long ( rs . getLong ( "id" ) ) ) ; return directory ; } } ) ; }
210：private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) { parentDirectory = getDirectoryWithImmediateParentPopulated ( parentDirectoryId ) ; } Directory directory = new Directory ( rs . getString ( "directory_name" )  parentDirectory   FieldUtils  setProtectedFieldValue  "id"  directory  new Long  rs  getLong  "id"     return directory      

211：} ; ; ) , 
211：public DistinguishedName buildDn ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }
211：public DistinguishedName buildDn ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute  username   return dn  

212：} ; ; ) , . ( . ; ) , . ( . 
212：private Map < Class < ? extends Object > , Object > createSharedObjects ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
212：private Map < Class < ? extends Object > , Object > createSharedObjects ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects  put  ContentNegotiationStrategy  class  contentNegotiationStrategy   sharedObjects  put  AuthenticationTrustResolver  class  trustResolver   return sharedObjects  

213：} } ; ) , ( . ; ) + " + + ( . 
213：private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = false ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
213：private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = false ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log  debug  "Setting security property ["  key  "] to:   loginConfigUrl   Security  setProperty  key  loginConfigUrl    

214：} ; } } } ; ) ) 
214：public static String getCurrentDate ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
214：public static String getCurrentDate ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now       return currentDate  

215：} ; ) ) ( . ( } ; { 
215：private static Long internalParseDate ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
215：private static Long internalParseDate ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null )  return null   return new Long  date  getTime     

216：} ; ) , ( . } 
216：@ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap cache , Object key , Object value ) { if ( value == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( key , value ) ; }
216：@ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap cache , Object key , Object value ) { if ( value == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ;  cache  put  key  value   

217：} ; ) ) 
217：protected void setDetails ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
217：protected void setDetails ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request    

218：} ; } ; ) + " " + + " ( . { ) 
218：private static String getSecurityName ( final Subject subject ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + subject ) ; } String userSecurityName = null ; if ( subject != null ) { Object credential = subject . getPublicCredentials ( getWSCredentialClass ( ) ) . iterator ( ) . next ( ) ; if ( credential != null ) { userSecurityName = ( String ) invokeMethod ( getSecurityNameMethod ( ) , credential ) ; } } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Websphere security name is " + userSecurityName + " for subject " + subject ) ; } return userSecurityName ; }
218：private static String getSecurityName ( final Subject subject ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + subject ) ; } String userSecurityName = null ; if ( subject != null ) { Object credential = subject . getPublicCredentials ( getWSCredentialClass ( ) ) . iterator ( ) . next ( ) ; if ( credential != null ) { userSecurityName = ( String ) invokeMethod ( getSecurityNameMethod ( ) , credential ) ; } } if ( logger . isDebugEnabled ( )   logger  debug  "Websphere security name is   userSecurityName   for subject   subject    return userSecurityName  

219：} } } ; ) , ( . { ) ( } } ; ) ( . { ) != ( { { } ; ) , ( 
219：@ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String securityName ) { Context ic = null ; try { ic = new InitialContext ( ) ; Object objRef = ic . lookup ( USER_REGISTRY ) ; Object userReg = invokeMethod ( getNarrowMethod ( ) , null , objRef , Class . forName ( "com.ibm.websphere.security.UserRegistry" ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining WebSphere groups for user " + securityName + " using WebSphere UserRegistry " + userReg ) ; } final Collection groups = ( Collection ) invokeMethod ( getGroupsForUserMethod ( ) , userReg , new Object [ ] { securityName } ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Groups for user " + securityName + ": " + groups . toString ( ) ) ; } return new ArrayList ( groups ) ; } catch ( Exception e ) { logger . error ( "Exception occured while looking up groups for user" , e ) ; throw new RuntimeException ( "Exception occured while looking up groups for user" , e ) ; } finally { try { if ( ic != null ) { ic . close ( ) ; } } catch ( NamingException e ) { logger . debug ( "Exception occured while closing context" , e ) ; } } }
219：@ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String securityName ) { Context ic = null ; try { ic = new InitialContext ( ) ; Object objRef = ic . lookup ( USER_REGISTRY ) ; Object userReg = invokeMethod ( getNarrowMethod ( ) , null , objRef , Class . forName ( "com.ibm.websphere.security.UserRegistry" ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining WebSphere groups for user " + securityName + " using WebSphere UserRegistry " + userReg ) ; } final Collection groups = ( Collection ) invokeMethod ( getGroupsForUserMethod ( ) , userReg , new Object [ ] { securityName } ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Groups for user " + securityName + ": " + groups . toString ( ) ) ; } return new ArrayList ( groups ) ; } catch ( Exception e ) { logger . error ( "Exception occured while looking up groups for user" , e ) ; throw new RuntimeException  "Exception occured while looking up groups for user"  e    finally  try  if  ic  null   ic  close      catch  NamingException e   logger  debug  "Exception occured while closing context"  e     

220：} } ; ) , , ( { } ; ) , , ( { 
220：public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
220：public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation )  changePasswordUsingExtensionOperation  userDn  oldPassword  newPassword    else  changePasswordUsingAttributeModification  userDn  oldPassword  newPassword    

221：} ; ; ) ) 
221：protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return dn ; }
221：protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase (    return dn  

222：} ; ) ( . } } ; = { ) ) ) ( . ( . 
222：protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; } SessionInformation leastRecentlyUsed = null ; for ( SessionInformation session : sessions ) { if ( ( leastRecentlyUsed == null ) || session . getLastRequest ( ) . before ( leastRecentlyUsed . getLastRequest ( ) ) ) { leastRecentlyUsed = session ; } } leastRecentlyUsed . expireNow ( ) ; }
222：protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; } SessionInformation leastRecentlyUsed = null ; for ( SessionInformation session : sessions ) { if ( ( leastRecentlyUsed == null ) || session . getLastRequest ( )  before  leastRecentlyUsed  getLastRequest      leastRecentlyUsed  session    leastRecentlyUsed  expireNow    

223：} } ; ) ) ( . 
223：private void copyDetails ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
223：private void copyDetails ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source  getDetails      

224：} ; } } ; 
224：private List < Filter > getFilters ( HttpServletRequest request ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( request ) ) { return chain . getFilters ( ) ; } } return null ; }
224：private List < Filter > getFilters ( HttpServletRequest request ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( request ) ) { return chain . getFilters ( )    return null  

225：} ; ) ) ) 
225：public List < Filter > getFilters ( String url ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
225：public List < Filter > getFilters ( String url ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( )     

226：} ; ) ( 
226：protected ApplicationContext getContext ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
226：protected ApplicationContext getContext ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext  servletContext   

227：} ; ; ) ( . } ; 
227：public static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
227：public static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn   baseDn  append  dn   return baseDn  

228：} ; ; ) . , , 
228：public MockMvcRequestSpecification sessionAttrs ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
228：public MockMvcRequestSpecification sessionAttrs ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) )  sessionAttributes  this  sessionAttributes   return this  

229：} ; ; ) ( . ; 
229：public AuthenticationScheme basic ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
229：public AuthenticationScheme basic ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName )  preemptiveBasicAuthScheme  setPassword  password   return preemptiveBasicAuthScheme  

230：} ; ) ( 
230：public static void filters ( List < Filter > filters ) { Validate . notNull ( filters , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( filters ) ; }
230：public static void filters ( List < Filter > filters ) { Validate . notNull ( filters , "Filter list cannot be null" ) ; RestAssured . filters . addAll  filters   

231：} } ; ) , . ( 
231：public static void filters ( Filter filter , Filter ... additionalFilters ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
231：public static void filters ( Filter filter , Filter ... additionalFilters ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( additionalFilters != null ) { Collections . addAll  RestAssured  filters  additionalFilters    

232：} ; ; ) ( 
232：public static AuthenticationScheme basic ( String userName , String password ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; return scheme ; }
232：public static AuthenticationScheme basic ( String userName , String password ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword  password   return scheme  

233：} ; ; ) ( . ; ) 
233：public static AuthenticationScheme ntlm ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( workstation ) ; scheme . setDomain ( domain ) ; return scheme ; }
233：public static AuthenticationScheme ntlm ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( workstation   scheme  setDomain  domain   return scheme  

234：} ; ; ) ( . ; ) ( . 
234：public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
234：public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme  setPassword  password   scheme  setConfig  config   return scheme  

235：} ; ) ) ) ( 
235：public static void proxy ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } proxy ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
235：public static void proxy ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } proxy ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme      

236：} ; ; ) ( . ; ) ( . = } ; ) ( . } ; ) . ( . ) . ( . { ) ) ( ! 
236：public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
236：public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL &&  isBlank  responseBodyToAppend    builder  append  SystemUtils  LINE_SEPARATOR   append  SystemUtils  LINE_SEPARATOR    builder  append  responseBodyToAppend    String response  builder  toString    stream  println  response   return response  

237：} ; ) ) . ( , ) . ( , ) . ( , ) . 
237：public RestAssuredConfig redirect ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
237：public RestAssuredConfig redirect ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig  class   conf  ParamConfig  class   conf  OAuthConfig  class   conf  FailureConfig  class    

238：} ; ) , , 
238：public EncoderConfig defaultQueryParameterCharset ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , true ) ; }
238：public EncoderConfig defaultQueryParameterCharset ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders  contentTypeToDefaultCharset  true   

239：} ; ) , , , , 
239：public ObjectMapperConfig defaultObjectMapperType ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , true ) ; }
239：public ObjectMapperConfig defaultObjectMapperType ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory  jackson2ObjectMapperFactory  jaxbObjectMapperFactory  johnzonObjectMapperFactory  true   

240：} ; ) , , , , , 
240：public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , true ) ; }
240：public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory  jackson1ObjectMapperFactory  jackson2ObjectMapperFactory  jaxbObjectMapperFactory  johnzonObjectMapperFactory  true   

241：} ; ) , , , , , 
241：public RestAssuredMockMvcConfig logConfig ( LogConfig logConfig ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
241：public RestAssuredMockMvcConfig logConfig ( LogConfig logConfig ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

242：} ; ) , , , , , 
242：public RestAssuredMockMvcConfig sessionConfig ( SessionConfig sessionConfig ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
242：public RestAssuredMockMvcConfig sessionConfig ( SessionConfig sessionConfig ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

243：} ; ) , , , , , 
243：public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig objectMapperConfig ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
243：public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig objectMapperConfig ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

244：} ; ) , , , , , 
244：public RestAssuredMockMvcConfig jsonConfig ( JsonConfig jsonConfig ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
244：public RestAssuredMockMvcConfig jsonConfig ( JsonConfig jsonConfig ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

245：} ; ) , , , , , 
245：public RestAssuredMockMvcConfig xmlConfig ( XmlConfig xmlConfig ) { notNull ( xmlConfig , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
245：public RestAssuredMockMvcConfig xmlConfig ( XmlConfig xmlConfig ) { notNull ( xmlConfig , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

246：} ; ) , , , , , 
246：public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig encoderConfig ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
246：public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig encoderConfig ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

247：} ; ) , , , , , 
247：public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
247：public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

248：} ; ) , , , , , 
248：public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig asyncConfig ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
248：public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig asyncConfig ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

249：} ; ) , , , , , , 
249：public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig mockMvcConfig ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
249：public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig mockMvcConfig ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig  headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

250：} ; ) , , , , , , 
250：public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig multiPartConfig ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
250：public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig multiPartConfig ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig  headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

251：} ; ) , , , , , , 
251：public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
251：public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig  headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

252：} ; ) , , , , , 
252：public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig matcherConfig ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
252：public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig matcherConfig ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig  asyncConfig  multiPartConfig  mockMvcConfig  paramConfig  matcherConfig   

253：} ; ) , , 
253：public CertificateAuthSettings allowAllHostnames ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
253：public CertificateAuthSettings allowAllHostnames ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore  ALLOW_ALL_HOSTNAME_VERIFIER  sslSocketFactory   

254：} ; ) , , , , 
254：public XmlPathConfig declareNamespaces ( Map < String , String > namespacesToDeclare ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , namespacesToDeclare , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
254：public XmlPathConfig declareNamespaces ( Map < String , String > namespacesToDeclare ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , namespacesToDeclare  properties  validating  namespaceAware  allowDocTypeDeclaration   

255：} ; ) , , , , , , , , , 
255：public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , true , allowDocTypeDeclaration ) ; }
255：public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory  defaultParserType  defaultDeserializer  charset  features  updatedNamespaces  properties  validating  true  allowDocTypeDeclaration   

256：} ; ) , , . 
256：public Object request ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . defaultContentType , hasBody , configClosure ) ; }
256：public Object request ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this  defaultContentType  hasBody  configClosure   

257：} } ; ) ) ( . , ) 
257：public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; } }
257：public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString (   val  toString      

258：} ; ) ) , 
258：public void setProxy ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
258：public void setProxy ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port  scheme    

259：} ; ; = . 
259：public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = true ; return this ; }
259：public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this  isControlNameExplicit  true  return this  

260：} ; ; ) , ( . } } ; ) ( 
260：public MultiPartSpecBuilder header ( String name , String value ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ; final Set < String > headerNames = headers . keySet ( ) ; final String trimmedName = name . trim ( ) ; for ( String headerName : headerNames ) { if ( headerName . equalsIgnoreCase ( trimmedName ) ) { headers . remove ( headerName ) ; } } headers . put ( name , value ) ; return this ; }
260：public MultiPartSpecBuilder header ( String name , String value ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ; final Set < String > headerNames = headers . keySet ( ) ; final String trimmedName = name . trim ( ) ; for ( String headerName : headerNames ) { if ( headerName . equalsIgnoreCase ( trimmedName ) ) { headers . remove  headerName     headers  put  name  value   return this  

261：} ; ) ) , ( 
261：public void basic ( String host , int port , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
261：public void basic ( String host , int port , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials  user  pass    

262：} ; ) ) , , , 
262：public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
262：public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user  pass  workstation  domain    

263：} ; ) ( } ; ) , 
263：public static Headers headers ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
263：public static Headers headers ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList  additionalHeaders    return new Headers  headerList   

264：} ; = ; = ; 
264：public static void reset ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
264：public static void reset ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null  requestSpecification  null  authentication  null  

265：} ; } ; ) ( . { ) ) ( . 
265：public ResponseBuilder setHeader ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
265：public ResponseBuilder setHeader ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name )  equalsIgnoreCase  CONTENT_TYPE    restAssuredResponse  setContentType  value    return this  

266：} ; ; ) ) ( ( . } ; ) ) 
266：public Response build ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
266：public Response build ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode (     restAssuredResponse  setRpr  new ResponseParserRegistrar     return restAssuredResponse  

267：} ; ) ) ) 
267：public DetailedCookieMatcher value ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
267：public DetailedCookieMatcher value ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher     

268：} ; ) ) ) 
268：public DetailedCookieMatcher comment ( Matcher < ? super String > commentMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , commentMatcher ) ) ) ; }
268：public DetailedCookieMatcher comment ( Matcher < ? super String > commentMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , commentMatcher     

269：} ; ) ) ) 
269：public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
269：public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher     

270：} ; ) ) ) 
270：public DetailedCookieMatcher domain ( Matcher < ? super String > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , domainMatcher ) ) ) ; }
270：public DetailedCookieMatcher domain ( Matcher < ? super String > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , domainMatcher     

271：} ; ) ) ) 
271：public DetailedCookieMatcher path ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
271：public DetailedCookieMatcher path ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher     

272：} ; ) ) ) 
272：public DetailedCookieMatcher secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
272：public DetailedCookieMatcher secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher     

273：} ; ) ) ) 
273：public DetailedCookieMatcher httpOnly ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , httpOnlyMatcher ) ) ) ; }
273：public DetailedCookieMatcher httpOnly ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , httpOnlyMatcher     

274：} ; ) ) ) 
274：public DetailedCookieMatcher version ( Matcher < ? super Integer > versionMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , versionMatcher ) ) ) ; }
274：public DetailedCookieMatcher version ( Matcher < ? super Integer > versionMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , versionMatcher     

275：} ; ) ) ) 
275：public DetailedCookieMatcher maxAge ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
275：public DetailedCookieMatcher maxAge ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher     

276：} ; ; ) 
276：public ResponseSpecBuilder expectHeader ( String headerName , Matcher < String > expectedValueMatcher ) { spec . header ( headerName , expectedValueMatcher ) ; return this ; }
276：public ResponseSpecBuilder expectHeader ( String headerName , Matcher < String > expectedValueMatcher ) { spec . header ( headerName , expectedValueMatcher   return this  

277：} ; ; 
277：public ResponseSpecBuilder expectHeader ( String headerName , String expectedValue ) { spec . header ( headerName , expectedValue ) ; return this ; }
277：public ResponseSpecBuilder expectHeader ( String headerName , String expectedValue ) { spec . header ( headerName , expectedValue )  return this  

278：} ; ; 
278：public ResponseSpecBuilder expectCookie ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
278：public ResponseSpecBuilder expectCookie ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue )  return this  

279：} ; ) 
279：public ProxySpecification withHost ( String host ) { return new ProxySpecification ( host , port , scheme , username , password ) ; }
279：public ProxySpecification withHost ( String host ) { return new ProxySpecification ( host , port , scheme , username , password   

280：} ; ) , , , 
280：public JsonPathConfig numberReturnType ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
280：public JsonPathConfig numberReturnType ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory  johnzonObjectMapperFactory  defaultDeserializer  charset   

281：} ; ) , , , , 
281：public JsonPathConfig defaultParserType ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
281：public JsonPathConfig defaultParserType ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory  jackson2ObjectMapperFactory  johnzonObjectMapperFactory  defaultDeserializer  charset   

282：} ; ) , 
282：public LogConfig defaultStream ( PrintStream printStream ) { return new LogConfig ( printStream , true , logDetailIfValidationFails , urlEncodeRequestUri , true ) ; }
282：public LogConfig defaultStream ( PrintStream printStream ) { return new LogConfig ( printStream , true , logDetailIfValidationFails , urlEncodeRequestUri  true   

283：} ; ) , , 
283：public LogConfig enableLoggingOfRequestAndResponseIfValidationFails ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , true ) ; }
283：public LogConfig enableLoggingOfRequestAndResponseIfValidationFails ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail  urlEncodeRequestUri  true   

284：} ; } ; ) ( . } ; ) ( { ) ( } 
284：static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ; if ( type == null || ( ! ( type . isInstance ( HttpEntityEnclosingRequest . class ) ) && hasBody ) ) { httpRequest = new CustomHttpMethod ( method , uri ) ; } else { try { httpRequest = type . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } httpRequest . setURI ( uri ) ; } return httpRequest ; }
284：static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ; if ( type == null || ( ! ( type . isInstance ( HttpEntityEnclosingRequest . class ) ) && hasBody ) ) { httpRequest = new CustomHttpMethod ( method , uri ) ; } else { try { httpRequest = type . newInstance ( ) ;  catch  Exception e   throw new RuntimeException  e    httpRequest  setURI  uri    return httpRequest  

285：} ; ) , 
285：public MultiPartConfig defaultBoundary ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , defaultBoundary , defaultCharset , true ) ; }
285：public MultiPartConfig defaultBoundary ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , defaultBoundary , defaultCharset  true   

286：} ; ; 
286：public MockMvcRequestSpecBuilder addAttribute ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
286：public MockMvcRequestSpecBuilder addAttribute ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue )  return this  

287：} ; ; 
287：public MockMvcRequestSpecBuilder addHeader ( String headerName , String headerValue ) { spec . header ( headerName , headerValue ) ; return this ; }
287：public MockMvcRequestSpecBuilder addHeader ( String headerName , String headerValue ) { spec . header ( headerName , headerValue )  return this  

288：} ; ; ) 
288：public MockMvcRequestSpecBuilder addMultiPart ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
288：public MockMvcRequestSpecBuilder addMultiPart ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType   return this  

289：} ; ; ) 
289：public MockMvcRequestSpecBuilder addResultHandlers ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
289：public MockMvcRequestSpecBuilder addResultHandlers ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers   return this  

290：} ; ) , , , , , ( 
290：public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , true ) ; }
290：public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig  httpClientFactory  newParams  httpMultipartMode  shouldReuseHttpClientInstance  NO_HTTP_CLIENT  true   

291：} ; ) , , , , , ( ; 
291：public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , true ) ; }
291：public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( httpClientParams )  return new HttpClientConfig  httpClientFactory  newParams  httpMultipartMode  shouldReuseHttpClientInstance  NO_HTTP_CLIENT  true   

292：} ; ) , , 
292：public HttpClientConfig httpClientFactory ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , true ) ; }
292：public HttpClientConfig httpClientFactory ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance  NO_HTTP_CLIENT  true   

293：} ; ) , , 
293：public HttpClientConfig httpMultipartMode ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , httpClient , true ) ; }
293：public HttpClientConfig httpMultipartMode ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance  httpClient  true   

294：} ; ) , ( . ) 
294：public < T > T get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( T ) jsonAssertion . getResult ( json , null ) ; }
294：public < T > T get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( T  jsonAssertion  getResult  json  null   

295：} } ; ) . , ( . { } 
295：public int getInt ( String path ) { Object value = get ( path ) ; if ( value instanceof Integer ) { return ( Integer ) value ; } else if ( value instanceof Short ) { return ( ( Short ) value ) . intValue ( ) ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . intValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Integer . class ) ; } }
295：public int getInt ( String path ) { Object value = get ( path ) ; if ( value instanceof Integer ) { return ( Integer ) value ; } else if ( value instanceof Short ) { return ( ( Short ) value ) . intValue ( ) ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . intValue ( ) ;  else  return ObjectConverter  convertObjectTo  value  Integer  class    

296：} } ; ) . , ( . { } 
296：public byte getByte ( String path ) { Object value = get ( path ) ; if ( value instanceof Byte ) { return ( Byte ) value ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . byteValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . byteValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Byte . class ) ; } }
296：public byte getByte ( String path ) { Object value = get ( path ) ; if ( value instanceof Byte ) { return ( Byte ) value ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . byteValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . byteValue ( ) ;  else  return ObjectConverter  convertObjectTo  value  Byte  class    

297：} } ; ) . , ( . { } 
297：public short getShort ( String path ) { Object value = get ( path ) ; if ( value instanceof Short ) { return ( Short ) value ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . shortValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . shortValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Short . class ) ; } }
297：public short getShort ( String path ) { Object value = get ( path ) ; if ( value instanceof Short ) { return ( Short ) value ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . shortValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . shortValue ( ) ;  else  return ObjectConverter  convertObjectTo  value  Short  class    

298：} } ; ) . , 
298：public float getFloat ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( ( Double ) value ) . floatValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Float . class ) ; } }
298：public float getFloat ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( ( Double ) value ) . floatValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value  Float  class    

299：} ; ) . , 
299：public double getDouble ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
299：public double getDouble ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value  Double  class   

300：} } ; ) . , ( . { } 
300：public long getLong ( String path ) { Object value = get ( path ) ; if ( value instanceof Long ) { return ( Long ) value ; } else if ( value instanceof Short ) { return ( ( Short ) value ) . longValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . longValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Long . class ) ; } }
300：public long getLong ( String path ) { Object value = get ( path ) ; if ( value instanceof Long ) { return ( Long ) value ; } else if ( value instanceof Short ) { return ( ( Short ) value ) . longValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . longValue ( ) ;  else  return ObjectConverter  convertObjectTo  value  Long  class    

301：} ; ) ( . } } ; ) ( . } ; ) , ( . 
301：public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) { String str = objectToString ( t ) ; e = ( T ) jsonStringToObject ( str , genericType ) ; } else { e = ObjectConverter . convertObjectTo ( t , genericType ) ; } newList . add ( e ) ; } } return Collections . unmodifiableList ( newList ) ; }
301：public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) { String str = objectToString ( t ) ; e = ( T ) jsonStringToObject ( str , genericType ) ; } else { e = ObjectConverter  convertObjectTo  t  genericType    newList  add  e     return Collections  unmodifiableList  newList   

302：} ; ) 
302：public < K , V > Map < K , V > getMap ( String path ) { return get ( path ) ; }
302：public < K , V > Map < K , V > getMap ( String path ) { return get ( path   

303：} ; ) , 
303：public < T > T getObject ( String path , Class < T > objectType ) { Object object = getFromPath ( path , false ) ; return getObjectAsType ( object , objectType ) ; }
303：public < T > T getObject ( String path , Class < T > objectType ) { Object object = getFromPath ( path , false ) ; return getObjectAsType ( object  objectType   

304：} ; ; 
304：public RequestSpecBuilder setBody ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
304：public RequestSpecBuilder setBody ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper )  return this  

305：} ; ; ) 
305：public RequestSpecBuilder addCookie ( String key , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( key , value , cookieNameValuePairs ) ; return this ; }
305：public RequestSpecBuilder addCookie ( String key , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( key , value , cookieNameValuePairs   return this  

306：} ; ; 
306：public RequestSpecBuilder addParam ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
306：public RequestSpecBuilder addParam ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues )  return this  

307：} ; ; ) 
307：public RequestSpecBuilder addParam ( String parameterName , Collection < ? > parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
307：public RequestSpecBuilder addParam ( String parameterName , Collection < ? > parameterValues ) { spec . param ( parameterName , parameterValues   return this  

308：} ; ) , , 
308：public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , true ) ; }
308：public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy  sessionUpdateStrategy  true   

309：} ; ) , 
309：public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( stream , matcher ) ; }
309：public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( stream  matcher   

310：} ; ) ( ; ) , ( 
310：public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
310：public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll  cookieList  additionalCookies   return new Cookies  cookieList   

311：} } } } } ; ) . ( . { 
311：private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
311：private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) )  backingMap  remove  keyAndSource  key       

312：} } ; ) , 
312：void index ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
312：void index ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( )  binding    

313：} ; ) , , ( } ; 
313：< T > BindingImpl < T > getBindingOrThrow ( Key < T > key , Errors errors , JitLimitation jitType ) throws ErrorsException { BindingImpl < T > binding = state . getExplicitBinding ( key ) ; if ( binding != null ) { return binding ; } return getJustInTimeBinding ( key , errors , jitType ) ; }
313：< T > BindingImpl < T > getBindingOrThrow ( Key < T > key , Errors errors , JitLimitation jitType ) throws ErrorsException { BindingImpl < T > binding = state . getExplicitBinding ( key ) ; if ( binding != null ) { return binding   return getJustInTimeBinding  key  errors  jitType   

314：} } ; ) ( . ) , , , , ( . { ) ( } ; { ) ( } ; ) , , , , ( > < } ; ) 
314：private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException { Key < String > stringKey = key . ofType ( STRING_TYPE ) ; BindingImpl < String > stringBinding = state . getExplicitBinding ( stringKey ) ; if ( stringBinding == null || ! stringBinding . isConstant ( ) ) { return null ; } @ SuppressWarnings ( "unchecked" ) String stringValue = ( ( InstanceBinding < String > ) stringBinding ) . getInstance ( ) ; Object source = stringBinding . getSource ( ) ; TypeLiteral < T > type = key . getTypeLiteral ( ) ; TypeConverterBinding typeConverterBinding = state . getConverter ( stringValue , type , errors , source ) ; if ( typeConverterBinding == null ) { return null ; } try { @ SuppressWarnings ( "unchecked" ) T converted = ( T ) typeConverterBinding . getTypeConverter ( ) . convert ( stringValue , type ) ; if ( converted == null ) { throw errors . converterReturnedNull ( stringValue , source , type , typeConverterBinding ) . toException ( ) ; } if ( ! type . getRawType ( ) . isInstance ( converted ) ) { throw errors . conversionTypeError ( stringValue , source , type , typeConverterBinding , converted ) . toException ( ) ; } return new ConvertedConstantBindingImpl < T > ( this , key , converted , stringBinding , typeConverterBinding ) ; } catch ( ErrorsException e ) { throw e ; } catch ( RuntimeException e ) { throw errors . conversionError ( stringValue , source , type , typeConverterBinding , e ) . toException ( ) ; } }
314：private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException { Key < String > stringKey = key . ofType ( STRING_TYPE ) ; BindingImpl < String > stringBinding = state . getExplicitBinding ( stringKey ) ; if ( stringBinding == null || ! stringBinding . isConstant ( ) ) { return null ; } @ SuppressWarnings ( "unchecked" ) String stringValue = ( ( InstanceBinding < String > ) stringBinding ) . getInstance ( ) ; Object source = stringBinding . getSource ( ) ; TypeLiteral < T > type = key . getTypeLiteral ( ) ; TypeConverterBinding typeConverterBinding = state . getConverter ( stringValue , type , errors , source ) ; if ( typeConverterBinding == null ) { return null ; } try { @ SuppressWarnings ( "unchecked" ) T converted = ( T ) typeConverterBinding . getTypeConverter ( ) . convert ( stringValue , type ) ; if ( converted == null ) { throw errors . converterReturnedNull ( stringValue , source , type , typeConverterBinding ) . toException ( ) ; } if ( ! type . getRawType ( ) . isInstance ( converted ) ) { throw errors . conversionTypeError ( stringValue , source , type , typeConverterBinding , converted ) . toException (    return new ConvertedConstantBindingImpl  T   this  key  converted  stringBinding  typeConverterBinding    catch  ErrorsException e   throw e   catch  RuntimeException e   throw errors  conversionError  stringValue  source  type  typeConverterBinding  e   toException     

315：} ; } } } ; = { ) == ) ( . ( } } ; = ; ) , ( { 
315：private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = false ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) { BindingImpl depBinding = jitBindings . get ( depKey ) ; if ( depBinding != null ) { boolean failed = cleanup ( depBinding , encountered ) ; if ( depBinding instanceof ConstructorBindingImpl ) { ConstructorBindingImpl ctorBinding = ( ConstructorBindingImpl ) depBinding ; ip = ctorBinding . getInternalConstructor ( ) ; if ( ! ctorBinding . isInitialized ( ) ) { failed = true ; } } if ( failed ) { removeFailedJitBinding ( depBinding , ip ) ; bindingFailed = true ; } } else if ( state . getExplicitBinding ( depKey ) == null ) { bindingFailed = true ; } } } return bindingFailed ; }
315：private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = false ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) { BindingImpl depBinding = jitBindings . get ( depKey ) ; if ( depBinding != null ) { boolean failed = cleanup ( depBinding , encountered ) ; if ( depBinding instanceof ConstructorBindingImpl ) { ConstructorBindingImpl ctorBinding = ( ConstructorBindingImpl ) depBinding ; ip = ctorBinding . getInternalConstructor ( ) ; if ( ! ctorBinding . isInitialized ( ) ) { failed = true ; } } if ( failed )  removeFailedJitBinding  depBinding  ip   bindingFailed  true    else if  state  getExplicitBinding  depKey   null   bindingFailed  true     return bindingFailed  

316：} } ; ) ( . { ) 
316：private void removeFailedJitBinding ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
316：private void removeFailedJitBinding ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null   constructors  remove  ip    

317：} } ; ) ( . { } ; 
317：@ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
317：@ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( )   else  return ImmutableSet  of     

318：} ; ) . , . && , , , , , , ( . } ; ) , , , ( ; ) , , ( . { ) 
318：< T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ; if ( rawType . isArray ( ) || ( rawType . isEnum ( ) && implementedBy != null ) ) { throw errors . missingImplementationWithHint ( key , this ) . toException ( ) ; } if ( rawType == TypeLiteral . class ) { @ SuppressWarnings ( "unchecked" ) BindingImpl < T > binding = ( BindingImpl < T > ) createTypeLiteralBinding ( ( Key < TypeLiteral < Object > > ) key , errors ) ; return binding ; } if ( implementedBy != null ) { Annotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; return createImplementedByBinding ( key , scoping , implementedBy , errors ) ; } ProvidedBy providedBy = rawType . getAnnotation ( ProvidedBy . class ) ; if ( providedBy != null ) { Annotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; return createProvidedByBinding ( key , scoping , providedBy , errors ) ; } return ConstructorBindingImpl . create ( this , key , null , source , scoping , errors , jitBinding && options . jitDisabled , options . atInjectRequired ) ; }
318：< T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ; if ( rawType . isArray ( ) || ( rawType . isEnum ( ) && implementedBy != null ) ) { throw errors . missingImplementationWithHint ( key , this ) . toException ( ) ; } if ( rawType == TypeLiteral . class ) { @ SuppressWarnings ( "unchecked" ) BindingImpl < T > binding = ( BindingImpl < T > ) createTypeLiteralBinding ( ( Key < TypeLiteral < Object > > ) key , errors ) ; return binding ; } if ( implementedBy != null ) { Annotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; return createImplementedByBinding ( key , scoping , implementedBy , errors ) ; } ProvidedBy providedBy = rawType . getAnnotation ( ProvidedBy . class ) ; if ( providedBy != null   Annotations  checkForMisplacedScopeAnnotations  rawType  source  errors   return createProvidedByBinding  key  scoping  providedBy  errors    return ConstructorBindingImpl  create  this  key  null  source  scoping  errors  jitBinding  options  jitDisabled  options  atInjectRequired   

319：} ; } ; ) ( . ] [ = 
319：static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { parameters [ i ] = parameterInjectors [ i ] . inject ( context ) ; } return parameters ; }
319：static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { parameters [ i ]  parameterInjectors  i   inject  context    return parameters  

320：} ; ) ) ) ( > < . , 
320：private static void bindInjector ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
320：private static void bindInjector ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory  ImmutableSet   InjectionPoint  of      

321：} ; ) ) ) ( > < . , 
321：private static void bindLogger ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
321：private static void bindLogger ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory  ImmutableSet   InjectionPoint  of      

322：} ; ; ) , ( . } } { ) ( } 
322：private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return false ; } if ( member instanceof Method ) { try { if ( member . getDeclaringClass ( ) . getDeclaredField ( member . getName ( ) ) != null ) { return false ; } } catch ( NoSuchFieldException ignore ) { } } errors . misplacedBindingAnnotation ( member , misplacedBindingAnnotation ) ; return true ; }
322：private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return false ; } if ( member instanceof Method ) { try { if ( member . getDeclaringClass ( ) . getDeclaredField ( member . getName ( ) ) != null ) { return false ; }  catch  NoSuchFieldException ignore     errors  misplacedBindingAnnotation  member  misplacedBindingAnnotation   return true  

323：} ; ) ) ( . ) ( . 
323：private static boolean overrides ( Method a , Method b ) { int modifiers = b . getModifiers ( ) ; if ( Modifier . isPublic ( modifiers ) || Modifier . isProtected ( modifiers ) ) { return true ; } if ( Modifier . isPrivate ( modifiers ) ) { return false ; } return a . getDeclaringClass ( ) . getPackage ( ) . equals ( b . getDeclaringClass ( ) . getPackage ( ) ) ; }
323：private static boolean overrides ( Method a , Method b ) { int modifiers = b . getModifiers ( ) ; if ( Modifier . isPublic ( modifiers ) || Modifier . isProtected ( modifiers ) ) { return true ; } if ( Modifier . isPrivate ( modifiers ) ) { return false ; } return a . getDeclaringClass ( ) . getPackage ( ) . equals ( b  getDeclaringClass    getPackage     

324：} ; ) , ( 
324：public void initializeDelegate ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
324：public void initializeDelegate ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull  delegate  "delegate"   

325：} ; ) ) ) 
325：@ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > providerType ( ) { return ( TypeLiteral < Provider < T > > ) get ( Types . providerOf ( getType ( ) ) ) ; }
325：@ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > providerType ( ) { return ( TypeLiteral < Provider < T > > ) get ( Types . providerOf ( getType (     

326：} ; ) ( . } ; ) 
326：private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int t = 0 ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
326：private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int t = 0 ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ]    return ImmutableList  copyOf  result   

327：} ; ; ) ) ( . ( . ) > < ( = > < ) ( } ; { ) . == ) ( . 
327：public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; @ SuppressWarnings ( "unchecked" ) TypeLiteral < T > guiceProviderType = ( TypeLiteral < T > ) TypeLiteral . get ( Types . providerOf ( parameterizedType . getActualTypeArguments ( ) [ 0 ] ) ) ; return guiceProviderType ; } @ SuppressWarnings ( "unchecked" ) TypeLiteral < T > wrappedPrimitives = ( TypeLiteral < T > ) PRIMITIVE_TO_WRAPPER . get ( typeLiteral ) ; if ( wrappedPrimitives != null ) { return wrappedPrimitives ; } if ( typeLiteral . getClass ( ) == TypeLiteral . class ) { return typeLiteral ; } @ SuppressWarnings ( "unchecked" ) TypeLiteral < T > recreated = ( TypeLiteral < T > ) TypeLiteral . get ( typeLiteral . getType ( ) ) ; return recreated ; }
327：public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; @ SuppressWarnings ( "unchecked" ) TypeLiteral < T > guiceProviderType = ( TypeLiteral < T > ) TypeLiteral . get ( Types . providerOf ( parameterizedType . getActualTypeArguments ( ) [ 0 ] ) ) ; return guiceProviderType ; } @ SuppressWarnings ( "unchecked" ) TypeLiteral < T > wrappedPrimitives = ( TypeLiteral < T > ) PRIMITIVE_TO_WRAPPER . get ( typeLiteral ) ; if ( wrappedPrimitives != null ) { return wrappedPrimitives ; } if ( typeLiteral  getClass    TypeLiteral  class   return typeLiteral   @ SuppressWarnings  "unchecked"  TypeLiteral  T  recreated   TypeLiteral  T   TypeLiteral  get  typeLiteral  getType     return recreated  

328：} ; ) } } ; { ) ( } } ; ) ) ( . ( { ) ( } ; ) ( . { { ) > ? < , ( ) ( { ) ( , } } ; { 
328：static void prepareBuiltInConverters ( InjectorImpl injector ) { convertToPrimitiveType ( injector , int . class , Integer . class ) ; convertToPrimitiveType ( injector , long . class , Long . class ) ; convertToPrimitiveType ( injector , boolean . class , Boolean . class ) ; convertToPrimitiveType ( injector , byte . class , Byte . class ) ; convertToPrimitiveType ( injector , short . class , Short . class ) ; convertToPrimitiveType ( injector , float . class , Float . class ) ; convertToPrimitiveType ( injector , double . class , Double . class ) ; convertToClass ( injector , Character . class , new TypeConverter ( ) { public Object convert ( String value , TypeLiteral < ? > toType ) { value = value . trim ( ) ; if ( value . length ( ) != 1 ) { throw new RuntimeException ( "Length != 1." ) ; } return value . charAt ( 0 ) ; } public String toString ( ) { return "TypeConverter<Character>" ; } } ) ; convertToClasses ( injector , Matchers . subclassesOf ( Enum . class ) , new TypeConverter ( ) { @ SuppressWarnings ( "unchecked" ) public Object convert ( String value , TypeLiteral < ? > toType ) { return Enum . valueOf ( ( Class ) toType . getRawType ( ) , value ) ; } public String toString ( ) { return "TypeConverter<E extends Enum<E>>" ; } } ) ; internalConvertToTypes ( injector , new AbstractMatcher < TypeLiteral < ? > > ( ) { public boolean matches ( TypeLiteral < ? > typeLiteral ) { return typeLiteral . getRawType ( ) == Class . class ; } public String toString ( ) { return "Class<?>" ; } } , new TypeConverter ( ) { @ SuppressWarnings ( "unchecked" ) public Object convert ( String value , TypeLiteral < ? > toType ) { try { return Class . forName ( value ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } public String toString ( ) { return "TypeConverter<Class<?>>" ; } } ) ; }
328：static void prepareBuiltInConverters ( InjectorImpl injector ) { convertToPrimitiveType ( injector , int . class , Integer . class ) ; convertToPrimitiveType ( injector , long . class , Long . class ) ; convertToPrimitiveType ( injector , boolean . class , Boolean . class ) ; convertToPrimitiveType ( injector , byte . class , Byte . class ) ; convertToPrimitiveType ( injector , short . class , Short . class ) ; convertToPrimitiveType ( injector , float . class , Float . class ) ; convertToPrimitiveType ( injector , double . class , Double . class ) ; convertToClass ( injector , Character . class , new TypeConverter ( ) { public Object convert ( String value , TypeLiteral < ? > toType ) { value = value . trim ( ) ; if ( value . length ( ) != 1 ) { throw new RuntimeException ( "Length != 1." ) ; } return value . charAt ( 0 ) ; } public String toString ( ) { return "TypeConverter<Character>" ; } } ) ; convertToClasses ( injector , Matchers . subclassesOf ( Enum . class ) , new TypeConverter ( ) { @ SuppressWarnings ( "unchecked" ) public Object convert ( String value , TypeLiteral < ? > toType ) { return Enum . valueOf ( ( Class ) toType . getRawType ( ) , value ) ; } public String toString ( ) { return "TypeConverter<E extends Enum<E>>" ; } } ) ; internalConvertToTypes ( injector , new AbstractMatcher < TypeLiteral < ? > > ( ) { public boolean matches ( TypeLiteral < ? > typeLiteral ) { return typeLiteral . getRawType ( ) == Class . class ; } public String toString ( )  return "Class<?>"     new TypeConverter    @ SuppressWarnings  "unchecked"  public Object convert  String value  TypeLiteral    toType   try  return Class  forName  value    catch  ClassNotFoundException e   throw new RuntimeException  e  getMessage       public String toString    return "TypeConverter<Class<?>>"      

329：} ; ) ( 
329：private static ClassLoader canonicalize ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
329：private static ClassLoader canonicalize ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent    

330：} } ; { ) ( } 
330：private static boolean hasSameVersionOfCglib ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return false ; } }
330：private static boolean hasSameVersionOfCglib ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ;  catch  ClassNotFoundException e   return false   

331：} ; } } ; { ) ) ) ( . ( . ! 
331：private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return false ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return false ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return false ; } } return true ; }
331：private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return false ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return false ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if (  Modifier  isPublic  type  getModifiers      return false    return true  

332：} ; ) ) ( 
332：public Key < ? > fixAnnotations ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
332：public Key < ? > fixAnnotations ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType     

333：} ; ; ) ( . ; ) , ( . ; ) ) ) ( . ( . , , , ) ( . : ? 
333：< T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ; if ( instance == null || ( injectionPoints . isEmpty ( ) && ! injector . membersInjectorStore . hasTypeListeners ( ) && provisionCallback == null ) ) { return Initializables . of ( instance ) ; } if ( initializablesCache . containsKey ( instance ) ) { @ SuppressWarnings ( "unchecked" ) Initializable < T > cached = ( Initializable < T > ) initializablesCache . get ( instance ) ; return cached ; } InjectableReference < T > injectableReference = new InjectableReference < T > ( injector , instance , binding == null ? null : binding . getKey ( ) , provisionCallback , source , cycleDetectingLockFactory . create ( instance . getClass ( ) ) ) ; initializablesCache . put ( instance , injectableReference ) ; pendingInjections . add ( injectableReference ) ; return injectableReference ; }
333：< T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ; if ( instance == null || ( injectionPoints . isEmpty ( ) && ! injector . membersInjectorStore . hasTypeListeners ( ) && provisionCallback == null ) ) { return Initializables . of ( instance ) ; } if ( initializablesCache . containsKey ( instance ) ) { @ SuppressWarnings ( "unchecked" ) Initializable < T > cached = ( Initializable < T > ) initializablesCache . get ( instance ) ; return cached ; } InjectableReference < T > injectableReference = new InjectableReference < T > ( injector , instance , binding == null  null  binding  getKey    provisionCallback  source  cycleDetectingLockFactory  create  instance  getClass      initializablesCache  put  instance  injectableReference   pendingInjections  add  injectableReference   return injectableReference  

334：} } } ; ) ) ( . 
334：void validateOustandingInjections ( Errors errors ) { validationStarted = true ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
334：void validateOustandingInjections ( Errors errors ) { validationStarted = true ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e  getErrors       

335：} } ; ) ( 
335：public T newInstance ( Object [ ] args ) throws Throwable { constructor . setAccessible ( true ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
335：public T newInstance ( Object [ ] args ) throws Throwable { constructor . setAccessible ( true ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause     

336：} ; } } ; ) ( . : ? ) 
336：@ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) { if ( ! servletPipeline . hasServletsMapped ( ) ) { return servletRequest ; } HttpServletRequest request = ( HttpServletRequest ) servletRequest ; return new HttpServletRequestWrapper ( request ) { public RequestDispatcher getRequestDispatcher ( String path ) { final RequestDispatcher dispatcher = servletPipeline . getRequestDispatcher ( path ) ; return ( null != dispatcher ) ? dispatcher : super . getRequestDispatcher ( path ) ; } } ; }
336：@ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) { if ( ! servletPipeline . hasServletsMapped ( ) ) { return servletRequest ; } HttpServletRequest request = ( HttpServletRequest ) servletRequest ; return new HttpServletRequestWrapper ( request ) { public RequestDispatcher getRequestDispatcher ( String path ) { final RequestDispatcher dispatcher = servletPipeline . getRequestDispatcher ( path ) ; return ( null != dispatcher   dispatcher  super  getRequestDispatcher  path      

337：} ; ) , ( > < ; ) ) , ( 
337：static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ; Provider < T > scoped = scope . scope ( key , new ProviderToInternalFactoryAdapter < T > ( injector , creator ) ) ; return new InternalFactoryToProviderAdapter < T > ( scoped , source ) ; }
337：static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ; Provider < T > scoped = scope . scope ( key , new ProviderToInternalFactoryAdapter < T >  injector  creator    return new InternalFactoryToProviderAdapter  T   scoped  source   

338：} ; ; ) ( . } ; ) ) 
338：static Scoping makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
338：static Scoping makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope (     errors  scopeNotFound  scopeAnnotation   return UNSCOPED  

339：} ; ) ( . } ; ) ( . { ) != ( ; ) , ( . } } ; 
339：static String normalizePath ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( '?' ) ; String query = null ; if ( queryStart != - 1 ) { query = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; } List < String > segments = new ArrayList < > ( ) ; for ( String segment : SLASH_SPLITTER . split ( path ) ) { String normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; if ( "." . equals ( normalized ) ) { } else if ( ".." . equals ( normalized ) ) { if ( segments . size ( ) > 1 ) { segments . remove ( segments . size ( ) - 1 ) ; } } else { segments . add ( normalized ) ; } } SLASH_JOINER . appendTo ( sb , segments ) ; if ( query != null ) { sb . append ( query ) ; } return sb . toString ( ) ; }
339：static String normalizePath ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( '?' ) ; String query = null ; if ( queryStart != - 1 ) { query = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; } List < String > segments = new ArrayList < > ( ) ; for ( String segment : SLASH_SPLITTER . split ( path ) ) { String normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; if ( "." . equals ( normalized ) ) { } else if ( ".." . equals ( normalized ) ) { if ( segments . size ( ) > 1 ) { segments . remove ( segments . size ( ) - 1 ) ; } } else { segments . add ( normalized )    SLASH_JOINER  appendTo  sb  segments   if  query  null   sb  append  query    return sb  toString    

340：} ; ) ( . ) 
340：public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
340：public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T  cache  getUnchecked  annotationType   

341：} ; . == ) ( 
341：public static boolean isRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
341：public static boolean isRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; return retention != null && retention . value    RetentionPolicy  RUNTIME  

342：} ; } } } ; = { } ; 
342：public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
342：public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , annotationType )   else  found  annotationType     return found  

343：} ; ) , ( . : ) ( 
343：public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
343：public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get  type   Key  get  type  found   

344：} } ; { } ; ) ( . ) 
344：public static String nameOf ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
344：public static String nameOf ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType (   getName     else  return ""   

345：} ; ) , ( 
345：public void initializeDelegate ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
345：public void initializeDelegate ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull  delegate  "delegate"   

346：} ; ) ) ( 
346：private void addDirectTypeBinding ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
346：private void addDirectTypeBinding ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T >  bindingSelection    

347：} ; ) , 
347：public ConstructorInjector < ? > get ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
347：public ConstructorInjector < ? > get ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector  errors   

348：} ; } } ; { 
348：private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return true ; } } return false ; }
348：private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) )  return true    return false  

349：} ; ) ) ) ) , ( ( . , ( . 
349：static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
349：static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder  newRealSetBinder  binder  valueTypeAndAnnotation  ofType  entryOfProviderOf  keyType  valueType      

350：} ; ; ) ) , ( > , < ( . ) ( . ; 
350：Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
350：Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) )  entrySetBinder  addBinding    toProvider  new ProviderMapEntry  K  V   key  valueKey    return valueKey  

351：} } ; ) ( . { } ; ) ) ( . ( . ) ( . ; : 
351：private T provision ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; } constructionContext . setCurrentReference ( t ) ; MembersInjectorImpl < T > localMembersInjector = membersInjector ; localMembersInjector . injectMembers ( t , context , false ) ; localMembersInjector . notifyListeners ( t ) ; return t ; } catch ( InvocationTargetException userException ) { Throwable cause = userException . getCause ( ) != null ? userException . getCause ( ) : userException ; throw InternalProvisionException . errorInjectingConstructor ( cause ) . addSource ( constructionProxy . getInjectionPoint ( ) ) ; } finally { constructionContext . removeCurrentReference ( ) ; } }
351：private T provision ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; } constructionContext . setCurrentReference ( t ) ; MembersInjectorImpl < T > localMembersInjector = membersInjector ; localMembersInjector . injectMembers ( t , context , false ) ; localMembersInjector . notifyListeners ( t ) ; return t ; } catch ( InvocationTargetException userException ) { Throwable cause = userException . getCause ( ) != null ? userException . getCause ( )  userException  throw InternalProvisionException  errorInjectingConstructor  cause   addSource  constructionProxy  getInjectionPoint      finally  constructionContext  removeCurrentReference     

352：} ; ) , , ) ( . ( 
352：private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
352：private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message  ImmutableList  copyOf  sourcesAsStrings   message  cause   

353：} ; ) ( 
353：static Module forModule ( Module module ) { if ( module instanceof CheckedProviderMethodsModule ) { return Modules . EMPTY_MODULE ; } return new CheckedProviderMethodsModule ( module ) ; }
353：static Module forModule ( Module module ) { if ( module instanceof CheckedProviderMethodsModule ) { return Modules . EMPTY_MODULE ; } return new CheckedProviderMethodsModule  module   

354：} ; ) ( . 
354：@ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > getAssistedMethods ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
354：@ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > getAssistedMethods ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod  values    

355：} } ; { } ; ) ) ( . ) 
355：private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return false ; } }
355：private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages   getMessage      else  return false   

356：} ; } } ; { ) . == ) ( . ( { ) : > ? < ( } 
356：private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; } for ( Key < ? > key : paramList ) { if ( ! constructorKeys . remove ( key ) ) { return false ; } } for ( Key < ? > key : constructorKeys ) { if ( key . getAnnotationType ( ) == Assisted . class ) { return false ; } } return true ; }
356：private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; } for ( Key < ? > key : paramList ) { if ( ! constructorKeys . remove ( key ) ) { return false ; }  for  Key    key  constructorKeys   if  key  getAnnotationType    Assisted  class   return false    return true  

357：} ; ) ( . } } ; ) ) ( 
357：private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
357：private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies       return builder  build    

358：} ; ) ( . } } ; ) ( . 
358：private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
358：private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder  add  dep     return builder  build    

359：} ; } ; ; ) } , , { ] [ , + " + " + " + " , . ( 
359：private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ; for ( Dependency < ? > dep : dependencies ) { if ( isInjectorOrAssistedProvider ( dep ) ) { if ( badDeps == null ) { badDeps = Sets . newHashSet ( ) ; } badDeps . add ( dep ) ; } } if ( badDeps != null && ! badDeps . isEmpty ( ) ) { logger . log ( Level . WARNING , "AssistedInject factory {0} will be slow " + "because {1} has assisted Provider dependencies or injects the Injector. " + "Stop injecting @Assisted Provider<T> (instead use @Assisted T) " + "or Injector to speed things up. (It will be a ~6500% speed bump!) " + "The exact offending deps are: {2}" , new Object [ ] { factoryType , implementation , badDeps } ) ; return false ; } return true ; }
359：private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ; for ( Dependency < ? > dep : dependencies ) { if ( isInjectorOrAssistedProvider ( dep ) ) { if ( badDeps == null ) { badDeps = Sets . newHashSet ( ) ; } badDeps . add ( dep ) ; } } if ( badDeps != null && ! badDeps . isEmpty ( ) ) { logger . log  Level  WARNING  "AssistedInject factory {0} will be slow   "because {1} has assisted Provider dependencies or injects the Injector.   "Stop injecting @Assisted Provider<T> (instead use @Assisted T)   "or Injector to speed things up. (It will be a ~6500% speed bump!)   "The exact offending deps are: {2}"  new Object    factoryType  implementation  badDeps    return false   return true  

360：} ; } ; = . { ) . ( ; ) ( . = > ? < ; ) ( . = ; } } } ; ) . ( . ) 
360：public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ; final Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; Module assistedModule = new AbstractModule ( ) { @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) protected void configure ( ) { Binder binder = binder ( ) . withSource ( method ) ; int p = 0 ; if ( ! data . optimized ) { for ( Key < ? > paramKey : data . paramTypes ) { binder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p ++ ] ) ) ; } } else { for ( Key < ? > paramKey : data . paramTypes ) { binder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p ++ ) ) ; } } Constructor constructor = data . constructor ; if ( constructor != null ) { binder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType ) . in ( Scopes . NO_SCOPE ) ; } } } ; Injector forCreate = injector . createChildInjector ( assistedModule ) ; Binding < ? > binding = forCreate . getBinding ( returnKey ) ; if ( data . optimized ) { data . cachedBinding = binding ; } return binding ; }
360：public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ; final Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; Module assistedModule = new AbstractModule ( ) { @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) protected void configure ( ) { Binder binder = binder ( ) . withSource ( method ) ; int p = 0 ; if ( ! data . optimized ) { for ( Key < ? > paramKey : data . paramTypes ) { binder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p ++ ] ) ) ; } } else { for ( Key < ? > paramKey : data . paramTypes ) { binder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p ++ ) ) ; } } Constructor constructor = data . constructor ; if ( constructor != null ) { binder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType   in  Scopes  NO_SCOPE       Injector forCreate  injector  createChildInjector  assistedModule   Binding    binding  forCreate  getBinding  returnKey   if  data  optimized   data  cachedBinding  binding   return binding  

361：} } } ; ) ( . { ) . : ( { } ; } } ; { ) ) , ( && != ( ; ) ( . = ; ) ) 
361：public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { if ( methodHandleByMethod . containsKey ( method ) ) { return methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; } if ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { if ( "equals" . equals ( method . getName ( ) ) ) { return proxy == args [ 0 ] ; } else if ( "hashCode" . equals ( method . getName ( ) ) ) { return System . identityHashCode ( proxy ) ; } else { return method . invoke ( this , args ) ; } } AssistData data = assistDataByMethod . get ( method ) ; checkState ( data != null , "No data for method: %s" , method ) ; Provider < ? > provider ; if ( data . cachedBinding != null ) { provider = data . cachedBinding . getProvider ( ) ; } else { provider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; } try { int p = 0 ; for ( ThreadLocalProvider tlp : data . providers ) { tlp . set ( args [ p ++ ] ) ; } return provider . get ( ) ; } catch ( ProvisionException e ) { if ( e . getErrorMessages ( ) . size ( ) == 1 ) { Message onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; Throwable cause = onlyError . getCause ( ) ; if ( cause != null && canRethrow ( method , cause ) ) { throw cause ; } } throw e ; } finally { for ( ThreadLocalProvider tlp : data . providers ) { tlp . remove ( ) ; } } }
361：public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { if ( methodHandleByMethod . containsKey ( method ) ) { return methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; } if ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { if ( "equals" . equals ( method . getName ( ) ) ) { return proxy == args [ 0 ] ; } else if ( "hashCode" . equals ( method . getName ( ) ) ) { return System . identityHashCode ( proxy ) ; } else { return method . invoke ( this , args ) ; } } AssistData data = assistDataByMethod . get ( method ) ; checkState ( data != null , "No data for method: %s" , method ) ; Provider < ? > provider ; if ( data . cachedBinding != null ) { provider = data . cachedBinding . getProvider ( ) ; } else { provider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; } try { int p = 0 ; for ( ThreadLocalProvider tlp : data . providers ) { tlp . set ( args [ p ++ ] ) ; } return provider . get ( ) ; } catch ( ProvisionException e ) { if ( e . getErrorMessages ( ) . size ( ) == 1 ) { Message onlyError = getOnlyElement ( e . getErrorMessages (    Throwable cause  onlyError  getCause    if  cause  null  canRethrow  method  cause    throw cause    throw e   finally  for  ThreadLocalProvider tlp  data  providers   tlp  remove      

362：} ; ) ) ( . ( } ; ) ) ( ( . { ) ) ) ( . ) ( . ( . && == ) ( . && ) ( . && ) ( . ( } } } ; ) ) , ( ( . { ) : ( ; ) ) ( 
362：< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ; List < String > possibleMatches = new ArrayList < > ( ) ; TypeLiteral < T > type = key . getTypeLiteral ( ) ; List < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; if ( ! sameTypes . isEmpty ( ) ) { sb . append ( format ( "%n Did you mean?" ) ) ; int howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; for ( int i = 0 ; i < howMany ; ++ i ) { sb . append ( format ( "%n * %s" , sameTypes . get ( i ) . getKey ( ) ) ) ; } int remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; if ( remaining > 0 ) { String plural = ( remaining == 1 ) ? "" : "s" ; sb . append ( format ( "%n %d more binding%s with other annotations." , remaining , plural ) ) ; } } else { String want = type . toString ( ) ; Map < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; for ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { String have = bindingKey . getTypeLiteral ( ) . toString ( ) ; if ( have . contains ( want ) || want . contains ( have ) ) { Formatter fmt = new Formatter ( ) ; Messages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; String match = String . format ( "%s bound%s" , convert ( bindingKey ) , fmt . toString ( ) ) ; possibleMatches . add ( match ) ; if ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { break ; } } } if ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { sb . append ( format ( "%n Did you mean?" ) ) ; for ( String possibleMatch : possibleMatches ) { sb . append ( format ( "%n %s" , possibleMatch ) ) ; } } } if ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { sb . append ( format ( "%nThe key seems very generic, did you forget an annotation?" ) ) ; } return addMessage ( sb . toString ( ) ) ; }
362：< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ; List < String > possibleMatches = new ArrayList < > ( ) ; TypeLiteral < T > type = key . getTypeLiteral ( ) ; List < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; if ( ! sameTypes . isEmpty ( ) ) { sb . append ( format ( "%n Did you mean?" ) ) ; int howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; for ( int i = 0 ; i < howMany ; ++ i ) { sb . append ( format ( "%n * %s" , sameTypes . get ( i ) . getKey ( ) ) ) ; } int remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; if ( remaining > 0 ) { String plural = ( remaining == 1 ) ? "" : "s" ; sb . append ( format ( "%n %d more binding%s with other annotations." , remaining , plural ) ) ; } } else { String want = type . toString ( ) ; Map < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; for ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { String have = bindingKey . getTypeLiteral ( ) . toString ( ) ; if ( have . contains ( want ) || want . contains ( have ) ) { Formatter fmt = new Formatter ( ) ; Messages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; String match = String . format ( "%s bound%s" , convert ( bindingKey ) , fmt . toString ( ) ) ; possibleMatches . add ( match ) ; if ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { break ; } } } if ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { sb . append ( format  "%n Did you mean?"    for  String possibleMatch  possibleMatches   sb  append  format  "%n %s"  possibleMatch       if  sameTypes  isEmpty    possibleMatches  isEmpty    key  getAnnotation    null  COMMON_AMBIGUOUS_TYPES  contains  key  getTypeLiteral    getRawType      sb  append  format  "%nThe key seems very generic, did you forget an annotation?"     return addMessage  sb  toString     

363：} ; ; ) ( . ; ) 
363：public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder < > ( binder , key ) ; binder . install ( result ) ; return result ; }
363：public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder < > ( binder , key   binder  install  result   return result  

364：} ; ) ) , , ) 
364：Key < T > getKeyForNewItem ( ) { checkConfiguration ( ! bindingSelection . isInitialized ( ) , "Multibinder was already initialized" ) ; return Key . get ( bindingSelection . getElementTypeLiteral ( ) , new RealElement ( bindingSelection . getSetName ( ) , MULTIBINDER , "" ) ) ; }
364：Key < T > getKeyForNewItem ( ) { checkConfiguration ( ! bindingSelection . isInitialized ( ) , "Multibinder was already initialized" ) ; return Key . get ( bindingSelection . getElementTypeLiteral ( ) , new RealElement ( bindingSelection . getSetName (   MULTIBINDER  ""    

365：} ; } } ; { 
365：private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
365：private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null )  return filter    return null  

366：} ; ) . 
366：private static boolean hasAtInject ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
366：private static boolean hasAtInject ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject  class   

367：} } ; { } 
367：InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
367：InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ;  else  return constructorInjectionPoint   

368：} ; ) ) ( . ( . } ; ) ) 
368：Set < Dependency < ? > > getInternalDependencies ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ; try { builder . addAll ( InjectionPoint . forInstanceMethodsAndFields ( constructorInjectionPoint . getDeclaringType ( ) ) ) ; } catch ( ConfigurationException ignored ) { } } else { builder . add ( getConstructor ( ) ) . addAll ( getInjectableMembers ( ) ) ; } return Dependency . forInjectionPoints ( builder . build ( ) ) ; }
368：Set < Dependency < ? > > getInternalDependencies ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ; try { builder . addAll ( InjectionPoint . forInstanceMethodsAndFields ( constructorInjectionPoint . getDeclaringType ( ) ) ) ; } catch ( ConfigurationException ignored ) { } } else { builder . add ( getConstructor ( ) ) . addAll ( getInjectableMembers (     return Dependency  forInjectionPoints  builder  build     

369：} ; ) 
369：public static Module forModule ( Object module , ModuleAnnotatedMethodScanner scanner ) { return forObject ( module , false , scanner ) ; }
369：public static Module forModule ( Object module , ModuleAnnotatedMethodScanner scanner ) { return forObject ( module , false , scanner   

370：} ; } } ; = } ; ; ) , , " + 
370：private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
370：private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s."   Methods can only have one annotation claimed per scanner."  scanner  method   return null   annotation  foundAnnotation    return annotation  

371：} ; ) ) ( ( 
371：public Integer getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
371：public Integer getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get  memberKey  member    

372：} ; ) 
372：void initialize ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
372：void initialize ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups   

373：} ; ) ) ( 
373：public static < T > Callable < T > continueRequest ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , continueRequest ( seedMap ) ) ; }
373：public static < T > Callable < T > continueRequest ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , continueRequest  seedMap    

374：} ; ) ) 
374：public static < T > Callable < T > transferRequest ( Callable < T > callable ) { return wrap ( callable , transferRequest ( ) ) ; }
374：public static < T > Callable < T > transferRequest ( Callable < T > callable ) { return wrap ( callable , transferRequest (    

375：} ; } ; ) + + + ) ( . 
375：private static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
375：private static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( )  getName    "] is not compatible with key["  key  "]"    return object  

376：} ; ) , ( . 
376：@ SuppressWarnings ( "unchecked" ) public < T > MembersInjectorImpl < T > get ( TypeLiteral < T > key , Errors errors ) throws ErrorsException { return ( MembersInjectorImpl < T > ) cache . get ( key , errors ) ; }
376：@ SuppressWarnings ( "unchecked" ) public < T > MembersInjectorImpl < T > get ( TypeLiteral < T > key , Errors errors ) throws ErrorsException { return ( MembersInjectorImpl < T > ) cache  get  key  errors   

377：} ; ) , , , ( > < ; ) ( . ; ) ( . } } } ; ) , , ( . { ) ( } 
377：private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl < > ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
377：private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl < > ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ;  catch  RuntimeException e   errors  errorNotifyingTypeListener  binding  type  e      encounter  invalidate    errors  throwIfNewErrors  numErrorsBefore   return new MembersInjectorImpl  T   injector  type  encounter  injectors   

378：} ; ) ( . } } { ) ( } ; ) ( . ; 
378：ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) { } } return ImmutableList . copyOf ( injectors ) ; }
378：ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember )  injectors  add  injector    catch  ErrorsException ignoredForNow     return ImmutableList  copyOf  injectors   

379：} ; ) , 
379：static < T > Key < T > get ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < T > ( type , annotationStrategy ) ; }
379：static < T > Key < T > get ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < T > ( type  annotationStrategy   

380：} ; ) ) ( . ( } ; 
380：static AnnotationStrategy strategyFor ( Annotation annotation ) { checkNotNull ( annotation , "annotation" ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , annotation ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; }
380：static AnnotationStrategy strategyFor ( Annotation annotation ) { checkNotNull ( annotation , "annotation" ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , annotation )   return new AnnotationInstanceStrategy  Annotations  canonicalizeIfNamed  annotation    

381：} ; ) , ( ; ) ( ; 
381：static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; if ( isAllDefaultMethods ( annotationType ) ) { return strategyFor ( generateAnnotation ( annotationType ) ) ; } checkNotNull ( annotationType , "annotation type" ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( annotationType , null ) ; }
381：static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; if ( isAllDefaultMethods ( annotationType ) ) { return strategyFor ( generateAnnotation ( annotationType ) ) ; } checkNotNull ( annotationType , "annotation type" ) ; ensureRetainedAtRuntime ( annotationType )  ensureIsBindingAnnotation  annotationType   return new AnnotationTypeStrategy  annotationType  null   

382：} } ; ) ) ] ) ( . [ ( . ( . 
382：private void pruneStacktrace ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
382：private void pruneStacktrace ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t  setStackTrace  pruned  toArray  new StackTraceElement  pruned  size        

383：} } ; ) ( . { 
383：public String getBindingSource ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
383：public String getBindingSource ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else  return source  toString     

384：} ; ) ( . } ; ) ) ( . , ( . { } ; ) ( . { ) == ) ( . ( } ; ) ( . } } ; ) , ) 
384：public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
384：public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName (   causeIdx     fmt  format  "%n"    if  errorMessages  size    1   fmt  format  "1 error"    else  fmt  format  "%s errors"  errorMessages  size      return fmt  toString    

385：} ; ) 
385：public static Message create ( String messageFormat , Object ... arguments ) { return create ( null , messageFormat , arguments ) ; }
385：public static Message create ( String messageFormat , Object ... arguments ) { return create ( null , messageFormat , arguments   

386：} ; ) , 
386：public static Message create ( Throwable cause , String messageFormat , Object ... arguments ) { return create ( cause , ImmutableList . of ( ) , messageFormat , arguments ) ; }
386：public static Message create ( Throwable cause , String messageFormat , Object ... arguments ) { return create ( cause , ImmutableList . of ( ) , messageFormat  arguments   

387：} ; ) , , 
387：public static Message create ( Throwable cause , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , cause ) ; }
387：public static Message create ( Throwable cause , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources  message  cause   

388：} ; ) , ( 
388：static Object convert ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return convert ( o , source ) ; }
388：static Object convert ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return convert  o  source   

389：} ; ) ( 
389：private boolean shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
389：private boolean shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains  className   

390：} ; } } ; ) - , , 
390：public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
390：public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure"  null   1     return UNKNOWN_SOURCE  

391：} ; ) . ( . ; ) ( . . ; ) , ] [ 
391：public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ; Thread . sleep ( Long . MAX_VALUE ) ; }
391：public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args  0   injector   System  out  println  "Press Ctrl+C to exit..."   Thread  sleep  Long  MAX_VALUE   

392：} ; ; ) , 
392：Dependency < ? > pushDependency ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
392：Dependency < ? > pushDependency ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency  source   return previous  

393：} ; ) 
393：void pushState ( com . google . inject . Key < ? > key , Object source ) { doPushState ( key , source ) ; }
393：void pushState ( com . google . inject . Key < ? > key , Object source ) { doPushState ( key , source   

394：} ; } } ; ) 
394：static < T > Initializable < T > of ( final T instance ) { return new Initializable < T > ( ) { public T get ( ) { return instance ; } public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
394：static < T > Initializable < T > of ( final T instance ) { return new Initializable < T > ( ) { public T get ( ) { return instance ; } public String toString ( ) { return String . valueOf ( instance      

395：} ; ; ) ( . } ; ) 
395：protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
395：protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency    constructionContext  setProxyDelegates  t   return t  

396：} } } ; ) , ( 
396：public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
396：public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent  remoteAddr  conn     

397：} ; ) ( . } ; ) ( 
397：public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( processor ) ; }
397：public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get  type    processorList  add  processor   

398：} ; } } ; ) , ( . { ) ( } ; ) , 
398：public static < T > T getFutureTaskResult ( RunStateRecordedFutureTask < T > task , Logger logger ) { T t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
398：public static < T > T getFutureTaskResult ( RunStateRecordedFutureTask < T > task , Logger logger ) { T t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!"  e    catch  FutureTaskNotCompleted e   logger  error  "Future task has not completed!"  e     return t  

399：} } ; ) , ( 
399：public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
399：public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException  "Not unchecked!"  t    

400：} ; ) , ( . . } ; ) ) 
400：public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
400：public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName (     this  cmd2processors  put  cmdCode  processor   

401：} } ; ) ) ( . 
401：public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
401：public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor  getClass      

402：} ; . } ; { 
402：public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
402：public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null )  return processor   return this  defaultProcessor  

403：} ; ) ( . 
403：private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
403：private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef  get    

404：} ; } ; ) ( . 
404：protected ProtocolCode decodeProtocolCode ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
404：protected ProtocolCode decodeProtocolCode ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode  fromBytes  protocolCodeBytes    return null  

405：} ; } } ; ) ) ( . , ) ( . ( . { ) 
405：public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
405：public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool   allConnections  put  entry  getKey    pool  getAll       return allConnections  

406：} } } } } } ; ) , ( . ; ) ( . { ) 
406：public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
406：public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME   iter  remove    logger  warn  "Remove expired pool task of poolKey {} which is empty."  poolKey        

407：} } ; ; ) ( . { } 
407：public Connection getAndCreateIfAbsent ( Url url ) throws InterruptedException , RemotingException { ConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; if ( null != pool ) { return pool . get ( ) ; } else { logger . error ( "[NOTIFYME] bug detected! pool here must not be null!" ) ; return null ; } }
407：public Connection getAndCreateIfAbsent ( Url url ) throws InterruptedException , RemotingException { ConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; if ( null != pool ) { return pool . get ( ) ;  else  logger  error  "[NOTIFYME] bug detected! pool here must not be null!"   return null   

408：} } ; ) ( . { } ; 
408：public void createConnectionAndHealIfNeed ( Url url ) throws InterruptedException , RemotingException { ConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; if ( null != pool ) { healIfNeed ( pool , url ) ; } else { logger . error ( "[NOTIFYME] bug detected! pool here must not be null!" ) ; } }
408：public void createConnectionAndHealIfNeed ( Url url ) throws InterruptedException , RemotingException { ConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; if ( null != pool ) { healIfNeed ( pool , url )   else  logger  error  "[NOTIFYME] bug detected! pool here must not be null!"    

409：} } } ; ) ( . { 
409：private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
409：private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool )  pool  removeAllAndTryClose      

410：} } ; ) ( . . } } ; ) ( . { } ; ) ( { ) ( ; ) ( . = ; ) ( . . { 
410：private void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ; if ( pool . isAsyncCreationDone ( ) && pool . size ( ) < url . getConnNum ( ) ) { FutureTask < Integer > task = this . healTasks . get ( poolKey ) ; if ( null == task ) { task = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; task = this . healTasks . putIfAbsent ( poolKey , task ) ; if ( null == task ) { task = this . healTasks . get ( poolKey ) ; task . run ( ) ; } } try { int numAfterHeal = task . get ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "[NOTIFYME] - conn num after heal {}, expected {}, warmup {}" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; } } catch ( InterruptedException e ) { this . healTasks . remove ( poolKey ) ; throw e ; } catch ( ExecutionException e ) { this . healTasks . remove ( poolKey ) ; Throwable cause = e . getCause ( ) ; if ( cause instanceof RemotingException ) { throw ( RemotingException ) cause ; } else { FutureTaskUtil . launderThrowable ( cause ) ; } } this . healTasks . remove ( poolKey ) ; } }
410：private void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ; if ( pool . isAsyncCreationDone ( ) && pool . size ( ) < url . getConnNum ( ) ) { FutureTask < Integer > task = this . healTasks . get ( poolKey ) ; if ( null == task ) { task = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; task = this . healTasks . putIfAbsent ( poolKey , task ) ; if ( null == task ) { task = this . healTasks . get ( poolKey ) ; task . run ( ) ; } } try { int numAfterHeal = task . get ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "[NOTIFYME] - conn num after heal {}, expected {}, warmup {}" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; } } catch ( InterruptedException e ) { this . healTasks . remove ( poolKey ) ; throw e ; } catch ( ExecutionException e )  this  healTasks  remove  poolKey   Throwable cause  e  getCause    if  cause instanceof RemotingException   throw  RemotingException  cause   else  FutureTaskUtil  launderThrowable  cause     this  healTasks  remove  poolKey    

411：} } } } ; ; ) ( . { ) ( } ; ) } } } ; ) ( . { } } ; ) ( . } ; ) , , ) ( . , ( . { ) ( } ; ) 
411：private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; } if ( syncCreateNumWhenNotWarmup > 0 ) { for ( int i = 0 ; i < syncCreateNumWhenNotWarmup ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } if ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { return ; } } initializeExecutor ( ) ; pool . markAsyncCreationStart ( ) ; try { this . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { public void run ( ) { try { for ( int i = pool . size ( ) ; i < url . getConnNum ( ) ; ++ i ) { Connection conn = null ; try { conn = create ( url ) ; } catch ( RemotingException e ) { logger . error ( "Exception occurred in async create connection thread for {}, taskName {}" , url . getUniqueKey ( ) , taskName , e ) ; } pool . add ( conn ) ; } } finally { pool . markAsyncCreationDone ( ) ; } } } ) ; } catch ( RejectedExecutionException e ) { pool . markAsyncCreationDone ( ) ; throw e ; } } } }
411：private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; } if ( syncCreateNumWhenNotWarmup > 0 ) { for ( int i = 0 ; i < syncCreateNumWhenNotWarmup ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } if ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { return ; } } initializeExecutor ( ) ; pool . markAsyncCreationStart ( ) ; try { this . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { public void run ( ) { try { for ( int i = pool . size ( ) ; i < url . getConnNum ( ) ; ++ i ) { Connection conn = null ; try { conn = create ( url    catch  RemotingException e   logger  error  "Exception occurred in async create connection thread for {}, taskName {}"  url  getUniqueKey    taskName  e    pool  add  conn     finally  pool  markAsyncCreationDone          catch  RejectedExecutionException e   pool  markAsyncCreationDone    throw e     

412：} ; ) ) 
412：public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
412：public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey (    

413：} } } ; ) ( . ; ) ( . ; 
413：public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
413：public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) )  future  cancelTimeout    future  tryAsyncExecuteInvokeCallbackAbnormally      

414：} } } ; ) , ) ) ( . . ( . , ( . { 
414：public void close ( ) { if ( closed . compareAndSet ( false , true ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
414：public void close ( ) { if ( closed . compareAndSet ( false , true ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e )  logger  warn  "Exception caught when closing connection {}"  RemotingUtil  parseRemoteAddress  Connection  this  getChannel     e     

415：} ; ) 
415：public Object setAttributeIfAbsent ( String key , Object value ) { return attributes . putIfAbsent ( key , value ) ; }
415：public Object setAttributeIfAbsent ( String key , Object value ) { return attributes . putIfAbsent ( key , value   

416：} } } ; ) ( ; + ) ( . + = { ) != ( 
416：public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
416：public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if  preProcessor  null   String errMsg  "Processor with interest key ["  processor  interest    "] has already been registered to rpc server, can not register again!"  throw new RuntimeException  errMsg     

417：} } } ; ) ( ; + + = { ) != ( 
417：private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
417：private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , processor ) ; if  preProcessor  null   String errMsg  "Processor with interest key ["  interest  "] has already been registered to rpc server, can not register again!"  throw new RuntimeException  errMsg     

418：} } } ; ) ) , , ( . ) ( . , , ( ; ) , ( . ; + = { ) ( } ; ) ) . , ( . ) ( . , , ( ; ) 
418：private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ; UserProcessor processor = ctx . getUserProcessor ( cmd . getRequestClass ( ) ) ; if ( processor instanceof AsyncUserProcessor ) { try { processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , new RpcAsyncContext ( ctx , cmd , this ) , cmd . getRequestObject ( ) ) ; } catch ( RejectedExecutionException e ) { logger . warn ( "RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor" ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; } catch ( Throwable t ) { String errMsg = "AYSNC process rpc request failed in RpcRequestProcessor, id=" + id ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; } } else { try { Object responseObject = processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , cmd . getRequestObject ( ) ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createResponse ( responseObject , cmd ) ) ; } catch ( RejectedExecutionException e ) { logger . warn ( "RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor" ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; } catch ( Throwable t ) { String errMsg = "SYNC process rpc request failed in RpcRequestProcessor, id=" + id ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; } } }
418：private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ; UserProcessor processor = ctx . getUserProcessor ( cmd . getRequestClass ( ) ) ; if ( processor instanceof AsyncUserProcessor ) { try { processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , new RpcAsyncContext ( ctx , cmd , this ) , cmd . getRequestObject ( ) ) ; } catch ( RejectedExecutionException e ) { logger . warn ( "RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor" ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; } catch ( Throwable t ) { String errMsg = "AYSNC process rpc request failed in RpcRequestProcessor, id=" + id ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; } } else { try { Object responseObject = processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , cmd . getRequestObject ( ) ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createResponse ( responseObject , cmd ) ) ; } catch ( RejectedExecutionException e ) { logger . warn ( "RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor"   sendResponseIfNecessary  ctx  type  this  getCommandFactory    createExceptionResponse  id  ResponseStatus  SERVER_THREADPOOL_BUSY     catch  Throwable t   String errMsg  "SYNC process rpc request failed in RpcRequestProcessor, id="  id  logger  error  errMsg  t   sendResponseIfNecessary  ctx  type  this  getCommandFactory    createExceptionResponse  id  t  errMsg      

419：} ; } ; = ; ) ) , , ) ( . ( . ) ( . , ) ( . , 
419：private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = true ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = false ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = false ; } return result ; }
419：private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = true ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = false ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx  cmd  getType    this  getCommandFactory    createExceptionResponse  cmd  getId    t  errMsg    result  false   return result  

420：} ; ) ) ( . - , . ( . 
420：private void preProcessRemotingContext ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
420：private void preProcessRemotingContext ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( )  putIfAbsent  InvokeContext  BOLT_PROCESS_WAIT_TIME  currentTimestamp  cmd  getArriveTime     

421：} ; ) ) ( . , ) ) ( . - ( , , ) ( . , ( . } 
421：private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
421：private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; }  logger  warn  "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]."  cmd  getId    remoteAddr   currentTimestamp  cmd  getArriveTime     cmd  getTimeout     

422：} } ; ) ) ( . , ) ) ( . - ( 
422：private void debugLog ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
422：private void debugLog ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) ,  currentTimestamp  cmd  getArriveTime     cmd  getTimeout      

423：} } ; ) ( . { 
423：public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
423：public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else  defaultExecutor  execute  task    

424：} } ; ) , ) ) ( . ( . , ( . } ; ) ( . ; ) ) , ) ( . ( . ( . ; ) ( . { ) != ( ; ) ( . = 
424：protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
424：protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f  conn  removeInvokeFuture  requestId   if  f  null   f  cancelTimeout    f  putResponse  commandFactory  createSendFailedResponse  conn  getRemoteAddress    e    f  tryAsyncExecuteInvokeCallbackAbnormally     logger  error  "Exception caught when sending invocation. The address is {}"  RemotingUtil  parseRemoteAddress  conn  getChannel     e    

425：} } } ; ) , ) ) ( . ( . , ( . { } 
425：protected void oneway ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
425：protected void oneway ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ;  else  logger  error  "Exception caught when sending invocation. The address is {}"  RemotingUtil  parseRemoteAddress  conn  getChannel     e     

426：} ; ) ( } ; ) + . + + . + 
426：public static byte toByte ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
426：public static byte toByte ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between ["  Byte  MIN_VALUE  "] to ["  Byte  MAX_VALUE  "]"    return  byte  value  

427：} ; } ; ) >> ( ) ( = ; ++ } 
427：public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
427：public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ;   index  value   byte   value  1    return bs  

428：} ; ) ( 
428：public void addReconnectTask ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
428：public void addReconnectTask ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add  task   

429：} ; ) ( . 
429：public void stop ( ) { if ( ! this . started ) { return ; } this . started = false ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
429：public void stop ( ) { if ( ! this . started ) { return ; } this . started = false ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled  clear    

430：} ; ; ) ( ; ) ( . ; ) ( . ; ) ) ( . ) ( . ( . ; ) ( . } ; ) ) } 
430：protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) { Object clientCustomSerializer = invokeContext . get ( InvokeContext . BOLT_CUSTOM_SERIALIZER ) ; if ( null != clientCustomSerializer ) { try { command . setSerializer ( ( Byte ) clientCustomSerializer ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( "Illegal custom serializer [" + clientCustomSerializer + "], the type of value should be [byte], but now is [" + clientCustomSerializer . getClass ( ) . getName ( ) + "]." ) ; } } Boolean crcSwitch = invokeContext . get ( InvokeContext . BOLT_CRC_SWITCH , ProtocolSwitch . CRC_SWITCH_DEFAULT_VALUE ) ; if ( null != crcSwitch && crcSwitch ) { command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { ProtocolSwitch . CRC_SWITCH_INDEX } ) ) ; } } else { command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { ProtocolSwitch . CRC_SWITCH_INDEX } ) ) ; } command . setTimeout ( timeoutMillis ) ; command . setRequestClass ( request . getClass ( ) . getName ( ) ) ; command . setInvokeContext ( invokeContext ) ; command . serialize ( ) ; logDebugInfo ( command ) ; return command ; }
430：protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) { Object clientCustomSerializer = invokeContext . get ( InvokeContext . BOLT_CUSTOM_SERIALIZER ) ; if ( null != clientCustomSerializer ) { try { command . setSerializer ( ( Byte ) clientCustomSerializer ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( "Illegal custom serializer [" + clientCustomSerializer + "], the type of value should be [byte], but now is [" + clientCustomSerializer . getClass ( ) . getName ( ) + "]." ) ; } } Boolean crcSwitch = invokeContext . get ( InvokeContext . BOLT_CRC_SWITCH , ProtocolSwitch . CRC_SWITCH_DEFAULT_VALUE ) ; if ( null != crcSwitch && crcSwitch ) { command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { ProtocolSwitch . CRC_SWITCH_INDEX } ) ) ; } } else { command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { ProtocolSwitch . CRC_SWITCH_INDEX      command  setTimeout  timeoutMillis   command  setRequestClass  request  getClass    getName     command  setInvokeContext  invokeContext   command  serialize    logDebugInfo  command   return command  

431：} ; ; ) , . ( . ; ) , . ( . } } ; ) ( . { } 
431：public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
431：public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; }  else  serviceOnConnections  add  connection     filteredConnections  put  Configs  CONN_SERVICE_STATUS_ON  serviceOnConnections   filteredConnections  put  Configs  CONN_SERVICE_STATUS_OFF  serviceOffConnections   return filteredConnections  

432：} } ; ) , ( . { ) ( } } } } } ; ) ( . { ) ) ( . ( { ) : ( } } ; ) , ) ( . , ( . { ) ) ( . ( } ; ) 
432：public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
432：public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections    if  logger  isInfoEnabled     logger  info  "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]."  serviceOnConnections  size    CONNECTION_THRESHOLD     for  Connection offConn  serviceOffConnections   if  offConn  isFine     offConn  close         catch  Exception e   logger  error  "ScheduledDisconnectStrategy monitor error"  e    

433：} } } } } ; ) ) ) ( . ( . , ( . 
433：private void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
433：private void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger  info  "Address={} won't close at this schedule turn"  RemotingUtil  parseRemoteAddress  lastSelectConnect  getChannel          

434：} ; ) 
434：public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
434：public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue )   

435：} } } ; ) , 
435：private void infoLog ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
435：private void infoLog ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format  "UNKNOWN-ADDR"     

436：} ; } ; { ) 
436：public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return true ; } return false ; }
436：public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout   return true   return false  

437：} ; ) ( 
437：public UserProcessor < ? > getUserProcessor ( String className ) { return StringUtils . isBlank ( className ) ? null : this . userProcessors . get ( className ) ; }
437：public UserProcessor < ? > getUserProcessor ( String className ) { return StringUtils . isBlank ( className ) ? null : this . userProcessors . get  className   

438：} ; } ; = { ) ) ( . ! 
438：private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
438：private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null &&  result  isFine     result  null   return result  

439：} ; : ) ( . 
439：@ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
439：@ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context  get  key   defaultIfNotFound  

440：} ; ) 
440：public String getProperty ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
440：public String getProperty ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key   

441：} } } ; ) + ( { } ; ) ) ( . , ( 
441：public static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
441：public static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException  msg  responseCommand  getCause      else  throw new InvokeException  msg  ", please check the server log for more."     

442：} ; ) ( . 
442：private static Object toResponseObject ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
442：private static Object toResponseObject ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response  getResponseObject    

443：} ; } ; ) ( { 
443：private static Throwable toThrowable ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
443：private static Throwable toThrowable ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable )  return  Throwable  ex   return null  

444：} } ; ) , ( . { } ; 
444：private static String detailErrMsg ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
444：private static String detailErrMsg ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) )   else  return String  format  "%s, ServerErrorMsg:null"  clientErrMsg    

445：} ; ; ) ) ( . ( . ; 
445：private RpcServerException createServerException ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
445：private RpcServerException createServerException ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg )  e  setStackTrace  t  getStackTrace     return e  

446：} } ; ) ) ( . ( . { ) ) ( . ( ; ) ( . ; 
446：public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
446：public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," )  logMsg  append  targetPort   if  logger  isInfoEnabled     logger  info  logMsg  toString      

447：} ; ) , ( : 
447：public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
447：public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory )  new NioEventLoopGroup  nThreads  threadFactory   

448：} ; ) . : ) 
448：public static String parseRemoteAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
448：public static String parseRemoteAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim (   StringUtils  EMPTY   

449：} ; ) . : ) ( 
449：public static String parseLocalAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
449：public static String parseLocalAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim    StringUtils  EMPTY   

450：} ; . } ; ) ( 
450：public static String parseRemoteIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
450：public static String parseRemoteIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress     return StringUtils  EMPTY  

451：} ; . } ; ) ( 
451：public static String parseRemoteHostName ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
451：public static String parseRemoteHostName ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName     return StringUtils  EMPTY  

452：} ; . } ; ) ( 
452：public static String parseLocalIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
452：public static String parseLocalIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress     return StringUtils  EMPTY  

453：} ; - } ; ) 
453：public static int parseRemotePort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
453：public static int parseRemotePort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort (    return  1  

454：} ; - } ; ) 
454：public static int parseLocalPort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
454：public static int parseLocalPort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort (    return  1  

455：} ; . } } ; ) 
455：public static String parseSocketAddressToHostIp ( SocketAddress socketAddress ) { final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
455：public static String parseSocketAddressToHostIp ( SocketAddress socketAddress ) { final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress (     return StringUtils  EMPTY  

456：} } ; ) ( 
456：public void add ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean res = this . conns . addIfAbsent ( connection ) ; if ( res ) { connection . increaseRef ( ) ; } }
456：public void add ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean res = this . conns . addIfAbsent ( connection ) ; if ( res ) { connection . increaseRef     

457：} } ; ) ( . { 
457：public void removeAndTryClose ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
457：public void removeAndTryClose ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) )  connection  close     

458：} } ; { } } ; { 
458：public Connection get ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
458：public Connection get ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else  return null    else  return null   

459：} } ; ) ) ( . ) 
459：public static void registerCustomSerializer ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
459：public static void registerCustomSerializer ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass (   getName      

460：} ; } ; 
460：public static CustomSerializer getCustomSerializer ( String className ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( className ) ; } return null ; }
460：public static CustomSerializer getCustomSerializer ( String className ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( className )   return null  

461：} } ; ) ) ( . ) 
461：public static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
461：public static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass (   getName      

462：} ; } ; 
462：public static CustomSerializer getCustomSerializer ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
462：public static CustomSerializer getCustomSerializer ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code )   return null  

463：} ; ) . , , , ( . . ; 
463：public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , true ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
463：public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , true ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( )  this  executor  scheduleAtFixedRate  monitorTask  initialDelay  period  TimeUnit  MILLISECONDS   

464：} ; ) ( 
464：public boolean isConnected ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
464：public boolean isConnected ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected  url   

465：} ; ) ) , ( , . ( . . } ; ) , , ( . { 
465：private void initWriteBufferWaterMark ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
465：private void initWriteBufferWaterMark ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else  logger  warn  "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes"  lowWaterMark  highWaterMark    this  bootstrap  childOption  ChannelOption  WRITE_BUFFER_WATER_MARK  new WriteBufferWaterMark  lowWaterMark  highWaterMark    

466：} } ; ) ( : ; ) ( : ; ) ( 
466：public static FramedataImpl1 get ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
466：public static FramedataImpl1 get ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame    case CONTINUOUS  return new ContinuousFrame    default  throw new IllegalArgumentException  "Supplied opcode is invalid"    

467：} ; ) ( . ) ) ( ( ! || == } ; ) ( . { ) . == ) ( . ) 
467：public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return false ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do { sockchannel . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { return false ; } else { ws . outQueue . poll ( ) ; buffer = ws . outQueue . peek ( ) ; } } while ( buffer != null ) ; } if ( ws . outQueue . isEmpty ( ) && ws . isFlushAndClose ( ) && ws . getDraft ( ) != null && ws . getDraft ( ) . getRole ( ) != null && ws . getDraft ( ) . getRole ( ) == Role . SERVER ) { ws . closeConnection ( ) ; } return c == null || ! ( ( WrappedByteChannel ) sockchannel ) . isNeedWrite ( ) ; }
467：public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return false ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do { sockchannel . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { return false ; } else { ws . outQueue . poll ( ) ; buffer = ws . outQueue . peek ( ) ; } } while ( buffer != null ) ; } if ( ws . outQueue . isEmpty ( ) && ws . isFlushAndClose ( ) && ws . getDraft ( ) != null && ws . getDraft ( ) . getRole ( ) != null && ws . getDraft (   getRole    Role  SERVER   ws  closeConnection     return c  null     WrappedByteChannel  sockchannel   isNeedWrite    

468：} ; ) ( } 
468：public void setCode ( int code ) { this . code = code ; if ( code == CloseFrame . TLS_ERROR ) { this . code = CloseFrame . NOCODE ; this . reason = "" ; } updatePayload ( ) ; }
468：public void setCode ( int code ) { this . code = code ; if ( code == CloseFrame . TLS_ERROR ) { this . code = CloseFrame . NOCODE ; this . reason = "" ;  updatePayload    

469：} } ; ) ( . { } 
469：private void validateUtf8 ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
469：private void validateUtf8 ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ;  finally  payload  position  mark    

470：} ; ) ( . ; ) ( . 
470：private void updatePayload ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
470：private void updatePayload ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay  rewind    super  setPayload  pay   

471：} ; . } } ; . ; 
471：private HandshakeState containsRequestedProtocol ( String requestedProtocol ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
471：private HandshakeState containsRequestedProtocol ( String requestedProtocol ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol )  return HandshakeState  MATCHED    return HandshakeState  NOT_MATCHED  

472：} } ; ) ( ; ) ( . { ) < ( } ; 
472：private void translateSingleFrameCheckLengthLimit ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
472：private void translateSingleFrameCheckLengthLimit ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize )   if  length  0   log  trace  "Limit underflow: Payloadsize is to little..."   throw new LimitExceededException  "Payloadsize is to little..."    

473：} } ; ) ( ; ) 
473：private void translateSingleFrameCheckPacketSize ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
473：private void translateSingleFrameCheckPacketSize ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize"   throw new IncompleteException  realpacketsize    

474：} ; ) ) ) ( . ( . ( . } 
474：private String generateFinalKey ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
474：private String generateFinalKey ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ;  return Base64  encodeBytes  sh1  digest  acc  getBytes      

475：} } ; ) ) ( . ( { ) != && . == ( } ; ) . ( 
475：private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } if ( curop == Opcode . TEXT && ! Charsetfunctions . isValidUTF8 ( frame . getPayloadData ( ) ) ) { log . error ( "Protocol error: Payload is not UTF8" ) ; throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } if ( curop == Opcode . CONTINUOUS && currentContinuousFrame != null ) { addToBufferList ( frame . getPayloadData ( ) ) ; } }
475：private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } if ( curop == Opcode . TEXT && ! Charsetfunctions . isValidUTF8 ( frame . getPayloadData ( ) ) ) { log . error ( "Protocol error: Payload is not UTF8" ) ; throw new InvalidDataException  CloseFrame  NO_UTF8    if  curop  Opcode  CONTINUOUS  currentContinuousFrame  null   addToBufferList  frame  getPayloadData      

476：} } ; ) , ( { 
476：private void processFrameBinary ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
476：private void processFrameBinary ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e )  logRuntimeException  webSocketImpl  e    

477：} ; ) , ( . 
477：private void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
477：private void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( )  onWebsocketError  webSocketImpl  e   

478：} } ; ) , ( { ) 
478：private void processFrameText ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
478：private void processFrameText ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e   logRuntimeException  webSocketImpl  e    

479：} ; ) ( ; = } } ; ) , ( { ) ( } ; ) ) ( . , ( . ) ( . { ; ) ( . ) 
479：private void processFrameIsFin ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
479：private void processFrameIsFin ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame   isValid    try  webSocketImpl  getWebSocketListener    onWebsocketMessage  webSocketImpl  currentContinuousFrame  getPayloadData      catch  RuntimeException e   logRuntimeException  webSocketImpl  e     currentContinuousFrame  null  clearBufferList    

480：} ; ) ( ; ) ) ( . ( 
480：private void processFrameIsNotFin ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
480：private void processFrameIsNotFin ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList  frame  getPayloadData     checkBufferLimit    

481：} } ; ) , , ( . ; ) , , ( . ) . 
481：private void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) { webSocketImpl . closeConnection ( code , reason , true ) ; } else { if ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) webSocketImpl . close ( code , reason , true ) ; else webSocketImpl . flushAndClose ( code , reason , false ) ; } }
481：private void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) { webSocketImpl . closeConnection ( code , reason , true ) ; } else { if ( getCloseHandshakeType ( ) == CloseHandshakeType  TWOWAY  webSocketImpl  close  code  reason  true   else webSocketImpl  flushAndClose  code  reason  false    

482：} } ; ) ( ; ) 
482：private void checkBufferLimit ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
482：private void checkBufferLimit ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize   throw new LimitExceededException  maxFrameSize    

483：} ; ; ) ( . } } ; ) 
483：private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
483：private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer     resultingByteBuffer  flip    return resultingByteBuffer  

484：} ; } } ; 
484：private long getByteBufferListSize ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } } return totalSize ; }
484：private long getByteBufferListSize ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( )    return totalSize  

485：} ; ; ) ] [ ( . ; ) ( = } ; ) ) , 
485：private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { if ( ! "GET" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid request method received: %s Status line: %s" , firstLineTokens [ 0 ] , line ) ) ; } if ( ! "HTTP/1.1" . equalsIgnoreCase ( firstLineTokens [ 2 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid status line received: %s Status line: %s" , firstLineTokens [ 2 ] , line ) ) ; } ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client ( ) ; clienthandshake . setResourceDescriptor ( firstLineTokens [ 1 ] ) ; return clienthandshake ; }
485：private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { if ( ! "GET" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid request method received: %s Status line: %s" , firstLineTokens [ 0 ] , line ) ) ; } if ( ! "HTTP/1.1" . equalsIgnoreCase ( firstLineTokens [ 2 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid status line received: %s Status line: %s" , firstLineTokens [ 2 ]  line     ClientHandshakeBuilder clienthandshake  new HandshakeImpl1Client    clienthandshake  setResourceDescriptor  firstLineTokens  1    return clienthandshake  

486：} ; ; ) ] [ ( . ; ) ) ] [ ( . ( . ; ) ( 
486：private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { if ( ! "101" . equals ( firstLineTokens [ 1 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid status code received: %s Status line: %s" , firstLineTokens [ 1 ] , line ) ) ; } if ( ! "HTTP/1.1" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid status line received: %s Status line: %s" , firstLineTokens [ 0 ] , line ) ) ; } HandshakeBuilder handshake = new HandshakeImpl1Server ( ) ; ServerHandshakeBuilder serverhandshake = ( ServerHandshakeBuilder ) handshake ; serverhandshake . setHttpStatus ( Short . parseShort ( firstLineTokens [ 1 ] ) ) ; serverhandshake . setHttpStatusMessage ( firstLineTokens [ 2 ] ) ; return handshake ; }
486：private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { if ( ! "101" . equals ( firstLineTokens [ 1 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid status code received: %s Status line: %s" , firstLineTokens [ 1 ] , line ) ) ; } if ( ! "HTTP/1.1" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid status line received: %s Status line: %s" , firstLineTokens [ 0 ] , line ) ) ; } HandshakeBuilder handshake = new HandshakeImpl1Server ( ) ; ServerHandshakeBuilder serverhandshake =  ServerHandshakeBuilder  handshake  serverhandshake  setHttpStatus  Short  parseShort  firstLineTokens  1     serverhandshake  setHttpStatusMessage  firstLineTokens  2    return handshake  

487：} } } } ; ) ( { ) ) ( . ( } ; ) ( { ) ) ( 
487：public void decode ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; if ( socketBuffer . hasRemaining ( ) ) { decodeFrames ( socketBuffer ) ; } else if ( tmpHandshakeBytes . hasRemaining ( ) ) { decodeFrames ( tmpHandshakeBytes ) ; } } } }
487：public void decode ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; if ( socketBuffer . hasRemaining     decodeFrames  socketBuffer    else if  tmpHandshakeBytes  hasRemaining     decodeFrames  tmpHandshakeBytes      

488：} ; ) , ) 
488：private void closeConnectionDueToWrongHandshake ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , false ) ; }
488：private void closeConnectionDueToWrongHandshake ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage (   false   

489：} ; ) , ) 
489：private void closeConnectionDueToInternalServerError ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , false ) ; }
489：private void closeConnectionDueToInternalServerError ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage (   false   

490：} ; ) ) + + + ) ) ( . + ( + " + 
490：private ByteBuffer generateHttpResponseDueToError ( int errorCode ) { String errorCodeDescription ; switch ( errorCode ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
490：private ByteBuffer generateHttpResponseDueToError ( int errorCode ) { String errorCodeDescription ; switch ( errorCode ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription  "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length:    48  errorCodeDescription  length     "\r\n\r\n<html><head></head><body><h1>"  errorCodeDescription  "</h1></body></html>"    

491：} ; ) ) . 
491：public void send ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; send ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
491：public void send ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; send ( draft . createFrames ( text , role == Role  CLIENT    

492：} ; ) . , ( = . ; ) ( = ; ) ( = } ; ; ) ) ( . 
492：private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
492：private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e  getMessage     return   connectLatch  new CountDownLatch  1   closeLatch  new CountDownLatch  1   this  engine  new WebSocketImpl  this  this  draft   

493：} ; ) ( . ; ) 
493：public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
493：public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( )   connectReadThread  start    

494：} ; } } ; ) + " ( { 
494：private int getPort ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
494：private int getPort ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else  throw new IllegalArgumentException  "unknown scheme:   scheme     return port  

495：} ; ) ( . } } ; ) ) ( . , ) ( . ( . { ) ) 
495：private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += '?' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
495：private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += '?' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet (    handshake  put  kv  getKey    kv  getValue       engine  startHandshake  handshake   

496：} } } ; ) ( } ; ) , ( . { ) ( } } } ; 
496：public void setConnectionLostTimeout ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ; try { ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( getConnections ( ) ) ; WebSocketImpl webSocketImpl ; for ( WebSocket conn : connections ) { if ( conn instanceof WebSocketImpl ) { webSocketImpl = ( WebSocketImpl ) conn ; webSocketImpl . updateLastPong ( ) ; } } } catch ( Exception e ) { log . error ( "Exception during connection lost restart" , e ) ; } restartConnectionLostTimer ( ) ; } } }
496：public void setConnectionLostTimeout ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ; try { ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( getConnections ( ) ) ; WebSocketImpl webSocketImpl ; for ( WebSocket conn : connections ) { if ( conn instanceof WebSocketImpl ) { webSocketImpl = ( WebSocketImpl ) conn ; webSocketImpl . updateLastPong ( )     catch  Exception e   log  error  "Exception during connection lost restart"  e    restartConnectionLostTimer      

497：} } } ; ) ( ; 
497：protected void stopConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = false ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
497：protected void stopConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = false ; log . trace ( "Connection lost timer stopped" )  cancelConnectionLostTimer      

498：} } ; ) ( ; = . 
498：protected void startConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = true ; restartConnectionLostTimer ( ) ; } }
498：protected void startConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this  websocketRunning  true  restartConnectionLostTimer     

499：} ; ) . , , , ( . = ; } } ; ) ( . } { ) 
499：private void restartConnectionLostTimer ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) { } connections . clear ( ) ; } } ; connectionLostCheckerFuture = connectionLostCheckerService . scheduleAtFixedRate ( connectionLostChecker , connectionLostTimeout , connectionLostTimeout , TimeUnit . NANOSECONDS ) ; }
499：private void restartConnectionLostTimer ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e    connections  clear       connectionLostCheckerFuture  connectionLostCheckerService  scheduleAtFixedRate  connectionLostChecker  connectionLostTimeout  connectionLostTimeout  TimeUnit  NANOSECONDS   

500：} } } ; ) , ( . { } ; ) ( . { ) ) ( . ( 
500：private void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
500：private void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if  webSocketImpl  isOpen     webSocketImpl  sendPing     else  log  trace  "Trying to ping a non open connection: {}"  webSocketImpl     

501：} } ; = ; ) ( 
501：private void cancelConnectionLostTimer ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( false ) ; connectionLostCheckerFuture = null ; } }
501：private void cancelConnectionLostTimer ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel  false   connectionLostCheckerFuture  null   

502：} ; ) ( 
502：public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
502：public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server    

503：} ; ) ) 
503：public void onWebsocketPing ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
503：public void onWebsocketPing ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f    

504：} } } ; ) ( . ; ) ( . { ) 
504：public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( false , true ) ) { return ; } List < WebSocket > socketsToClose ; synchronized ( connections ) { socketsToClose = new ArrayList < WebSocket > ( connections ) ; } for ( WebSocket ws : socketsToClose ) { ws . close ( CloseFrame . GOING_AWAY ) ; } wsf . close ( ) ; synchronized ( this ) { if ( selectorthread != null && selector != null ) { selector . wakeup ( ) ; selectorthread . join ( timeout ) ; } } }
504：public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( false , true ) ) { return ; } List < WebSocket > socketsToClose ; synchronized ( connections ) { socketsToClose = new ArrayList < WebSocket > ( connections ) ; } for ( WebSocket ws : socketsToClose ) { ws . close ( CloseFrame . GOING_AWAY ) ; } wsf . close ( ) ; synchronized ( this ) { if ( selectorthread != null && selector != null   selector  wakeup    selectorthread  join  timeout     

505：} ; } ; ) 
505：public int getPort ( ) { int port = getAddress ( ) . getPort ( ) ; if ( port == 0 && server != null ) { port = server . socket ( ) . getLocalPort ( ) ; } return port ; }
505：public int getPort ( ) { int port = getAddress ( ) . getPort ( ) ; if ( port == 0 && server != null ) { port = server . socket ( ) . getLocalPort (    return port  

506：} } } ; ; ) ( { ) ( } } ; ) ( 
506：private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
506：private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer  buf     catch  IOException e   pushBuffer  buf   throw e    

507：} } ; ) , , ) ( . ( ; ) ( . ) ( . ) != ) ( . 
507：private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( false ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( true ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
507：private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( false ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( true ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w  getSelectionKey    null  w  getSelectionKey    cancel    handleIOException  w  getSelectionKey    null  ex    

508：} ; } ; ; ) ( { ) ( } } ; ) ( { } } ; ) ( { 
508：private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return false ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return true ; }
508：private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return false ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else  pushBuffer  buf     else  pushBuffer  buf     catch  IOException e   pushBuffer  buf   throw e   return true  

509：} } } ; ) . ( 
509：private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
509：private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps  SelectionKey  OP_READ     

510：} ; } ; ; ) , ( { ) ( } ; ) ( } ; 
510：private boolean doSetupSelectorAndServerThread ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( false ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return false ; } return true ; }
510：private boolean doSetupSelectorAndServerThread ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( false ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( )   onStart     catch  IOException ex   handleFatal  null  ex   return false   return true  

511：} ; } } ; { ) 
511：private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return false ; } } return true ; }
511：private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( )   return false    return true  

512：} } } ; ) , ( ; ) , ( . { ) 
512：private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
512：private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e   log  error  "IOException during server.close"  e   onError  null  e     

513：} ; ) ( . 
513：private Socket getSocket ( WebSocket conn ) { WebSocketImpl impl = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
513：private Socket getSocket ( WebSocket conn ) { WebSocketImpl impl = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) )  socket    

514：} ; ) , ) 
514：public void broadcast ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( data ) , clients ) ; }
514：public void broadcast ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( data   clients   

515：} ; ) , ( 
515：public void broadcast ( String text , Collection < WebSocket > clients ) { if ( text == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , clients ) ; }
515：public void broadcast ( String text , Collection < WebSocket > clients ) { if ( text == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast  text  clients   

516：} } } } { ) ( } ; ) ) ( . ( . { ; ) 
516：private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) { } } } }
516：private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData   try  client  sendFrame  draftFrames  get  draft     catch  WebsocketNotConnectedException e      

517：} } } ; ) , ( . { ) != ( 
517：private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , false ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , false ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
517：private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , false ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , false ) ; } if  frames  null   draftFrames  put  draft  frames     

518：} } ; ; ) ( . { } ; ; ) 
518：public static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
518：public static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source   return limit   else  dest  put  source   return fremain   

519：} ; ; ) ) ) 
519：public JPAApi start ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
519：public JPAApi start ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName     return this  

520：} ; ) ( . 
520：public EntityManager em ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
520：public EntityManager em ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf  createEntityManager    

521：} ; ) } 
521：public void withTransaction ( Consumer < EntityManager > block ) { withTransaction ( em -> { block . accept ( em ) ; return null ; } ) ; }
521：public void withTransaction ( Consumer < EntityManager > block ) { withTransaction ( em -> { block . accept ( em ) ; return null ;    

522：} ; ) ( . ) 
522：private static Seq < Object > convertArgsToScalaBuffer ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
522：private static Seq < Object > convertArgsToScalaBuffer ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala (   toList    

523：} ; } ; ) ( . = 
523：private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out = Arrays . asList ( args ) ; } return out ; }
523：private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out  Arrays  asList  args    return out  

524：} ; ) , , ( 
524：public String get ( play . api . i18n . Lang lang , String key , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , scalaArgs , lang ) ; }
524：public String get ( play . api . i18n . Lang lang , String key , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply  key  scalaArgs  lang   

525：} ; ) , , ) ( . ( . 
525：public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
525：public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages  apply  keyArgs  toSeq    scalaArgs  lang   

526：} ; ) , 
526：public Boolean isDefinedAt ( play . api . i18n . Lang lang , String key ) { return messages . isDefinedAt ( key , lang ) ; }
526：public Boolean isDefinedAt ( play . api . i18n . Lang lang , String key ) { return messages . isDefinedAt ( key  lang   

527：} ; ) , ) ) ( 
527：public Messages preferred ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
527：public Messages preferred ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang     this   

528：} ; ) , ) 
528：public Messages preferred ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
528：public Messages preferred ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( )   this   

529：} ; ) ( 
529：public Result setLang ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
529：public Result setLang ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava    

530：} ; ) ) 
530：public final Self bindings ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
530：public final Self bindings ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules )    

531：} ; ) 
531：public final Self bindings ( play . api . inject . Module ... modules ) { return bindings ( Guiceable . modules ( modules ) ) ; }
531：public final Self bindings ( play . api . inject . Module ... modules ) { return bindings ( Guiceable . modules ( modules )   

532：} ; ) ) 
532：public final Self bindings ( play . api . inject . Binding < ? > ... bindings ) { return bindings ( Guiceable . bindings ( bindings ) ) ; }
532：public final Self bindings ( play . api . inject . Binding < ? > ... bindings ) { return bindings ( Guiceable . bindings ( bindings    

533：} ; ) ) 
533：public final Self overrides ( GuiceableModule ... modules ) { return newBuilder ( delegate . overrides ( Scala . varargs ( modules ) ) ) ; }
533：public final Self overrides ( GuiceableModule ... modules ) { return newBuilder ( delegate . overrides ( Scala . varargs ( modules )    

534：} ; ) 
534：public final Self overrides ( play . api . inject . Module ... modules ) { return overrides ( Guiceable . modules ( modules ) ) ; }
534：public final Self overrides ( play . api . inject . Module ... modules ) { return overrides ( Guiceable . modules ( modules )   

535：} ; ) ) 
535：public final Self overrides ( play . api . inject . Binding < ? > ... bindings ) { return overrides ( Guiceable . bindings ( bindings ) ) ; }
535：public final Self overrides ( play . api . inject . Binding < ? > ... bindings ) { return overrides ( Guiceable . bindings ( bindings    

536：} ; ) ) 
536：public final Self disable ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
536：public final Self disable ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses )    

537：} ; ) ) ( . 
537：public CompletionStage < Result > call ( Context ctx ) { return call ( ctx . args != null && ! ctx . args . isEmpty ( ) ? ctx . request ( ) . addAttr ( CTX_ARGS , ctx . args ) : ctx . request ( ) ) ; }
537：public CompletionStage < Result > call ( Context ctx ) { return call ( ctx . args != null && ! ctx . args . isEmpty ( ) ? ctx . request ( ) . addAttr ( CTX_ARGS , ctx . args ) : ctx  request     

538：} ; ) } ; ) ( ; ) ) ( > < ( 
538：public CompletionStage < Result > call ( Request req ) { return Context . safeCurrent ( ) . map ( threadLocalCtx -> { Context newCtx = threadLocalCtx . withRequest ( req . removeAttr ( CTX_ARGS ) ) ; Context . setCurrent ( newCtx ) ; return call ( newCtx ) ; } ) . orElseGet ( ( ) -> { Context ctx = new Context ( req . removeAttr ( CTX_ARGS ) , contextComponents ) ; ctx . args = req . attrs ( ) . getOptional ( CTX_ARGS ) . orElse ( new HashMap < > ( ) ) ; return call ( ctx ) ; } ) ; }
538：public CompletionStage < Result > call ( Request req ) { return Context . safeCurrent ( ) . map ( threadLocalCtx -> { Context newCtx = threadLocalCtx . withRequest ( req . removeAttr ( CTX_ARGS ) ) ; Context . setCurrent ( newCtx ) ; return call ( newCtx ) ; } ) . orElseGet ( ( ) -> { Context ctx = new Context ( req . removeAttr ( CTX_ARGS ) , contextComponents ) ; ctx . args = req . attrs ( ) . getOptional ( CTX_ARGS ) . orElse  new HashMap       return call  ctx      

539：} ; ) ) 
539：public Optional < File > getExistingFile ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
539：public Optional < File > getExistingFile ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath    

540：} ; ) ( 
540：public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
540：public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava    

541：} ; ) , 
541：public static < A , B > Tuple < A , B > Tuple ( A a , B b ) { return new Tuple < A , B > ( a , b ) ; }
541：public static < A , B > Tuple < A , B > Tuple ( A a , B b ) { return new Tuple < A , B > ( a  b   

542：} ; ) , , , , ( 
542：public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C c , D d , E e ) { return new Tuple5 < A , B , C , D , E > ( a , b , c , d , e ) ; }
542：public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C c , D d , E e ) { return new Tuple5 < A , B , C , D , E >  a  b  c  d  e   

543：} } ; { } 
543：private static Executor toExecutor ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
543：private static Executor toExecutor ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ;  else  return prepared :: execute   

544：} ; ) ) 
544：public static JPAConfig of ( String name , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , unitName ) ) ; }
544：public static JPAConfig of ( String name , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , unitName    

545：} ; ) ) , ( . 
545：public static JPAConfig of ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
545：public static JPAConfig of ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig  PersistenceUnit  n2  u2    

546：} ; ) ) ( . ( } ; ) ) 
546：public static JPAConfig from ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
546：public static JPAConfig from ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( )     return new DefaultJPAConfig  persistenceUnits  build     

547：} ; ) ) ( ( . 
547：public static Flow < String , ByteString , NotUsed > string ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
547：public static Flow < String , ByteString , NotUsed > string ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } )  via  flow  callbackName    

548：} ; ) ) ( ( 
548：public static Flow < JsonNode , ByteString , NotUsed > json ( String callbackName ) { return Flow . of ( JsonNode . class ) . map ( json -> { return ByteString . fromString ( Json . stringify ( json ) ) ; } ) . via ( flow ( callbackName ) ) ; }
548：public static Flow < JsonNode , ByteString , NotUsed > json ( String callbackName ) { return Flow . of ( JsonNode . class ) . map ( json -> { return ByteString . fromString ( Json . stringify ( json ) ) ; } ) . via  flow  callbackName    

549：} ; ; ) ) 
549：public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
549：public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , (  -> constraintValidator   return this  

550：} } ; ) ( { 
550：private < T extends ConstraintValidator < ? , ? > > T newInstance ( Class < T > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
550：private < T extends ConstraintValidator < ? , ? > > T newInstance ( Class < T > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex )  throw new RuntimeException  ex    

551：} ; } } ; { ) ) ( . ! && ) ( . ! ( ; ) ( . ) ( . ] - . [ = ; ) ( . ] - . [ 
551：public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) { } Method bestMatch = null ; final Method [ ] methods = cls . getMethods ( ) ; for ( final Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) && MemberUtils . isMatchingMethod ( method , parameterTypes ) ) { final Method accessibleMethod = getAccessibleMethod ( method ) ; if ( accessibleMethod != null && ( bestMatch == null || MemberUtils . compareMethodFit ( accessibleMethod , bestMatch , parameterTypes ) < 0 ) ) { bestMatch = accessibleMethod ; } } } if ( bestMatch != null ) { MemberUtils . setAccessibleWorkaround ( bestMatch ) ; } if ( bestMatch != null && bestMatch . isVarArgs ( ) && bestMatch . getParameterTypes ( ) . length > 0 && parameterTypes . length > 0 ) { final Class < ? > [ ] methodParameterTypes = bestMatch . getParameterTypes ( ) ; final Class < ? > methodParameterComponentType = methodParameterTypes [ methodParameterTypes . length - 1 ] . getComponentType ( ) ; final String methodParameterComponentTypeName = ClassUtils . primitiveToWrapper ( methodParameterComponentType ) . getName ( ) ; final String parameterTypeName = parameterTypes [ parameterTypes . length - 1 ] . getName ( ) ; final String parameterTypeSuperClassName = parameterTypes [ parameterTypes . length - 1 ] . getSuperclass ( ) . getName ( ) ; if ( ! methodParameterComponentTypeName . equals ( parameterTypeName ) && ! methodParameterComponentTypeName . equals ( parameterTypeSuperClassName ) ) { return null ; } } return bestMatch ; }
551：public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) { } Method bestMatch = null ; final Method [ ] methods = cls . getMethods ( ) ; for ( final Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) && MemberUtils . isMatchingMethod ( method , parameterTypes ) ) { final Method accessibleMethod = getAccessibleMethod ( method ) ; if ( accessibleMethod != null && ( bestMatch == null || MemberUtils . compareMethodFit ( accessibleMethod , bestMatch , parameterTypes ) < 0 ) ) { bestMatch = accessibleMethod ; } } } if ( bestMatch != null ) { MemberUtils . setAccessibleWorkaround ( bestMatch ) ; } if ( bestMatch != null && bestMatch . isVarArgs ( ) && bestMatch . getParameterTypes ( ) . length > 0 && parameterTypes . length > 0 ) { final Class < ? > [ ] methodParameterTypes = bestMatch . getParameterTypes ( ) ; final Class < ? > methodParameterComponentType = methodParameterTypes [ methodParameterTypes . length - 1 ] . getComponentType ( ) ; final String methodParameterComponentTypeName = ClassUtils . primitiveToWrapper ( methodParameterComponentType ) . getName ( ) ; final String parameterTypeName = parameterTypes  parameterTypes  length  1   getName    final String parameterTypeSuperClassName  parameterTypes  parameterTypes  length  1   getSuperclass    getName    if   methodParameterComponentTypeName  equals  parameterTypeName    methodParameterComponentTypeName  equals  parameterTypeSuperClassName    return null    return bestMatch  

552：} } ; ) + " + + " ( { } ; 
552：public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
552：public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , message )   else  throw new IllegalArgumentException  "onClientError invoked with non client error status code   statusCode  ":   message    

553：} ; ) ) ) ) ( 
553：protected CompletionStage < Result > onBadRequest ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
553：protected CompletionStage < Result > onBadRequest ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala       

554：} ; ) ) ) ) 
554：protected CompletionStage < Result > onForbidden ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
554：protected CompletionStage < Result > onForbidden ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala (      

555：} } ; ) ) ) ) ( . , ) ) ( . 
555：protected CompletionStage < Result > onNotFound ( RequestHeader request , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
555：protected CompletionStage < Result > onNotFound ( RequestHeader request , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes  get     request  asScala        

556：} } ; ) ) ( . ( . ; ) , 
556：public CompletionStage < Result > onServerError ( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
556：public CompletionStage < Result > onServerError ( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error"  e   return CompletableFuture  completedFuture  Results  internalServerError      

557：} ; ) , ) ) ( . 
557：protected void logServerError ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
557：protected void logServerError ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request  uri     usefulException   

558：} ; ) , ) 
558：protected final UsefulException throwableToUsefulException ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , throwable ) ; }
558：protected final UsefulException throwableToUsefulException ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd (   throwable   

559：} ; ) ) ) ) 
559：protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
559：protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala (      

560：} ; ) ) ) ) 
560：protected CompletionStage < Result > onProdServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( exception , request . asScala ( ) ) ) ) ; }
560：protected CompletionStage < Result > onProdServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( exception , request . asScala (      

561：} ; ) } } ; ) ( . { ) : ( { ) ( , ) ( ( 
561：public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList < > ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else { JarFile jarFile = new JarFile ( file ) ; jarFiles . add ( jarFile ) ; repositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; } } return new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { for ( JarFile jarFile : jarFiles ) { jarFile . close ( ) ; } } ) ; }
561：public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList < > ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else { JarFile jarFile = new JarFile ( file ) ; jarFiles . add ( jarFile ) ; repositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; } } return new DocumentationHandler  new AggregateFileRepository  repositories     ->  for  JarFile jarFile  jarFiles   jarFile  close        

562：} ; ) ( 
562：public static BuildDocHandler fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
562：public static BuildDocHandler fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler  repo   

563：} ; ) , 
563：public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base ) { return fromDirectoryAndJar ( directory , jarFile , base , false ) ; }
563：public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base ) { return fromDirectoryAndJar ( directory , jarFile , base  false   

564：} ; ) , ( } ; = { } ; ) 
564：public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
564：public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo }    else  manualRepo  fileRepo   return new DocumentationHandler  manualRepo  jarRepo   

565：} ; ) ( ; 
565：public static BuildDocHandler fromJar ( JarFile jarFile , String base ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
565：public static BuildDocHandler fromJar ( JarFile jarFile , String base ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( base ) )  return new DocumentationHandler  repo   

566：} ; ) , 
566：public CompletionStage < ByteString > consumeData ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
566：public CompletionStage < ByteString > consumeData ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat  mat   

567：} ; ) ) + + ) ( . 
567：public static final HttpEntity fromContent ( Content content , String charset ) { String body ; if ( content instanceof Xml ) { body = content . body ( ) . trim ( ) ; } else { body = content . body ( ) ; } return new Strict ( ByteString . fromString ( body , charset ) , Optional . of ( content . contentType ( ) + "; charset=" + charset ) ) ; }
567：public static final HttpEntity fromContent ( Content content , String charset ) { String body ; if ( content instanceof Xml ) { body = content . body ( ) . trim ( ) ; } else { body = content . body ( ) ; } return new Strict ( ByteString . fromString ( body , charset ) , Optional . of ( content  contentType    "; charset="  charset    

568：} ; ) ) + 
568：public static final HttpEntity fromString ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
568：public static final HttpEntity fromString ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( "text/plain; charset="  charset    

569：} ; ) , ) 
569：public static final HttpEntity chunked ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
569：public static final HttpEntity chunked ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new   contentType   

570：} ; ) 
570：public static Result status ( int status , JsonNode content ) { return status ( status , content , JsonEncoding . UTF8 ) ; }
570：public static Result status ( int status , JsonNode content ) { return status ( status , content , JsonEncoding . UTF8   

571：} ; ) , ( 
571：public static Result status ( int status , JsonNode content , JsonEncoding encoding ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return status ( status ) . sendJson ( content , encoding ) ; }
571：public static Result status ( int status , JsonNode content , JsonEncoding encoding ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return status ( status ) . sendJson  content  encoding   

572：} ; ) ) ) ( 
572：public static Result status ( int status , byte [ ] content ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; }
572：public static Result status ( int status , byte [ ] content ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty      

573：} ; ) 
573：public static Result status ( int status , InputStream content , long contentLength ) { return status ( status ) . sendInputStream ( content , contentLength ) ; }
573：public static Result status ( int status , InputStream content , long contentLength ) { return status ( status ) . sendInputStream ( content , contentLength   

574：} ; ) ) 
574：public static Result status ( int status , File content ) { return status ( status , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
574：public static Result status ( int status , File content ) { return status ( status , content , StaticFileMimeTypes . fileMimeTypes (    

575：} ; ; ) ( 
575：private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
575：private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf  id   return user  

576：} ; ) ) ) 
576：public Lang preferred ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
576：public Lang preferred ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq (     

577：} ; ) ) 
577：public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
577：public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment (    

578：} ; ) , 
578：public Call withFragment ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
578：public Call withFragment ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( )  fragment   

579：} ; ) 
579：public String absoluteURL ( Http . Request request ) { return absoluteURL ( request . secure ( ) , request . host ( ) ) ; }
579：public String absoluteURL ( Http . Request request ) { return absoluteURL ( request . secure ( ) , request . host ( )   

580：} ; ) ) 
580：public String webSocketURL ( Http . Request request ) { return webSocketURL ( request . secure ( ) , request . host ( ) ) ; }
580：public String webSocketURL ( Http . Request request ) { return webSocketURL ( request . secure ( ) , request . host (    

581：} ; } } } ; ) , ( 
581：AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
581：AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException  "Connection runnable failed"  e       

582：} ; } } } ; ) , ( 
582：< A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
582：< A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException  "Connection callable failed"  e       

583：} ; ) ( . 
583：public static Server forRouter ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }
583：public static Server forRouter ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port )  build  block   

584：} } ; ) 
584：public static JsonNode toJson ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
584：public static JsonNode toJson ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e    

585：} } ; ) ( 
585：public static < A > A fromJson ( JsonNode json , Class < A > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
585：public static < A > A fromJson ( JsonNode json , Class < A > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException  e    

586：} } ; ) 
586：public static JsonNode parse ( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
586：public static JsonNode parse ( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t    

587：} } ; ) ( 
587：public static JsonNode parse ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
587：public static JsonNode parse ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException  t    

588：} ; + + ) ) ( . ( . ) ( . ; = ) > . ( ; = ; ) . , . , , , 
588：public static String relative ( String startPath , String targetPath ) { if ( startPath . equals ( targetPath ) ) { return CURRENT_DIR ; } String [ ] start = toSegments ( canonical ( startPath ) ) ; String [ ] target = toSegments ( canonical ( targetPath ) ) ; if ( ! startPath . endsWith ( SEPARATOR ) ) start = Arrays . copyOfRange ( start , 0 , start . length - 1 ) ; String targetFile = "" ; if ( ! targetPath . endsWith ( SEPARATOR ) ) { targetFile = target [ target . length - 1 ] ; target = Arrays . copyOfRange ( target , 0 , target . length - 1 ) ; } String [ ] common = commonPrefix ( start , target ) ; String [ ] parents = toParentDirs ( start . length - common . length ) ; int relativeStartIdx = common . length ; String [ ] relativeDirs = Arrays . copyOfRange ( target , relativeStartIdx , target . length ) ; String [ ] relativePath = Arrays . copyOf ( parents , parents . length + relativeDirs . length ) ; System . arraycopy ( relativeDirs , 0 , relativePath , parents . length , relativeDirs . length ) ; String trailingSep = "" ; if ( relativePath . length > 0 ) trailingSep = SEPARATOR ; return Arrays . stream ( relativePath ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep + targetFile ; }
588：public static String relative ( String startPath , String targetPath ) { if ( startPath . equals ( targetPath ) ) { return CURRENT_DIR ; } String [ ] start = toSegments ( canonical ( startPath ) ) ; String [ ] target = toSegments ( canonical ( targetPath ) ) ; if ( ! startPath . endsWith ( SEPARATOR ) ) start = Arrays . copyOfRange ( start , 0 , start . length - 1 ) ; String targetFile = "" ; if ( ! targetPath . endsWith ( SEPARATOR ) ) { targetFile = target [ target . length - 1 ] ; target = Arrays . copyOfRange ( target , 0 , target . length - 1 ) ; } String [ ] common = commonPrefix ( start , target ) ; String [ ] parents = toParentDirs ( start . length - common . length ) ; int relativeStartIdx = common . length ; String [ ] relativeDirs = Arrays . copyOfRange ( target , relativeStartIdx , target . length ) ; String [ ] relativePath = Arrays . copyOf ( parents , parents . length + relativeDirs . length ) ; System . arraycopy ( relativeDirs  0  relativePath  parents  length  relativeDirs  length   String trailingSep  ""  if  relativePath  length  0  trailingSep  SEPARATOR  return Arrays  stream  relativePath   collect  Collectors  joining  SEPARATOR    trailingSep  targetFile  

589：} ; + ) ) ( . ( . ) ( . + ; : ? ) 
589：public static String canonical ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > canonical = new Stack < > ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( PARENT_DIR ) ) ) canonical . push ( comp ) ; else canonical . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + canonical . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
589：public static String canonical ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > canonical = new Stack < > ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( PARENT_DIR ) ) ) canonical . push ( comp ) ; else canonical . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR   SEPARATOR  ""  return prefixSep  canonical  stream    collect  Collectors  joining  SEPARATOR    trailingSep  

590：} ; ) ) ( . ( . ) 
590：public static List < Tuple < String , List < Object > > > displayableConstraint ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c ) ) . collect ( Collectors . toList ( ) ) ; }
590：public static List < Tuple < String , List < Object > > > displayableConstraint ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c )   collect  Collectors  toList     

591：} ; ) ) ) ) ( . ( . 
591：public static Tuple < String , List < Object > > displayableConstraint ( ConstraintDescriptor < ? > constraint ) { final Display displayAnnotation = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
591：public static Tuple < String , List < Object > > displayableConstraint ( ConstraintDescriptor < ? > constraint ) { final Display displayAnnotation = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) )  collect  Collectors  toList       

592：} ; ) ) ) ) ( ( . , 
592：public < A > CompletionStage < A > timeout ( final CompletionStage < A > stage , final long amount , final TimeUnit unit ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
592：public < A > CompletionStage < A > timeout ( final CompletionStage < A > stage , final long amount , final TimeUnit unit ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( duration  Scala  asScalaWithFuture    -> stage     

593：} ; } } ; { ) == ) , ] [ , ] [ 
593：public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return false ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { return false ; } } return true ; }
593：public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return false ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( isAssignable ( classArray  i   toClassArray  i   autoboxing   false   return false    return true  

594：} } ; ) , + 
594：public static Date parseCRONExpression ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
594：public static Date parseCRONExpression ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : "  cron  e    

595：} } ; ) , + 
595：public static long cronInterval ( String cron , Date date ) { try { return new CronExpression ( cron ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
595：public static long cronInterval ( String cron , Date date ) { try { return new CronExpression ( cron ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : "  cron  e    

596：} ; ) , ( ; ) , 
596：public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
596：public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache  materializer   return new AhcWSClient  client  materializer   

597：} ; ) ) ( 
597：public GuiceApplicationBuilder builder ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
597：public GuiceApplicationBuilder builder ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides  context    

598：} ; ) ) ) 
598：public static Result TODO ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
598：public static Result TODO ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala (     

599：} ; ) 
599：public static void session ( String key , String value ) { session ( ) . put ( key , value ) ; }
599：public static void session ( String key , String value ) { session ( ) . put ( key , value   

600：} ; ) 
600：public static void flash ( String key , String value ) { flash ( ) . put ( key , value ) ; }
600：public static void flash ( String key , String value ) { flash ( ) . put ( key , value   

601：} ; ) ( 
601：public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
601：public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava    

602：} ; ) ( 
602：public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
602：public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava    

603：} ; ) ( 
603：public Binding < T > to ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
603：public Binding < T > to ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava    

604：} ; ) ( 
604：public Binding < T > to ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
604：public Binding < T > to ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava    

605：} ; ) ( . 
605：public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier < > ( instance ) ) . asJava ( ) ; }
605：public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier < > ( instance ) )  asJava    

606：} ; ) ( 
606：public Binding < T > to ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
606：public Binding < T > to ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava    

607：} ; ) ( . 
607：public < P extends Provider < ? extends T > > Binding < T > toProvider ( final Class < P > provider ) { return underlying . toProvider ( provider ) . asJava ( ) ; }
607：public < P extends Provider < ? extends T > > Binding < T > toProvider ( final Class < P > provider ) { return underlying . toProvider ( provider )  asJava    

608：} ; ) ) ( ( . ) ( . ) 
608：public static List < Lang > availables ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
608：public static List < Lang > availables ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream (   map  Lang :: new   collect  toList     

609：} ; ) ) ) ( . ( . ( ; ) ) ( 
609：public static Lang preferred ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
609：public static Lang preferred ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList     return new Lang  langs  preferred  Scala  toSeq  langSeq     

610：} ; ) ( { 
610：public static play . api . db . evolutions . EvolutionsReader fromMap ( Map < String , List < Evolution > > evolutions ) { return new SimpleEvolutionsReader ( evolutions ) ; }
610：public static play . api . db . evolutions . EvolutionsReader fromMap ( Map < String , List < Evolution > > evolutions )  return new SimpleEvolutionsReader  evolutions   

611：} ; ) ( ; ) ) ( 
611：public static play . api . db . evolutions . EvolutionsReader forDefault ( Evolution ... evolutions ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( evolutions ) ) ; return fromMap ( map ) ; }
611：public static play . api . db . evolutions . EvolutionsReader forDefault ( Evolution ... evolutions ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList  evolutions    return fromMap  map   

612：} ; ) , ) ( . 
612：public static void cleanupEvolutions ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
612：public static void cleanupEvolutions ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions  resetScripts    autocommit   

613：} ; ) ) ) ) 
613：public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
613：public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) )      

614：} ; ) ) ) ) ) ) ( 
614：public GuiceApplicationBuilder withModuleLoader ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
614：public GuiceApplicationBuilder withModuleLoader ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying         

615：} ; ) ) 
615：public GuiceApplicationBuilder load ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
615：public GuiceApplicationBuilder load ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules )    

616：} ; ) ) 
616：public GuiceApplicationBuilder load ( com . google . inject . Module ... modules ) { return load ( Guiceable . modules ( modules ) ) ; }
616：public GuiceApplicationBuilder load ( com . google . inject . Module ... modules ) { return load ( Guiceable . modules ( modules    

617：} ; ) ) 
617：public GuiceApplicationBuilder load ( play . api . inject . Module ... modules ) { return load ( Guiceable . modules ( modules ) ) ; }
617：public GuiceApplicationBuilder load ( play . api . inject . Module ... modules ) { return load ( Guiceable . modules ( modules    

618：} ; ) ) 
618：public GuiceApplicationBuilder load ( play . api . inject . Binding < ? > ... bindings ) { return load ( Guiceable . bindings ( bindings ) ) ; }
618：public GuiceApplicationBuilder load ( play . api . inject . Binding < ? > ... bindings ) { return load ( Guiceable . bindings ( bindings    

619：} ; ) ( 
619：protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
619：protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder  builder   

620：} ; ) ( ; 
620：public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; encode ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
620：public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; encode ( buf , cookie )  return stripTrailingSeparator  buf   

621：} ; ) ( . } ; ) } ; ) ( { ) 
621：public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( true ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
621：public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( true ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( (  ->  throw new RuntimeException  "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread."       return ems  peekFirst    

622：} ; ) } } ; ) ( { } ; ) ( . { ) ( { ) 
622：@ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque < > ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> { if ( threadLocalFallback ) { return this . get ( ) ; } else { throw new RuntimeException ( "No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead." ) ; } } ) ; }
622：@ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque < > ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( (  ->  if  threadLocalFallback   return this  get     else  throw new RuntimeException  "No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead."       

623：} } ; ) ( . } ; ) 
623：void pushOrPopEm ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
623：void pushOrPopEm ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set."    ems  pop     

624：} ; ) , ) ( . . . . 
624：public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
624：public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( splitter :: apply ) , play . api  libs  streams  AkkaStreams  onlyFirstCanFinishMerge  2   flow   

625：} ; ) ) ) } ; ) ) ( . , ) ( . ( > < ; ) ) ( . ( . ) ) ( . ( . ) ) ( . ( . ) ) ( . ( . ; ) ) ( . ( . ) ) ( 
625：public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> { UniformFanOutShape < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > > broadcast = builder . add ( Broadcast . create ( 2 , true ) ) ; UniformFanInShape < Out , Out > merge = builder . add ( mergeStrategy ) ; Flow < F . Either < FlowIn , Out > , FlowIn , ? > collectIn = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { if ( x . left . isPresent ( ) ) { return x . left . get ( ) ; } else { throw Scala . noMatch ( ) ; } } ) ) ; Flow < F . Either < FlowIn , Out > , Out , ? > collectOut = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { if ( x . right . isPresent ( ) ) { return x . right . get ( ) ; } else { throw Scala . noMatch ( ) ; } } ) ) ; Flow < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > , ? > blockCancel = play . api . libs . streams . AkkaStreams . < F . Either < FlowIn , Out > > ignoreAfterCancellation ( ) . asJava ( ) ; builder . from ( broadcast . out ( 0 ) ) . via ( builder . add ( collectIn ) ) . via ( builder . add ( flow ) ) . toInlet ( merge . in ( 0 ) ) ; builder . from ( broadcast . out ( 1 ) ) . via ( builder . add ( blockCancel ) ) . via ( builder . add ( collectOut ) ) . toInlet ( merge . in ( 1 ) ) ; return new FlowShape < > ( broadcast . in ( ) , merge . out ( ) ) ; } ) ) ) ; }
625：public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> { UniformFanOutShape < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > > broadcast = builder . add ( Broadcast . create ( 2 , true ) ) ; UniformFanInShape < Out , Out > merge = builder . add ( mergeStrategy ) ; Flow < F . Either < FlowIn , Out > , FlowIn , ? > collectIn = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { if ( x . left . isPresent ( ) ) { return x . left . get ( ) ; } else { throw Scala . noMatch ( ) ; } } ) ) ; Flow < F . Either < FlowIn , Out > , Out , ? > collectOut = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { if ( x . right . isPresent ( ) ) { return x . right . get ( ) ; } else { throw Scala . noMatch ( ) ; } } ) ) ; Flow < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > , ? > blockCancel = play . api . libs . streams . AkkaStreams . < F . Either < FlowIn , Out > > ignoreAfterCancellation ( ) . asJava ( ) ; builder . from ( broadcast . out ( 0 ) ) . via ( builder . add ( collectIn ) ) . via ( builder . add  flow    toInlet  merge  in  0    builder  from  broadcast  out  1    via  builder  add  blockCancel    via  builder  add  collectOut    toInlet  merge  in  1    return new FlowShape    broadcast  in    merge  out          

626：} ; ) ( . ) , , , , } } ; 
626：public static < In , Out > Flow < In , Out , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
626：public static < In , Out > Flow < In , Out , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { public Props apply ( ActorRef v1 ) { return props . apply ( v1 )     bufferSize  overflowStrategy  factory  mat   asJava    

627：} ; ) ( . ; ) ) ( 
627：private List < Object > convertErrorArguments ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
627：private List < Object > convertErrorArguments ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList     return Collections  unmodifiableList  converted   

628：} ; ) , , , , , , , 
628：public Form < T > fill ( T value ) { if ( value == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form < > ( rootName , backedType , new HashMap < > ( ) , new HashMap < > ( ) , new ArrayList < > ( ) , Optional . ofNullable ( value ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
628：public Form < T > fill ( T value ) { if ( value == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form < > ( rootName , backedType , new HashMap < > ( ) , new HashMap < > ( ) , new ArrayList < > ( ) , Optional . ofNullable ( value )  groups  messagesApi  formatters  validatorFactory  config  lang  directFieldAccess   

629：} ; ) ) ) 
629：public List < ValidationError > globalErrors ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
629：public List < ValidationError > globalErrors ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList (     

630：} ; ) ( . . . ; ) } } ; ) , ) ( . ( 
630：public JsonNode errorsAsJson ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap < > ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList < > ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList < > ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
630：public JsonNode errorsAsJson ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap < > ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList < > ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList < > ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put  error  key    messages       return play  libs  Json  toJson  allMessages   

631：} ; ) ) 
631：public Optional < Object > value ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
631：public Optional < Object > value ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key )    

632：} ; ) ) ( . ) ( , 
632：public DynamicForm fill ( Map < String , Object > value ) { Form < Dynamic > form = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
632：public DynamicForm fill ( Map < String , Object > value ) { Form < Dynamic > form = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesApi , formatters , validatorFactory , config  lang    orElse  null    

633：} ; ) 
633：public < T > T parse ( String text , Class < T > clazz ) { return conversion . convert ( text , clazz ) ; }
633：public < T > T parse ( String text , Class < T > clazz ) { return conversion . convert ( text , clazz   

634：} ; ) ) 
634：@ SuppressWarnings ( "unchecked" ) public < T > T parse ( Field field , String text ) { return ( T ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
634：@ SuppressWarnings ( "unchecked" ) public < T > T parse ( Field field , String text ) { return ( T ) conversion . convert ( text , new TypeDescriptor ( field    

635：} } ; ) ( . { 
635：public < T > String print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
635：public < T > String print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else  return t  toString     

636：} ; ) 
636：public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
636：public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t   

637：} } ; ) ( . { } ; ) . , 
637：public < T > String print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
637：public < T > String print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t  String  class    else  return t  toString     

638：} ; ; ) } } ; ; ) ) . , . ( ( . ; ) ) . , . ( ( 
638：private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) { Object element = conversion . convert ( source , sourceType , targetType . elementTypeDescriptor ( source ) ) ; return Optional . ofNullable ( element ) ; } else if ( targetType . getObjectType ( ) . equals ( String . class ) ) { if ( source == null ) return "" ; Optional < ? > opt = ( Optional ) source ; return opt . map ( o -> conversion . convert ( source , sourceType . getElementTypeDescriptor ( ) , targetType ) ) . orElse ( "" ) ; } return null ; } public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < ConvertiblePair > result = new HashSet < > ( ) ; result . add ( new ConvertiblePair ( Optional . class , String . class ) ) ; result . add ( new ConvertiblePair ( String . class , Optional . class ) ) ; return result ; } } ) ; return this ; }
638：private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) { Object element = conversion . convert ( source , sourceType , targetType . elementTypeDescriptor ( source ) ) ; return Optional . ofNullable ( element ) ; } else if ( targetType . getObjectType ( ) . equals ( String . class ) ) { if ( source == null ) return "" ; Optional < ? > opt = ( Optional ) source ; return opt . map ( o -> conversion . convert ( source , sourceType . getElementTypeDescriptor ( ) , targetType ) ) . orElse ( "" ) ; } return null ; } public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < ConvertiblePair > result = new HashSet < > ( ) ; result . add  new ConvertiblePair  Optional  class  String  class    result  add  new ConvertiblePair  String  class  Optional  class    return result      return this  

639：} ; ; ) } } ; ) ( . { ) 
639：public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
639：public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString (   return formatter  toString        return this  

640：} ; ; ) } } ; + " + ) ( . + " " + ) ( . + " + ) ( . . { ) ( } } ; ) , , , ( { ) ( } ; ) , ) ( , ( . { ; ) 
640：@ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet < > ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet < > ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
640：@ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet < > ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet < > ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale (   try  return formatter  parse  a   String  source  locale    catch  Exception ex   throw new ConversionFailedException  sourceType  targetType  source  ex     public String toString    return String  class  getName     -> @"  annotationType  getName       clazz  getName    ":   formatter      return this  

641：} ; ) ( } ; ) . , ( { ) ) ( . ( } ; ) . , ( { ) ) ( . ( } ; ) ) ( . , 
641：public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 ) : new Date ( cookie . maxAge ( ) * 1000L + System . currentTimeMillis ( ) ) ; add ( buf , CookieHeaderNames . EXPIRES , HttpHeaderDateFormat . get ( ) . format ( expires ) ) ; } if ( cookie . sameSite ( ) != null ) { add ( buf , CookieHeaderNames . SAMESITE , cookie . sameSite ( ) ) ; } if ( cookie . path ( ) != null ) { add ( buf , CookieHeaderNames . PATH , cookie . path ( ) ) ; } if ( cookie . domain ( ) != null ) { add ( buf , CookieHeaderNames . DOMAIN , cookie . domain ( ) ) ; } if ( cookie . isSecure ( ) ) { add ( buf , CookieHeaderNames . SECURE ) ; } if ( cookie . isHttpOnly ( ) ) { add ( buf , CookieHeaderNames . HTTPONLY ) ; } return stripTrailingSeparator ( buf ) ; }
641：public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 ) : new Date ( cookie . maxAge ( ) * 1000L + System . currentTimeMillis ( ) ) ; add ( buf , CookieHeaderNames . EXPIRES , HttpHeaderDateFormat . get ( ) . format ( expires ) ) ; } if ( cookie . sameSite ( ) != null ) { add ( buf , CookieHeaderNames . SAMESITE , cookie . sameSite ( ) ) ; } if ( cookie . path ( ) != null ) { add ( buf , CookieHeaderNames . PATH , cookie . path ( ) ) ; } if ( cookie . domain ( ) != null ) { add ( buf , CookieHeaderNames . DOMAIN  cookie  domain      if  cookie  isSecure     add  buf  CookieHeaderNames  SECURE    if  cookie  isHttpOnly     add  buf  CookieHeaderNames  HTTPONLY    return stripTrailingSeparator  buf   

642：} ; ) 
642：public static NodeList selectNodes ( String path , Object node ) { return selectNodes ( path , node , null ) ; }
642：public static NodeList selectNodes ( String path , Object node ) { return selectNodes ( path , node , null   

643：} ; ) ( . ) ( 
643：public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > list ) { return scala . collection . JavaConverters . asScalaBufferConverter ( list ) . asScala ( ) . toList ( ) ; }
643：public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > list ) { return scala . collection . JavaConverters . asScalaBufferConverter ( list ) . asScala    toList    

644：} ; ) ) ( 
644：public static < T > scala . collection . immutable . Seq < T > toSeq ( T [ ] array ) { return toSeq ( java . util . Arrays . asList ( array ) ) ; }
644：public static < T > scala . collection . immutable . Seq < T > toSeq ( T [ ] array ) { return toSeq ( java . util . Arrays . asList  array    

645：} ; ) ( 
645：public static < T > scala . collection . immutable . Seq < T > varargs ( T ... array ) { return toSeq ( array ) ; }
645：public static < T > scala . collection . immutable . Seq < T > varargs ( T ... array ) { return toSeq  array   

646：} ; ) } } ; ) ( { ) ( } ; ) ) ( . ) ( . . . ( . { 
646：public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > in ) { return new MappedWebSocketAcceptor < > ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
646：public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > in ) { return new MappedWebSocketAcceptor < > ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try  return new Message  Text  play  libs  Json  mapper    writeValueAsString  outMessage     catch  Exception e   throw new RuntimeException  e       

647：} ; } } ; ) } } ; ) ( . . ; ) ) ( . ) ( . . , ) ( 
647：private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
647：private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge  2   resultOrFlow  right  get    map  outMapper :: apply    return F  Either  Right  flow          

648：} ; } } { ) ( } ; ; ) 
648：static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return false ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( true ) ; return true ; } catch ( final SecurityException e ) { } } return false ; }
648：static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return false ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( true   return true   catch  final SecurityException e     return false  

649：} ; } } } ; ] + [ = { ) - . < ( ; 
649：private static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) { cost += 0.1f ; cls = ClassUtils . wrapperToPrimitive ( cls ) ; } for ( int i = 0 ; cls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; i ++ ) { if ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { cost += 0.1f ; if ( i < ORDERED_PRIMITIVE_TYPES . length - 1 ) { cls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; } } } return cost ; }
649：private static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) { cost += 0.1f ; cls = ClassUtils . wrapperToPrimitive ( cls ) ; } for ( int i = 0 ; cls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; i ++ ) { if ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { cost += 0.1f  if  i  ORDERED_PRIMITIVE_TYPES  length  1   cls  ORDERED_PRIMITIVE_TYPES  i  1      return cost  

650：} ; } } } ; + ) , ( ; ] [ = > ? < { ) ++ ; . < ; - . = ( { } ; + ) , ( ; ) ( 
650：private static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ; float totalCost = 0.0f ; final long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; if ( srcArgs . length < normalArgsLen ) { return Float . MAX_VALUE ; } for ( int i = 0 ; i < normalArgsLen ; i ++ ) { totalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; } if ( isVarArgs ) { final boolean noVarArgsPassed = srcArgs . length < destArgs . length ; final boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; final float varArgsCost = 0.001f ; final Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; if ( noVarArgsPassed ) { totalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; } else if ( explicitArrayForVarags ) { final Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; totalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; } else { for ( int i = destArgs . length - 1 ; i < srcArgs . length ; i ++ ) { final Class < ? > srcClass = srcArgs [ i ] ; totalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; } } } return totalCost ; }
650：private static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ; float totalCost = 0.0f ; final long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; if ( srcArgs . length < normalArgsLen ) { return Float . MAX_VALUE ; } for ( int i = 0 ; i < normalArgsLen ; i ++ ) { totalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; } if ( isVarArgs ) { final boolean noVarArgsPassed = srcArgs . length < destArgs . length ; final boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; final float varArgsCost = 0.001f ; final Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; if ( noVarArgsPassed ) { totalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; } else if ( explicitArrayForVarags ) { final Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType    totalCost += getObjectTransformationCost  sourceClass  destClass   varArgsCost   else  for  int i  destArgs  length  1  i  srcArgs  length  i    final Class    srcClass  srcArgs  i   totalCost += getObjectTransformationCost  srcClass  destClass   varArgsCost     return totalCost  

651：} ; } ; { ) == ( } ; ) ( . = 
651：private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { cost += 0.25f ; break ; } cost ++ ; srcClass = srcClass . getSuperclass ( ) ; } if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
651：private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { cost += 0.25f ; break ; } cost ++ ; srcClass  srcClass  getSuperclass     if  srcClass  null   cost += 1.5f   return cost  

652：} ; ) 
652：public String at ( String key , Object ... args ) { return messagesApi . get ( lang , key , args ) ; }
652：public String at ( String key , Object ... args ) { return messagesApi . get ( lang , key , args   

653：} ; ) 
653：public String at ( List < String > keys , Object ... args ) { return messagesApi . get ( lang , keys , args ) ; }
653：public String at ( List < String > keys , Object ... args ) { return messagesApi . get ( lang , keys , args   

654：} ; ) , 
654：public static Database createFrom ( String driver , String url , Map < String , ? extends Object > config ) { return createFrom ( "default" , driver , url , config ) ; }
654：public static Database createFrom ( String driver , String url , Map < String , ? extends Object > config ) { return createFrom ( "default" , driver , url  config   

655：} ; ) ( 
655：public static ParallelSorter create ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
655：public static ParallelSorter create ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create    

656：} ; ) - 
656：public void quickSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
656：public void quickSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( lo , hi  1   

657：} ; ) - 
657：public void mergeSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
657：public void mergeSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , hi  1   

658：} } ; ; ) + " ( ) < 
658：public Object invoke ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
658：public Object invoke ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1  0  throw new IllegalArgumentException  "Protected method:   sig1   throw e   

659：} } } } ; ) . ( . { ) . == ( } ; ) . ( . { ) . == ( } ; ) . ( . { ) . == ( } ; ) . ( . { 
659：public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
659：public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE )  mv  visitInsn  Constants  I2D    else if  to  Type  FLOAT_TYPE   mv  visitInsn  Constants  I2F    else if  to  Type  LONG_TYPE   mv  visitInsn  Constants  I2L    else if  to  Type  SHORT_TYPE   mv  visitInsn  Constants  I2S      

660：} ; ) ) 
660：public void load_arg ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
660：public void load_arg ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index    

661：} ; ) ) ( 
661：void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
661：void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor     

662：} } ; ) ( { } } ; ) ( 
662：public void zero_or_null ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
662：public void zero_or_null ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push  0     else  aconst_null     

663：} } ; ) ( { } } ; ) ( 
663：public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
663：public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark  end     else  checkcast  type    

664：} ; ) , . ( . ; ) ( . ; ) ( . ; ) ( . ; ) ( . 
664：public static void process_array ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; callback . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
664：public static void process_array ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; callback . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e  mark  checkloop   e  load_local  loopvar   e  load_local  array   e  arraylength    e  if_icmp  e  LT  loopbody   

665：} ; ) ( . ; ) ( . ; ) ( . ; ) ( 
665：private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
665：private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark  oneNullHelper   e  pop2    e  goTo  oneNull   e  mark  end   

666：} ; } } { ) ( } } ; ) ( . { } ; ) . | 
666：public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( '.' , '/' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
666：public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( '.' , '/' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES  ClassReader  SKIP_DEBUG    finally  is  close      catch  IOException ignored     return resolved  

667：} ; ) , 
667：public static void getMethods ( Class superclass , Class [ ] interfaces , List methods ) { getMethods ( superclass , interfaces , methods , null , null ) ; }
667：public static void getMethods ( Class superclass , Class [ ] interfaces , List methods ) { getMethods ( superclass , interfaces , methods , null  null   

668：} ; ) + " ( 
668：protected void filterConstructors ( Class sc , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , true ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
668：protected void filterConstructors ( Class sc , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , true ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException  "No visible constructors in   sc   

669：} ; = . 
669：public void setSuperclass ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . superclass = superclass ; }
669：public void setSuperclass ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this  superclass  superclass  

670：} ; ) ( . ; ) } } ; ) , ( . { ) ( } 
670：private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
670：private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ;  public void processDefault    e  throw_exception  ILLEGAL_ARGUMENT_EXCEPTION  "Unknown field name"       e  end_method    

671：} ; ) 
671：public void add ( Method method ) { add ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method ) ) ; }
671：public void add ( Method method ) { add ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method )   

672：} ; } ; ; 
672：public int cardinality ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
672：public int cardinality ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ]  w >>= 8   return c  

673：} ; = . 
673：public void setNamingPolicy ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = namingPolicy ; }
673：public void setNamingPolicy ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this  namingPolicy  namingPolicy  

674：} ; } } { ) == ] [ ( ; ) ] + * [ 
674：public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) { } } return result ; }
674：public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors  i  2  1    if  result  i   null     return result  

675：} ; ) ( . 
675：public static Path resolve ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
675：public static Path resolve ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base  resolve  child   

676：} } ; ) ( . 
676：public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ; StreamUtil . copy ( reader , writer ) ; return writer . toString ( ) ; } }
676：public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ; StreamUtil . copy ( reader , writer ) ; return writer  toString     

677：} ; } ; ) 
677：public HttpRequest host ( final String host ) { this . host = host ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , host ) ; } return this ; }
677：public HttpRequest host ( final String host ) { this . host = host ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , host    return this  

678：} ; ) ( 
678：public static HttpRequest create ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( destination ) ; }
678：public static HttpRequest create ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set  destination   

679：} ; ) 
679：public static HttpRequest connect ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination ) ; }
679：public static HttpRequest connect ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination   

680：} ; ) 
680：public static HttpRequest get ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }
680：public static HttpRequest get ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination   

681：} ; ) 
681：public static HttpRequest post ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( destination ) ; }
681：public static HttpRequest post ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( destination   

682：} ; ) 
682：public static HttpRequest put ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
682：public static HttpRequest put ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination   

683：} ; ) 
683：public static HttpRequest patch ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
683：public static HttpRequest patch ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination   

684：} ; ) 
684：public static HttpRequest delete ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
684：public static HttpRequest delete ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination   

685：} ; ) 
685：public static HttpRequest head ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }
685：public static HttpRequest head ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination   

686：} ; ) 
686：public static HttpRequest trace ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }
686：public static HttpRequest trace ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination   

687：} ; ) 
687：public static HttpRequest options ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }
687：public static HttpRequest options ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination   

688：} ; ; = . } ; ) ( . = { 
688：public HttpRequest path ( String path ) { if ( ! path . startsWith ( StringPool . SLASH ) ) { path = StringPool . SLASH + path ; } int ndx = path . indexOf ( '?' ) ; if ( ndx != - 1 ) { String queryString = path . substring ( ndx + 1 ) ; path = path . substring ( 0 , ndx ) ; query = HttpUtil . parseQuery ( queryString , true ) ; } else { query = HttpMultiMap . newCaseInsensitiveMap ( ) ; } this . path = path ; return this ; }
688：public HttpRequest path ( String path ) { if ( ! path . startsWith ( StringPool . SLASH ) ) { path = StringPool . SLASH + path ; } int ndx = path . indexOf ( '?' ) ; if ( ndx != - 1 ) { String queryString = path . substring ( ndx + 1 ) ; path = path . substring ( 0 , ndx ) ; query = HttpUtil . parseQuery ( queryString , true ) ; } else  query  HttpMultiMap  newCaseInsensitiveMap     this  path  path  return this  

689：} ; ; ) ) ( . , ( } ; ) ) ( . 
689：public HttpRequest cookies ( final Cookie ... cookies ) { if ( cookies . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = true ; for ( Cookie cookie : cookies ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = false ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( '=' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
689：public HttpRequest cookies ( final Cookie ... cookies ) { if ( cookies . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = true ; for ( Cookie cookie : cookies ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = false ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( '=' ) ; cookieString . append ( cookie  getValue      headerOverwrite  "cookie"  cookieString  toString     return this  

690：} ; } ; ) , ( . ; ) 
690：public HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String name = parameters [ i ] . toString ( ) ; String value = parameters [ i + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
690：public HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String name = parameters [ i ] . toString ( ) ; String value = parameters [ i + 1 ] . toString (   query  add  name  value    return this  

691：} ; } ; ) ) 
691：public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > entry : queryMap . entrySet ( ) ) { query . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
691：public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > entry : queryMap . entrySet ( ) ) { query . add ( entry . getKey ( ) , entry . getValue (     return this  

692：} ; ; ) 
692：public HttpRequest queryString ( final String queryString , final boolean decode ) { this . query = HttpUtil . parseQuery ( queryString , decode ) ; return this ; }
692：public HttpRequest queryString ( final String queryString , final boolean decode ) { this . query = HttpUtil . parseQuery ( queryString , decode   return this  

693：} ; ) , 
693：public String queryString ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
693：public String queryString ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query  queryEncoding   

694：} ; ) ( . } ; ) ( 
694：public String hostUrl ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ':' ) ; url . append ( port ) ; } return url . toString ( ) ; }
694：public String hostUrl ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ':' ) ; url . append  port    return url  toString    

695：} ; } ; ) + " , 
695：public HttpRequest basicAuthentication ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
695：public HttpRequest basicAuthentication ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION  "Basic   base64    return this  

696：} ; ; ) , 
696：public HttpRequest setHostHeader ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
696：public HttpRequest setHostHeader ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST  hostPort   return this  

697：} ; ; ) , , ( ; ) ( . ) ( . ) ( . } ; 
697：protected Buffer buffer ( final boolean fullRequest ) { if ( header ( HEADER_HOST ) == null ) { setHostHeader ( ) ; } Buffer formBuffer = formBuffer ( ) ; String queryString = queryString ( ) ; if ( header ( "User-Agent" ) == null ) { header ( "User-Agent" , Defaults . userAgent ) ; } if ( method . equals ( "POST" ) && ( contentLength ( ) == null ) ) { contentLength ( 0 ) ; } Buffer request = new Buffer ( ) ; request . append ( method ) . append ( SPACE ) . append ( path ) ; if ( query != null && ! query . isEmpty ( ) ) { request . append ( '?' ) ; request . append ( queryString ) ; } request . append ( SPACE ) . append ( httpVersion ) . append ( CRLF ) ; populateHeaderAndBody ( request , formBuffer , fullRequest ) ; return request ; }
697：protected Buffer buffer ( final boolean fullRequest ) { if ( header ( HEADER_HOST ) == null ) { setHostHeader ( ) ; } Buffer formBuffer = formBuffer ( ) ; String queryString = queryString ( ) ; if ( header ( "User-Agent" ) == null ) { header ( "User-Agent" , Defaults . userAgent ) ; } if ( method . equals ( "POST" ) && ( contentLength ( ) == null ) ) { contentLength ( 0 ) ; } Buffer request = new Buffer ( ) ; request . append ( method ) . append ( SPACE ) . append ( path ) ; if ( query != null && ! query . isEmpty ( ) ) { request . append ( '?' ) ; request . append ( queryString )   request  append  SPACE   append  httpVersion   append  CRLF   populateHeaderAndBody  request  formBuffer  fullRequest   return request  

698：} ; ) ) 
698：public < R > R sendAndReceive ( final Function < HttpResponse , R > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
698：public < R > R sendAndReceive ( final Function < HttpResponse , R > responseHandler ) { return responseHandler . apply ( send (    

699：} } ; ) , . , ( ; ) . , , ( = . { } ; ) , . , ( 
699：static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; if ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) { return firstHandler ; } if ( rangeStart <= handlerStart ) { if ( rangeEnd >= handlerEnd ) { return firstHandler . nextHandler ; } else { return new Handler ( firstHandler , end , firstHandler . endPc ) ; } } else if ( rangeEnd >= handlerEnd ) { return new Handler ( firstHandler , firstHandler . startPc , start ) ; } else { firstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; return new Handler ( firstHandler , firstHandler . startPc , start ) ; } }
699：static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; if ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) { return firstHandler ; } if ( rangeStart <= handlerStart ) { if ( rangeEnd >= handlerEnd ) { return firstHandler . nextHandler ; } else { return new Handler ( firstHandler , end , firstHandler . endPc ) ; } } else if ( rangeEnd >= handlerEnd ) { return new Handler  firstHandler  firstHandler  startPc  start    else  firstHandler  nextHandler  new Handler  firstHandler  end  firstHandler  endPc   return new Handler  firstHandler  firstHandler  startPc  start    

700：} ; } ; . 
700：static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler . nextHandler ; } return length ; }
700：static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler  nextHandler   return length  

701：} ; ) ) ) ( . 
701：protected void collectActionInterceptors ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList < > ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
701：protected void collectActionInterceptors ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList < > ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( )  getSimpleName      

702：} ; ) ) ) ( . 
702：protected void collectActionFilters ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList < > ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
702：protected void collectActionFilters ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList < > ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( )  getSimpleName      

703：} ; ) ) ) ( . 
703：protected void collectActionResults ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList < > ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
703：protected void collectActionResults ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList < > ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( )  getSimpleName      

704：} ; ) ) 
704：protected void collectActionRuntimes ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
704：protected void collectActionRuntimes ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath    

705：} ; ) , . + " ( } ; { ) 
705：@ SuppressWarnings ( { "unchecked" } ) protected void setSimpleProperty ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ; if ( setter != null ) { invokeSetter ( setter , bp , value ) ; return ; } if ( bp . isMap ( ) ) { ( ( Map ) bp . bean ) . put ( bp . name , value ) ; return ; } if ( isSilent ) { return ; } throw new BeanException ( "Simple property not found: " + bp . name , bp ) ; }
705：@ SuppressWarnings ( { "unchecked" } ) protected void setSimpleProperty ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ; if ( setter != null ) { invokeSetter ( setter , bp , value ) ; return ; } if ( bp . isMap ( ) ) { ( ( Map ) bp . bean ) . put ( bp . name , value ) ; return ; } if ( isSilent   return   throw new BeanException  "Simple property not found:   bp  name  bp   

706：} } } ; { ) ( } ; ) 
706：public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
706：public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty    catch  Exception ignore   return null    

707：} ; ) , ( . 
707：public String extractThisReference ( final String propertyName ) { int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; if ( ndx == - 1 ) { return propertyName ; } return propertyName . substring ( 0 , ndx ) ; }
707：public String extractThisReference ( final String propertyName ) { int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; if ( ndx == - 1 ) { return propertyName ; } return propertyName  substring  0  ndx   

708：} ; } ; 
708：public PrintWriter getWriter ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
708：public PrintWriter getWriter ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer )   return printWriter  

709：} ; ) , ( 
709：public void setObjectReference ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap < > ( ) ; } objectRefs . put ( name , object ) ; }
709：public void setObjectReference ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap < > ( ) ; } objectRefs . put  name  object   

710：} ; ) ( 
710：public Object getObjectReference ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
710：public Object getObjectReference ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get  name   

711：} ; } ; ) 
711：public Object lookupObject ( final String ref ) { Object value = getObjectReference ( ref ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return value ; }
711：public Object lookupObject ( final String ref ) { Object value = getObjectReference ( ref ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref    return value  

712：} ; . : ? == 
712：public DbEntityDescriptor getTableDescriptor ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . desc ; }
712：public DbEntityDescriptor getTableDescriptor ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t  null  null  t  desc  

713：} ; } } ; { ) 
713：public DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
713：public DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null   return ded    return null  

714：} ; . : ? 
714：public String getTableAlias ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . alias ; }
714：public String getTableAlias ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null  null  t  alias  

715：} } ; ) + " ( { ) 
715：public void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap < > ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
715：public void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap < > ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null   throw new DbSqlBuilderException  "Duplicated table reference:   tableReference    

716：} ; } ; ) + 
716：protected DbEntityDescriptor lookupTableRef ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return ded ; }
716：protected DbEntityDescriptor lookupTableRef ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: "  tableRef    return ded  

717：} ; ) ( 
717：public void registerHint ( final String hint ) { if ( hints == null ) { hints = new ArrayList < > ( hintCount ) ; } hints . add ( hint ) ; }
717：public void registerHint ( final String hint ) { if ( hints == null ) { hints = new ArrayList < > ( hintCount ) ; } hints . add  hint   

718：} ; ; ) ( . 
718：public final boolean serialize ( final JsonContext jsonContext , final T value ) { if ( jsonContext . pushValue ( value ) ) { return false ; } serializeValue ( jsonContext , value ) ; jsonContext . popValue ( ) ; return true ; }
718：public final boolean serialize ( final JsonContext jsonContext , final T value ) { if ( jsonContext . pushValue ( value ) ) { return false ; } serializeValue ( jsonContext , value ) ; jsonContext  popValue    return true  

719：} } ; ) } } ; ) , , ( . 
719：protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , true ) ; } } ) ; } }
719：protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target  writeValue  name  attrValue  true        

720：} } ; ) } } } ; ) , , ( . ; ) ] [ : ? != . ( = } } } ; ) , 
720：protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , true ) ; } } } ) ; } }
720：protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1  encoding      final Object value   paramValues  length  1  paramValues  paramValues  0    target  writeValue  name  value  true         

721：} } ; ) } } ; ) , , ( . ; ) : ] [ ? == . ( = } } } ; = ] 
721：protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , true ) ; } } ) ; } }
721：protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j   null     final Object value   paramValues  length  1  paramValues  0   paramValues   target  writeValue  name  value  true        

722：} ; ) ( . ) ( : ) ( . 
722：public String convertPropertyNameToColumnName ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
722：public String convertPropertyNameToColumnName ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName )  toString    toLowercase  tableName   toString    

723：} ; } ; ) ( . } } ; ) ) ( . 
723：public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = false ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = true ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = false ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
723：public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = false ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = true ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = false ; } else { propertyName . append ( Character  toLowerCase  c      return propertyName  toString     return columnName  

724：} ; ) ( 
724：public String applyToColumnName ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
724：public String applyToColumnName ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName  propertyName   

725：} ; ) , , , 
725：public void storeValue ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
725：public void storeValue ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st  index  t  dbSqlType   

726：} ; ) , ( . ) ( 
726：@ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
726：@ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get    convertType  t  destinationType   

727：} ; ; ) ) 
727：protected Set < T > getAll ( ) { final Set < T > set = new HashSet < > ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
727：protected Set < T > getAll ( ) { final Set < T > set = new HashSet < > ( wrappers . size ( ) ) ; set . addAll ( wrappers . values (    return set  

728：} ; } ; ) , ( . 
728：public T resolve ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
728：public T resolve ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers  put  wrapperClassName  wrapper    return wrapper  

729：} } ; ) , + " 
729：protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
729：protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper:   wrapperClass  ex    

730：} } ; ) ( { 
730：public static String separatorsToSystem ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
730：public static String separatorsToSystem ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else  return separatorsToUnix  path    

731：} ; ) , ( . } ; . { ) 
731：private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
731：private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex   return StringPool  EMPTY   return filename  substring  prefix  endIndex   

732：} ; } , , , { ] [ } } ; ) + ( . = ; ) , ) ( . + ) ( . 
732：public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
732：public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix  length    path  length    lastExtensionIndex   extension  filename  substring  lastExtensionIndex  1     return new String    prefix  path  baseName  extension   

733：} ; ) ( . 
733：public static String relativePath ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
733：public static String relativePath ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) )  toString    

734：} ; ; ) ) 
734：public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent ) ) ; return this ; }
734：public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent    return this  

735：} ; ; ) ) , ( 
735：public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
735：public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with  actionConfigType  actionConfigConsumer    return this  

736：} ; ; ) ( ; ) . ( . ; ) ( ; = } ; ) ( . ; ) ( . ; ) ( . = { ) ) 
736：public WebApp start ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ; for ( final Map < String , Object > params : paramsList ) { madvocContainer . defineParams ( params ) ; } for ( final Props props : propsList ) { madvocContainer . defineParams ( props ) ; } propsList = null ; registerMadvocComponents ( ) ; madvocComponents . forEach ( madvocComponent -> madvocContainer . registerComponent ( madvocComponent . type ( ) , madvocComponent . consumer ( ) ) ) ; madvocComponents = null ; madvocComponentInstances . forEach ( madvocContainer :: registerComponentInstance ) ; madvocComponentInstances = null ; configureDefaults ( ) ; madvocContainer . fireEvent ( Init . class ) ; componentConfigs . accept ( madvocContainer ) ; componentConfigs = null ; initialized ( ) ; madvocContainer . fireEvent ( Start . class ) ; if ( ! madvocRouterConsumers . isEmpty ( ) ) { final MadvocRouter madvocRouter = MadvocRouter . create ( ) ; madvocContainer . registerComponentInstance ( madvocRouter ) ; madvocRouterConsumers . accept ( madvocRouter ) ; } madvocRouterConsumers = null ; started ( ) ; madvocContainer . fireEvent ( Ready . class ) ; ready ( ) ; return this ; }
736：public WebApp start ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ; for ( final Map < String , Object > params : paramsList ) { madvocContainer . defineParams ( params ) ; } for ( final Props props : propsList ) { madvocContainer . defineParams ( props ) ; } propsList = null ; registerMadvocComponents ( ) ; madvocComponents . forEach ( madvocComponent -> madvocContainer . registerComponent ( madvocComponent . type ( ) , madvocComponent . consumer ( ) ) ) ; madvocComponents = null ; madvocComponentInstances . forEach ( madvocContainer :: registerComponentInstance ) ; madvocComponentInstances = null ; configureDefaults ( ) ; madvocContainer . fireEvent ( Init . class ) ; componentConfigs . accept ( madvocContainer ) ; componentConfigs = null ; initialized ( ) ; madvocContainer . fireEvent ( Start . class ) ; if ( ! madvocRouterConsumers . isEmpty (    final MadvocRouter madvocRouter  MadvocRouter  create    madvocContainer  registerComponentInstance  madvocRouter   madvocRouterConsumers  accept  madvocRouter    madvocRouterConsumers  null  started    madvocContainer  fireEvent  Ready  class   ready    return this  

737：} ; ) . ( . 
737：protected void configureDefaults ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
737：protected void configureDefaults ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager  registerAnnotation  RestAction  class   

738：} ; ) . ( . ; ) . ( . ; ) . ( . ; ) . ( . ; ) . ( . ; ) . ( . ; ) 
738：protected void registerMadvocComponents ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
738：protected void registerMadvocComponents ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class   madvocContainer  registerComponent  ResultsManager  class   madvocContainer  registerComponent  ResultMapper  class   madvocContainer  registerComponent  ScopeResolver  class   madvocContainer  registerComponent  ScopeDataInspector  class   madvocContainer  registerComponent  AsyncActionExecutor  class   madvocContainer  registerComponent  FileUploader  class   

739：} ; } ; ) 
739：public ClassScanner excludeJars ( final String ... excludedJars ) { for ( final String excludedJar : excludedJars ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
739：public ClassScanner excludeJars ( final String ... excludedJars ) { for ( final String excludedJar : excludedJars ) { rulesJars . exclude ( excludedJar    return this  

740：} ; } ; ) 
740：public ClassScanner includeJars ( final String ... includedJars ) { for ( final String includedJar : includedJars ) { rulesJars . include ( includedJar ) ; } return this ; }
740：public ClassScanner includeJars ( final String ... includedJars ) { for ( final String includedJar : includedJars ) { rulesJars . include ( includedJar    return this  

741：} ; } ; 
741：public ClassScanner includeEntries ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
741：public ClassScanner includeEntries ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry )   return this  

742：} ; } ; 
742：public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String excludedEntry : excludedEntries ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
742：public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String excludedEntry : excludedEntries ) { rulesEntries . exclude ( excludedEntry )   return this  

743：} ; ) ( . } } } ; ; ) ( . { ) ! ( { ) ( } } } ; ) ( . { } ; 
743：protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , true ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , false ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
743：protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , true ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , false ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry )   finally  classPathEntry  closeInputStream       catch  RuntimeException rex   if   ignoreException   ZipUtil  close  zipFile   throw rex     ZipUtil  close  zipFile   

744：} } } } ; { ) ! ( { ) ( } } ; ) , , 
744：protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , true ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , false ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
744：protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , true ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath  file  false     catch  RuntimeException rex   if   ignoreException   throw rex     

745：} ; ) ( . 
745：public static byte [ ] bytecodeSignatureOfType ( final Class type ) { final String name = 'L' + type . getName ( ) . replace ( '.' , '/' ) + ';' ; return name . getBytes ( ) ; }
745：public static byte [ ] bytecodeSignatureOfType ( final Class type ) { final String name = 'L' + type . getName ( ) . replace ( '.' , '/' ) + ';' ; return name  getBytes    

746：} ; } ; 
746：public ClassScanner scan ( final String ... paths ) { for ( final String path : paths ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
746：public ClassScanner scan ( final String ... paths ) { for ( final String path : paths ) { filesToScan . add ( new File ( path ) )   return this  

747：} ; ) } } ; ) ( { ) 
747：public void start ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
747：public void start ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( )   scanClassPath  file       

748：} ; ) , 
748：protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
748：protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope  active   

749：} ; ) ( ) ( } 
749：@ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
749：@ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ;  return  S  getOrInitScope  scopeClass   

750：} ; ; ) ( . } ; ) , + " ( { 
750：protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } } final MadvocScope newScope ; try { newScope = madpc . createBean ( madvocScopeType ) ; } catch ( Exception ex ) { throw new MadvocException ( "Unable to create scope: " + madvocScopeType , ex ) ; } allScopes . add ( newScope ) ; return newScope ; }
750：protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } } final MadvocScope newScope ; try { newScope = madpc . createBean ( madvocScopeType ) ; } catch ( Exception ex )  throw new MadvocException  "Unable to create scope:   madvocScopeType  ex    allScopes  add  newScope   return newScope  

751：} ; ) ( . ; 
751：public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( scope ) ; }
751：public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( scopeType )  madvocScopeConsumer  accept  scope   

752：} ; } } ; ) >> ( ) ( = ] ++ [ { ) ; < ; = ( } ; ) * - ( << ] ] ++ [ [ { ) ++ ; - 
752：public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == '\r' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
752：public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == '\r' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx  pad  j    i |= INV  arr  sndx      18  j  6    for  int r  16  d  len  r -= 8   dest  d     byte   i  r     return dest  

753：} ; ; ) ! ( } ; ) ) , ( ( . = 
753：@ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet < > ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
753：@ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet < > ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique  tokenSet  add  new Token  value  timeToLive     while   unique   return value  

754：} } ; ) ( . { ) ) >= ) ( . ( && 
754：protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
754：protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null )   tokenSet  size    maxTokensPerSession    tokenSet  remove  tokenToRemove    

755：} ; } } ; = ; ) ( . { ) ) ( . ) ( . 
755：@ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return true ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return false ; } boolean found = false ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = true ; } } return found ; }
755：@ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return true ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return false ; } boolean found = false ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t  getValue    equals  tokenValue    it  remove    found  true    return found  

756：} ; ; = 
756：public static BeanCopy from ( final Object source ) { BeanCopy beanCopy = new BeanCopy ( source ) ; beanCopy . isSourceMap = source instanceof Map ; return beanCopy ; }
756：public static BeanCopy from ( final Object source ) { BeanCopy beanCopy = new BeanCopy ( source ) ; beanCopy . isSourceMap  source instanceof Map  return beanCopy  

757：} ; ) ( 
757：public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( true ) ; visit ( ) ; }
757：public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( true ) ; visit    

758：} ; ; ) , , 
758：protected boolean visitProperty ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return true ; }
758：protected boolean visitProperty ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination  name  value   return true  

759：} ; ) , , ( . } ; ) ( . = { ) 
759：public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
759：public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null   tableReference  ded  getEntityName     templateData  registerTableReference  tableReference  ded  tableAlias   

760：} ; } ; ) , ( . ; ) , ( } 
760：@ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
760：@ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ;  registerScope  scopeType  scope   scopes  put  scopeType  scope    return scope  

761：} } } ; ) , ( . { } } ; ) , ( . { ) != ( ; 
761：protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ; } } else { beansAlt . put ( altName , beanDefinition ) ; } } }
761：protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName )  if  existing  null   beansAlt  put  altName  null     else  beansAlt  put  altName  beanDefinition     

762：} } ; ) ( { ) : 
762：public void removeBean ( final Class type ) { Set < String > beanNames = new HashSet < > ( ) ; for ( BeanDefinition def : beans . values ( ) ) { if ( def . type . equals ( type ) ) { beanNames . add ( def . name ) ; } } for ( String beanName : beanNames ) { removeBean ( beanName ) ; } }
762：public void removeBean ( final Class type ) { Set < String > beanNames = new HashSet < > ( ) ; for ( BeanDefinition def : beans . values ( ) ) { if ( def . type . equals ( type ) ) { beanNames . add ( def . name ) ; } } for ( String beanName  beanNames   removeBean  beanName    

763：} ; ; ) , ( . } ; ) ] [ ( . = { } ; 
763：protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList < > ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
763：protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList < > ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY   else  beanNames  list  toArray  new String  0     beanCollections  put  type  beanNames   return beanNames  

764：} ; ) , ( = . ; ) , ( . = ] [ } ; ) ) ( . . + " ( { ) 
764：public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
764：public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null   throw new PetiteException  "Constructor not found:   beanDefinition  type  getName      BeanReferences   ref  referencesResolver  resolveReferenceFromValues  constructor  references   beanDefinition  ctor  new CtorInjectionPoint  constructor  ref   

765：} ; ) ( . ; ) , ( = ; ) , ( . = 
765：public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + '#' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
765：public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + '#' + property ) ; } BeanReferences ref  referencesResolver  resolveReferenceFromValue  propertyDescriptor  reference   PropertyInjectionPoint pip  new PropertyInjectionPoint  propertyDescriptor  ref   beanDefinition  addPropertyInjectionPoint  pip   

766：} ; ) ( . ; ) ( = } ; ) + 
766：public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + '#' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
766：public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + '#'  property    SetInjectionPoint sip  new SetInjectionPoint  propertyDescriptor   beanDefinition  addSetInjectionPoint  sip   

767：} ; ) ( . ; ) , ( = ; ) , ( . = ] [ } ; ) + + ) ( . . + " 
767：public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + '#' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + '#' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
767：public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + '#' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found:   beanDefinition  type  getName    '#'  methodName    BeanReferences   ref  referencesResolver  resolveReferenceFromValues  method  references   MethodInjectionPoint mip  new MethodInjectionPoint  method  ref   beanDefinition  addMethodInjectionPoint  mip   

768：} ; ) ( . } ; ) , , ) ( . ( = ] [ } ; ) ] [ + + 
768：public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + '#' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
768：public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( )  '#'  initMethodNames  i     initMethodPoints  i   new InitMethodPoint  md  getMethod    i  invocationStrategy    beanDefinition  addInitMethodPoints  initMethodPoints   

769：} ; ) ( . } ; ) ) ( . ( = ] [ } ; ) ] [ + + ) 
769：public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + '#' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
769：public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName (   '#'  destroyMethodNames  i     destroyMethodPoints  i   new DestroyMethodPoint  md  getMethod      beanDefinition  addDestroyMethodPoints  destroyMethodPoints   

770：} ; ) , ( . ; ) ) ( . , , ( = } ; 
770：public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
770：public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName )   ProviderDefinition providerDefinition  new ProviderDefinition  providerName  beanName  md  getMethod     providers  put  providerName  providerDefinition   

771：} ; ) , ( . ; ) ) ( . , 
771：public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , true ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
771：public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , true ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName  md  getMethod     providers  put  providerName  providerDefinition   

772：} ; ) } } ; 
772：public void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
772：public void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name )      

773：} } ; ) ) ( 
773：public void defineParameters ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
773：public void defineParameters ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue      

774：} ; } ; ) , , ( ; - ) ( 
774：public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = actionRequest . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( actionRequest , executionTime , result ) ; } return result ; }
774：public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = actionRequest . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis    startTime  printAfter  actionRequest  executionTime  result    return result  

775：} ; : ? > ; 
775：public static int resolveJavaVersion ( final int version ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = javaVersionNumber - 8 + 52 ; return version > platformVersion ? version : platformVersion ; }
775：public static int resolveJavaVersion ( final int version ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = javaVersionNumber - 8 + 52  return version  platformVersion  version  platformVersion  

776：} } ; ) , ( . { } 
776：public static void pushInt ( final MethodVisitor mv , final int value ) { if ( value <= 5 ) { mv . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , value ) ; } else { mv . visitIntInsn ( SIPUSH , value ) ; } }
776：public static void pushInt ( final MethodVisitor mv , final int value ) { if ( value <= 5 ) { mv . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , value ) ;  else  mv  visitIntInsn  SIPUSH  value    

777：} } ; ) + " 
777：public static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
777：public static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index:   argIndex    

778：} ; + . 
778：public static String adviceFieldName ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
778：public static String adviceFieldName ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames  fieldDivider  index  

779：} ; + . 
779：public static String adviceMethodName ( final String name , final int index ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + index ; }
779：public static String adviceMethodName ( final String name , final int index ) { return ProxettaNames . methodPrefix + name + ProxettaNames  methodDivider  index  

780：} } ; ) , , ( 
780：public static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
780：public static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument  mv  methodInfo  i    

781：} } ; ) , , 
781：public static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
781：public static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv  methodInfo  i    

782：} } ; ) , , 
782：public static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
782：public static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv  methodInfo  i    

783：} } ; ) , ( . : ; ; ) , ( . : ; ; ) 
783：public static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case 'V' : break ; case 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case 'J' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case 'F' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case 'D' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
783：public static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case 'V' : break ; case 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case 'J' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case 'F' : mv . visitVarInsn ( FLOAD , offset   break  case 'D'  mv  visitVarInsn  DLOAD  offset   break  default  mv  visitVarInsn  ALOAD  offset    

784：} } ; ) , ( . : ; ; ) , ( . : ; ; ) 
784：public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case 'V' : break ; case 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case 'J' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case 'F' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case 'D' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
784：public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case 'V' : break ; case 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case 'J' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case 'F' : mv . visitVarInsn ( FSTORE , offset   break  case 'D'  mv  visitVarInsn  DSTORE  offset   break  default  mv  visitVarInsn  ASTORE  offset    

785：} } ; ; ) ( . : ; ; ) ( . : ; ; ) ( . : ; 
785：public static void prepareReturnValue ( final MethodVisitor mv , final MethodInfo methodInfo , int varOffset ) { varOffset += methodInfo . getAllArgumentsSize ( ) ; switch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { case 'V' : mv . visitInsn ( ACONST_NULL ) ; break ; case 'B' : AsmUtil . valueOfByte ( mv ) ; break ; case 'C' : AsmUtil . valueOfCharacter ( mv ) ; break ; case 'S' : AsmUtil . valueOfShort ( mv ) ; break ; case 'I' : AsmUtil . valueOfInteger ( mv ) ; break ; case 'Z' : AsmUtil . valueOfBoolean ( mv ) ; break ; case 'J' : AsmUtil . valueOfLong ( mv ) ; break ; case 'F' : AsmUtil . valueOfFloat ( mv ) ; break ; case 'D' : AsmUtil . valueOfDouble ( mv ) ; break ; } }
785：public static void prepareReturnValue ( final MethodVisitor mv , final MethodInfo methodInfo , int varOffset ) { varOffset += methodInfo . getAllArgumentsSize ( ) ; switch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { case 'V' : mv . visitInsn ( ACONST_NULL ) ; break ; case 'B' : AsmUtil . valueOfByte ( mv ) ; break ; case 'C' : AsmUtil . valueOfCharacter ( mv ) ; break ; case 'S' : AsmUtil . valueOfShort ( mv ) ; break ; case 'I' : AsmUtil . valueOfInteger ( mv ) ; break ; case 'Z' : AsmUtil . valueOfBoolean ( mv ) ; break  case 'J'  AsmUtil  valueOfLong  mv   break  case 'F'  AsmUtil  valueOfFloat  mv   break  case 'D'  AsmUtil  valueOfDouble  mv   break   

786：} ; ) ( . ) ( . ) 
786：public static String createMethodSignaturesKey ( final int access , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
786：public static String createMethodSignaturesKey ( final int access , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH   append  methodName   toString    

787：} ; ) ) ( . , ( . } ; ; ) , ( . { ) . == ( } ; ; ) 
787：public static void newArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
787：public static void newArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN   return   if  componentType  char  class   mv  visitIntInsn  NEWARRAY  T_CHAR   return   mv  visitTypeInsn  ANEWARRAY  AsmUtil  typeToSignature  componentType    

788：} ; ) ( . } ; ; ) ( . { ) . == ( } ; ; ) 
788：public static void storeIntoArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
788：public static void storeIntoArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE   return   if  componentType  char  class   mv  visitInsn  CASTORE   return   mv  visitInsn  AASTORE   

789：} ; } ; = } 
789：public static String extractEncoding ( final String contentType , String defaultEncoding ) { String encoding = extractEncoding ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
789：public static String extractEncoding ( final String contentType , String defaultEncoding ) { String encoding = extractEncoding ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ;  encoding  defaultEncoding   return encoding  

790：} ; } ; { ) > . 
790：public static boolean isEmptyFlags ( Flags flags ) { if ( flags == null ) return true ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return false ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return false ; } return true ; }
790：public static boolean isEmptyFlags ( Flags flags ) { if ( flags == null ) return true ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return false ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags  length  0   return false   return true  

791：} ; ) ( . ) + ( 
791：public static String resolveAuthBearerToken ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return header . substring ( ndx + 7 ) . trim ( ) ; }
791：public static String resolveAuthBearerToken ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return header . substring  ndx  7   trim    

792：} ; ) . ( . 
792：public static void requireAuthentication ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + '\"' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
792：public static void requireAuthentication ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + '\"' ) ; resp  sendError  HttpServletResponse  SC_UNAUTHORIZED   

793：} ; ) ) ( . ) ( , , 
793：public static void prepareDownload ( final HttpServletResponse response , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; }
793：public static void prepareDownload ( final HttpServletResponse response , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( response , file . getAbsolutePath ( )  mimeType   int  file  length     

794：} } ; ) + + + , ( . ; ) ( . = ; 
794：public static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( extension ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; } if ( fileName != null ) { String name = FileNameUtil . getName ( fileName ) ; String encodedFileName = URLCoder . encode ( name ) ; response . setHeader ( CONTENT_DISPOSITION , "attachment;filename=\"" + name + "\";filename*=utf8''" + encodedFileName ) ; } }
794：public static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( extension ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; } if ( fileName != null ) { String name = FileNameUtil . getName ( fileName )  String encodedFileName  URLCoder  encode  name   response  setHeader  CONTENT_DISPOSITION  "attachment;filename=\""  name  "\";filename*=utf8''"  encodedFileName    

795：} ; ) ] [ ( . } ; { ) ) 
795：public static Cookie [ ] getAllCookies ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList < > ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
795：public static Cookie [ ] getAllCookies ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList < > ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty (    return null   return list  toArray  new Cookie  0    

796：} ; ) ( . 
796：public static String readRequestBodyFromReader ( final HttpServletRequest request ) throws IOException { BufferedReader buff = request . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }
796：public static String readRequestBodyFromReader ( final HttpServletRequest request ) throws IOException { BufferedReader buff = request . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out  toString    

797：} ; ) ( . } ; ) ( . { } } ; . 
797：public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
797：public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool  EMPTY    finally  StreamUtil  close  bufferedReader    return charArrayWriter  toString    

798：} ; ) , ( . ; ) 
798：public static void storeContextPath ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
798：public static void storeContextPath ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext (   servletContext  setAttribute  contextPathVariableName  ctxPath   

799：} ; ) , 
799：public static void storeContextPath ( final ServletContext servletContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
799：public static void storeContextPath ( final ServletContext servletContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName  ctxPath   

800：} ; } } ; { ) ) ( 
800：public boolean isGetParameter ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + '=' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , '&' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return true ; } } return false ; }
800：public boolean isGetParameter ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + '=' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , '&' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith  name    return true    return false  

801：} ; } } ; { ) ) == ( && ) ( ( } ; 
801：public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
801：public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue   if   ignoreEmptyRequestParams    emptyCount  total    return null    return paramValues  

802：} } ; ) : ] [ ? == . , ( . ; ) ( . = ] [ } ; { ) != ) ( . 
802：public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; } if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; } }
802：public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; } if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest  getAttribute  paramName   null   continue   FileUpload   paramValues  multipartRequest  getFiles  paramName   servletRequest  setAttribute  paramName  paramValues  length  1  paramValues  0   paramValues    

803：} } ; ) , ( 
803：public static void invokeBody ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
803：public static void invokeBody ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException  "Tag body failed"  ioex    

804：} ; ) ( . 
804：public static char [ ] renderBody ( final JspFragment body ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( body , writer ) ; return writer . toCharArray ( ) ; }
804：public static char [ ] renderBody ( final JspFragment body ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( body , writer ) ; return writer  toCharArray    

805：} ; ) ( 
805：public static String renderBodyToString ( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String ( result ) ; }
805：public static String renderBodyToString ( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String  result   

806：} } } ; ) , + " ( { 
806：public void invokeInitMethods ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
806：public void invokeInitMethods ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex )  throw new PetiteException  "Invalid init method:   initMethod  ex     

807：} } } ; ) , . + 
807：public void callDestroyMethods ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
807：public void callDestroyMethods ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: "  destroyMethodPoint  method  ex     

808：} ; } ; ) , . . + " + ) ( . . + ( { ) ( } ; ) ( . . . = { 
808：public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ; if ( beanDefinition . wiringMode != WiringMode . NONE ) { for ( int i = 0 ; i < paramNo ; i ++ ) { args [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; if ( args [ i ] == null ) { if ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) { throw new PetiteException ( "Wiring constructor failed. References '" + beanDefinition . ctor . references [ i ] + "' not found for constructor: " + beanDefinition . ctor . constructor ) ; } } } } final Object bean ; try { bean = beanDefinition . ctor . constructor . newInstance ( args ) ; } catch ( Exception ex ) { throw new PetiteException ( "Failed to create new bean instance '" + beanDefinition . type . getName ( ) + "' using constructor: " + beanDefinition . ctor . constructor , ex ) ; } return bean ; }
808：public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ; if ( beanDefinition . wiringMode != WiringMode . NONE ) { for ( int i = 0 ; i < paramNo ; i ++ ) { args [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; if ( args [ i ] == null ) { if ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) { throw new PetiteException ( "Wiring constructor failed. References '" + beanDefinition . ctor . references [ i ] + "' not found for constructor: " + beanDefinition . ctor . constructor ) ; } } } } final Object bean ; try  bean  beanDefinition  ctor  constructor  newInstance  args    catch  Exception ex   throw new PetiteException  "Failed to create new bean instance '"  beanDefinition  type  getName    "' using constructor:   beanDefinition  ctor  constructor  ex    return bean  

809：} } } ; ) , . + " + . + ( { ) ( } ; ) , . , ( . 
809：public void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) { final int len = beanDefinition . name . length ( ) + 1 ; for ( final String param : beanDefinition . params ) { final Object value = paramManager . get ( param ) ; final String destination = param . substring ( len ) ; try { BeanUtil . declared . setProperty ( bean , destination , value ) ; } catch ( Exception ex ) { throw new PetiteException ( "Unable to set parameter: '" + param + "' to bean: " + beanDefinition . name , ex ) ; } } } for ( final ValueInjectionPoint pip : beanDefinition . values ) { final String value = paramManager . parseKeyTemplate ( pip . valueTemplate ) ; try { BeanUtil . declared . setProperty ( bean , pip . property , value ) ; } catch ( Exception ex ) { throw new PetiteException ( "Unable to set value for: '" + pip . valueTemplate + "' to bean: " + beanDefinition . name , ex ) ; } } }
809：public void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) { final int len = beanDefinition . name . length ( ) + 1 ; for ( final String param : beanDefinition . params ) { final Object value = paramManager . get ( param ) ; final String destination = param . substring ( len ) ; try { BeanUtil . declared . setProperty ( bean , destination , value ) ; } catch ( Exception ex ) { throw new PetiteException ( "Unable to set parameter: '" + param + "' to bean: " + beanDefinition . name , ex ) ; } } } for ( final ValueInjectionPoint pip : beanDefinition . values ) { final String value = paramManager . parseKeyTemplate ( pip . valueTemplate ) ; try { BeanUtil . declared  setProperty  bean  pip  property  value    catch  Exception ex   throw new PetiteException  "Unable to set value for: '"  pip  valueTemplate  "' to bean:   beanDefinition  name  ex     

810：} ; { ) 
810：@ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest servletRequest , final String actionPath , final String httpMethod ) { return actionPath ; }
810：@ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest servletRequest , final String actionPath , final String httpMethod   return actionPath  

811：} ; ) , ( . ; ) 
811：public void addHeader ( final String name , final String value ) { List < String > valuesList = super . getAll ( name ) ; if ( valuesList . isEmpty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; valuesList . add ( value ) ; super . addAll ( name , valuesList ) ; }
811：public void addHeader ( final String name , final String value ) { List < String > valuesList = super . getAll ( name ) ; if ( valuesList . isEmpty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; valuesList . add ( value   super  addAll  name  valuesList   

812：} ; ) , ( . ; = } ; = . { } ; 
812：protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ; if ( first == null ) { first = propsEntry ; } else { last . next = propsEntry ; } last = propsEntry ; map . put ( key , propsEntry ) ; }
812：protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ; if ( first == null ) { first = propsEntry   else  last  next  propsEntry   last  propsEntry  map  put  key  propsEntry   

813：} ; ) , 
813：public void putBaseProperty ( final String key , final String value , final boolean append ) { put ( null , baseProperties , key , value , append ) ; }
813：public void putBaseProperty ( final String key , final String value , final boolean append ) { put ( null , baseProperties , key , value  append   

814：} ; ) , , , , 
814：public void putProfileProperty ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap < > ( ) ) ; put ( profile , map , key , value , append ) ; }
814：public void putProfileProperty ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap < > ( ) ) ; put ( profile  map  key  value  append   

815：} ; ) ( . } 
815：public PropsEntry getProfileProperty ( final String profile , final String key ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( key ) ; }
815：public PropsEntry getProfileProperty ( final String profile , final String key ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; if ( profileMap == null ) { return null ;  return profileMap  get  key   

816：} ; } ; = } } ; { ) == ) ( . ( { ) ( } ; { ) ) ( . ( ; ) , ( . = 
816：public String resolveMacros ( String value , final String ... profiles ) { StringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; stringTemplateParser . setResolveEscapes ( false ) ; if ( ! ignoreMissingMacros ) { stringTemplateParser . setReplaceMissingKey ( false ) ; } else { stringTemplateParser . setReplaceMissingKey ( true ) ; stringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; } final Function < String , String > macroResolver = macroName -> { String [ ] lookupProfiles = profiles ; int leftIndex = macroName . indexOf ( '<' ) ; if ( leftIndex != - 1 ) { int rightIndex = macroName . indexOf ( '>' ) ; String profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; macroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; lookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; StringUtil . trimAll ( lookupProfiles ) ; } return lookupValue ( macroName , lookupProfiles ) ; } ; int loopCount = 0 ; while ( loopCount ++ < MAX_INNER_MACROS ) { final String newValue = stringTemplateParser . parse ( value , macroResolver ) ; if ( newValue . equals ( value ) ) { break ; } if ( skipEmptyProps ) { if ( newValue . length ( ) == 0 ) { return null ; } } value = newValue ; } return value ; }
816：public String resolveMacros ( String value , final String ... profiles ) { StringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; stringTemplateParser . setResolveEscapes ( false ) ; if ( ! ignoreMissingMacros ) { stringTemplateParser . setReplaceMissingKey ( false ) ; } else { stringTemplateParser . setReplaceMissingKey ( true ) ; stringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; } final Function < String , String > macroResolver = macroName -> { String [ ] lookupProfiles = profiles ; int leftIndex = macroName . indexOf ( '<' ) ; if ( leftIndex != - 1 ) { int rightIndex = macroName . indexOf ( '>' ) ; String profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; macroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; lookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; StringUtil . trimAll ( lookupProfiles ) ; } return lookupValue ( macroName , lookupProfiles ) ; } ; int loopCount = 0 ; while ( loopCount ++ < MAX_INNER_MACROS ) { final String newValue  stringTemplateParser  parse  value  macroResolver   if  newValue  equals  value    break   if  skipEmptyProps   if  newValue  length    0   return null    value  newValue   return value  

817：} ; ; ) , , , . , ( } } } ; ) , ( . = } 
817：public Map extract ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( target == null ) { target = new HashMap ( ) ; } if ( prefix != null ) { if ( ! StringUtil . endsWithChar ( prefix , '.' ) ) { prefix += StringPool . DOT ; } } if ( profiles != null ) { for ( String profile : profiles ) { while ( true ) { final Map < String , PropsEntry > map = this . profileProperties . get ( profile ) ; if ( map != null ) { extractMap ( target , map , profiles , wildcardPatterns , prefix ) ; } final int ndx = profile . lastIndexOf ( '.' ) ; if ( ndx == - 1 ) { break ; } profile = profile . substring ( 0 , ndx ) ; } } } extractMap ( target , this . baseProperties , profiles , wildcardPatterns , prefix ) ; return target ; }
817：public Map extract ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( target == null ) { target = new HashMap ( ) ; } if ( prefix != null ) { if ( ! StringUtil . endsWithChar ( prefix , '.' ) ) { prefix += StringPool . DOT ; } } if ( profiles != null ) { for ( String profile : profiles ) { while ( true ) { final Map < String , PropsEntry > map = this . profileProperties . get ( profile ) ; if ( map != null ) { extractMap ( target , map , profiles , wildcardPatterns , prefix ) ; } final int ndx = profile . lastIndexOf ( '.' ) ; if ( ndx == - 1 ) { break ;  profile  profile  substring  0  ndx      extractMap  target  this  baseProperties  profiles  wildcardPatterns  prefix   return target  

818：} ; ; = ] [ } ; . % 
818：private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
818：private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 )  data  length   offp  0   off  return word  

819：} ; ) ( . ; ) ) - * . , ( ( . ) ) . , ( ( . ) ( . ) ( . } ; ) ( { ) > ( } ; ) ( . { ) < ( ; ) 
819：public static String hashpw ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != '$' || salt . charAt ( 1 ) != '2' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == '$' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != 'a' || salt . charAt ( 3 ) != '$' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; } if ( salt . charAt ( off + 2 ) > '$' ) { throw new IllegalArgumentException ( "Missing salt rounds" ) ; } rounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; real_salt = salt . substring ( off + 3 , off + 25 ) ; try { passwordb = ( password + ( minor >= 'a' ? "\000" : "" ) ) . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { throw new AssertionError ( "UTF-8 is not supported" ) ; } saltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; B = new BCrypt ( ) ; hashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; rs . append ( "$2" ) ; if ( minor >= 'a' ) { rs . append ( minor ) ; } rs . append ( '$' ) ; if ( rounds < 10 ) { rs . append ( '0' ) ; } if ( rounds > 30 ) { throw new IllegalArgumentException ( "rounds exceeds maximum (30)" ) ; } rs . append ( rounds ) . append ( '$' ) . append ( encode_base64 ( saltb , saltb . length ) ) . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * 4 - 1 ) ) ; return rs . toString ( ) ; }
819：public static String hashpw ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != '$' || salt . charAt ( 1 ) != '2' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == '$' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != 'a' || salt . charAt ( 3 ) != '$' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; } if ( salt . charAt ( off + 2 ) > '$' ) { throw new IllegalArgumentException ( "Missing salt rounds" ) ; } rounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; real_salt = salt . substring ( off + 3 , off + 25 ) ; try { passwordb = ( password + ( minor >= 'a' ? "\000" : "" ) ) . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { throw new AssertionError ( "UTF-8 is not supported" ) ; } saltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; B = new BCrypt ( ) ; hashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; rs . append ( "$2" ) ; if ( minor >= 'a' ) { rs . append ( minor ) ; } rs . append ( '$'   if  rounds  10   rs  append  '0'    if  rounds  30   throw new IllegalArgumentException  "rounds exceeds maximum (30)"    rs  append  rounds   append  '$'   append  encode_base64  saltb  saltb  length    append  encode_base64  hashed  bf_crypt_ciphertext  length  4  1    return rs  toString    

820：} ; == } ; ] [ ^ ] [ { ) ++ ; . < 
820：public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return false ; } if ( hashed_bytes . length != try_bytes . length ) { return false ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
820：public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return false ; } if ( hashed_bytes . length != try_bytes . length ) { return false ; } byte ret = 0 ; for ( int i = 0 ; i  try_bytes  length  i    ret |= hashed_bytes  i   try_bytes  i    return ret  0  

821：} ; } ; ++ ; 
821：public int copyAll ( final OutputStream out ) throws IOException { int count = 0 ; while ( true ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }
821：public int copyAll ( final OutputStream out ) throws IOException { int count = 0 ; while ( true ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b )  count    return count  

822：} ; } } ; { ) == 
822：public int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { int count = 0 ; while ( true ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
822：public int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { int count = 0 ; while ( true ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count  maxBytes   return count    return count  

823：} ; ) , , , , , , , , , ( ; ) ( . = > ? < ; ) ( 
823：public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ; ActionInterceptor [ ] actionInterceptors = parseActionInterceptors ( actionClass , actionMethod , actionConfig ) ; ActionFilter [ ] actionFilters = parseActionFilters ( actionClass , actionMethod , actionConfig ) ; if ( actionDefinition == null ) { actionDefinition = parseActionDefinition ( actionClass , actionMethod ) ; } detectAndRegisterAlias ( annotationValues , actionDefinition ) ; final boolean async = parseMethodAsyncFlag ( actionMethod ) ; final boolean auth = parseMethodAuthFlag ( actionMethod ) ; final Class < ? extends ActionResult > actionResult = parseActionResult ( actionMethod ) ; final Class < ? extends ActionResult > defaultActionResult = actionConfig . getActionResult ( ) ; return createActionRuntime ( null , actionClass , actionMethod , actionResult , defaultActionResult , actionFilters , actionInterceptors , actionDefinition , async , auth ) ; }
823：public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ; ActionInterceptor [ ] actionInterceptors = parseActionInterceptors ( actionClass , actionMethod , actionConfig ) ; ActionFilter [ ] actionFilters = parseActionFilters ( actionClass , actionMethod , actionConfig ) ; if ( actionDefinition == null ) { actionDefinition = parseActionDefinition ( actionClass , actionMethod ) ; } detectAndRegisterAlias ( annotationValues , actionDefinition ) ; final boolean async = parseMethodAsyncFlag ( actionMethod ) ; final boolean auth = parseMethodAuthFlag ( actionMethod ) ; final Class < ? extends ActionResult > actionResult = parseActionResult  actionMethod   final Class   extends ActionResult  defaultActionResult  actionConfig  getActionResult    return createActionRuntime  null  actionClass  actionMethod  actionResult  defaultActionResult  actionFilters  actionInterceptors  actionDefinition  async  auth   

824：} ; ) ( . } ; 
824：protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > annotationType ; if ( annotationValues == null ) { annotationType = Action . class ; } else { annotationType = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
824：protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > annotationType ; if ( annotationValues == null ) { annotationType = Action . class ; } else { annotationType = annotationValues . annotationType ( )   return actionConfigManager  lookup  annotationType   

825：} } ; ) , ( . ; 
825：protected void detectAndRegisterAlias ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( annotationValues ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
825：protected void detectAndRegisterAlias ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( annotationValues ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH )  actionsManager  registerPathAlias  alias  aliasPath    

826：} ; } } ; = { ) == . 
826：protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
826：protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result  length  0   result  null    return result  

827：} ; } } ; = { ) == 
827：protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
827：protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length  0   result  null    return result  

828：} ; ) ) . , ( . , ) , ( . ( . } ; ) , ( . { ) == ( ; ) ( . = } } ; 
828：protected String [ ] readPackageActionPath ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ; String packageActionPathFromAnnotation ; mainloop : while ( true ) { MadvocAction madvocActionAnnotation = actionPackage . getAnnotation ( MadvocAction . class ) ; packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation . value ( ) . trim ( ) : null ; if ( StringUtil . isEmpty ( packageActionPathFromAnnotation ) ) { packageActionPathFromAnnotation = null ; } if ( packageActionPathFromAnnotation == null ) { String newPackage = actionPackage . getName ( ) ; actionPackage = null ; while ( actionPackage == null ) { final int ndx = newPackage . lastIndexOf ( '.' ) ; if ( ndx == - 1 ) { break mainloop ; } newPackage = newPackage . substring ( 0 , ndx ) ; actionPackage = Packages . of ( actionClass . getClassLoader ( ) , newPackage ) ; } } else { rootPackages . addRootPackage ( actionPackage . getName ( ) , packageActionPathFromAnnotation ) ; break ; } } String packagePath = rootPackages . findPackagePathForActionPackage ( actionPackageName ) ; if ( packagePath == null ) { return ArraysUtil . array ( null , null ) ; } return ArraysUtil . array ( StringUtil . stripChar ( packagePath , '/' ) , StringUtil . surround ( packagePath , StringPool . SLASH ) ) ; }
828：protected String [ ] readPackageActionPath ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ; String packageActionPathFromAnnotation ; mainloop : while ( true ) { MadvocAction madvocActionAnnotation = actionPackage . getAnnotation ( MadvocAction . class ) ; packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation . value ( ) . trim ( ) : null ; if ( StringUtil . isEmpty ( packageActionPathFromAnnotation ) ) { packageActionPathFromAnnotation = null ; } if ( packageActionPathFromAnnotation == null ) { String newPackage = actionPackage . getName ( ) ; actionPackage = null ; while ( actionPackage == null ) { final int ndx = newPackage . lastIndexOf ( '.' ) ; if ( ndx == - 1 ) { break mainloop ; } newPackage = newPackage . substring ( 0 , ndx ) ; actionPackage = Packages . of ( actionClass . getClassLoader ( ) , newPackage ) ; } } else { rootPackages . addRootPackage ( actionPackage . getName ( ) , packageActionPathFromAnnotation ) ; break    String packagePath  rootPackages  findPackagePathForActionPackage  actionPackageName   if  packagePath  null   return ArraysUtil  array  null  null    return ArraysUtil  array  StringUtil  stripChar  packagePath  '/'   StringUtil  surround  packagePath  StringPool  SLASH    

829：} ; ) , ( . } } ; ; = { ) ) ( 
829：protected String [ ] readMethodActionPath ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) { String methodActionPath = annotationValues != null ? annotationValues . value ( ) : null ; if ( methodActionPath == null ) { methodActionPath = methodName ; } else { if ( methodActionPath . equals ( Action . NONE ) ) { return ArraysUtil . array ( null , null ) ; } } for ( String path : actionConfig . getActionMethodNames ( ) ) { if ( methodActionPath . equals ( path ) ) { methodActionPath = null ; break ; } } return ArraysUtil . array ( methodName , methodActionPath ) ; }
829：protected String [ ] readMethodActionPath ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) { String methodActionPath = annotationValues != null ? annotationValues . value ( ) : null ; if ( methodActionPath == null ) { methodActionPath = methodName ; } else { if ( methodActionPath . equals ( Action . NONE ) ) { return ArraysUtil . array ( null , null ) ; } } for ( String path : actionConfig . getActionMethodNames ( ) ) { if ( methodActionPath . equals  path    methodActionPath  null  break    return ArraysUtil  array  methodName  methodActionPath   

830：} ; } ; ) 
830：protected String parseMethodAlias ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }
830：protected String parseMethodAlias ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias (    return alias  

831：} ; ) , , , , , , , , , , , ( } ; ) , , ) ( . , , ] [ ( = ] [ } } ; ; ) ) ( . ) ) ( ( ( . 
831：public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; final Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; final MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; final Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; String [ ] methodParamNames = null ; for ( int ndx = 0 ; ndx < paramTypes . length ; ndx ++ ) { Class paramType = paramTypes [ ndx ] ; if ( methodParamNames == null ) { methodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; } final String paramName = methodParamNames [ ndx ] ; final Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; final ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; MapperFunction mapperFunction = null ; for ( final Annotation annotation : parameterAnnotations ) { if ( annotation instanceof Mapper ) { mapperFunction = MapperFunctionInstances . get ( ) . lookup ( ( ( Mapper ) annotation ) . value ( ) ) ; break ; } } params [ ndx ] = new MethodParam ( paramTypes [ ndx ] , paramName , scopeDataInspector . detectAnnotationType ( parameterAnnotations ) , paramsScopeData , mapperFunction ) ; } return new ActionRuntime ( null , actionClass , actionClassMethod , filters , interceptors , actionDefinition , actionResult , defaultActionResult , async , auth , scopeData , params ) ; }
831：public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; final Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; final MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; final Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; String [ ] methodParamNames = null ; for ( int ndx = 0 ; ndx < paramTypes . length ; ndx ++ ) { Class paramType = paramTypes [ ndx ] ; if ( methodParamNames == null ) { methodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; } final String paramName = methodParamNames [ ndx ] ; final Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; final ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; MapperFunction mapperFunction = null ; for ( final Annotation annotation : parameterAnnotations ) { if ( annotation instanceof Mapper ) { mapperFunction = MapperFunctionInstances . get ( )  lookup    Mapper  annotation   value     break    params  ndx   new MethodParam  paramTypes  ndx   paramName  scopeDataInspector  detectAnnotationType  parameterAnnotations   paramsScopeData  mapperFunction    return new ActionRuntime  null  actionClass  actionClassMethod  filters  interceptors  actionDefinition  actionResult  defaultActionResult  async  auth  scopeData  params   

832：} } } ; ) . ( . ; ) ( 
832：protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
832：protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset    response  setStatus  HttpServletResponse  SC_NOT_MODIFIED     

833：} } ; ) ( { ) ( } ; ) ( ; ) 
833：public static < T > T applyAdvice ( final Class < T > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) { adviceClass = PROXY_PROXETTA . proxy ( ) . setTarget ( targetClass ) . define ( ) ; cache . put ( targetClass , adviceClass ) ; } try { Object advice = ClassUtil . newInstance ( adviceClass ) ; Field field = adviceClass . getField ( "$ target$0" ) ; field . set ( advice , targetClass ) ; return ( T ) advice ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
833：public static < T > T applyAdvice ( final Class < T > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) { adviceClass = PROXY_PROXETTA . proxy ( ) . setTarget ( targetClass ) . define ( ) ; cache . put ( targetClass , adviceClass ) ; } try { Object advice = ClassUtil . newInstance ( adviceClass ) ; Field field = adviceClass . getField ( "$ target$0" ) ; field . set ( advice , targetClass   return  T  advice   catch  Exception ex   throw new ProxettaException  ex    

834：} } ; ) ( { ) ( 
834：public static void injectTargetIntoProxy ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$ target$0" ) ; field . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
834：public static void injectTargetIntoProxy ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( "$ target$0" ) ; field . set ( proxy , target ) ; } catch  Exception ex   throw new ProxettaException  ex    

835：} ; } ; 
835：public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , visible ) ; } return null ; }
835：public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , visible )   return null  

836：} ; ] [ } ; { 
836：public String resolveRealName ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
836：public String resolveRealName ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 )  return jsonName   return realNames  jsonIndex   

837：} ; ] [ } ; { 
837：public String resolveJsonName ( final String realName ) { if ( realNames == null ) { return realName ; } int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; if ( realIndex == - 1 ) { return realName ; } return jsonNames [ realIndex ] ; }
837：public String resolveJsonName ( final String realName ) { if ( realNames == null ) { return realName ; } int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; if ( realIndex == - 1 )  return realName   return jsonNames  realIndex   

838：} ; } } ; ) , ( . ; 
838：public TypeData lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
838：public TypeData lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type )  typeDataMap  put  type  typeData     return typeData  

839：} ; } ; ) , ( 
839：protected TypeData _lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } return typeData ; }
839：protected TypeData _lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put  type  typeData    return typeData  

840：} ; } } ; ) ( { ) != ) ( . ( { ) 
840：protected TypeData findSubclassTypeData ( final Class type ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( type . getAnnotation ( defaultAnnotation ) != null ) { return null ; } ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; Class [ ] superClasses = cd . getAllSuperclasses ( ) ; for ( Class superClass : superClasses ) { if ( superClass . getAnnotation ( defaultAnnotation ) != null ) { return _lookupTypeData ( superClass ) ; } } Class [ ] interfaces = cd . getAllInterfaces ( ) ; for ( Class interfaze : interfaces ) { if ( interfaze . getAnnotation ( defaultAnnotation ) != null ) { return _lookupTypeData ( interfaze ) ; } } return null ; }
840：protected TypeData findSubclassTypeData ( final Class type ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( type . getAnnotation ( defaultAnnotation ) != null ) { return null ; } ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; Class [ ] superClasses = cd . getAllSuperclasses ( ) ; for ( Class superClass : superClasses ) { if ( superClass . getAnnotation ( defaultAnnotation ) != null ) { return _lookupTypeData ( superClass ) ; } } Class [ ] interfaces = cd . getAllInterfaces ( ) ; for ( Class interfaze : interfaces   if  interfaze  getAnnotation  defaultAnnotation   null   return _lookupTypeData  interfaze     return null  

841：} ; ) ( 
841：public String resolveJsonName ( final Class type , final String name ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( name ) ; }
841：public String resolveJsonName ( final Class type , final String name ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName  name   

842：} ; ) ( . 
842：public String resolveRealName ( final Class type , final String jsonName ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveRealName ( jsonName ) ; }
842：public String resolveRealName ( final Class type , final String jsonName ) { TypeData typeData = lookupTypeData ( type ) ; return typeData  resolveRealName  jsonName   

843：} ; } ; ) 
843：public byte [ ] getFileContent ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
843：public byte [ ] getFileContent ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile    return null  

844：} } } ; ) ) & , , . , ( ( } ; ) ( . ) , ( . ; ; ) ( . = { ) > -- ( ; ) ( . ) , 
844：private void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { byte [ ] inputBytes = classReader . b ; int currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; for ( int i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) { String attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; if ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { bootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; break ; } currentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; } if ( bootstrapMethodCount > 0 ) { int bootstrapMethodsOffset = currentAttributeOffset + 8 ; int bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; bootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; bootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; int currentOffset = bootstrapMethodsOffset ; for ( int i = 0 ; i < bootstrapMethodCount ; i ++ ) { int offset = currentOffset - bootstrapMethodsOffset ; int bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; int numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; int hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; while ( numBootstrapArguments -- > 0 ) { int bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; hashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; } add ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; } } }
844：private void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { byte [ ] inputBytes = classReader . b ; int currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; for ( int i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) { String attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; if ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { bootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; break ; } currentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; } if ( bootstrapMethodCount > 0 ) { int bootstrapMethodsOffset = currentAttributeOffset + 8 ; int bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; bootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; bootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; int currentOffset = bootstrapMethodsOffset ; for ( int i = 0 ; i < bootstrapMethodCount ; i ++ ) { int offset = currentOffset - bootstrapMethodsOffset ; int bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; int numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; int hashCode = classReader . readConst ( bootstrapMethodRef  charBuffer   hashCode    while  numBootstrapArguments   0   int bootstrapArgument  classReader  readUnsignedShort  currentOffset   currentOffset += 2  hashCode ^= classReader  readConst  bootstrapArgument  charBuffer   hashCode     add  new Entry  i  Symbol  BOOTSTRAP_METHOD_TAG  offset  hashCode  0x7FFFFFFF      

845：} ; . ) ( 
845：int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
845：int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass  className   index  

846：} ; ) . 
846：void putConstantPool ( final ByteVector output ) { output . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
846：void putConstantPool ( final ByteVector output ) { output . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool  length   

847：} } ; ) . , , . 
847：void putBootstrapMethods ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
847：void putBootstrapMethods ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods  data  0  bootstrapMethods  length    

848：} ; ) , , 
848：Symbol addConstantFieldref ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }
848：Symbol addConstantFieldref ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner  name  descriptor   

849：} ; ) , , , ( 
849：Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }
849：Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference  tag  owner  name  descriptor   

850：} ; ) ) , , , , , , ++ ( ( ; ) ) 
850：private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
850：private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor    return put  new Entry  constantPoolCount   tag  owner  name  descriptor  0  hashCode    

851：} ; ) ) ) , 
851：private void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( index , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }
851：private void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( index , tag , owner , name , descriptor , 0 , hash ( tag , owner , name  descriptor     

852：} ; ) ) , , , ++ ( ( ; 
852：private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
852：private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value )  return put  new Entry  constantPoolCount   tag  value  hashCode    

853：} ; ) ) ) 
853：private void addConstantIntegerOrFloat ( final int index , final int tag , final int value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
853：private void addConstantIntegerOrFloat ( final int index , final int tag , final int value ) { add ( new Entry ( index , tag , value , hash ( tag , value     

854：} ; ) ) , , , ( ( ; ; ) 
854：private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }
854：private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value   constantPoolCount += 2  return put  new Entry  index  tag  value  hashCode    

855：} ; ) ) ) 
855：private void addConstantLongOrDouble ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
855：private void addConstantLongOrDouble ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value     

856：} ; . ) ) , , , , ++ ( ( ; ) ) ( 
856：int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
856：int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8  descriptor    return put  new Entry  constantPoolCount   tag  name  descriptor  hashCode    index  

857：} ; ) ) ) , , 
857：private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
857：private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag  name  descriptor     

858：} ; . ) ) , , . , ++ ( ( ; ) 
858：int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
858：int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value   return put  new Entry  constantPoolCount   Symbol  CONSTANT_UTF8_TAG  value  hashCode    index  

859：} ; ) ) ) , 
859：private void addConstantUtf8 ( final int index , final String value ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
859：private void addConstantUtf8 ( final int index , final String value ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG  value     

860：} ; ) ) , , , , , , ++ ( ( } ; ) . ) , , , ( , , 
860：Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } if ( referenceKind <= Opcodes . H_PUTSTATIC ) { constantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; } else { constantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; } return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
860：Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } if ( referenceKind <= Opcodes . H_PUTSTATIC ) { constantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; } else { constantPool . put112 ( tag  referenceKind  addConstantMethodref  owner  name  descriptor  isInterface   index    return put  new Entry  constantPoolCount   tag  owner  name  descriptor  referenceKind  hashCode    

861：} ; ) ) , , , , , 
861：private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
861：private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag  owner  name  descriptor  referenceKind  hashCode    

862：} ; ) . , , , . 
862：Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
862：Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol  CONSTANT_DYNAMIC_TAG  name  descriptor  bootstrapMethod  index   

863：} ; ) . , , , . 
863：Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
863：Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol  CONSTANT_INVOKE_DYNAMIC_TAG  name  descriptor  bootstrapMethod  index   

864：} ; ) ) , , , , , , ++ ( ( ; ) ) , 
864：private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
864：private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name  descriptor    return put  new Entry  constantPoolCount   tag  null  name  descriptor  bootstrapMethodIndex  hashCode    

865：} ; ) ) , , , , 
865：private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
865：private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null  name  descriptor  bootstrapMethodIndex  hashCode    

866：} ; ) ) , , , ++ ( ( ; ) 
866：private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
866：private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value )   return put  new Entry  constantPoolCount   tag  value  hashCode    

867：} ; ) ) ) 
867：private void addConstantUtf8Reference ( final int index , final int tag , final String value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
867：private void addConstantUtf8Reference ( final int index , final int tag , final String value ) { add ( new Entry ( index , tag , value , hash ( tag , value     

868：} ; ) , , ( ; } ; ) ( . { ) : ( ; ) ( . = ; - . = } ; 
868：Symbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; } for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { addConstant ( bootstrapMethodArgument ) ; } int bootstrapMethodOffset = bootstrapMethodsAttribute . length ; bootstrapMethodsAttribute . putShort ( addConstantMethodHandle ( bootstrapMethodHandle . getTag ( ) , bootstrapMethodHandle . getOwner ( ) , bootstrapMethodHandle . getName ( ) , bootstrapMethodHandle . getDesc ( ) , bootstrapMethodHandle . isInterface ( ) ) . index ) ; int numBootstrapArguments = bootstrapMethodArguments . length ; bootstrapMethodsAttribute . putShort ( numBootstrapArguments ) ; for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { bootstrapMethodsAttribute . putShort ( addConstant ( bootstrapMethodArgument ) . index ) ; } int bootstrapMethodlength = bootstrapMethodsAttribute . length - bootstrapMethodOffset ; int hashCode = bootstrapMethodHandle . hashCode ( ) ; for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { hashCode ^= bootstrapMethodArgument . hashCode ( ) ; } hashCode &= 0x7FFFFFFF ; return addBootstrapMethod ( bootstrapMethodOffset , bootstrapMethodlength , hashCode ) ; }
868：Symbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; } for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { addConstant ( bootstrapMethodArgument ) ; } int bootstrapMethodOffset = bootstrapMethodsAttribute . length ; bootstrapMethodsAttribute . putShort ( addConstantMethodHandle ( bootstrapMethodHandle . getTag ( ) , bootstrapMethodHandle . getOwner ( ) , bootstrapMethodHandle . getName ( ) , bootstrapMethodHandle . getDesc ( ) , bootstrapMethodHandle . isInterface ( ) ) . index ) ; int numBootstrapArguments = bootstrapMethodArguments . length ; bootstrapMethodsAttribute . putShort ( numBootstrapArguments ) ; for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { bootstrapMethodsAttribute . putShort ( addConstant ( bootstrapMethodArgument ) . index )   int bootstrapMethodlength  bootstrapMethodsAttribute  length  bootstrapMethodOffset  int hashCode  bootstrapMethodHandle  hashCode    for  Object bootstrapMethodArgument  bootstrapMethodArguments   hashCode ^= bootstrapMethodArgument  hashCode     hashCode &= 0x7FFFFFFF  return addBootstrapMethod  bootstrapMethodOffset  bootstrapMethodlength  hashCode   

869：} ; ; = . ) ) , , . , ( ( ; ) ) , ( . ( = ; 
869：int addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) { long data = typeTableIndex1 | ( ( ( long ) typeTableIndex2 ) << 32 ) ; int hashCode = hash ( Symbol . MERGED_TYPE_TAG , typeTableIndex1 + typeTableIndex2 ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . MERGED_TYPE_TAG && entry . hashCode == hashCode && entry . data == data ) { return entry . info ; } entry = entry . next ; } String type1 = typeTable [ typeTableIndex1 ] . value ; String type2 = typeTable [ typeTableIndex2 ] . value ; int commonSuperTypeIndex = addType ( classWriter . getCommonSuperClass ( type1 , type2 ) ) ; put ( new Entry ( typeCount , Symbol . MERGED_TYPE_TAG , data , hashCode ) ) . info = commonSuperTypeIndex ; return commonSuperTypeIndex ; }
869：int addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) { long data = typeTableIndex1 | ( ( ( long ) typeTableIndex2 ) << 32 ) ; int hashCode = hash ( Symbol . MERGED_TYPE_TAG , typeTableIndex1 + typeTableIndex2 ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . MERGED_TYPE_TAG && entry . hashCode == hashCode && entry . data == data ) { return entry . info ; } entry = entry . next ; } String type1 = typeTable [ typeTableIndex1 ] . value ; String type2 = typeTable [ typeTableIndex2 ] . value  int commonSuperTypeIndex  addType  classWriter  getCommonSuperClass  type1  type2    put  new Entry  typeCount  Symbol  MERGED_TYPE_TAG  data  hashCode    info  commonSuperTypeIndex  return commonSuperTypeIndex  

870：} ; - } ; . { ) . == ( } 
870：private int hash ( final String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char c = name . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= 'A' && c <= 'Z' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
870：private int hash ( final String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char c = name . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= 'A' && c <= 'Z' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ;  if  h  Integer  MIN_VALUE   return Integer  MAX_VALUE   return  h  

871：} ; ; = . 
871：public HttpMultiMap < V > clear ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
871：public HttpMultiMap < V > clear ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head  after  head  return this  

872：} ; } ; . = } ; ) ) ( 
872：public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList < > ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
872：public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList < > ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue      e  e  next   return values  

873：} ; } } ; ) ( { ) ( } ; ; . ] 
873：public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { public boolean hasNext ( ) { return e [ 0 ] != head ; } @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
873：public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { public boolean hasNext ( ) { return e [ 0 ] != head ; } @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0   after  return next   public void remove    throw new UnsupportedOperationException       

874：} ; } ; . = ; ) 
874：public List < Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > all = new LinkedList < > ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
874：public List < Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > all = new LinkedList < > ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e   e  e  after   return all  

875：} ; ) , ( . 
875：private void grow ( final int minCapacity ) { final int oldCapacity = buffer . length ; int newCapacity = oldCapacity << 1 ; if ( newCapacity - minCapacity < 0 ) { newCapacity = minCapacity + 512 ; } buffer = Arrays . copyOf ( buffer , newCapacity ) ; }
875：private void grow ( final int minCapacity ) { final int oldCapacity = buffer . length ; int newCapacity = oldCapacity << 1 ; if ( newCapacity - minCapacity < 0 ) { newCapacity = minCapacity + 512 ; } buffer = Arrays  copyOf  buffer  newCapacity   

876：} ; } ; ) ) 
876：public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( csq . charAt ( i ) ) ; } return this ; }
876：public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( csq . charAt ( i     return this  

877：} ; ) ( ; 
877：public AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ; return new AnnotationVisitorAdapter ( destAnn ) ; }
877：public AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible )  return new AnnotationVisitorAdapter  destAnn   

878：} } ; ) ( ; 
878：public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int p = 0 ; p < tmd . proxyData . length ; p ++ ) { tmd . selectCurrentProxy ( p ) ; createProxyMethod ( tmd ) ; } }
878：public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int p = 0 ; p < tmd . proxyData . length ; p ++ ) { tmd . selectCurrentProxy ( p )  createProxyMethod  tmd    

879：} ; ) , ) ( . . , ) ( . . , ) ( . 
879：protected void createFirstChainDelegate_Start ( ) { int access = msign . getAccessFlags ( ) ; if ( ! wd . allowFinalMethods ) { if ( ( access & AsmUtil . ACC_FINAL ) != 0 ) { throw new ProxettaException ( "Unable to create proxy for final method: " + msign + ". Remove final modifier or change the pointcut definition." ) ; } } tmd = new TargetMethodData ( msign , aspectList ) ; access &= ~ ACC_NATIVE ; access &= ~ ACC_ABSTRACT ; methodVisitor = wd . dest . visitMethod ( access , tmd . msign . getMethodName ( ) , tmd . msign . getDescription ( ) , tmd . msign . getAsmMethodSignature ( ) , null ) ; }
879：protected void createFirstChainDelegate_Start ( ) { int access = msign . getAccessFlags ( ) ; if ( ! wd . allowFinalMethods ) { if ( ( access & AsmUtil . ACC_FINAL ) != 0 ) { throw new ProxettaException ( "Unable to create proxy for final method: " + msign + ". Remove final modifier or change the pointcut definition." ) ; } } tmd = new TargetMethodData ( msign , aspectList ) ; access &= ~ ACC_NATIVE ; access &= ~ ACC_ABSTRACT ; methodVisitor = wd . dest . visitMethod ( access , tmd . msign  getMethodName    tmd  msign  getDescription    tmd  msign  getAsmMethodSignature    null   

880：} ; ) ( . ; ) , ( . ; ) , . , ( } ; 
880：protected void createFirstChainDelegate_Continue ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; } visitReturn ( methodVisitor , tmd . msign , false ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
880：protected void createFirstChainDelegate_Continue ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false )   visitReturn  methodVisitor  tmd  msign  false   methodVisitor  visitMaxs  0  0   methodVisitor  visitEnd    

881：} ; ) ) 
881：public static Path parse ( final String path ) { return path == null ? new Path ( ) : new Path ( StringUtil . splitc ( path , '.' ) ) ; }
881：public static Path parse ( final String path ) { return path == null ? new Path ( ) : new Path ( StringUtil . splitc ( path , '.'    

882：} ; } ; 
882：public Path push ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
882：public Path push ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field )   return this  

883：} ; ) , , ( . ; ) . . . , 
883：private void configureServletContext ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , true , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , true , contextPath ) ; }
883：private void configureServletContext ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , true , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc"  jodd  madvoc  MadvocServletFilter  class   filter  addMappingForUrlPatterns  madvocDispatcherTypes  true  contextPath   

884：} ; ) ( . 
884：public Object execute ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
884：public Object execute ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget  returnValue  next   

885：} ; } ; = . ; ) ) ) ( 
885：public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }
885：public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName      this  allFields  allFields   return allFields  

886：} ; ) , , , , ( . } ; ) , ) ] [ ( 
886：@ SuppressWarnings ( "unchecked" ) protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
886：@ SuppressWarnings ( "unchecked" ) protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , originalType , proxetta . getAspects  new ProxyAspect  0    consumer    return super  createBeanDefinitionForRegistration  name  type  scope  wiringMode  consumer   

887：} ; ) ) ( . , ( } ; ) ( : ; ; . = : ; ; . = 
887：public static DbTransactionMode convertToDbMode ( final JtxTransactionMode txMode ) { final int isolation ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; }
887：public static DbTransactionMode convertToDbMode ( final JtxTransactionMode txMode ) { final int isolation ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation  DbTransactionMode  ISOLATION_REPEATABLE_READ  break  case ISOLATION_SERIALIZABLE  isolation  DbTransactionMode  ISOLATION_SERIALIZABLE  break  default  throw new IllegalArgumentException     return new DbTransactionMode  isolation  txMode  isReadOnly     

888：} ; } } ; ) ( 
888：private Object readProperty ( final Object source , final PropertyDescriptor propertyDescriptor ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
888：private Object readProperty ( final Object source , final PropertyDescriptor propertyDescriptor ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException  ex     return null  

889：} } ; ) ) 
889：public void putAll ( final Map t ) { for ( Object o : t . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
889：public void putAll ( final Map t ) { for ( Object o : t . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue (     

890：} ; ; . ; 
890：public Buffer append ( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) { return buffer ; } list . addAll ( buffer . list ) ; last = buffer . last ; size += buffer . size ; return this ; }
890：public Buffer append ( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) { return buffer ; } list . addAll ( buffer . list ) ; last = buffer . last  size += buffer  size  return this  

891：} } } } ; ) ( . { } ; ) . , 
891：public void writeTo ( final Writer writer ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] array = fastByteBuffer . toArray ( ) ; writer . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
891：public void writeTo ( final Writer writer ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] array = fastByteBuffer . toArray ( ) ; writer . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer  StringPool  ISO_8859_1    finally  StreamUtil  close  inputStream      

892：} } } } ; ) ( . { } ; 
892：public void writeTo ( final OutputStream out ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; out . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , out ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
892：public void writeTo ( final OutputStream out ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; out . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , out )   finally  StreamUtil  close  inputStream      

893：} } ; ) ( . { ) != ( } } } ; ) ( . { } } } ; ; ) ( . { ) >= ( ; ; 
893：public void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { final int size = size ( ) ; final int callbackSize = progressListener . callbackSize ( size ) ; int count = 0 ; int step = 0 ; progressListener . transferred ( count ) ; for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] bytes = fastByteBuffer . toArray ( ) ; int offset = 0 ; while ( offset < bytes . length ) { int chunk = callbackSize - step ; if ( offset + chunk > bytes . length ) { chunk = bytes . length - offset ; } out . write ( bytes , offset , chunk ) ; offset += chunk ; step += chunk ; count += chunk ; if ( step >= callbackSize ) { progressListener . transferred ( count ) ; step -= callbackSize ; } } } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; int remaining = uploadable . getSize ( ) ; try { while ( remaining > 0 ) { int chunk = callbackSize - step ; if ( chunk > remaining ) { chunk = remaining ; } StreamUtil . copy ( inputStream , out , chunk ) ; remaining -= chunk ; step += chunk ; count += chunk ; if ( step >= callbackSize ) { progressListener . transferred ( count ) ; step -= callbackSize ; } } } finally { StreamUtil . close ( inputStream ) ; } } } if ( step != 0 ) { progressListener . transferred ( count ) ; } }
893：public void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { final int size = size ( ) ; final int callbackSize = progressListener . callbackSize ( size ) ; int count = 0 ; int step = 0 ; progressListener . transferred ( count ) ; for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] bytes = fastByteBuffer . toArray ( ) ; int offset = 0 ; while ( offset < bytes . length ) { int chunk = callbackSize - step ; if ( offset + chunk > bytes . length ) { chunk = bytes . length - offset ; } out . write ( bytes , offset , chunk ) ; offset += chunk ; step += chunk ; count += chunk ; if ( step >= callbackSize ) { progressListener . transferred ( count ) ; step -= callbackSize ; } } } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; int remaining = uploadable . getSize ( ) ; try { while ( remaining > 0 ) { int chunk = callbackSize - step ; if ( chunk > remaining ) { chunk = remaining ; } StreamUtil . copy ( inputStream , out , chunk ) ; remaining -= chunk ; step += chunk  count += chunk  if  step  callbackSize   progressListener  transferred  count   step -= callbackSize     finally  StreamUtil  close  inputStream      if  step  0   progressListener  transferred  count    

894：} ; ) ( 
894：public String getString ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
894：public String getString ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString    

895：} ; ) ( . } 
895：public Integer getInteger ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
895：public Integer getInteger ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ;  return number  intValue    

896：} ; ) ( . } 
896：public Long getLong ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
896：public Long getLong ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ;  return number  longValue    

897：} ; ) ( . } 
897：public Double getDouble ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
897：public Double getDouble ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ;  return number  doubleValue    

898：} ; ) ( . } 
898：public Float getFloat ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
898：public Float getFloat ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ;  return number  floatValue    

899：} ; } ; ) ) ( ( 
899：@ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T val = ( T ) map . get ( key ) ; if ( val instanceof Map ) { return ( T ) new JsonObject ( ( Map ) val ) ; } if ( val instanceof List ) { return ( T ) new JsonArray ( ( List ) val ) ; } return val ; }
899：@ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T val = ( T ) map . get ( key ) ; if ( val instanceof Map ) { return ( T ) new JsonObject ( ( Map ) val ) ; } if ( val instanceof List ) { return ( T ) new JsonArray   List  val    return val  

900：} ; ; ) 
900：public JsonObject put ( final String key , final String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; }
900：public JsonObject put ( final String key , final String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value   return this  

901：} } ; ) , + " ( { ) ( 
901：public void useFolder ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . folderName = folderName ; this . folder = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + folderName , msgexc ) ; } }
901：public void useFolder ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . folderName = folderName ; this . folder = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch  final MessagingException msgexc   throw new MailException  "Failed to connect to folder:   folderName  msgexc    

902：} } ; ) , ( { ) ( } ; } } ; ) ( . { ) ) . . ( . ( { ) ) ( . ! ( } ; ) ( . { ) != ( } } 
902：ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( filter == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( filter . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; } final ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; for ( int i = 0 ; i < messages . length ; i ++ ) { final Message msg = messages [ i ] ; emails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; if ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { emails [ i ] . flags ( flagsToSet ) ; msg . setFlags ( flagsToSet , true ) ; } if ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { emails [ i ] . flags ( ) . remove ( flagsToUnset ) ; msg . setFlags ( flagsToUnset , false ) ; } if ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) { msg . setFlag ( Flags . Flag . SEEN , false ) ; } } if ( processedMessageConsumer != null ) { processedMessageConsumer . accept ( messages ) ; } if ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { if ( flagsToSet . contains ( Flags . Flag . DELETED ) ) { folder . expunge ( ) ; } } return emails ; } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to fetch messages" , msgexc ) ; } }
902：ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( filter == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( filter . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; } final ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; for ( int i = 0 ; i < messages . length ; i ++ ) { final Message msg = messages [ i ] ; emails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; if ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { emails [ i ] . flags ( flagsToSet ) ; msg . setFlags ( flagsToSet , true ) ; } if ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { emails [ i ] . flags ( ) . remove ( flagsToUnset ) ; msg . setFlags ( flagsToUnset , false ) ; } if ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) { msg . setFlag ( Flags . Flag . SEEN , false ) ;   if  processedMessageConsumer  null   processedMessageConsumer  accept  messages    if   EmailUtil  isEmptyFlags  flagsToSet    if  flagsToSet  contains  Flags  Flag  DELETED    folder  expunge      return emails   catch  final MessagingException msgexc   throw new MailException  "Failed to fetch messages"  msgexc    

903：} } ; ) , ( { ) 
903：public void updateEmailFlags ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , true ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
903：public void updateEmailFlags ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , true ) ; } catch ( MessagingException mex   throw new MailException  "Failed to fetch messages"  mex    

904：} } } { 
904：protected void closeFolderIfOpened ( final Folder folder ) { if ( folder != null ) { try { folder . close ( true ) ; } catch ( final MessagingException ignore ) { } } }
904：protected void closeFolderIfOpened ( final Folder folder ) { if ( folder != null ) { try { folder . close ( true ) ; } catch ( final MessagingException ignore )    

905：} ; } ; . = 
905：DbQueryNamedParameter lookupNamedParameter ( final String name ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( name ) ) { return p ; } p = p . next ; } return null ; }
905：DbQueryNamedParameter lookupNamedParameter ( final String name ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( name ) ) { return p ; } p  p  next   return null  

906：} ; ) . 
906：protected String alias ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
906：protected String alias ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool  RIGHT_CHEV   

907：} ; == ; ) ( . 
907：protected boolean validateAction ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
907：protected boolean validateAction ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor  getViolations    return violations  null  

908：} ; ) ) 
908：protected void addViolation ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }
908：protected void addViolation ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue    

909：} ; } ; ) ( 
909：public RawData as ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
909：public RawData as ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType  mimeOrExtension    return this  

910：} ; ; ) ) 
910：public RawData downloadableAs ( final String downloadFileName ) { this . downloadFileName = downloadFileName ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( downloadFileName ) ) ; return this ; }
910：public RawData downloadableAs ( final String downloadFileName ) { this . downloadFileName = downloadFileName ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( downloadFileName    return this  

911：} ; ) ( 
911：protected T setTarget ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
911：protected T setTarget ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this    

912：} ; ) ( } ; ) , + " ( ; 
912：protected T setTarget ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
912：protected T setTarget ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream )  throw new ProxettaException  "Unable to get stream class name:   targetName  ioex    return _this    

913：} ; ) ( } ; ) , ) ( . + " 
913：public T setTarget ( final Class target ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + target . getName ( ) ) ; } targetClass = target ; targetClassName = target . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + target . getName ( ) , ioex ) ; } return _this ( ) ; }
913：public T setTarget ( final Class target ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + target . getName ( ) ) ; } targetClass = target ; targetClassName = target . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class:   target  getName    ioex    return _this    

914：} ; ) , ( . . = ; . = ; ) , ( = } ; ) ) ( 
914：protected void process ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; } final ClassReader classReader ; try { classReader = new ClassReader ( targetInputStream ) ; } catch ( IOException ioex ) { throw new ProxettaException ( "Error reading class input stream" , ioex ) ; } final TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader ( proxetta . getClassLoader ( ) ) ; classReader . accept ( targetClassInfoReader , 0 ) ; this . destClassWriter = new ClassWriter ( ClassWriter . COMPUTE_MAXS | ClassWriter . COMPUTE_FRAMES ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "processing: " + classReader . getClassName ( ) ) ; } WorkData wd = process ( classReader , targetClassInfoReader ) ; proxyApplied = wd . proxyApplied ; proxyClassName = wd . thisReference . replace ( '/' , '.' ) ; }
914：protected void process ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; } final ClassReader classReader ; try { classReader = new ClassReader ( targetInputStream ) ; } catch ( IOException ioex ) { throw new ProxettaException ( "Error reading class input stream" , ioex ) ; } final TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader ( proxetta . getClassLoader ( ) ) ; classReader . accept ( targetClassInfoReader , 0 ) ; this . destClassWriter = new ClassWriter ( ClassWriter . COMPUTE_MAXS | ClassWriter . COMPUTE_FRAMES ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "processing: " + classReader . getClassName      WorkData wd  process  classReader  targetClassInfoReader   proxyApplied  wd  proxyApplied  proxyClassName  wd  thisReference  replace  '/'  '.'   

915：} ; } ; ) ) ( . + " ( . { 
915：public byte [ ] create ( ) { process ( ) ; byte [ ] result = toByteArray ( ) ; dumpClassInDebugFolder ( result ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return result ; }
915：public byte [ ] create ( ) { process ( ) ; byte [ ] result = toByteArray ( ) ; dumpClassInDebugFolder ( result ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) )  log  debug  "Proxy created   StringUtil  toSafeString  targetClassName     return result  

916：} } ; ) , ( { ) ( } ; ) , , ) ( ( . ; ) ( ; ) ( = ] [ 
916：public Class define ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
916：public Class define ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte   bytes  toByteArray    dumpClassInDebugFolder  bytes   return DefineClass  of  getProxyClassName    bytes  classLoader    catch  Exception ex   throw new ProxettaException  "Class definition failed"  ex    

917：} } ; ) , ( 
917：public Object newInstance ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
917：public Object newInstance ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException  "Invalid Proxetta class"  ex    

918：} } ; ) , + " ( . { ) ( } ; ) , 
918：protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
918：protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file  bytes    catch  IOException ioex   log  warn  "Error writing class as   file  ioex    

919：} ; ) 
919：public T from ( final String personalName , final String from ) { return from ( new EmailAddress ( personalName , from ) ) ; }
919：public T from ( final String personalName , final String from ) { return from ( new EmailAddress ( personalName , from )   

920：} ; ) ( 
920：public T to ( final EmailAddress to ) { this . to = ArraysUtil . append ( this . to , to ) ; return _this ( ) ; }
920：public T to ( final EmailAddress to ) { this . to = ArraysUtil . append ( this . to , to ) ; return _this    

921：} ; ) 
921：public T to ( final String personalName , final String to ) { return to ( new EmailAddress ( personalName , to ) ) ; }
921：public T to ( final String personalName , final String to ) { return to ( new EmailAddress ( personalName , to )   

922：} ; ) ( 
922：public T replyTo ( final EmailAddress ... replyTo ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( replyTo ) ) ; return _this ( ) ; }
922：public T replyTo ( final EmailAddress ... replyTo ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( replyTo ) ) ; return _this    

923：} ; ) ( ; 
923：public T cc ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
923：public T cc ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) )  return _this    

924：} ; ) ) 
924：public T textMessage ( final String text , final String encoding ) { return message ( new EmailMessage ( text , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }
924：public T textMessage ( final String text , final String encoding ) { return message ( new EmailMessage ( text , MimeTypes . MIME_TEXT_PLAIN , encoding    

925：} ; ) ) 
925：public T htmlMessage ( final String html , final String encoding ) { return message ( new EmailMessage ( html , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
925：public T htmlMessage ( final String html , final String encoding ) { return message ( new EmailMessage ( html , MimeTypes . MIME_TEXT_HTML , encoding    

926：} ; ) 
926：public T header ( final String name , final String value ) { headers . put ( name , value ) ; return _this ( ) ; }
926：public T header ( final String name , final String value ) { headers . put ( name , value ) ; return _this (   

927：} ; } ; { ) == ( } { 
927：public static String get ( final String name , final String defaultValue ) { Objects . requireNonNull ( name ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( name ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return defaultValue ; } return value ; }
927：public static String get ( final String name , final String defaultValue ) { Objects . requireNonNull ( name ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( name ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore )   if  value  null   return defaultValue   return value  

928：} } ; : ; : : : : ; : 
928：public static boolean getBoolean ( final String name , final boolean defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return true ; case "false" : case "no" : case "0" : case "off" : return false ; default : return defaultValue ; } }
928：public static boolean getBoolean ( final String name , final boolean defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on"  return true  case "false"  case "no"  case "0"  case "off"  return false  default  return defaultValue   

929：} } ; { ) ( } 
929：public static long getInt ( final String name , final int defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
929：public static long getInt ( final String name , final int defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ;  catch  NumberFormatException nfex   return defaultValue   

930：} } ; { ) ( } 
930：public static long getLong ( final String name , final long defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
930：public static long getLong ( final String name , final long defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ;  catch  NumberFormatException nfex   return defaultValue   

931：} ; ) ( . } ; ) 
931：MethodParameter [ ] getResolvedParameters ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + '#' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
931：MethodParameter [ ] getResolvedParameters ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + '#' + methodName    return paramExtractor  getMethodParameters    

932：} ; ; ) ( . } ; ++ { ) ) ( . ( ; ) ( . } ; ) 
932：protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; } boolean include = true ; if ( value != null ) { include = jsonContext . matchIgnoredPropertyTypes ( value . getClass ( ) , false , include ) ; include = jsonContext . matchPathToQueries ( include ) ; } if ( ! include ) { currentPath . pop ( ) ; return count ; } if ( key == null ) { jsonContext . pushName ( null , count > 0 ) ; } else { jsonContext . pushName ( key . toString ( ) , count > 0 ) ; } jsonContext . serialize ( value ) ; if ( jsonContext . isNamePopped ( ) ) { count ++ ; } currentPath . pop ( ) ; return count ; }
932：protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; } boolean include = true ; if ( value != null ) { include = jsonContext . matchIgnoredPropertyTypes ( value . getClass ( ) , false , include ) ; include = jsonContext . matchPathToQueries ( include ) ; } if ( ! include ) { currentPath . pop ( ) ; return count ; } if ( key == null ) { jsonContext . pushName ( null , count > 0 ) ; } else { jsonContext . pushName ( key . toString ( ) , count > 0    jsonContext  serialize  value   if  jsonContext  isNamePopped     count    currentPath  pop    return count  

933：} ; } } ; ) ( 
933：protected String lookupAlias ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
933：protected String lookupAlias ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . getActionPath      return value  

934：} ; ) ( . } ; ) , - ( . { ) > ( } ; ++ } ; { ) != ) ( . ( { ) 
934：protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( '<' , i ) ; if ( ndx == - 1 ) { if ( i == 0 ) { String alias = lookupAlias ( value ) ; return ( alias != null ? alias : value ) ; } else { result . append ( value . substring ( i ) ) ; } break ; } result . append ( value . substring ( i , ndx ) ) ; ndx ++ ; int ndx2 = value . indexOf ( '>' , ndx ) ; String aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; String alias = lookupAlias ( aliasName ) ; if ( alias != null ) { result . append ( alias ) ; } else { if ( log . isWarnEnabled ( ) ) { log . warn ( "Alias not found: " + aliasName ) ; } } i = ndx2 + 1 ; } i = 0 ; len = result . length ( ) ; while ( i < len ) { if ( result . charAt ( i ) != '/' ) { break ; } i ++ ; } if ( i > 1 ) { return result . substring ( i - 1 , len ) ; } return result . toString ( ) ; }
934：protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( '<' , i ) ; if ( ndx == - 1 ) { if ( i == 0 ) { String alias = lookupAlias ( value ) ; return ( alias != null ? alias : value ) ; } else { result . append ( value . substring ( i ) ) ; } break ; } result . append ( value . substring ( i , ndx ) ) ; ndx ++ ; int ndx2 = value . indexOf ( '>' , ndx ) ; String aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; String alias = lookupAlias ( aliasName ) ; if ( alias != null ) { result . append ( alias ) ; } else { if ( log . isWarnEnabled ( ) ) { log . warn ( "Alias not found: " + aliasName ) ; } } i = ndx2 + 1 ; } i = 0 ; len = result . length ( ) ; while ( i < len   if  result  charAt  i   '/'   break   i    if  i  1   return result  substring  i  1  len    return result  toString    

935：} ; ) , ( } } ; + = { ) != ( { ) ! ( } } } } } ; = } } ; + { } ; { ) ) , 
935：public ResultPath resolveResultPath ( String path , String value ) { boolean absolutePath = false ; if ( value != null ) { value = resolveAlias ( value ) ; if ( StringUtil . startsWithChar ( value , '/' ) ) { absolutePath = true ; int dotNdx = value . indexOf ( ".." ) ; if ( dotNdx != - 1 ) { path = value . substring ( 0 , dotNdx ) ; value = value . substring ( dotNdx + 2 ) ; } else { path = value ; value = null ; } } else { int i = 0 ; while ( i < value . length ( ) ) { if ( value . charAt ( i ) != '#' ) { break ; } int dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; if ( dotNdx != - 1 ) { path = path . substring ( 0 , dotNdx ) ; } i ++ ; } if ( i > 0 ) { value = value . substring ( i ) ; if ( StringUtil . startsWithChar ( value , '.' ) ) { value = value . substring ( 1 ) ; } else { int dotNdx = value . indexOf ( ".." ) ; if ( dotNdx != - 1 ) { path += '.' + value . substring ( 0 , dotNdx ) ; value = value . substring ( dotNdx + 2 ) ; } else { if ( value . length ( ) > 0 ) { if ( StringUtil . endsWithChar ( path , '/' ) ) { path += value ; } else { path += '.' + value ; } } value = null ; } } } } } if ( ! absolutePath ) { if ( resultPathPrefix != null ) { path = resultPathPrefix + path ; } } return new ResultPath ( path , value ) ; }
935：public ResultPath resolveResultPath ( String path , String value ) { boolean absolutePath = false ; if ( value != null ) { value = resolveAlias ( value ) ; if ( StringUtil . startsWithChar ( value , '/' ) ) { absolutePath = true ; int dotNdx = value . indexOf ( ".." ) ; if ( dotNdx != - 1 ) { path = value . substring ( 0 , dotNdx ) ; value = value . substring ( dotNdx + 2 ) ; } else { path = value ; value = null ; } } else { int i = 0 ; while ( i < value . length ( ) ) { if ( value . charAt ( i ) != '#' ) { break ; } int dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; if ( dotNdx != - 1 ) { path = path . substring ( 0 , dotNdx ) ; } i ++ ; } if ( i > 0 ) { value = value . substring ( i ) ; if ( StringUtil . startsWithChar ( value , '.' ) ) { value = value . substring ( 1 ) ; } else { int dotNdx = value . indexOf ( ".." ) ; if ( dotNdx != - 1 ) { path += '.' + value . substring ( 0 , dotNdx ) ; value = value . substring ( dotNdx + 2 ) ; } else { if ( value . length ( ) > 0 ) { if ( StringUtil . endsWithChar ( path  '/'    path += value   else  path += '.'  value    value  null       if   absolutePath   if  resultPathPrefix  null   path  resultPathPrefix  path    return new ResultPath  path  value   

936：} ; ) ( ; ) 
936：public String resolveResultPathString ( final String path , final String value ) { final ResultPath resultPath = resolveResultPath ( path , value ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
936：public String resolveResultPathString ( final String path , final String value ) { final ResultPath resultPath = resolveResultPath ( path , value ) ; final String result = resultPath . pathValue (   return resolveAlias  result   

937：} ; } } ; - = { } ; = { 
937：public static int lastIndexOfSlashDot ( final String str ) { int slashNdx = str . lastIndexOf ( '/' ) ; int dotNdx = StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
937：public static int lastIndexOfSlashDot ( final String str ) { int slashNdx = str . lastIndexOf ( '/' ) ; int dotNdx = StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 )  dotNdx  slashNdx   else  dotNdx   1    return dotNdx  

938：} ; ) , ) ( 
938：public static int lastIndexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( '/' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; }
938：public static int lastIndexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( '/' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , '.' , str . length    slashNdx   

939：} ; ) , ( . 
939：public static int indexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( '/' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( '.' , slashNdx ) ; }
939：public static int indexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( '/' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str  indexOf  '.'  slashNdx   

940：} ; } ; ) , ( . = 
940：public static String stripLastCamelWord ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }
940：public static String stripLastCamelWord ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name  name  substring  0  ndx    return name  

941：} ; } ; = { ) ) == ) 
941：public static String resolveSchemaName ( final Class < ? > type , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }
941：public static String resolveSchemaName ( final Class < ? > type , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length (   0    schemaName  defaultSchemaName   return schemaName  

942：} ; ) , , ) ( . , ) ( . , ) ) ( . , ) ( . , ( , ( } ; = { ) . == ( } } ; ) ( . = { ) ) ( . ! ( { } ; ) ) ( . 
942：public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = false ; Class < ? extends SqlType > sqlTypeClass = null ; DbId dbId = null ; if ( property . getFieldDescriptor ( ) != null ) { dbId = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbId . class ) ; } if ( dbId == null && property . getReadMethodDescriptor ( ) != null ) { dbId = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; } if ( dbId == null && property . getWriteMethodDescriptor ( ) != null ) { dbId = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; } if ( dbId != null ) { columnName = dbId . value ( ) . trim ( ) ; sqlTypeClass = dbId . sqlType ( ) ; isId = true ; } else { DbColumn dbColumn = null ; if ( property . getFieldDescriptor ( ) != null ) { dbColumn = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbColumn . class ) ; } if ( dbColumn == null && property . getReadMethodDescriptor ( ) != null ) { dbColumn = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; } if ( dbColumn == null && property . getWriteMethodDescriptor ( ) != null ) { dbColumn = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; } if ( dbColumn != null ) { columnName = dbColumn . value ( ) . trim ( ) ; sqlTypeClass = dbColumn . sqlType ( ) ; } else { if ( isAnnotated ) { return null ; } } } if ( StringUtil . isEmpty ( columnName ) ) { columnName = columnNamingStrategy . convertPropertyNameToColumnName ( property . getName ( ) ) ; } else { if ( ! columnNamingStrategy . isStrictAnnotationNames ( ) ) { columnName = columnNamingStrategy . applyToColumnName ( columnName ) ; } } if ( sqlTypeClass == SqlType . class ) { sqlTypeClass = null ; } return new DbEntityColumnDescriptor ( dbEntityDescriptor , quoteIfRequired ( columnName , columnNamingStrategy . isAlwaysQuoteNames ( ) , columnNamingStrategy . getQuoteChar ( ) ) , property . getName ( ) , property . getType ( ) , isId , sqlTypeClass ) ; }
942：public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = false ; Class < ? extends SqlType > sqlTypeClass = null ; DbId dbId = null ; if ( property . getFieldDescriptor ( ) != null ) { dbId = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbId . class ) ; } if ( dbId == null && property . getReadMethodDescriptor ( ) != null ) { dbId = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; } if ( dbId == null && property . getWriteMethodDescriptor ( ) != null ) { dbId = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; } if ( dbId != null ) { columnName = dbId . value ( ) . trim ( ) ; sqlTypeClass = dbId . sqlType ( ) ; isId = true ; } else { DbColumn dbColumn = null ; if ( property . getFieldDescriptor ( ) != null ) { dbColumn = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbColumn . class ) ; } if ( dbColumn == null && property . getReadMethodDescriptor ( ) != null ) { dbColumn = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; } if ( dbColumn == null && property . getWriteMethodDescriptor ( ) != null ) { dbColumn = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; } if ( dbColumn != null ) { columnName = dbColumn . value ( ) . trim ( ) ; sqlTypeClass = dbColumn . sqlType ( ) ; } else { if ( isAnnotated ) { return null ; } } } if ( StringUtil . isEmpty ( columnName ) ) { columnName = columnNamingStrategy . convertPropertyNameToColumnName ( property  getName      else  if   columnNamingStrategy  isStrictAnnotationNames     columnName  columnNamingStrategy  applyToColumnName  columnName     if  sqlTypeClass  SqlType  class   sqlTypeClass  null   return new DbEntityColumnDescriptor  dbEntityDescriptor  quoteIfRequired  columnName  columnNamingStrategy  isAlwaysQuoteNames    columnNamingStrategy  getQuoteChar     property  getName    property  getType    isId  sqlTypeClass   

943：} ; ] [ ^ ] [ = ] [ ; ] [ = ] [ ; ] [ = ] [ ; = ] [ . } ; 
943：public void init ( final long [ ] key , final long [ ] tweak ) { final int newNw = key . length ; if ( nw != newNw ) { nw = newNw ; switch ( nw ) { case WORDS_4 : pi = PI4 ; rpi = RPI4 ; r = R4 ; break ; case WORDS_8 : pi = PI8 ; rpi = RPI8 ; r = R8 ; break ; case WORDS_16 : pi = PI16 ; rpi = RPI16 ; r = R16 ; break ; default : throw new RuntimeException ( "Invalid threefish key" ) ; } this . k = new long [ nw + 1 ] ; vd = new long [ nw ] ; ed = new long [ nw ] ; fd = new long [ nw ] ; ksd = new long [ nw ] ; } System . arraycopy ( key , 0 , this . k , 0 , key . length ) ; long knw = EXTENDED_KEY_SCHEDULE_CONST ; for ( int i = 0 ; i < nw ; i ++ ) { knw ^= this . k [ i ] ; } this . k [ nw ] = knw ; t [ 0 ] = tweak [ 0 ] ; t [ 1 ] = tweak [ 1 ] ; t [ 2 ] = t [ 0 ] ^ t [ 1 ] ; }
943：public void init ( final long [ ] key , final long [ ] tweak ) { final int newNw = key . length ; if ( nw != newNw ) { nw = newNw ; switch ( nw ) { case WORDS_4 : pi = PI4 ; rpi = RPI4 ; r = R4 ; break ; case WORDS_8 : pi = PI8 ; rpi = RPI8 ; r = R8 ; break ; case WORDS_16 : pi = PI16 ; rpi = RPI16 ; r = R16 ; break ; default : throw new RuntimeException ( "Invalid threefish key" ) ; } this . k = new long [ nw + 1 ] ; vd = new long [ nw ] ; ed = new long [ nw ] ; fd = new long [ nw ] ; ksd = new long [ nw ] ; } System . arraycopy ( key , 0 , this . k , 0 , key . length ) ; long knw = EXTENDED_KEY_SCHEDULE_CONST ; for ( int i = 0 ; i < nw ; i ++ ) { knw ^= this . k [ i ]   this  k  nw   knw  t  0   tweak  0   t  1   tweak  1   t  2   t  0   t  1   

944：} ; ] [ ] [ ; ) ) - 
944：private void mix ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ; y [ 1 ] = ( x [ 1 ] << rotl ) | ( x [ 1 ] >>> ( Long . SIZE - rotl ) ) ; y [ 1 ] ^= y [ 0 ] ; }
944：private void mix ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ; y [ 1 ] = ( x [ 1 ] << rotl ) | ( x [ 1 ] >>> ( Long . SIZE  rotl    y  1  ^= y  0   

945：} ; ] [ - ] [ = ] [ 
945：private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ j ] ; x [ 1 ] = ( y [ 1 ] << ( Long . SIZE - rotr ) ) | ( y [ 1 ] >>> rotr ) ; x [ 0 ] = y [ 0 ] - x [ 1 ] ; }
945：private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ j ] ; x [ 1 ] = ( y [ 1 ] << ( Long . SIZE - rotr ) ) | ( y [ 1 ] >>> rotr ) ; x  0   y  0   x  1   

946：} } } ; ] [ { ) - == ( } ; 
946：private void keySchedule ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) { ksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; if ( i == nw - 3 ) { ksd [ i ] += t [ s % TWEAK_VALUES ] ; } else if ( i == nw - 2 ) { ksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; } else if ( i == nw - 1 ) { ksd [ i ] += s ; } } }
946：private void keySchedule ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) { ksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; if ( i == nw - 3 ) { ksd [ i ] += t [ s % TWEAK_VALUES ] ; } else if ( i == nw - 2 ) { ksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ]   else if  i  nw  1   ksd  i  += s    

947：} ; ) , ) ( ( ; ) . : . 
947：public void init ( final String keyMessage , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }
947：public void init ( final String keyMessage , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key  length  keyData  length   init  bytesToLongs  key   tweak   

948：} ; ) ( ; ) , ( 
948：public byte [ ] encryptBlock ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
948：public byte [ ] encryptBlock ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt  contentBlock  encryptedBlock   return longsToBytes  encryptedBlock   

949：} ; } ; ; ) , ( . 
949：protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }
949：protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits  getLong  ba  i8   i8 += 8   return result  

950：} ; } ; ) - ) ( . 
950：private static String removeAnyBounding ( final char s , final char e , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( e ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }
950：private static String removeAnyBounding ( final char s , final char e , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( e ) ) ) { return str . substring ( 1 , str  length    1    return str  

951：} ; } ; + 
951：public String path ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + '#' + methodName ; } return path ; }
951：public String path ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + '#'  methodName   return path  

952：} ; ) ( } ; ) ( . ; ) ( . { } 
952：public static File zlib ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
952：public static File zlib ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ;  finally  StreamUtil  close  dos   StreamUtil  close  fis    return new File  zlibFileName   

953：} ; ) ( } ; ) ( . ; ) ( 
953：public static File gzip ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
953：public static File gzip ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close  gzos   StreamUtil  close  fis    return new File  gzipName   

954：} ; } ; ) ( . ; ) ( . 
954：public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
954：public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil  close  fos   StreamUtil  close  gzis    return out  

955：} ; ) ( . } ; ) ( . 
955：public static List < String > listZip ( final File zipFile ) throws IOException { List < String > entries = new ArrayList < > ( ) ; ZipFile zip = new ZipFile ( zipFile ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
955：public static List < String > listZip ( final File zipFile ) throws IOException { List < String > entries = new ArrayList < > ( ) ; ZipFile zip = new ZipFile ( zipFile ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries  add  entryName    return Collections  unmodifiableList  entries   

956：} ; ) , 
956：public static void unzip ( final String zipFile , final String destDir , final String ... patterns ) throws IOException { unzip ( new File ( zipFile ) , new File ( destDir ) , patterns ) ; }
956：public static void unzip ( final String zipFile , final String destDir , final String ... patterns ) throws IOException { unzip ( new File ( zipFile ) , new File ( destDir )  patterns   

957：} } } } ; ) , , , , ( ; ) ( . + ) : . ? ( = { ) : ( { ) != . && != ( 
957：public static void addToZip ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } if ( path == null ) { path = file . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) { path = path . substring ( 1 ) ; } boolean isDir = file . isDirectory ( ) ; if ( isDir ) { if ( ! StringUtil . endsWithChar ( path , '/' ) ) { path += '/' ; } } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( file . lastModified ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } if ( isDir ) { zipEntry . setSize ( 0 ) ; zipEntry . setCrc ( 0 ) ; } zos . putNextEntry ( zipEntry ) ; if ( ! isDir ) { InputStream is = new FileInputStream ( file ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } } zos . closeEntry ( ) ; if ( recursive && file . isDirectory ( ) ) { boolean noRelativePath = StringUtil . isEmpty ( path ) ; final File [ ] children = file . listFiles ( ) ; if ( children != null && children . length != 0 ) { for ( File child : children ) { String childRelativePath = ( noRelativePath ? StringPool . EMPTY : path ) + child . getName ( ) ; addToZip ( zos , child , childRelativePath , comment , recursive ) ; } } } }
957：public static void addToZip ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } if ( path == null ) { path = file . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) { path = path . substring ( 1 ) ; } boolean isDir = file . isDirectory ( ) ; if ( isDir ) { if ( ! StringUtil . endsWithChar ( path , '/' ) ) { path += '/' ; } } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( file . lastModified ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } if ( isDir ) { zipEntry . setSize ( 0 ) ; zipEntry . setCrc ( 0 ) ; } zos . putNextEntry ( zipEntry ) ; if ( ! isDir ) { InputStream is = new FileInputStream ( file ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } } zos . closeEntry ( ) ; if ( recursive && file . isDirectory ( ) ) { boolean noRelativePath = StringUtil . isEmpty ( path ) ; final File [ ] children = file . listFiles ( ) ; if  children  null  children  length  0   for  File child  children   String childRelativePath   noRelativePath  StringPool  EMPTY  path   child  getName    addToZip  zos  child  childRelativePath  comment  recursive      

958：} ; ) ( . } ; ) ( . { } ; ) , ( . { ; 
958：public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , '/' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
958：public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , '/' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content )  try  StreamUtil  copy  is  zos    finally  StreamUtil  close  is    zos  closeEntry    

959：} ; } } ; { 
959：public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( declared ) ) { return null ; } } return fieldDescriptor ; }
959：public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( declared ) )  return null    return fieldDescriptor  

960：} ; } ; { ) 
960：public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }
960：public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared )   return propertyDescriptor   return null  

961：} ; ) , ( . 
961：public static void setRequestBundleName ( final ServletRequest request , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }
961：public static void setRequestBundleName ( final ServletRequest request , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } request  setAttribute  REQUEST_BUNDLE_NAME_ATTR  bundleName   

962：} ; ) , ( . ; 
962：public static void setSessionLocale ( final HttpSession session , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode ) ; session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
962：public static void setSessionLocale ( final HttpSession session , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode )  session  setAttribute  SESSION_LOCALE_ATTR  locale   

963：} ; : ) ( 
963：public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
963：public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale    locale  

964：} } ; ) ] [ ( . { } ; . { ) ) ( 
964：public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + '.' ; List < String > list = new ArrayList < > ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; } String value = PropertiesUtil . resolveProperty ( params , key ) ; entry . setValue ( value ) ; } if ( list . isEmpty ( ) ) { return StringPool . EMPTY_ARRAY ; } else { return list . toArray ( new String [ 0 ] ) ; } }
964：public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + '.' ; List < String > list = new ArrayList < > ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; } String value = PropertiesUtil . resolveProperty ( params , key ) ; entry . setValue ( value ) ; } if ( list . isEmpty     return StringPool  EMPTY_ARRAY   else  return list  toArray  new String  0     

965：} ; } ; ) 
965：public PropsEntries profile ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String profile : profiles ) { addProfiles ( profile ) ; } return this ; }
965：public PropsEntries profile ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String profile : profiles ) { addProfiles ( profile    return this  

966：} ; ) ) & ] [ ( ( | ) << ) & ] 
966：public static long getLongLittleEndian ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 ) | ( ( buf [ offset + 6 ] & 0xffL ) << 48 ) | ( ( buf [ offset + 5 ] & 0xffL ) << 40 ) | ( ( buf [ offset + 4 ] & 0xffL ) << 32 ) | ( ( buf [ offset + 3 ] & 0xffL ) << 24 ) | ( ( buf [ offset + 2 ] & 0xffL ) << 16 ) | ( ( buf [ offset + 1 ] & 0xffL ) << 8 ) | ( ( buf [ offset ] & 0xffL ) ) ; }
966：public static long getLongLittleEndian ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 ) | ( ( buf [ offset + 6 ] & 0xffL ) << 48 ) | ( ( buf [ offset + 5 ] & 0xffL ) << 40 ) | ( ( buf [ offset + 4 ] & 0xffL ) << 32 ) | ( ( buf [ offset + 3 ] & 0xffL ) << 24 ) | ( ( buf [ offset + 2 ] & 0xffL ) << 16 ) | ( ( buf [ offset + 1   0xffL   8     buf  offset   0xffL    

967：} } } ; ) ( . { ) ( { } ; ) 
967：private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
967：private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray (    finally  if  close   inputStream  close      

968：} ; ] [ } 
968：protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
968：protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ;  return labels  bytecodeOffset   

969：} ; ) + ] [ ( } 
969：private int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }
969：private int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ;  return readUnsignedShort  typeAnnotationOffsets  typeAnnotationIndex   1   

970：} ; } ; ) ( . { ) != ( } } ; ) , 
970：private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ; int numElementValuePairs = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; if ( named ) { while ( numElementValuePairs -- > 0 ) { String elementName = readUTF8 ( currentOffset , charBuffer ) ; currentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; } } else { while ( numElementValuePairs -- > 0 ) { currentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; } } if ( annotationVisitor != null ) { annotationVisitor . visitEnd ( ) ; } return currentOffset ; }
970：private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ; int numElementValuePairs = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; if ( named ) { while ( numElementValuePairs -- > 0 ) { String elementName = readUTF8 ( currentOffset , charBuffer ) ; currentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; } } else { while ( numElementValuePairs -- > 0 ) { currentOffset = readElementValue ( annotationVisitor , currentOffset , null  charBuffer     if  annotationVisitor  null   annotationVisitor  visitEnd     return currentOffset  

971：} ; } ; ) ( : ; ; ; ) , ) ( ( = ] [ : . ; ; ; ) , ( = ] 
971：private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
971：private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index   readClass  currentOffset  charBuffer   currentOffset += 2  break  case Frame  ITEM_UNINITIALIZED  frame  index   createLabel  readUnsignedShort  currentOffset   labels   currentOffset += 2  break  default  throw new IllegalArgumentException     return currentOffset  

972：} ; } ; } ; } ; * ) + ( + ; = ] [ { ) ++ ; . < 
972：private int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) { String attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; int attributeLength = readInt ( currentAttributeOffset + 2 ) ; currentAttributeOffset += 6 ; if ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { currentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; int currentBootstrapMethodOffset = currentAttributeOffset + 2 ; for ( int j = 0 ; j < currentBootstrapMethodOffsets . length ; ++ j ) { currentBootstrapMethodOffsets [ j ] = currentBootstrapMethodOffset ; currentBootstrapMethodOffset += 4 + readUnsignedShort ( currentBootstrapMethodOffset + 2 ) * 2 ; } return currentBootstrapMethodOffsets ; } currentAttributeOffset += attributeLength ; } return null ; }
972：private int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) { String attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; int attributeLength = readInt ( currentAttributeOffset + 2 ) ; currentAttributeOffset += 6 ; if ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { currentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; int currentBootstrapMethodOffset = currentAttributeOffset + 2 ; for ( int j = 0 ; j  currentBootstrapMethodOffsets  length   j   currentBootstrapMethodOffsets  j   currentBootstrapMethodOffset  currentBootstrapMethodOffset += 4  readUnsignedShort  currentBootstrapMethodOffset  2   2   return currentBootstrapMethodOffsets   currentAttributeOffset += attributeLength   return null  

973：} ; } } ; = { ) ) ( . ( ; = 
973：protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
973：protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ]  ctorDescriptor  if  ctorDescriptor  isDefault     defaultCtor  ctorDescriptor    return allCtors  

974：} ; } ; } } ; { ) ] [ 
974：public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] arg = ctorDescriptor . getParameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != args [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
974：public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] arg = ctorDescriptor . getParameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != args  j    continue ctors    return ctorDescriptor   return null  

975：} ; ) ( . 
975：@ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > getRequestMap ( final HttpServletRequest servletRequest ) { return ( Map < String , TransientBeanData > ) servletRequest . getAttribute ( ATTR_NAME ) ; }
975：@ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > getRequestMap ( final HttpServletRequest servletRequest ) { return ( Map < String , TransientBeanData > ) servletRequest  getAttribute  ATTR_NAME   

976：} ; ; ) , ( 
976：protected Map < String , TransientBeanData > createRequestMap ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > map = new HashMap < > ( ) ; servletRequest . setAttribute ( ATTR_NAME , map ) ; return map ; }
976：protected Map < String , TransientBeanData > createRequestMap ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > map = new HashMap < > ( ) ; servletRequest . setAttribute  ATTR_NAME  map   return map  

977：} ; } } ; ) ] [ ( = ] [ 
977：protected long [ ] convertArrayToArray ( final Object value ) { final Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( valueComponentType . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; } else { final Object [ ] array = ( Object [ ] ) value ; result = new long [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = convertType ( array [ i ] ) ; } } return result ; }
977：protected long [ ] convertArrayToArray ( final Object value ) { final Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( valueComponentType . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; } else { final Object [ ] array = ( Object [ ] ) value ; result = new long [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result  i   convertType  array  i      return result  

978：} } ; ) , ( . ) ( . = { ) != ( ; ) ( . = } ; ) ( = { } } ; ) ( 
978：public void init ( final FilterConfig filterConfig ) throws ServletException { final String decoraManagerClass = filterConfig . getInitParameter ( PARAM_DECORA_MANAGER ) ; if ( decoraManagerClass != null ) { try { final Class decoraManagerType = ClassLoaderUtil . loadClass ( decoraManagerClass ) ; decoraManager = ( DecoraManager ) ClassUtil . newInstance ( decoraManagerType ) ; } catch ( Exception ex ) { log . error ( "Unable to load Decora manager class: " + decoraManagerClass , ex ) ; throw new ServletException ( ex ) ; } } else { decoraManager = createDecoraManager ( ) ; } final String decoraParserClass = filterConfig . getInitParameter ( PARAM_DECORA_PARSER ) ; if ( decoraParserClass != null ) { try { final Class decoraParserType = ClassLoaderUtil . loadClass ( decoraParserClass ) ; decoraParser = ( DecoraParser ) ClassUtil . newInstance ( decoraParserType ) ; } catch ( Exception ex ) { log . error ( "Unable to load Decora parser class: " + decoraParserClass , ex ) ; throw new ServletException ( ex ) ; } } else { decoraParser = createDecoraParser ( ) ; } final String decoraCache = filterConfig . getInitParameter ( PARAM_DECORA_CACHE ) ; if ( decoraCache != null ) { cached = Converter . get ( ) . toBoolean ( decoraCache , false ) ; } }
978：public void init ( final FilterConfig filterConfig ) throws ServletException { final String decoraManagerClass = filterConfig . getInitParameter ( PARAM_DECORA_MANAGER ) ; if ( decoraManagerClass != null ) { try { final Class decoraManagerType = ClassLoaderUtil . loadClass ( decoraManagerClass ) ; decoraManager = ( DecoraManager ) ClassUtil . newInstance ( decoraManagerType ) ; } catch ( Exception ex ) { log . error ( "Unable to load Decora manager class: " + decoraManagerClass , ex ) ; throw new ServletException ( ex ) ; } } else { decoraManager = createDecoraManager ( ) ; } final String decoraParserClass = filterConfig . getInitParameter ( PARAM_DECORA_PARSER ) ; if ( decoraParserClass != null ) { try { final Class decoraParserType = ClassLoaderUtil . loadClass ( decoraParserClass ) ; decoraParser = ( DecoraParser ) ClassUtil . newInstance ( decoraParserType ) ; } catch ( Exception ex ) { log . error ( "Unable to load Decora parser class: " + decoraParserClass , ex ) ; throw new ServletException  ex     else  decoraParser  createDecoraParser     final String decoraCache  filterConfig  getInitParameter  PARAM_DECORA_CACHE   if  decoraCache  null   cached  Converter  get    toBoolean  decoraCache  false    

979：} ; } ; ) 
979：public FindFile onFile ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
979：public FindFile onFile ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer    return this  

980：} ; ; ) ( } ; 
980：public FindFile searchPath ( final URI searchPath ) { File file ; try { file = new File ( searchPath ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + searchPath , ex ) ; } addPath ( file ) ; return this ; }
980：public FindFile searchPath ( final URI searchPath ) { File file ; try { file = new File ( searchPath ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + searchPath , ex )   addPath  file   return this  

981：} ; ; ) ( } 
981：public FindFile searchPath ( final URL searchPath ) { File file = FileUtil . toContainerFile ( searchPath ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + searchPath ) ; } addPath ( file ) ; return this ; }
981：public FindFile searchPath ( final URL searchPath ) { File file = FileUtil . toContainerFile ( searchPath ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + searchPath ) ;  addPath  file   return this  

982：} ; } ; 
982：public FindFile include ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
982：public FindFile include ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern )   return this  

983：} ; } ; 
983：public FindFile exclude ( final String ... patterns ) { for ( String pattern : patterns ) { rules . exclude ( pattern ) ; } return this ; }
983：public FindFile exclude ( final String ... patterns ) { for ( String pattern : patterns ) { rules . exclude ( pattern )   return this  

984：} ; ) ( . 
984：protected void addPath ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList < > ( ) ; } pathList . add ( path ) ; }
984：protected void addPath ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList < > ( ) ; } pathList  add  path   

985：} ; } ; ) ( 
985：public List < File > findAll ( ) { List < File > allFiles = new ArrayList < > ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
985：public List < File > findAll ( ) { List < File > allFiles = new ArrayList < > ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add  file    return allFiles  

986：} } ; ) ( . ; ) ( = { ) != ( } } ; ) ( 
986：protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList < > ( ) ; todoFolders = new LinkedList < > ( ) ; if ( pathList == null ) { pathList = new LinkedList < > ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
986：protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList < > ( ) ; todoFolders = new LinkedList < > ( ) ; if ( pathList == null ) { pathList = new LinkedList < > ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove      if  index  0   FilesIterator filesIterator  new FilesIterator  files   todoFiles  add  filesIterator    

987：} ; } } ; ) ( { ) 
987：public Iterator < File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
987：public Iterator < File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } public void remove (   throw new UnsupportedOperationException       

988：} ; . : ) ( . 
988：public WiringMode resolveBeanWiringMode ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
988：public WiringMode resolveBeanWiringMode ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean  wiring    WiringMode  DEFAULT  

989：} ; } } ; ) ) ( . ( . = { } 
989：public String resolveBeanName ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }
989：public String resolveBeanName ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ;  else  name  StringUtil  uncapitalize  type  getSimpleName       return name  

990：} ; } ; } } { ) 
990：public PrintWriter getWriter ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { public void close ( ) { } } ; } return outWriter ; }
990：public PrintWriter getWriter ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { public void close (       return outWriter  

991：} ; } ; = ; 
991：public ServletOutputStream getOutputStream ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
991：public ServletOutputStream getOutputStream ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( )  outStream  bufferOutputStream   return outStream  

992：} } ; ) ( : ; ) , ( . ) , ( . : : ; 
992：public String getClassName ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( '/' , '.' ) ; default : throw new AssertionError ( ) ; } }
992：public String getClassName ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( )  case OBJECT  case INTERNAL  return valueBuffer  substring  valueBegin  valueEnd   replace  '/'  '.'   default  throw new AssertionError     

993：} ; ) ( . ) ( . 
993：public static String getConstructorDescriptor ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( '(' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
993：public static String getConstructorDescriptor ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( '(' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder  append  ")V"   toString    

994：} ; ) ( . ; ) ( 
994：public static String getMethodDescriptor ( final Type returnType , final Type ... argumentTypes ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( '(' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ')' ) ; returnType . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }
994：public static String getMethodDescriptor ( final Type returnType , final Type ... argumentTypes ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( '(' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ')' ) ; returnType . appendDescriptor  stringBuilder   return stringBuilder  toString    

995：} ; ) ( . ; ) , ) 
995：public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( '(' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ')' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
995：public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( '(' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ')' ) ; appendDescriptor ( method . getReturnType (   stringBuilder   return stringBuilder  toString    

996：} } ; ) , , ( . { 
996：private void appendDescriptor ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( 'L' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ';' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
996：private void appendDescriptor ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( 'L' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ';' ) ; } else  stringBuilder  append  valueBuffer  valueBegin  valueEnd    

997：} } ; ) ( : ; 
997：public int getSize ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
997：public int getSize ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2  default  throw new AssertionError     

998：} } ; | << ; : ? ) == || == ( = { } ; << { ) == 
998：public static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { int argumentsSize = 1 ; int currentOffset = 1 ; int currentChar = methodDescriptor . charAt ( currentOffset ) ; while ( currentChar != ')' ) { if ( currentChar == 'J' || currentChar == 'D' ) { currentOffset ++ ; argumentsSize += 2 ; } else { while ( methodDescriptor . charAt ( currentOffset ) == '[' ) { currentOffset ++ ; } if ( methodDescriptor . charAt ( currentOffset ++ ) == 'L' ) { currentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; } argumentsSize += 1 ; } currentChar = methodDescriptor . charAt ( currentOffset ) ; } currentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; if ( currentChar == 'V' ) { return argumentsSize << 2 ; } else { int returnSize = ( currentChar == 'J' || currentChar == 'D' ) ? 2 : 1 ; return argumentsSize << 2 | returnSize ; } }
998：public static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { int argumentsSize = 1 ; int currentOffset = 1 ; int currentChar = methodDescriptor . charAt ( currentOffset ) ; while ( currentChar != ')' ) { if ( currentChar == 'J' || currentChar == 'D' ) { currentOffset ++ ; argumentsSize += 2 ; } else { while ( methodDescriptor . charAt ( currentOffset ) == '[' ) { currentOffset ++ ; } if ( methodDescriptor . charAt ( currentOffset ++ ) == 'L' ) { currentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; } argumentsSize += 1 ; } currentChar = methodDescriptor . charAt ( currentOffset ) ; } currentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; if ( currentChar  'V'   return argumentsSize  2   else  int returnSize   currentChar  'J'  currentChar  'D'   2  1  return argumentsSize  2  returnSize   

999：} ; = ; = } } ; ) 
999：public void setRollbackOnly ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
999：public void setRollbackOnly ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only"     rollbackCause  th  status  STATUS_MARKED_ROLLBACK  

